public static Boolean negate(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static Boolean negate(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static Boolean negate(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static Boolean toBooleanObject(final int value) { [EOL]     return value == 0 ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return true; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return false; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return true; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (value == trueValue) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (value == nullValue) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Integer toIntegerObject(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO; [EOL] }
public static int toInteger(final boolean bool, final int trueValue, final int falseValue) { [EOL]     return bool ? trueValue : falseValue; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static boolean toBoolean(final String str) { [EOL]     return toBooleanObject(str) == Boolean.TRUE; [EOL] }
public static String toStringTrueFalse(final boolean bool) { [EOL]     return toString(bool, "true", "false"); [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeExactMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Method getAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         return getAccessibleMethod(cls.getMethod(methodName, parameterTypes)); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         return null; [EOL]     } [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static short min(final short[] array) { [EOL]     validateArray(array); [EOL]     short min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static short min(final short[] array) { [EOL]     validateArray(array); [EOL]     short min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static short min(final short[] array) { [EOL]     validateArray(array); [EOL]     short min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static byte max(final byte[] array) { [EOL]     validateArray(array); [EOL]     byte max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
public int getValue(final int holder) { [EOL]     return getRawValue(holder) >> _shift_count; [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public static <L, R> Pair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
public SerializationException() { [EOL]     super(); [EOL] }
public SerializationException(final String msg) { [EOL]     super(msg); [EOL] }
public SerializationException(final String msg, final Throwable cause) { [EOL]     super(msg, cause); [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] }
public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] }
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
public L fire() { [EOL]     return proxy; [EOL] }
public void addListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.add(listener); [EOL] }
public void addListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.add(listener); [EOL] }
int getListenerCount() { [EOL]     return listeners.size(); [EOL] }
int getListenerCount() { [EOL]     return listeners.size(); [EOL] }
public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] }
public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] }
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { [EOL]     for (final L listener : listeners) { [EOL]         method.invoke(listener, args); [EOL]     } [EOL]     return null; [EOL] }
public MutableFloat() { [EOL]     super(); [EOL] }
public MutableFloat(final float value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
@Override [EOL] public Float getValue() { [EOL]     return Float.valueOf(this.value); [EOL] }
public void setValue(final float value) { [EOL]     this.value = value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.floatValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.floatValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.floatValue(); [EOL] }
public boolean isNaN() { [EOL]     return Float.isNaN(value); [EOL] }
public boolean isNaN() { [EOL]     return Float.isNaN(value); [EOL] }
public boolean isInfinite() { [EOL]     return Float.isInfinite(value); [EOL] }
public void increment() { [EOL]     value++; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void subtract(final float operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final float operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final float operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.floatValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.floatValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
private static void addAbbreviation(final String primitive, final String abbreviation) { [EOL]     abbreviationMap.put(primitive, abbreviation); [EOL]     reverseAbbreviationMap.put(abbreviation, primitive); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getSimpleName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return cls.getSimpleName(); [EOL] }
public static String getSimpleName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return cls.getSimpleName(); [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] }
public static boolean isPrimitiveWrapper(final Class<?> type) { [EOL]     return wrapperPrimitiveMap.containsKey(type); [EOL] }
public static boolean isPrimitiveWrapper(final Class<?> type) { [EOL]     return wrapperPrimitiveMap.containsKey(type); [EOL] }
public static boolean isPrimitiveWrapper(final Class<?> type) { [EOL]     return wrapperPrimitiveMap.containsKey(type); [EOL] }
public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) { [EOL]     return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static Class<?> primitiveToWrapper(final Class<?> cls) { [EOL]     Class<?> convertedClass = cls; [EOL]     if (cls != null && cls.isPrimitive()) { [EOL]         convertedClass = primitiveWrapperMap.get(cls); [EOL]     } [EOL]     return convertedClass; [EOL] }
public static Class<?> primitiveToWrapper(final Class<?> cls) { [EOL]     Class<?> convertedClass = cls; [EOL]     if (cls != null && cls.isPrimitive()) { [EOL]         convertedClass = primitiveWrapperMap.get(cls); [EOL]     } [EOL]     return convertedClass; [EOL] }
public static Class<?> primitiveToWrapper(final Class<?> cls) { [EOL]     Class<?> convertedClass = cls; [EOL]     if (cls != null && cls.isPrimitive()) { [EOL]         convertedClass = primitiveWrapperMap.get(cls); [EOL]     } [EOL]     return convertedClass; [EOL] }
public static Class<?> wrapperToPrimitive(final Class<?> cls) { [EOL]     return wrapperPrimitiveMap.get(cls); [EOL] }
public static Class<?> wrapperToPrimitive(final Class<?> cls) { [EOL]     return wrapperPrimitiveMap.get(cls); [EOL] }
public static Class<?> wrapperToPrimitive(final Class<?> cls) { [EOL]     return wrapperPrimitiveMap.get(cls); [EOL] }
public static Class<?> wrapperToPrimitive(final Class<?> cls) { [EOL]     return wrapperPrimitiveMap.get(cls); [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
private static String getCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         return null; [EOL]     } else { [EOL]         int dim = 0; [EOL]         while (className.startsWith("[")) { [EOL]             dim++; [EOL]             className = className.substring(1); [EOL]         } [EOL]         if (dim < 1) { [EOL]             return className; [EOL]         } else { [EOL]             if (className.startsWith("L")) { [EOL]                 className = className.substring(1, className.endsWith(";") ? className.length() - 1 : className.length()); [EOL]             } else { [EOL]                 if (className.length() > 0) { [EOL]                     className = reverseAbbreviationMap.get(className.substring(0, 1)); [EOL]                 } [EOL]             } [EOL]             final StringBuilder canonicalClassNameBuffer = new StringBuilder(className); [EOL]             for (int i = 0; i < dim; i++) { [EOL]                 canonicalClassNameBuffer.append("[]"); [EOL]             } [EOL]             return canonicalClassNameBuffer.toString(); [EOL]         } [EOL]     } [EOL] }
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) { [EOL]     if (isStarted()) { [EOL]         throw new IllegalStateException("Cannot set ExecutorService after start()!"); [EOL]     } [EOL]     this.externalExecutor = externalExecutor; [EOL] }
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) { [EOL]     if (isStarted()) { [EOL]         throw new IllegalStateException("Cannot set ExecutorService after start()!"); [EOL]     } [EOL]     this.externalExecutor = externalExecutor; [EOL] }
public static String[][] ISO8859_1_ESCAPE() { [EOL]     return ISO8859_1_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] ISO8859_1_UNESCAPE() { [EOL]     return ISO8859_1_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] HTML40_EXTENDED_UNESCAPE() { [EOL]     return HTML40_EXTENDED_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] BASIC_ESCAPE() { [EOL]     return BASIC_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] BASIC_UNESCAPE() { [EOL]     return BASIC_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] APOS_ESCAPE() { [EOL]     return APOS_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] APOS_UNESCAPE() { [EOL]     return APOS_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] JAVA_CTRL_CHARS_ESCAPE() { [EOL]     return JAVA_CTRL_CHARS_ESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { [EOL]     return JAVA_CTRL_CHARS_UNESCAPE.clone(); [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static String[][] invert(final String[][] array) { [EOL]     final String[][] newarray = new String[array.length][2]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         newarray[i][0] = array[i][1]; [EOL]         newarray[i][1] = array[i][0]; [EOL]     } [EOL]     return newarray; [EOL] } public static String[][] ISO8859_1_ESCAPE(); public static String[][] ISO8859_1_UNESCAPE(); public static String[][] HTML40_EXTENDED_ESCAPE(); public static String[][] HTML40_EXTENDED_UNESCAPE(); public static String[][] BASIC_ESCAPE(); public static String[][] BASIC_UNESCAPE(); public static String[][] APOS_ESCAPE(); public static String[][] APOS_UNESCAPE(); public static String[][] JAVA_CTRL_CHARS_ESCAPE(); public static String[][] JAVA_CTRL_CHARS_UNESCAPE(); public static String[][] invert(final String[][] array); String[][] ISO8859_1_ESCAPE=Optional[{ // non-breaking space; { "\u00A0", "&nbsp;" }, // inverted exclamation mark; { "\u00A1", "&iexcl;" }, // cent sign; { "\u00A2", "&cent;" }, // pound sign; { "\u00A3", "&pound;" }, // currency sign; { "\u00A4", "&curren;" }, // yen sign = yuan sign; { "\u00A5", "&yen;" }, // broken bar = broken vertical bar; { "\u00A6", "&brvbar;" }, // section sign; { "\u00A7", "&sect;" }, // diaeresis = spacing diaeresis; { "\u00A8", "&uml;" }, //  - copyright sign; { "\u00A9", "&copy;" }, // feminine ordinal indicator; { "\u00AA", "&ordf;" }, // left-pointing double angle quotation mark = left pointing guillemet; { "\u00AB", "&laquo;" }, // not sign; { "\u00AC", "&not;" }, // soft hyphen = discretionary hyphen; { "\u00AD", "&shy;" }, //  - registered trademark sign; { "\u00AE", "&reg;" }, // macron = spacing macron = overline = APL overbar; { "\u00AF", "&macr;" }, // degree sign; { "\u00B0", "&deg;" }, // plus-minus sign = plus-or-minus sign; { "\u00B1", "&plusmn;" }, // superscript two = superscript digit two = squared; { "\u00B2", "&sup2;" }, // superscript three = superscript digit three = cubed; { "\u00B3", "&sup3;" }, // acute accent = spacing acute; { "\u00B4", "&acute;" }, // micro sign; { "\u00B5", "&micro;" }, // pilcrow sign = paragraph sign; { "\u00B6", "&para;" }, // middle dot = Georgian comma = Greek middle dot; { "\u00B7", "&middot;" }, // cedilla = spacing cedilla; { "\u00B8", "&cedil;" }, // superscript one = superscript digit one; { "\u00B9", "&sup1;" }, // masculine ordinal indicator; { "\u00BA", "&ordm;" }, // right-pointing double angle quotation mark = right pointing guillemet; { "\u00BB", "&raquo;" }, // vulgar fraction one quarter = fraction one quarter; { "\u00BC", "&frac14;" }, // vulgar fraction one half = fraction one half; { "\u00BD", "&frac12;" }, // vulgar fraction three quarters = fraction three quarters; { "\u00BE", "&frac34;" }, // inverted question mark = turned question mark; { "\u00BF", "&iquest;" }, //  - uppercase A, grave accent; { "\u00C0", "&Agrave;" }, //  - uppercase A, acute accent; { "\u00C1", "&Aacute;" }, //  - uppercase A, circumflex accent; { "\u00C2", "&Acirc;" }, //  - uppercase A, tilde; { "\u00C3", "&Atilde;" }, //  - uppercase A, umlaut; { "\u00C4", "&Auml;" }, //  - uppercase A, ring; { "\u00C5", "&Aring;" }, //  - uppercase AE; { "\u00C6", "&AElig;" }, //  - uppercase C, cedilla; { "\u00C7", "&Ccedil;" }, //  - uppercase E, grave accent; { "\u00C8", "&Egrave;" }, //  - uppercase E, acute accent; { "\u00C9", "&Eacute;" }, //  - uppercase E, circumflex accent; { "\u00CA", "&Ecirc;" }, //  - uppercase E, umlaut; { "\u00CB", "&Euml;" }, //  - uppercase I, grave accent; { "\u00CC", "&Igrave;" }, //  - uppercase I, acute accent; { "\u00CD", "&Iacute;" }, //  - uppercase I, circumflex accent; { "\u00CE", "&Icirc;" }, //  - uppercase I, umlaut; { "\u00CF", "&Iuml;" }, //  - uppercase Eth, Icelandic; { "\u00D0", "&ETH;" }, //  - uppercase N, tilde; { "\u00D1", "&Ntilde;" }, //  - uppercase O, grave accent; { "\u00D2", "&Ograve;" }, //  - uppercase O, acute accent; { "\u00D3", "&Oacute;" }, //  - uppercase O, circumflex accent; { "\u00D4", "&Ocirc;" }, //  - uppercase O, tilde; { "\u00D5", "&Otilde;" }, //  - uppercase O, umlaut; { "\u00D6", "&Ouml;" }, // multiplication sign; { "\u00D7", "&times;" }, //  - uppercase O, slash; { "\u00D8", "&Oslash;" }, //  - uppercase U, grave accent; { "\u00D9", "&Ugrave;" }, //  - uppercase U, acute accent; { "\u00DA", "&Uacute;" }, //  - uppercase U, circumflex accent; { "\u00DB", "&Ucirc;" }, //  - uppercase U, umlaut; { "\u00DC", "&Uuml;" }, //  - uppercase Y, acute accent; { "\u00DD", "&Yacute;" }, //  - uppercase THORN, Icelandic; { "\u00DE", "&THORN;" }, //  - lowercase sharps, German; { "\u00DF", "&szlig;" }, //  - lowercase a, grave accent; { "\u00E0", "&agrave;" }, //  - lowercase a, acute accent; { "\u00E1", "&aacute;" }, //  - lowercase a, circumflex accent; { "\u00E2", "&acirc;" }, //  - lowercase a, tilde; { "\u00E3", "&atilde;" }, //  - lowercase a, umlaut; { "\u00E4", "&auml;" }, //  - lowercase a, ring; { "\u00E5", "&aring;" }, //  - lowercase ae; { "\u00E6", "&aelig;" }, //  - lowercase c, cedilla; { "\u00E7", "&ccedil;" }, //  - lowercase e, grave accent; { "\u00E8", "&egrave;" }, //  - lowercase e, acute accent; { "\u00E9", "&eacute;" }, //  - lowercase e, circumflex accent; { "\u00EA", "&ecirc;" }, //  - lowercase e, umlaut; { "\u00EB", "&euml;" }, //  - lowercase i, grave accent; { "\u00EC", "&igrave;" }, //  - lowercase i, acute accent; { "\u00ED", "&iacute;" }, //  - lowercase i, circumflex accent; { "\u00EE", "&icirc;" }, //  - lowercase i, umlaut; { "\u00EF", "&iuml;" }, //  - lowercase eth, Icelandic; { "\u00F0", "&eth;" }, //  - lowercase n, tilde; { "\u00F1", "&ntilde;" }, //  - lowercase o, grave accent; { "\u00F2", "&ograve;" }, //  - lowercase o, acute accent; { "\u00F3", "&oacute;" }, //  - lowercase o, circumflex accent; { "\u00F4", "&ocirc;" }, //  - lowercase o, tilde; { "\u00F5", "&otilde;" }, //  - lowercase o, umlaut; { "\u00F6", "&ouml;" }, // division sign; { "\u00F7", "&divide;" }, //  - lowercase o, slash; { "\u00F8", "&oslash;" }, //  - lowercase u, grave accent; { "\u00F9", "&ugrave;" }, //  - lowercase u, acute accent; { "\u00FA", "&uacute;" }, //  - lowercase u, circumflex accent; { "\u00FB", "&ucirc;" }, //  - lowercase u, umlaut; { "\u00FC", "&uuml;" }, //  - lowercase y, acute accent; { "\u00FD", "&yacute;" }, //  - lowercase thorn, Icelandic; { "\u00FE", "&thorn;" }, //  - lowercase y, umlaut; { "\u00FF", "&yuml;" } }]; String[][] ISO8859_1_UNESCAPE=Optional[invert(ISO8859_1_ESCAPE)]; String[][] HTML40_EXTENDED_ESCAPE=Optional[{ // <!-- Latin Extended-B -->; // latin small f with hook = function= florin, U+0192 ISOtech -->; { "\u0192", "&fnof;" }, // <!-- Greek -->; // greek capital letter alpha, U+0391 -->; { "\u0391", "&Alpha;" }, // greek capital letter beta, U+0392 -->; { "\u0392", "&Beta;" }, // greek capital letter gamma,U+0393 ISOgrk3 -->; { "\u0393", "&Gamma;" }, // greek capital letter delta,U+0394 ISOgrk3 -->; { "\u0394", "&Delta;" }, // greek capital letter epsilon, U+0395 -->; { "\u0395", "&Epsilon;" }, // greek capital letter zeta, U+0396 -->; { "\u0396", "&Zeta;" }, // greek capital letter eta, U+0397 -->; { "\u0397", "&Eta;" }, // greek capital letter theta,U+0398 ISOgrk3 -->; { "\u0398", "&Theta;" }, // greek capital letter iota, U+0399 -->; { "\u0399", "&Iota;" }, // greek capital letter kappa, U+039A -->; { "\u039A", "&Kappa;" }, // greek capital letter lambda,U+039B ISOgrk3 -->; { "\u039B", "&Lambda;" }, // greek capital letter mu, U+039C -->; { "\u039C", "&Mu;" }, // greek capital letter nu, U+039D -->; { "\u039D", "&Nu;" }, // greek capital letter xi, U+039E ISOgrk3 -->; { "\u039E", "&Xi;" }, // greek capital letter omicron, U+039F -->; { "\u039F", "&Omicron;" }, // greek capital letter pi, U+03A0 ISOgrk3 -->; { "\u03A0", "&Pi;" }, // greek capital letter rho, U+03A1 -->; { "\u03A1", "&Rho;" }, // <!-- there is no Sigmaf, and no U+03A2 character either -->; // greek capital letter sigma,U+03A3 ISOgrk3 -->; { "\u03A3", "&Sigma;" }, // greek capital letter tau, U+03A4 -->; { "\u03A4", "&Tau;" }, // greek capital letter upsilon,U+03A5 ISOgrk3 -->; { "\u03A5", "&Upsilon;" }, // greek capital letter phi,U+03A6 ISOgrk3 -->; { "\u03A6", "&Phi;" }, // greek capital letter chi, U+03A7 -->; { "\u03A7", "&Chi;" }, // greek capital letter psi,U+03A8 ISOgrk3 -->; { "\u03A8", "&Psi;" }, // greek capital letter omega,U+03A9 ISOgrk3 -->; { "\u03A9", "&Omega;" }, // greek small letter alpha,U+03B1 ISOgrk3 -->; { "\u03B1", "&alpha;" }, // greek small letter beta, U+03B2 ISOgrk3 -->; { "\u03B2", "&beta;" }, // greek small letter gamma,U+03B3 ISOgrk3 -->; { "\u03B3", "&gamma;" }, // greek small letter delta,U+03B4 ISOgrk3 -->; { "\u03B4", "&delta;" }, // greek small letter epsilon,U+03B5 ISOgrk3 -->; { "\u03B5", "&epsilon;" }, // greek small letter zeta, U+03B6 ISOgrk3 -->; { "\u03B6", "&zeta;" }, // greek small letter eta, U+03B7 ISOgrk3 -->; { "\u03B7", "&eta;" }, // greek small letter theta,U+03B8 ISOgrk3 -->; { "\u03B8", "&theta;" }, // greek small letter iota, U+03B9 ISOgrk3 -->; { "\u03B9", "&iota;" }, // greek small letter kappa,U+03BA ISOgrk3 -->; { "\u03BA", "&kappa;" }, // greek small letter lambda,U+03BB ISOgrk3 -->; { "\u03BB", "&lambda;" }, // greek small letter mu, U+03BC ISOgrk3 -->; { "\u03BC", "&mu;" }, // greek small letter nu, U+03BD ISOgrk3 -->; { "\u03BD", "&nu;" }, // greek small letter xi, U+03BE ISOgrk3 -->; { "\u03BE", "&xi;" }, // greek small letter omicron, U+03BF NEW -->; { "\u03BF", "&omicron;" }, // greek small letter pi, U+03C0 ISOgrk3 -->; { "\u03C0", "&pi;" }, // greek small letter rho, U+03C1 ISOgrk3 -->; { "\u03C1", "&rho;" }, // greek small letter final sigma,U+03C2 ISOgrk3 -->; { "\u03C2", "&sigmaf;" }, // greek small letter sigma,U+03C3 ISOgrk3 -->; { "\u03C3", "&sigma;" }, // greek small letter tau, U+03C4 ISOgrk3 -->; { "\u03C4", "&tau;" }, // greek small letter upsilon,U+03C5 ISOgrk3 -->; { "\u03C5", "&upsilon;" }, // greek small letter phi, U+03C6 ISOgrk3 -->; { "\u03C6", "&phi;" }, // greek small letter chi, U+03C7 ISOgrk3 -->; { "\u03C7", "&chi;" }, // greek small letter psi, U+03C8 ISOgrk3 -->; { "\u03C8", "&psi;" }, // greek small letter omega,U+03C9 ISOgrk3 -->; { "\u03C9", "&omega;" }, // greek small letter theta symbol,U+03D1 NEW -->; { "\u03D1", "&thetasym;" }, // greek upsilon with hook symbol,U+03D2 NEW -->; { "\u03D2", "&upsih;" }, // greek pi symbol, U+03D6 ISOgrk3 -->; { "\u03D6", "&piv;" }, // <!-- General Punctuation -->; // bullet = black small circle,U+2022 ISOpub -->; { "\u2022", "&bull;" }, // <!-- bullet is NOT the same as bullet operator, U+2219 -->; // horizontal ellipsis = three dot leader,U+2026 ISOpub -->; { "\u2026", "&hellip;" }, // prime = minutes = feet, U+2032 ISOtech -->; { "\u2032", "&prime;" }, // double prime = seconds = inches,U+2033 ISOtech -->; { "\u2033", "&Prime;" }, // overline = spacing overscore,U+203E NEW -->; { "\u203E", "&oline;" }, // fraction slash, U+2044 NEW -->; { "\u2044", "&frasl;" }, // <!-- Letterlike Symbols -->; // script capital P = power set= Weierstrass p, U+2118 ISOamso -->; { "\u2118", "&weierp;" }, // blackletter capital I = imaginary part,U+2111 ISOamso -->; { "\u2111", "&image;" }, // blackletter capital R = real part symbol,U+211C ISOamso -->; { "\u211C", "&real;" }, // trade mark sign, U+2122 ISOnum -->; { "\u2122", "&trade;" }, // alef symbol = first transfinite cardinal,U+2135 NEW -->; { "\u2135", "&alefsym;" }, // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the; // same glyph could be used to depict both characters -->; // <!-- Arrows -->; // leftwards arrow, U+2190 ISOnum -->; { "\u2190", "&larr;" }, // upwards arrow, U+2191 ISOnum-->; { "\u2191", "&uarr;" }, // rightwards arrow, U+2192 ISOnum -->; { "\u2192", "&rarr;" }, // downwards arrow, U+2193 ISOnum -->; { "\u2193", "&darr;" }, // left right arrow, U+2194 ISOamsa -->; { "\u2194", "&harr;" }, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->; { "\u21B5", "&crarr;" }, // leftwards double arrow, U+21D0 ISOtech -->; { "\u21D0", "&lArr;" }, // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'; // arrow but also does not have any other character for that function.; // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->; // upwards double arrow, U+21D1 ISOamsa -->; { "\u21D1", "&uArr;" }, // rightwards double arrow,U+21D2 ISOtech -->; { "\u21D2", "&rArr;" }, // <!-- ISO 10646 does not say this is the 'implies' character but does not; // have another character with this function so ?rArr can be used for; // 'implies' as ISOtech suggests -->; // downwards double arrow, U+21D3 ISOamsa -->; { "\u21D3", "&dArr;" }, // left right double arrow,U+21D4 ISOamsa -->; { "\u21D4", "&hArr;" }, // <!-- Mathematical Operators -->; // for all, U+2200 ISOtech -->; { "\u2200", "&forall;" }, // partial differential, U+2202 ISOtech -->; { "\u2202", "&part;" }, // there exists, U+2203 ISOtech -->; { "\u2203", "&exist;" }, // empty set = null set = diameter,U+2205 ISOamso -->; { "\u2205", "&empty;" }, // nabla = backward difference,U+2207 ISOtech -->; { "\u2207", "&nabla;" }, // element of, U+2208 ISOtech -->; { "\u2208", "&isin;" }, // not an element of, U+2209 ISOtech -->; { "\u2209", "&notin;" }, // contains as member, U+220B ISOtech -->; { "\u220B", "&ni;" }, // <!-- should there be a more memorable name than 'ni'? -->; // n-ary product = product sign,U+220F ISOamsb -->; { "\u220F", "&prod;" }, // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'; // though the same glyph might be used for both -->; // n-ary summation, U+2211 ISOamsb -->; { "\u2211", "&sum;" }, // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'; // though the same glyph might be used for both -->; // minus sign, U+2212 ISOtech -->; { "\u2212", "&minus;" }, // asterisk operator, U+2217 ISOtech -->; { "\u2217", "&lowast;" }, // square root = radical sign,U+221A ISOtech -->; { "\u221A", "&radic;" }, // proportional to, U+221D ISOtech -->; { "\u221D", "&prop;" }, // infinity, U+221E ISOtech -->; { "\u221E", "&infin;" }, // angle, U+2220 ISOamso -->; { "\u2220", "&ang;" }, // logical and = wedge, U+2227 ISOtech -->; { "\u2227", "&and;" }, // logical or = vee, U+2228 ISOtech -->; { "\u2228", "&or;" }, // intersection = cap, U+2229 ISOtech -->; { "\u2229", "&cap;" }, // union = cup, U+222A ISOtech -->; { "\u222A", "&cup;" }, // integral, U+222B ISOtech -->; { "\u222B", "&int;" }, // therefore, U+2234 ISOtech -->; { "\u2234", "&there4;" }, // tilde operator = varies with = similar to,U+223C ISOtech -->; { "\u223C", "&sim;" }, // <!-- tilde operator is NOT the same character as the tilde, U+007E,although; // the same glyph might be used to represent both -->; // approximately equal to, U+2245 ISOtech -->; { "\u2245", "&cong;" }, // almost equal to = asymptotic to,U+2248 ISOamsr -->; { "\u2248", "&asymp;" }, // not equal to, U+2260 ISOtech -->; { "\u2260", "&ne;" }, // identical to, U+2261 ISOtech -->; { "\u2261", "&equiv;" }, // less-than or equal to, U+2264 ISOtech -->; { "\u2264", "&le;" }, // greater-than or equal to,U+2265 ISOtech -->; { "\u2265", "&ge;" }, // subset of, U+2282 ISOtech -->; { "\u2282", "&sub;" }, // superset of, U+2283 ISOtech -->; { "\u2283", "&sup;" }, // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the; // Symbol font encoding and is not included. Should it be, for symmetry?; // It is in ISOamsn --> <!ENTITY nsub", "8836"},; // not a subset of, U+2284 ISOamsn -->; // subset of or equal to, U+2286 ISOtech -->; { "\u2286", "&sube;" }, // superset of or equal to,U+2287 ISOtech -->; { "\u2287", "&supe;" }, // circled plus = direct sum,U+2295 ISOamsb -->; { "\u2295", "&oplus;" }, // circled times = vector product,U+2297 ISOamsb -->; { "\u2297", "&otimes;" }, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->; { "\u22A5", "&perp;" }, // dot operator, U+22C5 ISOamsb -->; { "\u22C5", "&sdot;" }, // <!-- dot operator is NOT the same character as U+00B7 middle dot -->; // <!-- Miscellaneous Technical -->; // left ceiling = apl upstile,U+2308 ISOamsc -->; { "\u2308", "&lceil;" }, // right ceiling, U+2309 ISOamsc -->; { "\u2309", "&rceil;" }, // left floor = apl downstile,U+230A ISOamsc -->; { "\u230A", "&lfloor;" }, // right floor, U+230B ISOamsc -->; { "\u230B", "&rfloor;" }, // left-pointing angle bracket = bra,U+2329 ISOtech -->; { "\u2329", "&lang;" }, // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation; // mark' -->; // right-pointing angle bracket = ket,U+232A ISOtech -->; { "\u232A", "&rang;" }, // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A; // 'single right-pointing angle quotation mark' -->; // <!-- Geometric Shapes -->; // lozenge, U+25CA ISOpub -->; { "\u25CA", "&loz;" }, // <!-- Miscellaneous Symbols -->; // black spade suit, U+2660 ISOpub -->; { "\u2660", "&spades;" }, // <!-- black here seems to mean filled as opposed to hollow -->; // black club suit = shamrock,U+2663 ISOpub -->; { "\u2663", "&clubs;" }, // black heart suit = valentine,U+2665 ISOpub -->; { "\u2665", "&hearts;" }, // black diamond suit, U+2666 ISOpub -->; { "\u2666", "&diams;" }, // <!-- Latin Extended-A -->; // -- latin capital ligature OE,U+0152 ISOlat2 -->; { "\u0152", "&OElig;" }, // -- latin small ligature oe, U+0153 ISOlat2 -->; { "\u0153", "&oelig;" }, // <!-- ligature is a misnomer, this is a separate character in some languages -->; // -- latin capital letter S with caron,U+0160 ISOlat2 -->; { "\u0160", "&Scaron;" }, // -- latin small letter s with caron,U+0161 ISOlat2 -->; { "\u0161", "&scaron;" }, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->; { "\u0178", "&Yuml;" }, // <!-- Spacing Modifier Letters -->; // -- modifier letter circumflex accent,U+02C6 ISOpub -->; { "\u02C6", "&circ;" }, // small tilde, U+02DC ISOdia -->; { "\u02DC", "&tilde;" }, // <!-- General Punctuation -->; // en space, U+2002 ISOpub -->; { "\u2002", "&ensp;" }, // em space, U+2003 ISOpub -->; { "\u2003", "&emsp;" }, // thin space, U+2009 ISOpub -->; { "\u2009", "&thinsp;" }, // zero width non-joiner,U+200C NEW RFC 2070 -->; { "\u200C", "&zwnj;" }, // zero width joiner, U+200D NEW RFC 2070 -->; { "\u200D", "&zwj;" }, // left-to-right mark, U+200E NEW RFC 2070 -->; { "\u200E", "&lrm;" }, // right-to-left mark, U+200F NEW RFC 2070 -->; { "\u200F", "&rlm;" }, // en dash, U+2013 ISOpub -->; { "\u2013", "&ndash;" }, // em dash, U+2014 ISOpub -->; { "\u2014", "&mdash;" }, // left single quotation mark,U+2018 ISOnum -->; { "\u2018", "&lsquo;" }, // right single quotation mark,U+2019 ISOnum -->; { "\u2019", "&rsquo;" }, // single low-9 quotation mark, U+201A NEW -->; { "\u201A", "&sbquo;" }, // left double quotation mark,U+201C ISOnum -->; { "\u201C", "&ldquo;" }, // right double quotation mark,U+201D ISOnum -->; { "\u201D", "&rdquo;" }, // double low-9 quotation mark, U+201E NEW -->; { "\u201E", "&bdquo;" }, // dagger, U+2020 ISOpub -->; { "\u2020", "&dagger;" }, // double dagger, U+2021 ISOpub -->; { "\u2021", "&Dagger;" }, // per mille sign, U+2030 ISOtech -->; { "\u2030", "&permil;" }, // single left-pointing angle quotation mark,U+2039 ISO proposed -->; { "\u2039", "&lsaquo;" }, // <!-- lsaquo is proposed but not yet ISO standardized -->; // single right-pointing angle quotation mark,U+203A ISO proposed -->; { "\u203A", "&rsaquo;" }, // <!-- rsaquo is proposed but not yet ISO standardized -->; // -- euro sign, U+20AC NEW -->; { "\u20AC", "&euro;" } }]; String[][] HTML40_EXTENDED_UNESCAPE=Optional[invert(HTML40_EXTENDED_ESCAPE)]; String[][] BASIC_ESCAPE=Optional[{ // " - double-quote; { "\"", "&quot;" }, // & - ampersand; { "&", "&amp;" }, // < - less-than; { "<", "&lt;" }, // > - greater-than; { ">", "&gt;" } }]; String[][] BASIC_UNESCAPE=Optional[invert(BASIC_ESCAPE)]; String[][] APOS_ESCAPE=Optional[{ // XML apostrophe; { "'", "&apos;" } }]; String[][] APOS_UNESCAPE=Optional[invert(APOS_ESCAPE)]; String[][] JAVA_CTRL_CHARS_ESCAPE=Optional[{ { "\b", "\\b" }, { "\n", "\\n" }, { "\t", "\\t" }, { "\f", "\\f" }, { "\r", "\\r" } }
public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] }
public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException { [EOL]     return initializer != null ? initializer.get() : null; [EOL] }
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException { [EOL]     return initializer != null ? initializer.get() : null; [EOL] }
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) { [EOL]     try { [EOL]         return createIfAbsent(map, key, init); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) { [EOL]     try { [EOL]         return createIfAbsent(map, key, init); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) { [EOL]     try { [EOL]         return createIfAbsent(map, key, init); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Locale getLocale() { [EOL]     return locale; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL]     final Date date = parse(source, new ParsePosition(0)); [EOL]     if (date == null) { [EOL]         if (locale.equals(JAPANESE_IMPERIAL)) { [EOL]             throw new ParseException("(The " + locale + " locale does not support dates before 1868 AD)\n" + "Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]         } [EOL]         throw new ParseException("Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]     } [EOL]     return date; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL]     final Date date = parse(source, new ParsePosition(0)); [EOL]     if (date == null) { [EOL]         if (locale.equals(JAPANESE_IMPERIAL)) { [EOL]             throw new ParseException("(The " + locale + " locale does not support dates before 1868 AD)\n" + "Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]         } [EOL]         throw new ParseException("Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]     } [EOL]     return date; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL]     final int offset = pos.getIndex(); [EOL]     final Matcher matcher = parsePattern.matcher(source.substring(offset)); [EOL]     if (!matcher.lookingAt()) { [EOL]         return null; [EOL]     } [EOL]     final Calendar cal = Calendar.getInstance(timeZone, locale); [EOL]     cal.clear(); [EOL]     for (int i = 0; i < strategies.length; ) { [EOL]         final Strategy strategy = strategies[i++]; [EOL]         strategy.setCalendar(this, cal, matcher.group(i)); [EOL]     } [EOL]     pos.setIndex(offset + matcher.end()); [EOL]     return cal.getTime(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int getFieldWidth() { [EOL]     return currentFormatField.length(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private Strategy getStrategy(String formatField, final Calendar definingCalendar) { [EOL]     switch(formatField.charAt(0)) { [EOL]         case '\'': [EOL]             if (formatField.length() > 2) { [EOL]                 formatField = formatField.substring(1, formatField.length() - 1); [EOL]             } [EOL]         default: [EOL]             return new CopyQuotedStrategy(formatField); [EOL]         case 'D': [EOL]             return DAY_OF_YEAR_STRATEGY; [EOL]         case 'E': [EOL]             return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar); [EOL]         case 'F': [EOL]             return DAY_OF_WEEK_IN_MONTH_STRATEGY; [EOL]         case 'G': [EOL]             return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar); [EOL]         case 'H': [EOL]             return MODULO_HOUR_OF_DAY_STRATEGY; [EOL]         case 'K': [EOL]             return HOUR_STRATEGY; [EOL]         case 'M': [EOL]             return formatField.length() >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY; [EOL]         case 'S': [EOL]             return MILLISECOND_STRATEGY; [EOL]         case 'W': [EOL]             return WEEK_OF_MONTH_STRATEGY; [EOL]         case 'a': [EOL]             return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [EOL]         case 'd': [EOL]             return DAY_OF_MONTH_STRATEGY; [EOL]         case 'h': [EOL]             return MODULO_HOUR_STRATEGY; [EOL]         case 'k': [EOL]             return HOUR_OF_DAY_STRATEGY; [EOL]         case 'm': [EOL]             return MINUTE_STRATEGY; [EOL]         case 's': [EOL]             return SECOND_STRATEGY; [EOL]         case 'w': [EOL]             return WEEK_OF_YEAR_STRATEGY; [EOL]         case 'y': [EOL]             return formatField.length() > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY; [EOL]         case 'Z': [EOL]         case 'z': [EOL]             return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar); [EOL]     } [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) { [EOL]     final ConcurrentMap<Locale, Strategy> cache = getCache(field); [EOL]     Strategy strategy = cache.get(locale); [EOL]     if (strategy == null) { [EOL]         strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(locale) : new TextStrategy(field, definingCalendar, locale); [EOL]         final Strategy inCache = cache.putIfAbsent(locale, strategy); [EOL]         if (inCache != null) { [EOL]             return inCache; [EOL]         } [EOL]     } [EOL]     return strategy; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     if (parser.isNextNumber()) { [EOL]         regex.append("(\\p{IsNd}{").append(parser.getFieldWidth()).append("}+)"); [EOL]     } else { [EOL]         regex.append("(\\p{IsNd}++)"); [EOL]     } [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     if (parser.isNextNumber()) { [EOL]         regex.append("(\\p{IsNd}{").append(parser.getFieldWidth()).append("}+)"); [EOL]     } else { [EOL]         regex.append("(\\p{IsNd}++)"); [EOL]     } [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
TimeZoneStrategy(final Locale locale) { [EOL]     for (final String id : TimeZone.getAvailableIDs()) { [EOL]         if (id.startsWith("GMT")) { [EOL]             continue; [EOL]         } [EOL]         final TimeZone tz = TimeZone.getTimeZone(id); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz); [EOL]         if (tz.useDaylightTime()) { [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz); [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz); [EOL]         } [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(); [EOL]     sb.append("(GMT[+\\-]\\d{0,1}\\d{2}|[+\\-]\\d{2}:?\\d{2}|"); [EOL]     for (final String id : tzNames.keySet()) { [EOL]         escapeRegex(sb, id, false).append('|'); [EOL]     } [EOL]     sb.setCharAt(sb.length() - 1, ')'); [EOL]     validTimeZoneChars = sb.toString(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
TimeZoneStrategy(final Locale locale) { [EOL]     for (final String id : TimeZone.getAvailableIDs()) { [EOL]         if (id.startsWith("GMT")) { [EOL]             continue; [EOL]         } [EOL]         final TimeZone tz = TimeZone.getTimeZone(id); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz); [EOL]         if (tz.useDaylightTime()) { [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz); [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz); [EOL]         } [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(); [EOL]     sb.append("(GMT[+\\-]\\d{0,1}\\d{2}|[+\\-]\\d{2}:?\\d{2}|"); [EOL]     for (final String id : tzNames.keySet()) { [EOL]         escapeRegex(sb, id, false).append('|'); [EOL]     } [EOL]     sb.setCharAt(sb.length() - 1, ')'); [EOL]     validTimeZoneChars = sb.toString(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
TimeZoneStrategy(final Locale locale) { [EOL]     for (final String id : TimeZone.getAvailableIDs()) { [EOL]         if (id.startsWith("GMT")) { [EOL]             continue; [EOL]         } [EOL]         final TimeZone tz = TimeZone.getTimeZone(id); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz); [EOL]         if (tz.useDaylightTime()) { [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz); [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz); [EOL]         } [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(); [EOL]     sb.append("(GMT[+\\-]\\d{0,1}\\d{2}|[+\\-]\\d{2}:?\\d{2}|"); [EOL]     for (final String id : tzNames.keySet()) { [EOL]         escapeRegex(sb, id, false).append('|'); [EOL]     } [EOL]     sb.setCharAt(sb.length() - 1, ')'); [EOL]     validTimeZoneChars = sb.toString(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
TimeZoneStrategy(final Locale locale) { [EOL]     for (final String id : TimeZone.getAvailableIDs()) { [EOL]         if (id.startsWith("GMT")) { [EOL]             continue; [EOL]         } [EOL]         final TimeZone tz = TimeZone.getTimeZone(id); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz); [EOL]         tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz); [EOL]         if (tz.useDaylightTime()) { [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz); [EOL]             tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz); [EOL]         } [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(); [EOL]     sb.append("(GMT[+\\-]\\d{0,1}\\d{2}|[+\\-]\\d{2}:?\\d{2}|"); [EOL]     for (final String id : tzNames.keySet()) { [EOL]         escapeRegex(sb, id, false).append('|'); [EOL]     } [EOL]     sb.setCharAt(sb.length() - 1, ')'); [EOL]     validTimeZoneChars = sb.toString(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(final int whole, final int numerator, final int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         throw new ArithmeticException("The denominator must not be negative"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         throw new ArithmeticException("The numerator must not be negative"); [EOL]     } [EOL]     long numeratorValue; [EOL]     if (whole < 0) { [EOL]         numeratorValue = whole * (long) denominator - numerator; [EOL]     } else { [EOL]         numeratorValue = whole * (long) denominator + numerator; [EOL]     } [EOL]     if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Numerator too large to represent as an Integer."); [EOL]     } [EOL]     return new Fraction((int) numeratorValue, denominator); [EOL] }
public Fraction negate() { [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: too large to negate"); [EOL]     } [EOL]     return new Fraction(-numerator, denominator); [EOL] }
public Fraction negate() { [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: too large to negate"); [EOL]     } [EOL]     return new Fraction(-numerator, denominator); [EOL] }
public Fraction abs() { [EOL]     if (numerator >= 0) { [EOL]         return this; [EOL]     } [EOL]     return negate(); [EOL] }
public Fraction abs() { [EOL]     if (numerator >= 0) { [EOL]         return this; [EOL]     } [EOL]     return negate(); [EOL] }
public Fraction abs() { [EOL]     if (numerator >= 0) { [EOL]         return this; [EOL]     } [EOL]     return negate(); [EOL] }
private static int subAndCheck(final int x, final int y) { [EOL]     final long s = (long) x - (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] }
private static int subAndCheck(final int x, final int y) { [EOL]     final long s = (long) x - (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] }
private static int subAndCheck(final int x, final int y) { [EOL]     final long s = (long) x - (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] }
public Fraction subtract(final Fraction fraction) { [EOL]     return addSub(fraction, false); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static int indexOf(final CharSequence cs, final int searchChar, int start) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).indexOf(searchChar, start); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         if (start < 0) { [EOL]             start = 0; [EOL]         } [EOL]         for (int i = start; i < sz; i++) { [EOL]             if (cs.charAt(i) == searchChar) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public static JavaUnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new JavaUnicodeEscaper(codepointLow, codepointHigh, false); [EOL] }
public static JavaUnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new JavaUnicodeEscaper(codepointLow, codepointHigh, false); [EOL] }
public JavaUnicodeEscaper(final int below, final int above, final boolean between) { [EOL]     super(below, above, between); [EOL] }
public JavaUnicodeEscaper(final int below, final int above, final boolean between) { [EOL]     super(below, above, between); [EOL] }
public JavaUnicodeEscaper(final int below, final int above, final boolean between) { [EOL]     super(below, above, between); [EOL] }
public JavaUnicodeEscaper(final int below, final int above, final boolean between) { [EOL]     super(below, above, between); [EOL] }
protected List<Rule> parsePattern() { [EOL]     final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL]     final List<Rule> rules = new ArrayList<Rule>(); [EOL]     final String[] ERAs = symbols.getEras(); [EOL]     final String[] months = symbols.getMonths(); [EOL]     final String[] shortMonths = symbols.getShortMonths(); [EOL]     final String[] weekdays = symbols.getWeekdays(); [EOL]     final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL]     final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL]     final int length = mPattern.length(); [EOL]     final int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         final String token = parseToken(mPattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         final int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         Rule rule; [EOL]         final char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 rule = new TextField(Calendar.ERA, ERAs); [EOL]                 break; [EOL]             case 'y': [EOL]                 if (tokenLen == 2) { [EOL]                     rule = TwoDigitYearField.INSTANCE; [EOL]                 } else { [EOL]                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TextField(Calendar.MONTH, months); [EOL]                 } else if (tokenLen == 3) { [EOL]                     rule = new TextField(Calendar.MONTH, shortMonths); [EOL]                 } else if (tokenLen == 2) { [EOL]                     rule = TwoDigitMonthField.INSTANCE; [EOL]                 } else { [EOL]                     rule = UnpaddedMonthField.INSTANCE; [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'h': [EOL]                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL]                 break; [EOL]             case 'H': [EOL]                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL]                 break; [EOL]             case 'D': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'F': [EOL]                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL]                 break; [EOL]             case 'W': [EOL]                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL]                 break; [EOL]             case 'k': [EOL]                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL]                 break; [EOL]             case 'K': [EOL]                 rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL]                 } else { [EOL]                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL]                 } else { [EOL]                     rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 final String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     rule = new CharacterLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     rule = new StringLiteral(sub); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]         rules.add(rule); [EOL]     } [EOL]     return rules; [EOL] }
protected String parseToken(final String pattern, final int[] indexRef) { [EOL]     final StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     final int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             final char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] }
private String applyRulesToString(final Calendar c) { [EOL]     return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); [EOL] }
private String applyRulesToString(final Calendar c) { [EOL]     return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); [EOL] }
private GregorianCalendar newCalendar() { [EOL]     return new GregorianCalendar(mTimeZone, mLocale); [EOL] }
@Override [EOL] public String format(final Date date) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRulesToString(c); [EOL] }
@Override [EOL] public String format(final Date date) { [EOL]     final Calendar c = newCalendar(); [EOL]     c.setTime(date); [EOL]     return applyRulesToString(c); [EOL] }
private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     init(); [EOL] }
StringLiteral(final String value) { [EOL]     mValue = value; [EOL] }
StringLiteral(final String value) { [EOL]     mValue = value; [EOL] }
StringLiteral(final String value) { [EOL]     mValue = value; [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return mValue.length(); [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return mValue.length(); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     buffer.append(mValue); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 10) { [EOL]         buffer.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
UnpaddedMonthField() { [EOL]     super(); [EOL] }
TwoDigitYearField() { [EOL]     super(); [EOL] }
TwelveHourField(final NumberRule rule) { [EOL]     mRule = rule; [EOL] }
TwelveHourField(final NumberRule rule) { [EOL]     mRule = rule; [EOL] }
TwentyFourHourField(final NumberRule rule) { [EOL]     mRule = rule; [EOL] }
TwentyFourHourField(final NumberRule rule) { [EOL]     mRule = rule; [EOL] }
@Override [EOL] public int estimateLength() { [EOL]     return mRule.estimateLength(); [EOL] }
static Set<Pair<IDKey, IDKey>> getRegistry() { [EOL]     return REGISTRY.get(); [EOL] }
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) { [EOL]     final IDKey left = new IDKey(lhs); [EOL]     final IDKey right = new IDKey(rhs); [EOL]     return Pair.of(left, right); [EOL] }
static boolean isRegistered(final Object lhs, final Object rhs) { [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight()); [EOL]     return registry != null && (registry.contains(pair) || registry.contains(swappedPair)); [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients) { [EOL]     return reflectionEquals(lhs, rhs, testTransients, null); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients) { [EOL]     return reflectionEquals(lhs, rhs, testTransients, null); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients) { [EOL]     return reflectionEquals(lhs, rhs, testTransients, null); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients) { [EOL]     return reflectionEquals(lhs, rhs, testTransients, null); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     if (isRegistered(lhs, rhs)) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         register(lhs, rhs); [EOL]         final Field[] fields = clazz.getDeclaredFields(); [EOL]         AccessibleObject.setAccessible(fields, true); [EOL]         for (int i = 0; i < fields.length && builder.isEquals; i++) { [EOL]             final Field f = fields[i]; [EOL]             if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]                 try { [EOL]                     builder.append(f.get(lhs), f.get(rhs)); [EOL]                 } catch (final IllegalAccessException e) { [EOL]                     throw new InternalError("Unexpected IllegalAccessException"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(lhs, rhs); [EOL]     } [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final int lhs, final int rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final int lhs, final int rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final int lhs, final int rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final char lhs, final char rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final char lhs, final char rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final char lhs, final char rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte lhs, final byte rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte lhs, final byte rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte lhs, final byte rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final char[] lhs, final char[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public void reset() { [EOL]     this.isEquals = true; [EOL] }
NoMatcher() { [EOL]     super(); [EOL] }
TrimMatcher() { [EOL]     super(); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public MutableByte(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Byte.parseByte(value); [EOL] }
public MutableByte(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Byte.parseByte(value); [EOL] }
public MutableByte(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Byte.parseByte(value); [EOL] }
@Override [EOL] public int compareTo(final MutableByte other) { [EOL]     final byte anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableByte other) { [EOL]     final byte anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableByte other) { [EOL]     final byte anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
public final CharSequenceTranslator with(final CharSequenceTranslator... translators) { [EOL]     final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1]; [EOL]     newArray[0] = this; [EOL]     System.arraycopy(translators, 0, newArray, 1, translators.length); [EOL]     return new AggregateTranslator(newArray); [EOL] }
public final CharSequenceTranslator with(final CharSequenceTranslator... translators) { [EOL]     final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1]; [EOL]     newArray[0] = this; [EOL]     System.arraycopy(translators, 0, newArray, 1, translators.length); [EOL]     return new AggregateTranslator(newArray); [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final CharSequence ellipsis) { [EOL]     return append(seq, formatter, flags, width, precision, ' ', ellipsis); [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final CharSequence ellipsis) { [EOL]     return append(seq, formatter, flags, width, precision, ' ', ellipsis); [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final CharSequence ellipsis) { [EOL]     return append(seq, formatter, flags, width, precision, ' ', ellipsis); [EOL] }
public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) { [EOL]     return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants())); [EOL] }
public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) { [EOL]     return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants())); [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) { [EOL]     checkBitVectorable(enumClass); [EOL]     Validate.notNull(values); [EOL]     long total = 0; [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         total |= 1 << constant.ordinal(); [EOL]     } [EOL]     return total; [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) { [EOL]     Validate.noNullElements(values); [EOL]     return generateBitVector(enumClass, Arrays.<E>asList(values)); [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) { [EOL]     Validate.noNullElements(values); [EOL]     return generateBitVector(enumClass, Arrays.<E>asList(values)); [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) { [EOL]     Validate.noNullElements(values); [EOL]     return generateBitVector(enumClass, Arrays.<E>asList(values)); [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
private static <E extends Enum<E>> Class<E> checkBitVectorable(final Class<E> enumClass) { [EOL]     final E[] constants = asEnum(enumClass).getEnumConstants(); [EOL]     Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS, constants.length, enumClass.getSimpleName(), Long.SIZE); [EOL]     return enumClass; [EOL] }
private static <E extends Enum<E>> Class<E> checkBitVectorable(final Class<E> enumClass) { [EOL]     final E[] constants = asEnum(enumClass).getEnumConstants(); [EOL]     Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS, constants.length, enumClass.getSimpleName(), Long.SIZE); [EOL]     return enumClass; [EOL] }
private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] }
private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] }
private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] }
public F getInstance() { [EOL]     return getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault()); [EOL] }
public static void setDefaultStyle(final ToStringStyle style) { [EOL]     if (style == null) { [EOL]         throw new IllegalArgumentException("The style must not be null"); [EOL]     } [EOL]     defaultStyle = style; [EOL] }
public ToStringBuilder(final Object object, final ToStringStyle style) { [EOL]     this(object, style, null); [EOL] }
public ToStringBuilder(final Object object, final ToStringStyle style) { [EOL]     this(object, style, null); [EOL] }
public ToStringBuilder append(final byte[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final byte[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final short value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final short value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final short value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder appendToString(final String toString) { [EOL]     if (toString != null) { [EOL]         style.appendToString(buffer, toString); [EOL]     } [EOL]     return this; [EOL] }
public ToStringBuilder appendToString(final String toString) { [EOL]     if (toString != null) { [EOL]         style.appendToString(buffer, toString); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public String build() { [EOL]     return toString(); [EOL] }
public MutableObject() { [EOL]     super(); [EOL] }
public MutableObject(final T value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
public MutableObject(final T value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
@Override [EOL] public T getValue() { [EOL]     return this.value; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { [EOL]     return parseDate(str, null, parsePatterns); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { [EOL]     return parseDateStrictly(str, null, parsePatterns); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { [EOL]     return parseDateWithLeniency(str, null, parsePatterns, false); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     Calendar start = null; [EOL]     Calendar end = null; [EOL]     int startCutoff = Calendar.SUNDAY; [EOL]     int endCutoff = Calendar.SATURDAY; [EOL]     switch(rangeStyle) { [EOL]         case RANGE_MONTH_SUNDAY: [EOL]         case RANGE_MONTH_MONDAY: [EOL]             start = truncate(focus, Calendar.MONTH); [EOL]             end = (Calendar) start.clone(); [EOL]             end.add(Calendar.MONTH, 1); [EOL]             end.add(Calendar.DATE, -1); [EOL]             if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL]                 startCutoff = Calendar.MONDAY; [EOL]                 endCutoff = Calendar.SUNDAY; [EOL]             } [EOL]             break; [EOL]         case RANGE_WEEK_SUNDAY: [EOL]         case RANGE_WEEK_MONDAY: [EOL]         case RANGE_WEEK_RELATIVE: [EOL]         case RANGE_WEEK_CENTER: [EOL]             start = truncate(focus, Calendar.DATE); [EOL]             end = truncate(focus, Calendar.DATE); [EOL]             switch(rangeStyle) { [EOL]                 case RANGE_WEEK_SUNDAY: [EOL]                     break; [EOL]                 case RANGE_WEEK_MONDAY: [EOL]                     startCutoff = Calendar.MONDAY; [EOL]                     endCutoff = Calendar.SUNDAY; [EOL]                     break; [EOL]                 case RANGE_WEEK_RELATIVE: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL]                     endCutoff = startCutoff - 1; [EOL]                     break; [EOL]                 case RANGE_WEEK_CENTER: [EOL]                     startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL]                     endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL]                     break; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL]     } [EOL]     if (startCutoff < Calendar.SUNDAY) { [EOL]         startCutoff += 7; [EOL]     } [EOL]     if (startCutoff > Calendar.SATURDAY) { [EOL]         startCutoff -= 7; [EOL]     } [EOL]     if (endCutoff < Calendar.SUNDAY) { [EOL]         endCutoff += 7; [EOL]     } [EOL]     if (endCutoff > Calendar.SATURDAY) { [EOL]         endCutoff -= 7; [EOL]     } [EOL]     while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL]         start.add(Calendar.DATE, -1); [EOL]     } [EOL]     while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL]         end.add(Calendar.DATE, 1); [EOL]     } [EOL]     return new DateIterator(start, end); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInHours(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
@Override [EOL] public Calendar next() { [EOL]     if (spot.equals(endFinal)) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     spot.add(Calendar.DATE, 1); [EOL]     return (Calendar) spot.clone(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
@Override [EOL] public void remove() { [EOL]     throw new UnsupportedOperationException(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public WordUtils() { [EOL]     super(); [EOL] }
public static String wrap(final String str, final int wrapLength) { [EOL]     return wrap(str, wrapLength, null, false); [EOL] }
public static String wrap(final String str, final int wrapLength) { [EOL]     return wrap(str, wrapLength, null, false); [EOL] }
public static String wrap(final String str, final int wrapLength) { [EOL]     return wrap(str, wrapLength, null, false); [EOL] }
public static String wrap(final String str, final int wrapLength) { [EOL]     return wrap(str, wrapLength, null, false); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public AggregateTranslator(final CharSequenceTranslator... translators) { [EOL]     this.translators = ArrayUtils.clone(translators); [EOL] }
public AggregateTranslator(final CharSequenceTranslator... translators) { [EOL]     this.translators = ArrayUtils.clone(translators); [EOL] }
public AggregateTranslator(final CharSequenceTranslator... translators) { [EOL]     this.translators = ArrayUtils.clone(translators); [EOL] }
public AggregateTranslator(final CharSequenceTranslator... translators) { [EOL]     this.translators = ArrayUtils.clone(translators); [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public static List<Locale> availableLocaleList() { [EOL]     return SyncAvoid.AVAILABLE_LOCALE_LIST; [EOL] }
public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] }
public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] }
public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] }
public static boolean isEquals(final Object array1, final Object array2) { [EOL]     return new EqualsBuilder().append(array1, array2).isEquals(); [EOL] }
public static char[] clone(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static char[] clone(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static char[] clone(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static int[] nullToEmpty(final int[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static int[] nullToEmpty(final int[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static int[] nullToEmpty(final int[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static double[] nullToEmpty(final double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static double[] nullToEmpty(final double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static double[] nullToEmpty(final double[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     final Class<?> type = array.getClass().getComponentType(); [EOL]     if (newSize <= 0) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final T[] emptyArray = (T[]) Array.newInstance(type, 0); [EOL]         return emptyArray; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] subarray = (T[]) Array.newInstance(type, newSize); [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] subarray = new char[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean isSameLength(final long[] array1, final long[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final long[] array1, final long[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final long[] array1, final long[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final long[] array1, final long[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final long[] array1, final long[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static int getLength(final Object array) { [EOL]     if (array == null) { [EOL]         return 0; [EOL]     } [EOL]     return Array.getLength(array); [EOL] }
public static int getLength(final Object array) { [EOL]     if (array == null) { [EOL]         return 0; [EOL]     } [EOL]     return Array.getLength(array); [EOL] }
public static int getLength(final Object array) { [EOL]     if (array == null) { [EOL]         return 0; [EOL]     } [EOL]     return Array.getLength(array); [EOL] }
public static int getLength(final Object array) { [EOL]     if (array == null) { [EOL]         return 0; [EOL]     } [EOL]     return Array.getLength(array); [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final Object[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     Object tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final short[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     short tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final char[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     char tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final byte[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     byte tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final double[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     double tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final long[] array, final long valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final int[] array, final int valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance); [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind, 0); [EOL] }
public static int indexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].longValue(); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] }
public static long[] toPrimitive(final Long[] array, final long valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] result = new long[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Long b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.longValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Byte b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.byteValue()); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Byte b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.byteValue()); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Byte b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.byteValue()); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Byte b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.byteValue()); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Byte b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.byteValue()); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static <T> T[] addAll(final T[] array1, final T... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final Class<?> type1 = array1.getClass().getComponentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     try { [EOL]         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     } catch (final ArrayStoreException ase) { [EOL]         final Class<?> type2 = array2.getClass().getComponentType(); [EOL]         if (!type1.isAssignableFrom(type2)) { [EOL]             throw new IllegalArgumentException("Cannot store " + type2.getName() + " in an array of " + type1.getName(), ase); [EOL]         } [EOL]         throw ase; [EOL]     } [EOL]     return joinedArray; [EOL] }
public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static boolean[] addAll(final boolean[] array1, final boolean... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final boolean[] joinedArray = new boolean[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static char[] addAll(final char[] array1, final char... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final char[] joinedArray = new char[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static byte[] addAll(final byte[] array1, final byte... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final byte[] joinedArray = new byte[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static short[] addAll(final short[] array1, final short... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final short[] joinedArray = new short[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static int[] addAll(final int[] array1, final int... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final int[] joinedArray = new int[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static int[] addAll(final int[] array1, final int... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final int[] joinedArray = new int[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static long[] addAll(final long[] array1, final long... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final long[] joinedArray = new long[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static float[] addAll(final float[] array1, final float... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final float[] joinedArray = new float[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
public static byte[] add(final byte[] array, final byte element) { [EOL]     final byte[] newArray = (byte[]) copyArrayGrow1(array, Byte.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static byte[] add(final byte[] array, final byte element) { [EOL]     final byte[] newArray = (byte[]) copyArrayGrow1(array, Byte.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static char[] remove(final char[] array, final int index) { [EOL]     return (char[]) remove((Object) array, index); [EOL] }
public static char[] remove(final char[] array, final int index) { [EOL]     return (char[]) remove((Object) array, index); [EOL] }
public static char[] remove(final char[] array, final int index) { [EOL]     return (char[]) remove((Object) array, index); [EOL] }
public static char[] remove(final char[] array, final int index) { [EOL]     return (char[]) remove((Object) array, index); [EOL] }
public static char[] remove(final char[] array, final int index) { [EOL]     return (char[]) remove((Object) array, index); [EOL] }
public static char[] remove(final char[] array, final int index) { [EOL]     return (char[]) remove((Object) array, index); [EOL] }
public static double[] remove(final double[] array, final int index) { [EOL]     return (double[]) remove((Object) array, index); [EOL] }
public static double[] remove(final double[] array, final int index) { [EOL]     return (double[]) remove((Object) array, index); [EOL] }
public static double[] remove(final double[] array, final int index) { [EOL]     return (double[]) remove((Object) array, index); [EOL] }
public static double[] remove(final double[] array, final int index) { [EOL]     return (double[]) remove((Object) array, index); [EOL] }
public static double[] remove(final double[] array, final int index) { [EOL]     return (double[]) remove((Object) array, index); [EOL] }
public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] }
public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] }
public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] }
public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] }
public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] }
public static short[] remove(final short[] array, final int index) { [EOL]     return (short[]) remove((Object) array, index); [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] removeAll(final T[] array, final int... indices) { [EOL]     return (T[]) removeAll((Object) array, clone(indices)); [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static <T> T[] removeElements(final T[] array, final T... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length); [EOL]     for (final T v : values) { [EOL]         final MutableInt count = occurrences.get(v); [EOL]         if (count == null) { [EOL]             occurrences.put(v, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]         final T v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v, found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] result = (T[]) removeAll(array, toRemove); [EOL]     return result; [EOL] }
public static byte[] removeElements(final byte[] array, final byte... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length); [EOL]     for (final byte v : values) { [EOL]         final Byte boxed = Byte.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) { [EOL]         final Byte v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.byteValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (byte[]) removeAll(array, toRemove); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
static void setAccessibleWorkaround(final AccessibleObject o) { [EOL]     if (o == null || o.isAccessible()) { [EOL]         return; [EOL]     } [EOL]     final Member m = (Member) o; [EOL]     if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { [EOL]         try { [EOL]             o.setAccessible(true); [EOL]         } catch (final SecurityException e) { [EOL]         } [EOL]     } [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] }
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] }
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] }
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public boolean isEmpty() { [EOL]     return size == 0; [EOL] }
public boolean isEmpty() { [EOL]     return size == 0; [EOL] }
public StrBuilder clear() { [EOL]     size = 0; [EOL]     return this; [EOL] }
public StrBuilder setCharAt(final int index, final char ch) { [EOL]     if (index < 0 || index >= length()) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     buffer[index] = ch; [EOL]     return this; [EOL] }
public StrBuilder setCharAt(final int index, final char ch) { [EOL]     if (index < 0 || index >= length()) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     buffer[index] = ch; [EOL]     return this; [EOL] }
public StrBuilder setCharAt(final int index, final char ch) { [EOL]     if (index < 0 || index >= length()) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     buffer[index] = ch; [EOL]     return this; [EOL] }
public char[] toCharArray() { [EOL]     if (size == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[size]; [EOL]     System.arraycopy(buffer, 0, chars, 0, size); [EOL]     return chars; [EOL] }
public char[] toCharArray() { [EOL]     if (size == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[size]; [EOL]     System.arraycopy(buffer, 0, chars, 0, size); [EOL]     return chars; [EOL] }
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] }
public StrBuilder appendNull() { [EOL]     if (nullText == null) { [EOL]         return this; [EOL]     } [EOL]     return append(nullText); [EOL] }
public StrBuilder appendNull() { [EOL]     if (nullText == null) { [EOL]         return this; [EOL]     } [EOL]     return append(nullText); [EOL] }
public StrBuilder append(final Object obj) { [EOL]     if (obj == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     return append(obj.toString()); [EOL] }
public StrBuilder append(final Object obj) { [EOL]     if (obj == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     return append(obj.toString()); [EOL] }
@Override [EOL] public StrBuilder append(final CharSequence seq) { [EOL]     if (seq == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     return append(seq.toString()); [EOL] }
@Override [EOL] public StrBuilder append(final CharSequence seq) { [EOL]     if (seq == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     return append(seq.toString()); [EOL] }
public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final char[] chars) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = chars.length; [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(chars, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final char[] chars) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = chars.length; [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(chars, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final char[] chars) { [EOL]     if (chars == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = chars.length; [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(chars, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendln(final String str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final String str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final String str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendAll(final Iterator<?> it) { [EOL]     if (it != null) { [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendAll(final Iterator<?> it) { [EOL]     if (it != null) { [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) { [EOL]     if (it != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) { [EOL]     final String str = isEmpty() ? defaultIfEmpty : standard; [EOL]     if (str != null) { [EOL]         append(str); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) { [EOL]     final String str = isEmpty() ? defaultIfEmpty : standard; [EOL]     if (str != null) { [EOL]         append(str); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) { [EOL]     final String str = isEmpty() ? defaultIfEmpty : standard; [EOL]     if (str != null) { [EOL]         append(str); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) { [EOL]     final String str = isEmpty() ? defaultIfEmpty : standard; [EOL]     if (str != null) { [EOL]         append(str); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendPadding(final int length, final char padChar) { [EOL]     if (length >= 0) { [EOL]         ensureCapacity(size + length); [EOL]         for (int i = 0; i < length; i++) { [EOL]             buffer[size++] = padChar; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendPadding(final int length, final char padChar) { [EOL]     if (length >= 0) { [EOL]         ensureCapacity(size + length); [EOL]         for (int i = 0; i < length; i++) { [EOL]             buffer[size++] = padChar; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendPadding(final int length, final char padChar) { [EOL]     if (length >= 0) { [EOL]         ensureCapacity(size + length); [EOL]         for (int i = 0; i < length; i++) { [EOL]             buffer[size++] = padChar; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final StrMatcher matcher) { [EOL]     return replace(matcher, null, 0, size, -1); [EOL] }
public StrBuilder deleteAll(final StrMatcher matcher) { [EOL]     return replace(matcher, null, 0, size, -1); [EOL] }
public StrBuilder deleteAll(final StrMatcher matcher) { [EOL]     return replace(matcher, null, 0, size, -1); [EOL] }
public StrBuilder deleteAll(final StrMatcher matcher) { [EOL]     return replace(matcher, null, 0, size, -1); [EOL] }
private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) { [EOL]     final int newSize = size - removeLen + insertLen; [EOL]     if (insertLen != removeLen) { [EOL]         ensureCapacity(newSize); [EOL]         System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex); [EOL]         size = newSize; [EOL]     } [EOL]     if (insertLen > 0) { [EOL]         insertStr.getChars(0, insertLen, buffer, startIndex); [EOL]     } [EOL] }
private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) { [EOL]     final int newSize = size - removeLen + insertLen; [EOL]     if (insertLen != removeLen) { [EOL]         ensureCapacity(newSize); [EOL]         System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex); [EOL]         size = newSize; [EOL]     } [EOL]     if (insertLen > 0) { [EOL]         insertStr.getChars(0, insertLen, buffer, startIndex); [EOL]     } [EOL] }
private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) { [EOL]     final int newSize = size - removeLen + insertLen; [EOL]     if (insertLen != removeLen) { [EOL]         ensureCapacity(newSize); [EOL]         System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex); [EOL]         size = newSize; [EOL]     } [EOL]     if (insertLen > 0) { [EOL]         insertStr.getChars(0, insertLen, buffer, startIndex); [EOL]     } [EOL] }
private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) { [EOL]     final int newSize = size - removeLen + insertLen; [EOL]     if (insertLen != removeLen) { [EOL]         ensureCapacity(newSize); [EOL]         System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex); [EOL]         size = newSize; [EOL]     } [EOL]     if (insertLen > 0) { [EOL]         insertStr.getChars(0, insertLen, buffer, startIndex); [EOL]     } [EOL] }
public StrBuilder replaceAll(final String searchStr, final String replaceStr) { [EOL]     final int searchLen = (searchStr == null ? 0 : searchStr.length()); [EOL]     if (searchLen > 0) { [EOL]         final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]         int index = indexOf(searchStr, 0); [EOL]         while (index >= 0) { [EOL]             replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); [EOL]             index = indexOf(searchStr, index + replaceLen); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, -1); [EOL] }
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, -1); [EOL] }
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, -1); [EOL] }
public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) { [EOL]     return replace(matcher, replaceStr, 0, size, -1); [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder trim() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     int len = size; [EOL]     final char[] buf = buffer; [EOL]     int pos = 0; [EOL]     while (pos < len && buf[pos] <= ' ') { [EOL]         pos++; [EOL]     } [EOL]     while (pos < len && buf[len - 1] <= ' ') { [EOL]         len--; [EOL]     } [EOL]     if (len < size) { [EOL]         delete(len, size); [EOL]     } [EOL]     if (pos > 0) { [EOL]         delete(0, pos); [EOL]     } [EOL]     return this; [EOL] }
public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean startsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         if (buffer[i] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] }
public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] }
public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] }
public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } [EOL]     return new String(buffer, index, length); [EOL] }
public boolean contains(final char ch) { [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = 0; i < this.size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(final char ch) { [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = 0; i < this.size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final StrMatcher matcher) { [EOL]     return indexOf(matcher, 0); [EOL] }
public int lastIndexOf(final char ch) { [EOL]     return lastIndexOf(ch, size - 1); [EOL] }
public int lastIndexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (buffer[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (buffer[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (buffer[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (buffer[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (str == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0 && strLen <= size) { [EOL]         if (strLen == 1) { [EOL]             return lastIndexOf(str.charAt(0), startIndex); [EOL]         } [EOL]         outer: for (int i = startIndex - strLen + 1; i >= 0; i--) { [EOL]             for (int j = 0; j < strLen; j++) { [EOL]                 if (str.charAt(j) != buffer[i + j]) { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]             return i; [EOL]         } [EOL]     } else if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     return -1; [EOL] }
public Writer asWriter() { [EOL]     return new StrBuilderWriter(); [EOL] }
StrBuilderWriter() { [EOL]     super(); [EOL] }
@Override [EOL] public void close() { [EOL] }
@Override [EOL] public void flush() { [EOL] }
@Override [EOL] public void write(final int c) { [EOL]     StrBuilder.this.append((char) c); [EOL] }
@Override [EOL] public void write(final int c) { [EOL]     StrBuilder.this.append((char) c); [EOL] }
@Override [EOL] public void write(final char[] cbuf) { [EOL]     StrBuilder.this.append(cbuf); [EOL] }
@Override [EOL] public void write(final char[] cbuf) { [EOL]     StrBuilder.this.append(cbuf); [EOL] }
@Override [EOL] public void write(final char[] cbuf) { [EOL]     StrBuilder.this.append(cbuf); [EOL] }
@Override [EOL] public void write(final char[] cbuf, final int off, final int len) { [EOL]     StrBuilder.this.append(cbuf, off, len); [EOL] }
@Override [EOL] public void write(final char[] cbuf, final int off, final int len) { [EOL]     StrBuilder.this.append(cbuf, off, len); [EOL] }
@Override [EOL] public void write(final char[] cbuf, final int off, final int len) { [EOL]     StrBuilder.this.append(cbuf, off, len); [EOL] }
@Override [EOL] public void write(final char[] cbuf, final int off, final int len) { [EOL]     StrBuilder.this.append(cbuf, off, len); [EOL] }
@Override [EOL] public void write(final char[] cbuf, final int off, final int len) { [EOL]     StrBuilder.this.append(cbuf, off, len); [EOL] }
@Override [EOL] public void write(final String str) { [EOL]     StrBuilder.this.append(str); [EOL] }
@Override [EOL] public void write(final String str) { [EOL]     StrBuilder.this.append(str); [EOL] }
@Override [EOL] public void write(final String str) { [EOL]     StrBuilder.this.append(str); [EOL] }
@Override [EOL] public void write(final String str, final int off, final int len) { [EOL]     StrBuilder.this.append(str, off, len); [EOL] }
@Override [EOL] public void write(final String str, final int off, final int len) { [EOL]     StrBuilder.this.append(str, off, len); [EOL] }
@Override [EOL] public void write(final String str, final int off, final int len) { [EOL]     StrBuilder.this.append(str, off, len); [EOL] }
@Override [EOL] public void write(final String str, final int off, final int len) { [EOL]     StrBuilder.this.append(str, off, len); [EOL] }
@Override [EOL] public void write(final String str, final int off, final int len) { [EOL]     StrBuilder.this.append(str, off, len); [EOL] }
@Override [EOL] public void write(final String str, final int off, final int len) { [EOL]     StrBuilder.this.append(str, off, len); [EOL] }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance() { [EOL]     return cache.getInstance(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone) { [EOL]     return cache.getInstance(pattern, timeZone, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone) { [EOL]     return cache.getInstance(pattern, timeZone, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL]     return parser.parse(source); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static File getUserDir() { [EOL]     return new File(System.getProperty(USER_DIR_KEY)); [EOL] }
public static File getUserHome() { [EOL]     return new File(System.getProperty(USER_HOME_KEY)); [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] }
public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] }
public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     return readStaticField(field, false); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredField(target, fieldName, value, false); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredField(target, fieldName, value, false); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredField(target, fieldName, value, false); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeDeclaredField(target, fieldName, value, false); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] }
public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (target == null) { [EOL]         throw new IllegalArgumentException("target object must not be null"); [EOL]     } [EOL]     final Class<?> cls = target.getClass(); [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, target, value); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
protected CharSet(final String... set) { [EOL]     super(); [EOL]     final int sz = set.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         add(set[i]); [EOL]     } [EOL] }
protected CharSet(final String... set) { [EOL]     super(); [EOL]     final int sz = set.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         add(set[i]); [EOL]     } [EOL] }
protected CharSet(final String... set) { [EOL]     super(); [EOL]     final int sz = set.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         add(set[i]); [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
public boolean contains(final char ch) { [EOL]     for (final CharRange range : set) { [EOL]         if (range.contains(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(final char ch) { [EOL]     for (final CharRange range : set) { [EOL]         if (range.contains(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(final char ch) { [EOL]     for (final CharRange range : set) { [EOL]         if (range.contains(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Constructor<T> ctor = cls.getConstructor(parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(ctor); [EOL]         return ctor; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Constructor<T> result = null; [EOL]     final Constructor<?>[] ctors = cls.getConstructors(); [EOL]     for (Constructor<?> ctor : ctors) { [EOL]         if (ClassUtils.isAssignable(parameterTypes, ctor.getParameterTypes(), true)) { [EOL]             ctor = getAccessibleConstructor(ctor); [EOL]             if (ctor != null) { [EOL]                 MemberUtils.setAccessibleWorkaround(ctor); [EOL]                 if (result == null || MemberUtils.compareParameterTypes(ctor.getParameterTypes(), result.getParameterTypes(), parameterTypes) < 0) { [EOL]                     @SuppressWarnings("unchecked") [EOL]                     final Constructor<T> constructor = (Constructor<T>) ctor; [EOL]                     result = constructor; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private CharRange(char start, char end, final boolean negated) { [EOL]     super(); [EOL]     if (start > end) { [EOL]         final char temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     this.start = start; [EOL]     this.end = end; [EOL]     this.negated = negated; [EOL] }
private CharRange(char start, char end, final boolean negated) { [EOL]     super(); [EOL]     if (start > end) { [EOL]         final char temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     this.start = start; [EOL]     this.end = end; [EOL]     this.negated = negated; [EOL] }
private CharRange(char start, char end, final boolean negated) { [EOL]     super(); [EOL]     if (start > end) { [EOL]         final char temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     this.start = start; [EOL]     this.end = end; [EOL]     this.negated = negated; [EOL] }
public boolean contains(final char ch) { [EOL]     return (ch >= start && ch <= end) != negated; [EOL] }
public boolean contains(final char ch) { [EOL]     return (ch >= start && ch <= end) != negated; [EOL] }
public boolean contains(final char ch) { [EOL]     return (ch >= start && ch <= end) != negated; [EOL] }
public boolean contains(final char ch) { [EOL]     return (ch >= start && ch <= end) != negated; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharRange == false) { [EOL]         return false; [EOL]     } [EOL]     final CharRange other = (CharRange) obj; [EOL]     return start == other.start && end == other.end && negated == other.negated; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharRange == false) { [EOL]         return false; [EOL]     } [EOL]     final CharRange other = (CharRange) obj; [EOL]     return start == other.start && end == other.end && negated == other.negated; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharRange == false) { [EOL]         return false; [EOL]     } [EOL]     final CharRange other = (CharRange) obj; [EOL]     return start == other.start && end == other.end && negated == other.negated; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharRange == false) { [EOL]         return false; [EOL]     } [EOL]     final CharRange other = (CharRange) obj; [EOL]     return start == other.start && end == other.end && negated == other.negated; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharRange == false) { [EOL]         return false; [EOL]     } [EOL]     final CharRange other = (CharRange) obj; [EOL]     return start == other.start && end == other.end && negated == other.negated; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return 83 + start + 7 * end + (negated ? 1 : 0); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return 83 + start + 7 * end + (negated ? 1 : 0); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return 83 + start + 7 * end + (negated ? 1 : 0); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (iToString == null) { [EOL]         final StringBuilder buf = new StringBuilder(4); [EOL]         if (isNegated()) { [EOL]             buf.append('^'); [EOL]         } [EOL]         buf.append(start); [EOL]         if (start != end) { [EOL]             buf.append('-'); [EOL]             buf.append(end); [EOL]         } [EOL]         iToString = buf.toString(); [EOL]     } [EOL]     return iToString; [EOL] }
public static double min(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         min = min(array[i], min); [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         min = min(array[i], min); [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         min = min(array[i], min); [EOL]     } [EOL]     return min; [EOL] }
public static float min(final float[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         min = min(array[i], min); [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return min(min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return min(min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return min(min(a, b), c); [EOL] }
public static double min(final double a, final double b, final double c) { [EOL]     return min(min(a, b), c); [EOL] }
public static double min(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return min(min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return min(min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return min(min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return min(min(a, b), c); [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static double max(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         max = max(array[j], max); [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return max(max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return max(max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return max(max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return max(max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return max(max(a, b), c); [EOL] }
public static double max(final double a, final double b) { [EOL]     if (Double.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Double.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return max(max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return max(max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return max(max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return max(max(a, b), c); [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public HashCodeBuilder append(final byte value) { [EOL]     iTotal = iTotal * iConstant + value; [EOL]     return this; [EOL] }
public HashCodeBuilder append(final byte value) { [EOL]     iTotal = iTotal * iConstant + value; [EOL]     return this; [EOL] }
public HashCodeBuilder append(final byte value) { [EOL]     iTotal = iTotal * iConstant + value; [EOL]     return this; [EOL] }
public HashCodeBuilder append(final byte[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final byte element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final byte[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final byte element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final byte[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final byte element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final double value) { [EOL]     return append(Double.doubleToLongBits(value)); [EOL] }
public HashCodeBuilder append(final double value) { [EOL]     return append(Double.doubleToLongBits(value)); [EOL] }
public HashCodeBuilder append(final double value) { [EOL]     return append(Double.doubleToLongBits(value)); [EOL] }
public HashCodeBuilder append(final double value) { [EOL]     return append(Double.doubleToLongBits(value)); [EOL] }
public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final long value) { [EOL]     iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32))); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final long value) { [EOL]     iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32))); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final long value) { [EOL]     iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32))); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static int toIntValue(final char ch, final int defaultValue) { [EOL]     if (isAsciiNumeric(ch) == false) { [EOL]         return defaultValue; [EOL]     } [EOL]     return ch - 48; [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static String toString(final char ch) { [EOL]     if (ch < 128) { [EOL]         return CHAR_STRING_ARRAY[ch]; [EOL]     } [EOL]     return new String(new char[] { ch }); [EOL] }
public static String toString(final char ch) { [EOL]     if (ch < 128) { [EOL]         return CHAR_STRING_ARRAY[ch]; [EOL]     } [EOL]     return new String(new char[] { ch }); [EOL] }
public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] }
public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] }
public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] }
public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiPrintable(final char ch) { [EOL]     return ch >= 32 && ch < 127; [EOL] }
public static boolean isAsciiPrintable(final char ch) { [EOL]     return ch >= 32 && ch < 127; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAsciiNumeric(final char ch) { [EOL]     return ch >= '0' && ch <= '9'; [EOL] }
public static boolean isAsciiNumeric(final char ch) { [EOL]     return ch >= '0' && ch <= '9'; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
@SuppressWarnings("unchecked") [EOL] private Range(final T element1, final T element2, Comparator<T> comparator) { [EOL]     if (element1 == null || element2 == null) { [EOL]         throw new IllegalArgumentException("Elements in a range must not be null: element1=" + element1 + ", element2=" + element2); [EOL]     } [EOL]     if (comparator == null) { [EOL]         comparator = ComparableComparator.INSTANCE; [EOL]     } [EOL]     if (comparator.compare(element1, element2) < 1) { [EOL]         this.minimum = element1; [EOL]         this.maximum = element2; [EOL]     } else { [EOL]         this.minimum = element2; [EOL]         this.maximum = element1; [EOL]     } [EOL]     this.comparator = comparator; [EOL] }
public Comparator<T> getComparator() { [EOL]     return comparator; [EOL] }
public boolean isNaturalOrdering() { [EOL]     return comparator == ComparableComparator.INSTANCE; [EOL] }
public boolean isNaturalOrdering() { [EOL]     return comparator == ComparableComparator.INSTANCE; [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] }
public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] }
public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] }
public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] }
public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] }
public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] }
public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static String toStringExclude(final Object object, final Collection<String> excludeFieldNames) { [EOL]     return toStringExclude(object, toNoNullStringArray(excludeFieldNames)); [EOL] }
public static String toStringExclude(final Object object, final Collection<String> excludeFieldNames) { [EOL]     return toStringExclude(object, toNoNullStringArray(excludeFieldNames)); [EOL] }
public static String toStringExclude(final Object object, final Collection<String> excludeFieldNames) { [EOL]     return toStringExclude(object, toNoNullStringArray(excludeFieldNames)); [EOL] }
static String[] toNoNullStringArray(final Collection<String> collection) { [EOL]     if (collection == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return toNoNullStringArray(collection.toArray()); [EOL] }
protected void appendFieldsIn(final Class<?> clazz) { [EOL]     if (clazz.isArray()) { [EOL]         this.reflectionAppendArray(this.getObject()); [EOL]         return; [EOL]     } [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (final Field field : fields) { [EOL]         final String fieldName = field.getName(); [EOL]         if (this.accept(field)) { [EOL]             try { [EOL]                 final Object fieldValue = this.getValue(field); [EOL]                 this.append(fieldName, fieldValue); [EOL]             } catch (final IllegalAccessException ex) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public ReflectionToStringBuilder reflectionAppendArray(final Object array) { [EOL]     this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array); [EOL]     return this; [EOL] }
public ReflectionToStringBuilder reflectionAppendArray(final Object array) { [EOL]     this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array); [EOL]     return this; [EOL] }
public MutableLong() { [EOL]     super(); [EOL] }
public MutableLong(final long value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
public MutableLong(final long value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
public MutableLong(final long value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
public MutableLong(final Number value) { [EOL]     super(); [EOL]     this.value = value.longValue(); [EOL] }
public MutableLong(final Number value) { [EOL]     super(); [EOL]     this.value = value.longValue(); [EOL] }
public MutableLong(final Number value) { [EOL]     super(); [EOL]     this.value = value.longValue(); [EOL] }
public MutableLong(final Number value) { [EOL]     super(); [EOL]     this.value = value.longValue(); [EOL] }
public MutableLong(final Number value) { [EOL]     super(); [EOL]     this.value = value.longValue(); [EOL] }
public MutableLong(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Long.parseLong(value); [EOL] }
public MutableLong(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Long.parseLong(value); [EOL] }
public MutableLong(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Long.parseLong(value); [EOL] }
public void add(final long operand) { [EOL]     this.value += operand; [EOL] }
public void add(final long operand) { [EOL]     this.value += operand; [EOL] }
public void add(final long operand) { [EOL]     this.value += operand; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
public MutableInt() { [EOL]     super(); [EOL] }
public MutableInt(final Number value) { [EOL]     super(); [EOL]     this.value = value.intValue(); [EOL] }
public MutableInt(final Number value) { [EOL]     super(); [EOL]     this.value = value.intValue(); [EOL] }
public MutableInt(final Number value) { [EOL]     super(); [EOL]     this.value = value.intValue(); [EOL] }
public MutableInt(final Number value) { [EOL]     super(); [EOL]     this.value = value.intValue(); [EOL] }
public MutableInt(final Number value) { [EOL]     super(); [EOL]     this.value = value.intValue(); [EOL] }
public MutableInt(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Integer.parseInt(value); [EOL] }
public MutableInt(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Integer.parseInt(value); [EOL] }
public void add(final int operand) { [EOL]     this.value += operand; [EOL] }
public void add(final int operand) { [EOL]     this.value += operand; [EOL] }
public void add(final int operand) { [EOL]     this.value += operand; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value; [EOL] }
public ObjectUtils() { [EOL]     super(); [EOL] }
public static void identityToString(final StringBuffer buffer, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static void identityToString(final StringBuffer buffer, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public CloneFailedException(final String message, final Throwable cause) { [EOL]     super(message, cause); [EOL] }
public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) { [EOL]     if (collection == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (collection.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return collection; [EOL] }
public static <T extends Collection<?>> T notEmpty(final T collection) { [EOL]     return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Collection<?>> T notEmpty(final T collection) { [EOL]     return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Collection<?>> T notEmpty(final T collection) { [EOL]     return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) { [EOL]     if (map == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (map.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return map; [EOL] }
public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) { [EOL]     if (map == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (map.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return map; [EOL] }
public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) { [EOL]     if (map == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (map.isEmpty()) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return map; [EOL] }
public static <T extends Map<?, ?>> T notEmpty(final T map) { [EOL]     return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) { [EOL]     Validate.notNull(iterable); [EOL]     int i = 0; [EOL]     for (final Iterator<?> it = iterable.iterator(); it.hasNext(); i++) { [EOL]         if (it.next() == null) { [EOL]             final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i)); [EOL]             throw new IllegalArgumentException(String.format(message, values2)); [EOL]         } [EOL]     } [EOL]     return iterable; [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) { [EOL]     Validate.notNull(iterable); [EOL]     int i = 0; [EOL]     for (final Iterator<?> it = iterable.iterator(); it.hasNext(); i++) { [EOL]         if (it.next() == null) { [EOL]             final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i)); [EOL]             throw new IllegalArgumentException(String.format(message, values2)); [EOL]         } [EOL]     } [EOL]     return iterable; [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) { [EOL]     Validate.notNull(iterable); [EOL]     int i = 0; [EOL]     for (final Iterator<?> it = iterable.iterator(); it.hasNext(); i++) { [EOL]         if (it.next() == null) { [EOL]             final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i)); [EOL]             throw new IllegalArgumentException(String.format(message, values2)); [EOL]         } [EOL]     } [EOL]     return iterable; [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(); [EOL] }
public static String formatDurationISO(final long durationMillis) { [EOL]     return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false); [EOL] }
public static String formatDurationISO(final long durationMillis) { [EOL]     return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false); [EOL] }
public static String formatDurationISO(final long durationMillis) { [EOL]     return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false); [EOL] }
public static String formatDuration(final long durationMillis, final String format) { [EOL]     return formatDuration(durationMillis, format, true); [EOL] }
public static String formatDuration(final long durationMillis, final String format) { [EOL]     return formatDuration(durationMillis, format, true); [EOL] }
public static String formatDuration(final long durationMillis, final String format) { [EOL]     return formatDuration(durationMillis, format, true); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] }
static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
Token(final Object value) { [EOL]     this.value = value; [EOL]     this.count = 1; [EOL] }
Token(final Object value) { [EOL]     this.value = value; [EOL]     this.count = 1; [EOL] }
void increment() { [EOL]     count++; [EOL] }
void increment() { [EOL]     count++; [EOL] }
int getCount() { [EOL]     return count; [EOL] }
Object getValue() { [EOL]     return value; [EOL] }
public CharSetUtils() { [EOL]     super(); [EOL] }
public static int count(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return 0; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     int count = 0; [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] }
public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] }
private static String modify(final String str, final String[] set, final boolean expect) { [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (chars.contains(chrs[i]) == expect) { [EOL]             buffer.append(chrs[i]); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type) { [EOL]     return indexOf(throwable, type, 0, true); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL]     return indexOf(throwable, type, fromIndex, true); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final Number value) { [EOL]     super(); [EOL]     this.value = value.shortValue(); [EOL] }
public MutableShort(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Short.parseShort(value); [EOL] }
public MutableShort(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Short.parseShort(value); [EOL] }
public MutableShort(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Short.parseShort(value); [EOL] }
public MutableShort(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Short.parseShort(value); [EOL] }
public void add(final short operand) { [EOL]     this.value += operand; [EOL] }
public void add(final short operand) { [EOL]     this.value += operand; [EOL] }
public void add(final short operand) { [EOL]     this.value += operand; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.shortValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.shortValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.shortValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public void unsplit() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch has not been split. "); [EOL]     } [EOL]     this.splitState = STATE_UNSPLIT; [EOL] }
public void unsplit() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch has not been split. "); [EOL]     } [EOL]     this.splitState = STATE_UNSPLIT; [EOL] }
public long getSplitTime() { [EOL]     return getSplitNanoTime() / NANO_2_MILLIS; [EOL] }
public long getSplitTime() { [EOL]     return getSplitNanoTime() / NANO_2_MILLIS; [EOL] }
public long getSplitNanoTime() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch must be split to get the split time. "); [EOL]     } [EOL]     return this.stopTime - this.startTime; [EOL] }
public long getSplitNanoTime() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch must be split to get the split time. "); [EOL]     } [EOL]     return this.stopTime - this.startTime; [EOL] }
public String toSplitString() { [EOL]     return DurationFormatUtils.formatDurationHMS(getSplitTime()); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (int i = 0; i < fields.length && builder.comparison == 0; i++) { [EOL]         final Field f = fields[i]; [EOL]         if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]             try { [EOL]                 builder.append(f.get(lhs), f.get(rhs)); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (int i = 0; i < fields.length && builder.comparison == 0; i++) { [EOL]         final Field f = fields[i]; [EOL]         if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]             try { [EOL]                 builder.append(f.get(lhs), f.get(rhs)); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (int i = 0; i < fields.length && builder.comparison == 0; i++) { [EOL]         final Field f = fields[i]; [EOL]         if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]             try { [EOL]                 builder.append(f.get(lhs), f.get(rhs)); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) { [EOL]     final Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (int i = 0; i < fields.length && builder.comparison == 0; i++) { [EOL]         final Field f = fields[i]; [EOL]         if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) { [EOL]             try { [EOL]                 builder.append(f.get(lhs), f.get(rhs)); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new InternalError("Unexpected IllegalAccessException"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int lhs, final int rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final int lhs, final int rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final short lhs, final short rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final short lhs, final short rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final short lhs, final short rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final short lhs, final short rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public static boolean isNotEmpty(final CharSequence cs) { [EOL]     return !StringUtils.isEmpty(cs); [EOL] }
public static boolean isNotEmpty(final CharSequence cs) { [EOL]     return !StringUtils.isEmpty(cs); [EOL] }
public static boolean isNotEmpty(final CharSequence cs) { [EOL]     return !StringUtils.isEmpty(cs); [EOL] }
public static boolean isNotEmpty(final CharSequence cs) { [EOL]     return !StringUtils.isEmpty(cs); [EOL] }
public static String stripToNull(String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     str = strip(str, null); [EOL]     return str.isEmpty() ? null : str; [EOL] }
public static String stripToNull(String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     str = strip(str, null); [EOL]     return str.isEmpty() ? null : str; [EOL] }
public static String stripToEmpty(final String str) { [EOL]     return str == null ? EMPTY : strip(str, null); [EOL] }
public static String stripToEmpty(final String str) { [EOL]     return str == null ? EMPTY : strip(str, null); [EOL] }
public static String stripToEmpty(final String str) { [EOL]     return str == null ? EMPTY : strip(str, null); [EOL] }
public static String stripToEmpty(final String str) { [EOL]     return str == null ? EMPTY : strip(str, null); [EOL] }
public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] }
public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] }
public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] }
public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] }
public static String stripAccents(final String input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); [EOL]     final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD); [EOL]     return pattern.matcher(decomposed).replaceAll(""); [EOL] }
public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) { [EOL]     if (str1 == null || str2 == null) { [EOL]         return str1 == str2; [EOL]     } else if (str1 == str2) { [EOL]         return true; [EOL]     } else if (str1.length() != str2.length()) { [EOL]         return false; [EOL]     } else { [EOL]         return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, str1.length()); [EOL]     } [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, startPos); [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, startPos); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     return indexOfIgnoreCase(str, searchStr, 0); [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos); [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) { [EOL]     if (str == null || searchStr == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = searchStr.length(); [EOL]     final int max = str.length() - len; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static int indexOfAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return i; [EOL]                     } [EOL]                 } else { [EOL]                     return i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAny(final CharSequence cs, final String searchChars) { [EOL]     if (isEmpty(cs) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return indexOfAny(cs, searchChars.toCharArray()); [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) { [EOL]     if (isEmpty(seq) || isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = seq.charAt(i); [EOL]         final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0; [EOL]         if (i + 1 < strLen && Character.isHighSurrogate(ch)) { [EOL]             final char ch2 = seq.charAt(i + 1); [EOL]             if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) { [EOL]                 return i; [EOL]             } [EOL]         } else { [EOL]             if (!chFound) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final char... valid) { [EOL]     if (valid == null || cs == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs.length() == 0) { [EOL]         return true; [EOL]     } [EOL]     if (valid.length == 0) { [EOL]         return false; [EOL]     } [EOL]     return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; [EOL] }
public static boolean containsOnly(final CharSequence cs, final String validChars) { [EOL]     if (cs == null || validChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsOnly(cs, validChars.toCharArray()); [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean containsNone(final CharSequence cs, final char... searchChars) { [EOL]     if (cs == null || searchChars == null) { [EOL]         return true; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return false; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static String substring(final String str, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = str.length() + end; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (end > str.length()) { [EOL]         end = str.length(); [EOL]     } [EOL]     if (start > end) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     return str.substring(start, end); [EOL] }
public static String substringAfterLast(final String str, final String separator) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(separator)) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.lastIndexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str.substring(pos + separator.length()); [EOL] }
public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, true); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String[] splitByCharacterType(final String str) { [EOL]     return splitByCharacterType(str, false); [EOL] }
public static String[] splitByCharacterType(final String str) { [EOL]     return splitByCharacterType(str, false); [EOL] }
public static String[] splitByCharacterType(final String str) { [EOL]     return splitByCharacterType(str, false); [EOL] }
public static String[] splitByCharacterType(final String str) { [EOL]     return splitByCharacterType(str, false); [EOL] }
public static String join(final Object[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final float[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final float[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final float[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, final String separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (separator == null) { [EOL]         separator = EMPTY; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         if (array[i] != null) { [EOL]             buf.append(array[i]); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final String separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         if (separator != null) { [EOL]             buf.append(separator); [EOL]         } [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String replacePattern(final String source, final String regex, final String replacement) { [EOL]     return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement); [EOL] }
public static String chop(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen < 2) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int lastIdx = strLen - 1; [EOL]     final String ret = str.substring(0, lastIdx); [EOL]     final char last = str.charAt(lastIdx); [EOL]     if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) { [EOL]         return ret.substring(0, lastIdx - 1); [EOL]     } [EOL]     return ret; [EOL] }
public static String repeat(final char ch, final int repeat) { [EOL]     final char[] buf = new char[repeat]; [EOL]     for (int i = repeat - 1; i >= 0; i--) { [EOL]         buf[i] = ch; [EOL]     } [EOL]     return new String(buf); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static String leftPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return leftPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return repeat(padChar, pads).concat(str); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(final String str, final int size) { [EOL]     return center(str, size, ' '); [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String center(String str, final int size, final char padChar) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padChar); [EOL]     str = rightPad(str, size, padChar); [EOL]     return str; [EOL] }
public static String upperCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(); [EOL] }
public static String upperCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(); [EOL] }
public static String upperCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(); [EOL] }
public static String upperCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toUpperCase(locale); [EOL] }
public static String lowerCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(); [EOL] }
public static String lowerCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(); [EOL] }
public static String lowerCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(); [EOL] }
public static String lowerCase(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(); [EOL] }
public static String lowerCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(locale); [EOL] }
public static String lowerCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(locale); [EOL] }
public static String lowerCase(final String str, final Locale locale) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.toLowerCase(locale); [EOL] }
public static String capitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isTitleCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String capitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isTitleCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String capitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isTitleCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String capitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isTitleCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isLowerCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isLowerCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isLowerCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     char firstChar = str.charAt(0); [EOL]     if (Character.isLowerCase(firstChar)) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(firstChar)).append(str.substring(1)).toString(); [EOL] }
public static boolean isNumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isNumericSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAllUpperCase(final CharSequence cs) { [EOL]     if (cs == null || isEmpty(cs)) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isUpperCase(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static String defaultString(final String str, final String defaultStr) { [EOL]     return str == null ? defaultStr : str; [EOL] }
public static String defaultString(final String str, final String defaultStr) { [EOL]     return str == null ? defaultStr : str; [EOL] }
public static String abbreviateMiddle(final String str, final String middle, final int length) { [EOL]     if (isEmpty(str) || isEmpty(middle)) { [EOL]         return str; [EOL]     } [EOL]     if (length >= str.length() || length < middle.length() + 2) { [EOL]         return str; [EOL]     } [EOL]     final int targetSting = length - middle.length(); [EOL]     final int startOffset = targetSting / 2 + targetSting % 2; [EOL]     final int endOffset = str.length() - targetSting / 2; [EOL]     final StringBuilder builder = new StringBuilder(length); [EOL]     builder.append(str.substring(0, startOffset)); [EOL]     builder.append(middle); [EOL]     builder.append(str.substring(endOffset)); [EOL]     return builder.toString(); [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int indexOfDifference(final CharSequence... css) { [EOL]     if (css == null || css.length <= 1) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     boolean anyStringNull = false; [EOL]     boolean allStringsNull = true; [EOL]     final int arrayLen = css.length; [EOL]     int shortestStrLen = Integer.MAX_VALUE; [EOL]     int longestStrLen = 0; [EOL]     for (int i = 0; i < arrayLen; i++) { [EOL]         if (css[i] == null) { [EOL]             anyStringNull = true; [EOL]             shortestStrLen = 0; [EOL]         } else { [EOL]             allStringsNull = false; [EOL]             shortestStrLen = Math.min(css[i].length(), shortestStrLen); [EOL]             longestStrLen = Math.max(css[i].length(), longestStrLen); [EOL]         } [EOL]     } [EOL]     if (allStringsNull || longestStrLen == 0 && !anyStringNull) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (shortestStrLen == 0) { [EOL]         return 0; [EOL]     } [EOL]     int firstDiff = -1; [EOL]     for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { [EOL]         final char comparisonChar = css[0].charAt(stringPos); [EOL]         for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { [EOL]             if (css[arrayPos].charAt(stringPos) != comparisonChar) { [EOL]                 firstDiff = stringPos; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (firstDiff != -1) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (firstDiff == -1 && shortestStrLen != longestStrLen) { [EOL]         return shortestStrLen; [EOL]     } [EOL]     return firstDiff; [EOL] }
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } [EOL]     return -1; [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWith(final CharSequence str, final CharSequence prefix) { [EOL]     return startsWith(str, prefix, false); [EOL] }
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.startsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) { [EOL]     if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { [EOL]         return false; [EOL]     } [EOL]     for (final CharSequence searchString : searchStrings) { [EOL]         if (StringUtils.endsWith(string, searchString)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) { [EOL]     if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) { [EOL]         return str; [EOL]     } [EOL]     if (prefixes != null && prefixes.length > 0) { [EOL]         for (final CharSequence p : prefixes) { [EOL]             if (startsWith(str, p, ignoreCase)) { [EOL]                 return str; [EOL]             } [EOL]         } [EOL]     } [EOL]     return prefix.toString() + str; [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public static String prependIfMissingIgnoreCase(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, true, prefixes); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.doubleValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.doubleValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.doubleValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.doubleValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendToString(final StringBuffer buffer, final String toString) { [EOL]     if (toString != null) { [EOL]         final int pos1 = toString.indexOf(contentStart) + contentStart.length(); [EOL]         final int pos2 = toString.lastIndexOf(contentEnd); [EOL]         if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) { [EOL]             final String data = toString.substring(pos1, pos2); [EOL]             if (fieldSeparatorAtStart) { [EOL]                 removeLastFieldSeparator(buffer); [EOL]             } [EOL]             buffer.append(data); [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setArraySeparator(String arraySeparator) { [EOL]     if (arraySeparator == null) { [EOL]         arraySeparator = ""; [EOL]     } [EOL]     this.arraySeparator = arraySeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public static char binaryToHexDigit(final boolean[] src) { [EOL]     return binaryToHexDigit(src, 0); [EOL] }
public static char binaryToHexDigit(final boolean[] src) { [EOL]     return binaryToHexDigit(src, 0); [EOL] }
public static char binaryToHexDigit(final boolean[] src) { [EOL]     return binaryToHexDigit(src, 0); [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if (nBytes > 16) { [EOL]         throw new IllegalArgumentException("nBytes is greather than 16"); [EOL]     } [EOL]     longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes); [EOL]     if (nBytes >= 8) { [EOL]         longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8); [EOL]     } [EOL]     return dst; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvEscaper should never reach the [1] index"); [EOL]     } [EOL]     if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) { [EOL]         out.write(input.toString()); [EOL]     } else { [EOL]         out.write(CSV_QUOTE); [EOL]         out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR)); [EOL]         out.write(CSV_QUOTE); [EOL]     } [EOL]     return input.length(); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvUnescaper should never reach the [1] index"); [EOL]     } [EOL]     if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) { [EOL]         out.write(input.toString()); [EOL]         return input.length(); [EOL]     } [EOL]     final String quoteless = input.subSequence(1, input.length() - 1).toString(); [EOL]     if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) { [EOL]         out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR)); [EOL]     } else { [EOL]         out.write(input.toString()); [EOL]     } [EOL]     return input.length(); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
