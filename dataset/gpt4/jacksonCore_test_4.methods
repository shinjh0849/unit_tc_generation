public String getOriginalMessage() { [EOL]     return super.getMessage(); [EOL] }
@Override [EOL] public boolean hasTextCharacters() { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         return true; [EOL]     } [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nameCopied; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean hasTextCharacters() { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         return true; [EOL]     } [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nameCopied; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean hasTextCharacters() { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         return true; [EOL]     } [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nameCopied; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean hasTextCharacters() { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         return true; [EOL]     } [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nameCopied; [EOL]     } [EOL]     return false; [EOL] }
protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException { [EOL]     String startDesc = "" + _parsingContext.getStartLocation(_ioContext.getSourceReference()); [EOL]     _reportError("Unexpected close marker '" + ((char) actCh) + "': expected '" + expCh + "' (for " + _parsingContext.getTypeDesc() + " starting at " + startDesc + ")"); [EOL] }
protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException { [EOL]     String startDesc = "" + _parsingContext.getStartLocation(_ioContext.getSourceReference()); [EOL]     _reportError("Unexpected close marker '" + ((char) actCh) + "': expected '" + expCh + "' (for " + _parsingContext.getTypeDesc() + " starting at " + startDesc + ")"); [EOL] }
protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException { [EOL]     String startDesc = "" + _parsingContext.getStartLocation(_ioContext.getSourceReference()); [EOL]     _reportError("Unexpected close marker '" + ((char) actCh) + "': expected '" + expCh + "' (for " + _parsingContext.getTypeDesc() + " starting at " + startDesc + ")"); [EOL] }
public ByteArrayBuilder _getByteArrayBuilder() { [EOL]     if (_byteArrayBuilder == null) { [EOL]         _byteArrayBuilder = new ByteArrayBuilder(); [EOL]     } else { [EOL]         _byteArrayBuilder.reset(); [EOL]     } [EOL]     return _byteArrayBuilder; [EOL] }
public ByteArrayBuilder _getByteArrayBuilder() { [EOL]     if (_byteArrayBuilder == null) { [EOL]         _byteArrayBuilder = new ByteArrayBuilder(); [EOL]     } else { [EOL]         _byteArrayBuilder.reset(); [EOL]     } [EOL]     return _byteArrayBuilder; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public ByteArrayBuilder(BufferRecycler br) { [EOL]     this(br, INITIAL_BLOCK_SIZE); [EOL] }
public ByteArrayBuilder(BufferRecycler br) { [EOL]     this(br, INITIAL_BLOCK_SIZE); [EOL] }
public ByteArrayBuilder(BufferRecycler br, int firstBlockSize) { [EOL]     _bufferRecycler = br; [EOL]     if (br == null) { [EOL]         _currBlock = new byte[firstBlockSize]; [EOL]     } else { [EOL]         _currBlock = br.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER); [EOL]     } [EOL] }
public ByteArrayBuilder(BufferRecycler br, int firstBlockSize) { [EOL]     _bufferRecycler = br; [EOL]     if (br == null) { [EOL]         _currBlock = new byte[firstBlockSize]; [EOL]     } else { [EOL]         _currBlock = br.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER); [EOL]     } [EOL] }
public void reset() { [EOL]     _pastLen = 0; [EOL]     _currBlockPtr = 0; [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         _pastBlocks.clear(); [EOL]     } [EOL] }
public void reset() { [EOL]     _pastLen = 0; [EOL]     _currBlockPtr = 0; [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         _pastBlocks.clear(); [EOL]     } [EOL] }
public void append(int i) { [EOL]     if (_currBlockPtr >= _currBlock.length) { [EOL]         _allocMore(); [EOL]     } [EOL]     _currBlock[_currBlockPtr++] = (byte) i; [EOL] }
public void append(int i) { [EOL]     if (_currBlockPtr >= _currBlock.length) { [EOL]         _allocMore(); [EOL]     } [EOL]     _currBlock[_currBlockPtr++] = (byte) i; [EOL] }
public void appendThreeBytes(int b24) { [EOL]     if ((_currBlockPtr + 2) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 16); [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b24; [EOL]     } else { [EOL]         append(b24 >> 16); [EOL]         append(b24 >> 8); [EOL]         append(b24); [EOL]     } [EOL] }
public void appendThreeBytes(int b24) { [EOL]     if ((_currBlockPtr + 2) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 16); [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b24; [EOL]     } else { [EOL]         append(b24 >> 16); [EOL]         append(b24 >> 8); [EOL]         append(b24); [EOL]     } [EOL] }
public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] }
public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] }
public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] }
public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] }
public byte[] resetAndGetFirstSegment() { [EOL]     reset(); [EOL]     return _currBlock; [EOL] }
public byte[] resetAndGetFirstSegment() { [EOL]     reset(); [EOL]     return _currBlock; [EOL] }
public byte[] completeAndCoalesce(int lastBlockLength) { [EOL]     _currBlockPtr = lastBlockLength; [EOL]     return toByteArray(); [EOL] }
public byte[] completeAndCoalesce(int lastBlockLength) { [EOL]     _currBlockPtr = lastBlockLength; [EOL]     return toByteArray(); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     if (_originalStream == null) { [EOL]         return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return _match.createParser(getDataStream()); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     if (_originalStream == null) { [EOL]         return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return _match.createParser(getDataStream()); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     if (_originalStream == null) { [EOL]         return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return _match.createParser(getDataStream()); [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(String numberStr, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     int actualLen = numberStr.length(); [EOL]     if (actualLen < cmpLen) [EOL]         return true; [EOL]     if (actualLen > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = numberStr.charAt(i) - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(String numberStr, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     int actualLen = numberStr.length(); [EOL]     if (actualLen < cmpLen) [EOL]         return true; [EOL]     if (actualLen > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = numberStr.charAt(i) - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(String numberStr, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     int actualLen = numberStr.length(); [EOL]     if (actualLen < cmpLen) [EOL]         return true; [EOL]     if (actualLen > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = numberStr.charAt(i) - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(String numberStr, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     int actualLen = numberStr.length(); [EOL]     if (actualLen < cmpLen) [EOL]         return true; [EOL]     if (actualLen > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = numberStr.charAt(i) - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static double parseDouble(String numStr) throws NumberFormatException { [EOL]     if (NASTY_SMALL_DOUBLE.equals(numStr)) { [EOL]         return Double.MIN_VALUE; [EOL]     } [EOL]     return Double.parseDouble(numStr); [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { [EOL]         _reportError("Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         try { [EOL]             _binaryValue = _decodeBase64(b64variant); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw _constructError("Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae.getMessage()); [EOL]         } [EOL]         _tokenIncomplete = false; [EOL]     } else { [EOL]         if (_binaryValue == null) { [EOL]             @SuppressWarnings("resource") [EOL]             ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]             _decodeBase64(getText(), builder, b64variant); [EOL]             _binaryValue = builder.toByteArray(); [EOL]         } [EOL]     } [EOL]     return _binaryValue; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { [EOL]         _reportError("Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         try { [EOL]             _binaryValue = _decodeBase64(b64variant); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw _constructError("Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae.getMessage()); [EOL]         } [EOL]         _tokenIncomplete = false; [EOL]     } else { [EOL]         if (_binaryValue == null) { [EOL]             @SuppressWarnings("resource") [EOL]             ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]             _decodeBase64(getText(), builder, b64variant); [EOL]             _binaryValue = builder.toByteArray(); [EOL]         } [EOL]     } [EOL]     return _binaryValue; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { [EOL]         _reportError("Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         try { [EOL]             _binaryValue = _decodeBase64(b64variant); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw _constructError("Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae.getMessage()); [EOL]         } [EOL]         _tokenIncomplete = false; [EOL]     } else { [EOL]         if (_binaryValue == null) { [EOL]             @SuppressWarnings("resource") [EOL]             ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]             _decodeBase64(getText(), builder, b64variant); [EOL]             _binaryValue = builder.toByteArray(); [EOL]         } [EOL]     } [EOL]     return _binaryValue; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { [EOL]         _reportError("Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         try { [EOL]             _binaryValue = _decodeBase64(b64variant); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw _constructError("Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae.getMessage()); [EOL]         } [EOL]         _tokenIncomplete = false; [EOL]     } else { [EOL]         if (_binaryValue == null) { [EOL]             @SuppressWarnings("resource") [EOL]             ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]             _decodeBase64(getText(), builder, b64variant); [EOL]             _binaryValue = builder.toByteArray(); [EOL]         } [EOL]     } [EOL]     return _binaryValue; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
private void _isNextTokenNameYes() throws IOException, JsonParseException { [EOL]     int i; [EOL]     if (_inputPtr < (_inputEnd - 1) && _inputBuffer[_inputPtr] == INT_COLON) { [EOL]         i = _inputBuffer[++_inputPtr]; [EOL]         ++_inputPtr; [EOL]         if (i == INT_QUOTE) { [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LCURLY) { [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LBRACKET) { [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         } [EOL]         i &= 0xFF; [EOL]         if (i <= INT_SPACE || i == INT_SLASH) { [EOL]             --_inputPtr; [EOL]             i = _skipWS(); [EOL]         } [EOL]     } else { [EOL]         i = _skipColon(); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         case INT_LBRACKET: [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         case INT_LCURLY: [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             _nextToken = JsonToken.VALUE_TRUE; [EOL]             return; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             _nextToken = JsonToken.VALUE_FALSE; [EOL]             return; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             _nextToken = JsonToken.VALUE_NULL; [EOL]             return; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             _nextToken = parseNumberText(i); [EOL]             return; [EOL]     } [EOL]     _nextToken = _handleUnexpectedValue(i); [EOL] }
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] }
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] }
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] }
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] }
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] }
@Override [EOL] public long nextLongValue(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getLongValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; [EOL] }
@Override [EOL] public long nextLongValue(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getLongValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; [EOL] }
@Override [EOL] public long nextLongValue(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getLongValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; [EOL] }
@Override [EOL] public long nextLongValue(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getLongValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     if ((_inputPtr + 9) > _inputEnd) { [EOL]         return slowParseFieldName(); [EOL]     } [EOL]     final byte[] input = _inputBuffer; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int q = input[_inputPtr++] & 0xFF; [EOL]     if (codes[q] == 0) { [EOL]         i = input[_inputPtr++] & 0xFF; [EOL]         if (codes[i] == 0) { [EOL]             q = (q << 8) | i; [EOL]             i = input[_inputPtr++] & 0xFF; [EOL]             if (codes[i] == 0) { [EOL]                 q = (q << 8) | i; [EOL]                 i = input[_inputPtr++] & 0xFF; [EOL]                 if (codes[i] == 0) { [EOL]                     q = (q << 8) | i; [EOL]                     i = input[_inputPtr++] & 0xFF; [EOL]                     if (codes[i] == 0) { [EOL]                         _quad1 = q; [EOL]                         return parseMediumFieldName(i, codes); [EOL]                     } [EOL]                     if (i == INT_QUOTE) { [EOL]                         return findName(q, 4); [EOL]                     } [EOL]                     return parseFieldName(q, i, 4); [EOL]                 } [EOL]                 if (i == INT_QUOTE) { [EOL]                     return findName(q, 3); [EOL]                 } [EOL]                 return parseFieldName(q, i, 3); [EOL]             } [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(q, 2); [EOL]             } [EOL]             return parseFieldName(q, i, 2); [EOL]         } [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(q, 1); [EOL]         } [EOL]         return parseFieldName(q, i, 1); [EOL]     } [EOL]     if (q == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseFieldName(0, q, 0); [EOL] }
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] }
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] }
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] }
private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException { [EOL]     return parseEscapedFieldName(_quadBuffer, 0, q1, ch, lastQuadBytes); [EOL] }
protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (codes[ch] != 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, "name"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
private int _skipColon() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++]; [EOL]     if (i == INT_COLON) { [EOL]         if (_inputPtr < _inputEnd) { [EOL]             i = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (i > INT_SPACE && i != INT_SLASH) { [EOL]                 ++_inputPtr; [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         i &= 0xFF; [EOL]         space_loop: while (true) { [EOL]             switch(i) { [EOL]                 case INT_SPACE: [EOL]                 case INT_TAB: [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_SLASH: [EOL]                     _skipComment(); [EOL]                     break; [EOL]                 default: [EOL]                     if (i < INT_SPACE) { [EOL]                         _throwInvalidSpace(i); [EOL]                     } [EOL]                     break space_loop; [EOL]             } [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]     } [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
public UTF32Reader(IOContext ctxt, InputStream in, byte[] buf, int ptr, int len, boolean isBigEndian) { [EOL]     super(ctxt, in, buf, ptr, len); [EOL]     _bigEndian = isBigEndian; [EOL]     _managedBuffers = (in != null); [EOL] }
public UTF32Reader(IOContext ctxt, InputStream in, byte[] buf, int ptr, int len, boolean isBigEndian) { [EOL]     super(ctxt, in, buf, ptr, len); [EOL]     _bigEndian = isBigEndian; [EOL]     _managedBuffers = (in != null); [EOL] }
public UTF32Reader(IOContext ctxt, InputStream in, byte[] buf, int ptr, int len, boolean isBigEndian) { [EOL]     super(ctxt, in, buf, ptr, len); [EOL]     _bigEndian = isBigEndian; [EOL]     _managedBuffers = (in != null); [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
@Override [EOL] public int read(char[] cbuf, int start, int len) throws IOException { [EOL]     if (_buffer == null) { [EOL]         return -1; [EOL]     } [EOL]     if (len < 1) { [EOL]         return len; [EOL]     } [EOL]     if (start < 0 || (start + len) > cbuf.length) { [EOL]         reportBounds(cbuf, start, len); [EOL]     } [EOL]     len += start; [EOL]     int outPtr = start; [EOL]     if (_surrogate != NULL_CHAR) { [EOL]         cbuf[outPtr++] = _surrogate; [EOL]         _surrogate = NULL_CHAR; [EOL]     } else { [EOL]         int left = (_length - _ptr); [EOL]         if (left < 4) { [EOL]             if (!loadMore(left)) { [EOL]                 return -1; [EOL]             } [EOL]         } [EOL]     } [EOL]     main_loop: while (outPtr < len) { [EOL]         int ptr = _ptr; [EOL]         int ch; [EOL]         if (_bigEndian) { [EOL]             ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); [EOL]         } else { [EOL]             ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); [EOL]         } [EOL]         _ptr += 4; [EOL]         if (ch > 0xFFFF) { [EOL]             if (ch > LAST_VALID_UNICODE_CHAR) { [EOL]                 reportInvalid(ch, outPtr - start, "(above " + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + ") "); [EOL]             } [EOL]             ch -= 0x10000; [EOL]             cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); [EOL]             ch = (0xDC00 | (ch & 0x03FF)); [EOL]             if (outPtr >= len) { [EOL]                 _surrogate = (char) ch; [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         cbuf[outPtr++] = (char) ch; [EOL]         if (_ptr >= _length) { [EOL]             break main_loop; [EOL]         } [EOL]     } [EOL]     len = outPtr - start; [EOL]     _charCount += len; [EOL]     return len; [EOL] }
private boolean loadMore(int available) throws IOException { [EOL]     _byteCount += (_length - available); [EOL]     if (available > 0) { [EOL]         if (_ptr > 0) { [EOL]             for (int i = 0; i < available; ++i) { [EOL]                 _buffer[i] = _buffer[_ptr + i]; [EOL]             } [EOL]             _ptr = 0; [EOL]         } [EOL]         _length = available; [EOL]     } else { [EOL]         _ptr = 0; [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer); [EOL]         if (count < 1) { [EOL]             _length = 0; [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length = count; [EOL]     } [EOL]     while (_length < 4) { [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer, _length, _buffer.length - _length); [EOL]         if (count < 1) { [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 reportUnexpectedEOF(_length, 4); [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length += count; [EOL]     } [EOL]     return true; [EOL] }
private boolean loadMore(int available) throws IOException { [EOL]     _byteCount += (_length - available); [EOL]     if (available > 0) { [EOL]         if (_ptr > 0) { [EOL]             for (int i = 0; i < available; ++i) { [EOL]                 _buffer[i] = _buffer[_ptr + i]; [EOL]             } [EOL]             _ptr = 0; [EOL]         } [EOL]         _length = available; [EOL]     } else { [EOL]         _ptr = 0; [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer); [EOL]         if (count < 1) { [EOL]             _length = 0; [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length = count; [EOL]     } [EOL]     while (_length < 4) { [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer, _length, _buffer.length - _length); [EOL]         if (count < 1) { [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 reportUnexpectedEOF(_length, 4); [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length += count; [EOL]     } [EOL]     return true; [EOL] }
private boolean loadMore(int available) throws IOException { [EOL]     _byteCount += (_length - available); [EOL]     if (available > 0) { [EOL]         if (_ptr > 0) { [EOL]             for (int i = 0; i < available; ++i) { [EOL]                 _buffer[i] = _buffer[_ptr + i]; [EOL]             } [EOL]             _ptr = 0; [EOL]         } [EOL]         _length = available; [EOL]     } else { [EOL]         _ptr = 0; [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer); [EOL]         if (count < 1) { [EOL]             _length = 0; [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length = count; [EOL]     } [EOL]     while (_length < 4) { [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer, _length, _buffer.length - _length); [EOL]         if (count < 1) { [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 reportUnexpectedEOF(_length, 4); [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length += count; [EOL]     } [EOL]     return true; [EOL] }
private boolean loadMore(int available) throws IOException { [EOL]     _byteCount += (_length - available); [EOL]     if (available > 0) { [EOL]         if (_ptr > 0) { [EOL]             for (int i = 0; i < available; ++i) { [EOL]                 _buffer[i] = _buffer[_ptr + i]; [EOL]             } [EOL]             _ptr = 0; [EOL]         } [EOL]         _length = available; [EOL]     } else { [EOL]         _ptr = 0; [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer); [EOL]         if (count < 1) { [EOL]             _length = 0; [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length = count; [EOL]     } [EOL]     while (_length < 4) { [EOL]         int count = (_in == null) ? -1 : _in.read(_buffer, _length, _buffer.length - _length); [EOL]         if (count < 1) { [EOL]             if (count < 0) { [EOL]                 if (_managedBuffers) { [EOL]                     freeBuffers(); [EOL]                 } [EOL]                 reportUnexpectedEOF(_length, 4); [EOL]             } [EOL]             reportStrangeStream(); [EOL]         } [EOL]         _length += count; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public final byte[] asQuotedUTF8() { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public final byte[] asQuotedUTF8() { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     return result; [EOL] }
public JsonEncoding getEncoding() { [EOL]     return _encoding; [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
public JsonParser enable(Feature f) { [EOL]     _features |= f.getMask(); [EOL]     return this; [EOL] }
public JsonParser enable(Feature f) { [EOL]     _features |= f.getMask(); [EOL]     return this; [EOL] }
public JsonParser disable(Feature f) { [EOL]     _features &= ~f.getMask(); [EOL]     return this; [EOL] }
public JsonParser disable(Feature f) { [EOL]     _features &= ~f.getMask(); [EOL]     return this; [EOL] }
public JsonParser configure(Feature f, boolean state) { [EOL]     if (state) { [EOL]         enable(f); [EOL]     } else { [EOL]         disable(f); [EOL]     } [EOL]     return this; [EOL] }
public JsonParser configure(Feature f, boolean state) { [EOL]     if (state) { [EOL]         enable(f); [EOL]     } else { [EOL]         disable(f); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEnabled(Feature f) { [EOL]     return (_features & f.getMask()) != 0; [EOL] }
public boolean isEnabled(Feature f) { [EOL]     return (_features & f.getMask()) != 0; [EOL] }
public byte[] getBinaryValue() throws IOException, JsonParseException { [EOL]     return getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] }
public byte[] getBinaryValue() throws IOException, JsonParseException { [EOL]     return getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] }
@Override [EOL] public JsonGenerator setHighestNonEscapedChar(int charCode) { [EOL]     _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode; [EOL]     return this; [EOL] }
@Override [EOL] public JsonGenerator setHighestNonEscapedChar(int charCode) { [EOL]     _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode; [EOL]     return this; [EOL] }
public TextBuffer(BufferRecycler allocator) { [EOL]     _allocator = allocator; [EOL] }
public TextBuffer(BufferRecycler allocator) { [EOL]     _allocator = allocator; [EOL] }
private char[] findBuffer(int needed) { [EOL]     if (_allocator != null) { [EOL]         return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed); [EOL]     } [EOL]     return new char[Math.max(needed, MIN_SEGMENT_LEN)]; [EOL] }
private char[] findBuffer(int needed) { [EOL]     if (_allocator != null) { [EOL]         return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed); [EOL]     } [EOL]     return new char[Math.max(needed, MIN_SEGMENT_LEN)]; [EOL] }
private char[] findBuffer(int needed) { [EOL]     if (_allocator != null) { [EOL]         return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed); [EOL]     } [EOL]     return new char[Math.max(needed, MIN_SEGMENT_LEN)]; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public char[] contentsAsArray() { [EOL]     char[] result = _resultArray; [EOL]     if (result == null) { [EOL]         _resultArray = result = buildResultArray(); [EOL]     } [EOL]     return result; [EOL] }
public char[] contentsAsArray() { [EOL]     char[] result = _resultArray; [EOL]     if (result == null) { [EOL]         _resultArray = result = buildResultArray(); [EOL]     } [EOL]     return result; [EOL] }
public void append(char c) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(16); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     if (_currentSize >= curr.length) { [EOL]         expand(1); [EOL]         curr = _currentSegment; [EOL]     } [EOL]     curr[_currentSize++] = c; [EOL] }
public void append(char c) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(16); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     if (_currentSize >= curr.length) { [EOL]         expand(1); [EOL]         curr = _currentSegment; [EOL]     } [EOL]     curr[_currentSize++] = c; [EOL] }
public void append(char c) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(16); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     if (_currentSize >= curr.length) { [EOL]         expand(1); [EOL]         curr = _currentSegment; [EOL]     } [EOL]     curr[_currentSize++] = c; [EOL] }
public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] }
public char[] expandCurrentSegment() { [EOL]     final char[] curr = _currentSegment; [EOL]     final int len = curr.length; [EOL]     int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); [EOL]     return (_currentSegment = Arrays.copyOf(curr, newLen)); [EOL] }
public char[] expandCurrentSegment() { [EOL]     final char[] curr = _currentSegment; [EOL]     final int len = curr.length; [EOL]     int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); [EOL]     return (_currentSegment = Arrays.copyOf(curr, newLen)); [EOL] }
@Override [EOL] public String toString() { [EOL]     return contentsAsString(); [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] _charArray(int len) { [EOL]     return new char[len]; [EOL] }
private char[] _charArray(int len) { [EOL]     return new char[len]; [EOL] }
@Override [EOL] public JsonGenerator enable(Feature f) { [EOL]     _features |= f.getMask(); [EOL]     if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { [EOL]         _cfgNumbersAsStrings = true; [EOL]     } else if (f == Feature.ESCAPE_NON_ASCII) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonGenerator enable(Feature f) { [EOL]     _features |= f.getMask(); [EOL]     if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { [EOL]         _cfgNumbersAsStrings = true; [EOL]     } else if (f == Feature.ESCAPE_NON_ASCII) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonGenerator enable(Feature f) { [EOL]     _features |= f.getMask(); [EOL]     if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { [EOL]         _cfgNumbersAsStrings = true; [EOL]     } else if (f == Feature.ESCAPE_NON_ASCII) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] }
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
public JsonLocation getStartLocation(Object srcRef) { [EOL]     long totalChars = -1L; [EOL]     return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr); [EOL] }
public JsonLocation getStartLocation(Object srcRef) { [EOL]     long totalChars = -1L; [EOL]     return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr); [EOL] }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write boolean value"); [EOL]     if ((_outputTail + 5) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; [EOL]     int len = keyword.length; [EOL]     System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write boolean value"); [EOL]     if ((_outputTail + 5) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; [EOL]     int len = keyword.length; [EOL]     System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         byte b; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 b = BYTE_COMMA; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 b = BYTE_COLON; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL]                     if (raw.length > 0) { [EOL]                         _writeBytes(raw); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = b; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeBytes(byte[] bytes) throws IOException { [EOL]     final int len = bytes.length; [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, 0, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxUnescaped = _maximumNonEscapedChar; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch > maxUnescaped) { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _outputMultiByteChar(int ch, int outputPtr) throws IOException { [EOL]     byte[] bbuf = _outputBuffer; [EOL]     if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { [EOL]         bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL]         bbuf[outputPtr++] = BYTE_u; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; [EOL]     } else { [EOL]         bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } [EOL]     return outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _outputMultiByteChar(int ch, int outputPtr) throws IOException { [EOL]     byte[] bbuf = _outputBuffer; [EOL]     if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { [EOL]         bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL]         bbuf[outputPtr++] = BYTE_u; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; [EOL]     } else { [EOL]         bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } [EOL]     return outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL]     bbuf[outputPtr++] = BYTE_u; [EOL]     if (charToEscape > 0xFF) { [EOL]         int hi = (charToEscape >> 8) & 0xFF; [EOL]         bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; [EOL]         charToEscape &= 0xFF; [EOL]     } else { [EOL]         bbuf[outputPtr++] = BYTE_0; [EOL]         bbuf[outputPtr++] = BYTE_0; [EOL]     } [EOL]     bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; [EOL]     bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; [EOL]     return outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public MinimalPrettyPrinter() { [EOL]     this(DEFAULT_ROOT_VALUE_SEPARATOR); [EOL] }
public MinimalPrettyPrinter(String rootValueSeparator) { [EOL]     _rootValueSeparator = rootValueSeparator; [EOL] }
public MinimalPrettyPrinter(String rootValueSeparator) { [EOL]     _rootValueSeparator = rootValueSeparator; [EOL] }
@Override [EOL] public void writeStartObject(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw('{'); [EOL] }
@Override [EOL] public void beforeObjectEntries(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL] }
@Override [EOL] public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(':'); [EOL] }
@Override [EOL] public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(','); [EOL] }
@Override [EOL] public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw('}'); [EOL] }
@Override [EOL] public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw('['); [EOL] }
@Override [EOL] public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL] }
@Override [EOL] public void writeArrayValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(','); [EOL] }
@Override [EOL] public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(']'); [EOL] }
public int getColumnNr() { [EOL]     return _columnNr; [EOL] }
public void writeBinary(byte[] data) throws IOException, JsonGenerationException { [EOL]     writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length); [EOL] }
public void writeBinary(byte[] data) throws IOException, JsonGenerationException { [EOL]     writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length); [EOL] }
public void writeBinary(byte[] data) throws IOException, JsonGenerationException { [EOL]     writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length); [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL]     boolean negative = (ch == INT_MINUS); [EOL]     int ptr = _inputPtr; [EOL]     int startPtr = ptr - 1; [EOL]     final int inputLen = _inputEnd; [EOL]     dummy_loop: do { [EOL]         if (negative) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = _inputBuffer[ptr++]; [EOL]             if (ch > INT_9 || ch < INT_0) { [EOL]                 _inputPtr = ptr; [EOL]                 return _handleInvalidNumberStart(ch, true); [EOL]             } [EOL]         } [EOL]         if (ch == INT_0) { [EOL]             break dummy_loop; [EOL]         } [EOL]         int intLen = 1; [EOL]         int_loop: while (true) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 break int_loop; [EOL]             } [EOL]             ++intLen; [EOL]         } [EOL]         int fractLen = 0; [EOL]         if (ch == INT_DECIMAL_POINT) { [EOL]             fract_loop: while (true) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]                 if (ch < INT_0 || ch > INT_9) { [EOL]                     break fract_loop; [EOL]                 } [EOL]                 ++fractLen; [EOL]             } [EOL]             if (fractLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL]             } [EOL]         } [EOL]         int expLen = 0; [EOL]         if (ch == INT_e || ch == INT_E) { [EOL]             if (ptr >= inputLen) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch == INT_MINUS || ch == INT_PLUS) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             while (ch <= INT_9 && ch >= INT_0) { [EOL]                 ++expLen; [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             if (expLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL]             } [EOL]         } [EOL]         --ptr; [EOL]         _inputPtr = ptr; [EOL]         int len = ptr - startPtr; [EOL]         _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL]         return reset(negative, intLen, fractLen, expLen); [EOL]     } while (false); [EOL]     _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL]     return parseNumberText2(negative); [EOL] }
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]     } [EOL]     int intLen = 0; [EOL]     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL]     if (c == '0') { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     boolean eof = false; [EOL]     int_loop: while (c >= '0' && c <= '9') { [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             c = CHAR_NULL; [EOL]             eof = true; [EOL]             break int_loop; [EOL]         } [EOL]         c = _inputBuffer[_inputPtr++]; [EOL]     } [EOL]     if (intLen == 0) { [EOL]         reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL]     } [EOL]     int fractLen = 0; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return reset(negative, intLen, fractLen, expLen); [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@Override [EOL] public void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '['; [EOL]     } [EOL] }
@Override [EOL] public void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '['; [EOL]     } [EOL] }
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeBinary(b64variant, data, offset, offset + len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     _flushBuffer(); [EOL]     final int textLen = text.length(); [EOL]     int offset = 0; [EOL]     do { [EOL]         int max = _outputEnd; [EOL]         int segmentLen = ((offset + max) > textLen) ? (textLen - offset) : max; [EOL]         text.getChars(offset, offset + segmentLen, _outputBuffer, 0); [EOL]         if (_characterEscapes != null) { [EOL]             _writeSegmentCustom(segmentLen); [EOL]         } else if (_maximumNonEscapedChar != 0) { [EOL]             _writeSegmentASCII(segmentLen, _maximumNonEscapedChar); [EOL]         } else { [EOL]             _writeSegment(segmentLen); [EOL]         } [EOL]         offset += segmentLen; [EOL]     } while (offset < textLen); [EOL] }
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     _flushBuffer(); [EOL]     final int textLen = text.length(); [EOL]     int offset = 0; [EOL]     do { [EOL]         int max = _outputEnd; [EOL]         int segmentLen = ((offset + max) > textLen) ? (textLen - offset) : max; [EOL]         text.getChars(offset, offset + segmentLen, _outputBuffer, 0); [EOL]         if (_characterEscapes != null) { [EOL]             _writeSegmentCustom(segmentLen); [EOL]         } else if (_maximumNonEscapedChar != 0) { [EOL]             _writeSegmentASCII(segmentLen, _maximumNonEscapedChar); [EOL]         } else { [EOL]             _writeSegment(segmentLen); [EOL]         } [EOL]         offset += segmentLen; [EOL]     } while (offset < textLen); [EOL] }
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     _flushBuffer(); [EOL]     final int textLen = text.length(); [EOL]     int offset = 0; [EOL]     do { [EOL]         int max = _outputEnd; [EOL]         int segmentLen = ((offset + max) > textLen) ? (textLen - offset) : max; [EOL]         text.getChars(offset, offset + segmentLen, _outputBuffer, 0); [EOL]         if (_characterEscapes != null) { [EOL]             _writeSegmentCustom(segmentLen); [EOL]         } else if (_maximumNonEscapedChar != 0) { [EOL]             _writeSegmentASCII(segmentLen, _maximumNonEscapedChar); [EOL]         } else { [EOL]             _writeSegment(segmentLen); [EOL]         } [EOL]         offset += segmentLen; [EOL]     } while (offset < textLen); [EOL] }
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     _flushBuffer(); [EOL]     final int textLen = text.length(); [EOL]     int offset = 0; [EOL]     do { [EOL]         int max = _outputEnd; [EOL]         int segmentLen = ((offset + max) > textLen) ? (textLen - offset) : max; [EOL]         text.getChars(offset, offset + segmentLen, _outputBuffer, 0); [EOL]         if (_characterEscapes != null) { [EOL]             _writeSegmentCustom(segmentLen); [EOL]         } else if (_maximumNonEscapedChar != 0) { [EOL]             _writeSegmentASCII(segmentLen, _maximumNonEscapedChar); [EOL]         } else { [EOL]             _writeSegment(segmentLen); [EOL]         } [EOL]         offset += segmentLen; [EOL]     } while (offset < textLen); [EOL] }
private void _writeSegment(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     int ptr = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]); [EOL]     } [EOL] }
private void _writeSegment(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     int ptr = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] }
private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] }
private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] }
private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] }
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] }
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] }
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] }
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] }
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] }
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] }
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] }
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] }
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] }
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] }
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] }
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] }
private char[] _allocateEntityBuffer() { [EOL]     char[] buf = new char[14]; [EOL]     buf[0] = '\\'; [EOL]     buf[2] = '\\'; [EOL]     buf[3] = 'u'; [EOL]     buf[4] = '0'; [EOL]     buf[5] = '0'; [EOL]     buf[8] = '\\'; [EOL]     buf[9] = 'u'; [EOL]     _entityBuffer = buf; [EOL]     return buf; [EOL] }
public static void appendQuoted(StringBuilder sb, String content) { [EOL]     final int[] escCodes = sOutputEscapes128; [EOL]     int escLen = escCodes.length; [EOL]     for (int i = 0, len = content.length(); i < len; ++i) { [EOL]         char c = content.charAt(i); [EOL]         if (c >= escLen || escCodes[c] == 0) { [EOL]             sb.append(c); [EOL]             continue; [EOL]         } [EOL]         sb.append('\\'); [EOL]         int escCode = escCodes[c]; [EOL]         if (escCode < 0) { [EOL]             sb.append('u'); [EOL]             sb.append('0'); [EOL]             sb.append('0'); [EOL]             int value = c; [EOL]             sb.append(HEX_CHARS[value >> 4]); [EOL]             sb.append(HEX_CHARS[value & 0xF]); [EOL]         } else { [EOL]             sb.append((char) escCode); [EOL]         } [EOL]     } [EOL] }
public static void appendQuoted(StringBuilder sb, String content) { [EOL]     final int[] escCodes = sOutputEscapes128; [EOL]     int escLen = escCodes.length; [EOL]     for (int i = 0, len = content.length(); i < len; ++i) { [EOL]         char c = content.charAt(i); [EOL]         if (c >= escLen || escCodes[c] == 0) { [EOL]             sb.append(c); [EOL]             continue; [EOL]         } [EOL]         sb.append('\\'); [EOL]         int escCode = escCodes[c]; [EOL]         if (escCode < 0) { [EOL]             sb.append('u'); [EOL]             sb.append('0'); [EOL]             sb.append('0'); [EOL]             int value = c; [EOL]             sb.append(HEX_CHARS[value >> 4]); [EOL]             sb.append(HEX_CHARS[value & 0xF]); [EOL]         } else { [EOL]             sb.append((char) escCode); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@Override [EOL] public JsonToken nextValue() throws IOException, JsonParseException { [EOL]     JsonToken t = nextToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         t = nextToken(); [EOL]     } [EOL]     return t; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public JsonToken nextValue() throws IOException, JsonParseException { [EOL]     JsonToken t = nextToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         t = nextToken(); [EOL]     } [EOL]     return t; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { [EOL]     if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { [EOL]         return ch; [EOL]     } [EOL]     if (ch == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return ch; [EOL]     } [EOL]     _reportError("Unrecognized character escape " + _getCharDesc(ch)); [EOL]     return ch; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
public final JsonWriteContext createChildArrayContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_ARRAY); [EOL] }
public final JsonWriteContext createChildArrayContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_ARRAY); [EOL] }
@Override [EOL] public final JsonWriteContext getParent() { [EOL]     return _parent; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
protected BaseReader(IOContext context, InputStream in, byte[] buf, int ptr, int len) { [EOL]     _context = context; [EOL]     _in = in; [EOL]     _buffer = buf; [EOL]     _ptr = ptr; [EOL]     _length = len; [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     InputStream in = _in; [EOL]     if (in != null) { [EOL]         _in = null; [EOL]         freeBuffers(); [EOL]         in.close(); [EOL]     } [EOL] }
public final JsonFactory configure(JsonFactory.Feature f, boolean state) { [EOL]     return state ? enable(f) : disable(f); [EOL] }
public final JsonFactory configure(JsonFactory.Feature f, boolean state) { [EOL]     return state ? enable(f) : disable(f); [EOL] }
public JsonFactory enable(JsonFactory.Feature f) { [EOL]     _factoryFeatures |= f.getMask(); [EOL]     return this; [EOL] }
public JsonFactory enable(JsonFactory.Feature f) { [EOL]     _factoryFeatures |= f.getMask(); [EOL]     return this; [EOL] }
public JsonFactory disable(JsonFactory.Feature f) { [EOL]     _factoryFeatures &= ~f.getMask(); [EOL]     return this; [EOL] }
public JsonFactory disable(JsonFactory.Feature f) { [EOL]     _factoryFeatures &= ~f.getMask(); [EOL]     return this; [EOL] }
public JsonFactory setOutputDecorator(OutputDecorator d) { [EOL]     _outputDecorator = d; [EOL]     return this; [EOL] }
public JsonFactory setOutputDecorator(OutputDecorator d) { [EOL]     _outputDecorator = d; [EOL]     return this; [EOL] }
public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] }
public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] }
public JsonParser createParser(File f) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(f, true); [EOL]     InputStream in = new FileInputStream(f); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(File f) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(f, true); [EOL]     InputStream in = new FileInputStream(f); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(URL url) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(url, true); [EOL]     InputStream in = _optimizedStreamFromURL(url); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(URL url) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(url, true); [EOL]     InputStream in = _optimizedStreamFromURL(url); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(URL url) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(url, true); [EOL]     InputStream in = _optimizedStreamFromURL(url); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, offset, len); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, offset, len, ctxt); [EOL] }
public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, offset, len); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, offset, len, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(Writer out) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     if (_outputDecorator != null) { [EOL]         out = _outputDecorator.decorate(ctxt, out); [EOL]     } [EOL]     return _createGenerator(out, ctxt); [EOL] }
public JsonGenerator createGenerator(Writer out) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     if (_outputDecorator != null) { [EOL]         out = _outputDecorator.decorate(ctxt, out); [EOL]     } [EOL]     return _createGenerator(out, ctxt); [EOL] }
public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException { [EOL]     OutputStream out = new FileOutputStream(f); [EOL]     IOContext ctxt = _createContext(out, true); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException { [EOL]     OutputStream out = new FileOutputStream(f); [EOL]     IOContext ctxt = _createContext(out, true); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException { [EOL]     OutputStream out = new FileOutputStream(f); [EOL]     IOContext ctxt = _createContext(out, true); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures, _objectCodec, _rootByteSymbols, _rootCharSymbols, isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures, _objectCodec, _rootByteSymbols, _rootCharSymbols, isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures, _objectCodec, _rootByteSymbols, _rootCharSymbols, isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException { [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         return new UTF8Writer(ctxt, out); [EOL]     } [EOL]     return new OutputStreamWriter(out, enc.getJavaName()); [EOL] }
protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException { [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         return new UTF8Writer(ctxt, out); [EOL]     } [EOL]     return new OutputStreamWriter(out, enc.getJavaName()); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad1) && (quad2 == mQuad2); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad1) && (quad2 == mQuad2); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad1) && (quad2 == mQuad2); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad1) && (quad2 == mQuad2); [EOL] }
