private CharsToNameCanonicalizer() { [EOL]     _canonicalize = true; [EOL]     _intern = true; [EOL]     _dirty = true; [EOL]     _hashSeed = 0; [EOL]     _longestCollisionList = 0; [EOL]     initTables(DEFAULT_TABLE_SIZE); [EOL] }
private void initTables(int initialSize) { [EOL]     _symbols = new String[initialSize]; [EOL]     _buckets = new Bucket[initialSize >> 1]; [EOL]     _indexMask = initialSize - 1; [EOL]     _size = 0; [EOL]     _longestCollisionList = 0; [EOL]     _sizeThreshold = _thresholdSize(initialSize); [EOL] }
public int bucketCount() { [EOL]     return _symbols.length; [EOL] }
public int collisionCount() { [EOL]     int count = 0; [EOL]     for (Bucket bucket : _buckets) { [EOL]         if (bucket != null) { [EOL]             count += bucket.length(); [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public int maxCollisionLength() { [EOL]     return _longestCollisionList; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public int calcHash(char[] buffer, int start, int len) { [EOL]     int hash = _hashSeed; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         hash = (hash * HASH_MULT) + (int) buffer[i]; [EOL]     } [EOL]     return (hash == 0) ? 1 : hash; [EOL] }
public int calcHash(char[] buffer, int start, int len) { [EOL]     int hash = _hashSeed; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         hash = (hash * HASH_MULT) + (int) buffer[i]; [EOL]     } [EOL]     return (hash == 0) ? 1 : hash; [EOL] }
public int calcHash(char[] buffer, int start, int len) { [EOL]     int hash = _hashSeed; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         hash = (hash * HASH_MULT) + (int) buffer[i]; [EOL]     } [EOL]     return (hash == 0) ? 1 : hash; [EOL] }
public int calcHash(char[] buffer, int start, int len) { [EOL]     int hash = _hashSeed; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         hash = (hash * HASH_MULT) + (int) buffer[i]; [EOL]     } [EOL]     return (hash == 0) ? 1 : hash; [EOL] }
public int calcHash(String key) { [EOL]     final int len = key.length(); [EOL]     int hash = _hashSeed; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         hash = (hash * HASH_MULT) + (int) key.charAt(i); [EOL]     } [EOL]     return (hash == 0) ? 1 : hash; [EOL] }
private void rehash() { [EOL]     int size = _symbols.length; [EOL]     int newSize = size + size; [EOL]     if (newSize > MAX_TABLE_SIZE) { [EOL]         _size = 0; [EOL]         Arrays.fill(_symbols, null); [EOL]         Arrays.fill(_buckets, null); [EOL]         _dirty = true; [EOL]         return; [EOL]     } [EOL]     String[] oldSyms = _symbols; [EOL]     Bucket[] oldBuckets = _buckets; [EOL]     _symbols = new String[newSize]; [EOL]     _buckets = new Bucket[newSize >> 1]; [EOL]     _indexMask = newSize - 1; [EOL]     _sizeThreshold = _thresholdSize(newSize); [EOL]     int count = 0; [EOL]     int maxColl = 0; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         String symbol = oldSyms[i]; [EOL]         if (symbol != null) { [EOL]             ++count; [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     size >>= 1; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         Bucket b = oldBuckets[i]; [EOL]         while (b != null) { [EOL]             ++count; [EOL]             String symbol = b.getSymbol(); [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]             b = b.getNext(); [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (count != _size) { [EOL]         throw new Error("Internal error on SymbolTable.rehash(): had " + _size + " entries; now have " + count + "."); [EOL]     } [EOL] }
private void rehash() { [EOL]     int size = _symbols.length; [EOL]     int newSize = size + size; [EOL]     if (newSize > MAX_TABLE_SIZE) { [EOL]         _size = 0; [EOL]         Arrays.fill(_symbols, null); [EOL]         Arrays.fill(_buckets, null); [EOL]         _dirty = true; [EOL]         return; [EOL]     } [EOL]     String[] oldSyms = _symbols; [EOL]     Bucket[] oldBuckets = _buckets; [EOL]     _symbols = new String[newSize]; [EOL]     _buckets = new Bucket[newSize >> 1]; [EOL]     _indexMask = newSize - 1; [EOL]     _sizeThreshold = _thresholdSize(newSize); [EOL]     int count = 0; [EOL]     int maxColl = 0; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         String symbol = oldSyms[i]; [EOL]         if (symbol != null) { [EOL]             ++count; [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     size >>= 1; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         Bucket b = oldBuckets[i]; [EOL]         while (b != null) { [EOL]             ++count; [EOL]             String symbol = b.getSymbol(); [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]             b = b.getNext(); [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (count != _size) { [EOL]         throw new Error("Internal error on SymbolTable.rehash(): had " + _size + " entries; now have " + count + "."); [EOL]     } [EOL] }
private void rehash() { [EOL]     int size = _symbols.length; [EOL]     int newSize = size + size; [EOL]     if (newSize > MAX_TABLE_SIZE) { [EOL]         _size = 0; [EOL]         Arrays.fill(_symbols, null); [EOL]         Arrays.fill(_buckets, null); [EOL]         _dirty = true; [EOL]         return; [EOL]     } [EOL]     String[] oldSyms = _symbols; [EOL]     Bucket[] oldBuckets = _buckets; [EOL]     _symbols = new String[newSize]; [EOL]     _buckets = new Bucket[newSize >> 1]; [EOL]     _indexMask = newSize - 1; [EOL]     _sizeThreshold = _thresholdSize(newSize); [EOL]     int count = 0; [EOL]     int maxColl = 0; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         String symbol = oldSyms[i]; [EOL]         if (symbol != null) { [EOL]             ++count; [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     size >>= 1; [EOL]     for (int i = 0; i < size; ++i) { [EOL]         Bucket b = oldBuckets[i]; [EOL]         while (b != null) { [EOL]             ++count; [EOL]             String symbol = b.getSymbol(); [EOL]             int index = _hashToIndex(calcHash(symbol)); [EOL]             if (_symbols[index] == null) { [EOL]                 _symbols[index] = symbol; [EOL]             } else { [EOL]                 int bix = (index >> 1); [EOL]                 Bucket newB = new Bucket(symbol, _buckets[bix]); [EOL]                 _buckets[bix] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]             b = b.getNext(); [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (count != _size) { [EOL]         throw new Error("Internal error on SymbolTable.rehash(): had " + _size + " entries; now have " + count + "."); [EOL]     } [EOL] }
public String getSymbol() { [EOL]     return _symbol; [EOL] }
public Bucket getNext() { [EOL]     return _next; [EOL] }
public String find(char[] buf, int start, int len) { [EOL]     String sym = _symbol; [EOL]     Bucket b = _next; [EOL]     while (true) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buf[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         if (b == null) { [EOL]             break; [EOL]         } [EOL]         sym = b.getSymbol(); [EOL]         b = b.getNext(); [EOL]     } [EOL]     return null; [EOL] }
public String find(char[] buf, int start, int len) { [EOL]     String sym = _symbol; [EOL]     Bucket b = _next; [EOL]     while (true) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buf[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         if (b == null) { [EOL]             break; [EOL]         } [EOL]         sym = b.getSymbol(); [EOL]         b = b.getNext(); [EOL]     } [EOL]     return null; [EOL] }
public String find(char[] buf, int start, int len) { [EOL]     String sym = _symbol; [EOL]     Bucket b = _next; [EOL]     while (true) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buf[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         if (b == null) { [EOL]             break; [EOL]         } [EOL]         sym = b.getSymbol(); [EOL]         b = b.getNext(); [EOL]     } [EOL]     return null; [EOL] }
public String find(char[] buf, int start, int len) { [EOL]     String sym = _symbol; [EOL]     Bucket b = _next; [EOL]     while (true) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buf[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         if (b == null) { [EOL]             break; [EOL]         } [EOL]         sym = b.getSymbol(); [EOL]         b = b.getNext(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonLocation getCurrentLocation() { [EOL]     int col = _inputPtr - _currInputRowStart + 1; [EOL]     return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr - 1, _currInputRow, col); [EOL] }
@Override [EOL] public JsonLocation getCurrentLocation() { [EOL]     int col = _inputPtr - _currInputRowStart + 1; [EOL]     return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr - 1, _currInputRow, col); [EOL] }
protected void _releaseBuffers() throws IOException { [EOL]     _textBuffer.releaseBuffers(); [EOL]     char[] buf = _nameCopyBuffer; [EOL]     if (buf != null) { [EOL]         _nameCopyBuffer = null; [EOL]         _ioContext.releaseNameCopyBuffer(buf); [EOL]     } [EOL] }
protected void _releaseBuffers() throws IOException { [EOL]     _textBuffer.releaseBuffers(); [EOL]     char[] buf = _nameCopyBuffer; [EOL]     if (buf != null) { [EOL]         _nameCopyBuffer = null; [EOL]         _ioContext.releaseNameCopyBuffer(buf); [EOL]     } [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
public int size() { [EOL]     if (_tableInfo != null) { [EOL]         return _tableInfo.get().count; [EOL]     } [EOL]     return _count; [EOL] }
public int size() { [EOL]     if (_tableInfo != null) { [EOL]         return _tableInfo.get().count; [EOL]     } [EOL]     return _count; [EOL] }
public int bucketCount() { [EOL]     return _mainHash.length; [EOL] }
public int collisionCount() { [EOL]     return _collCount; [EOL] }
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] }
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] }
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] }
public int calcHash(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     int hash = quads[0] ^ _hashSeed; [EOL]     hash += (hash >>> 9); [EOL]     hash *= MULT; [EOL]     hash += quads[1]; [EOL]     hash *= MULT2; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= quads[2]; [EOL]     hash += (hash >>> 17); [EOL]     for (int i = 3; i < qlen; ++i) { [EOL]         hash = (hash * MULT3) ^ quads[i]; [EOL]         hash += (hash >>> 3); [EOL]         hash ^= (hash << 7); [EOL]     } [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash << 9); [EOL]     return hash; [EOL] }
public int calcHash(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     int hash = quads[0] ^ _hashSeed; [EOL]     hash += (hash >>> 9); [EOL]     hash *= MULT; [EOL]     hash += quads[1]; [EOL]     hash *= MULT2; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= quads[2]; [EOL]     hash += (hash >>> 17); [EOL]     for (int i = 3; i < qlen; ++i) { [EOL]         hash = (hash * MULT3) ^ quads[i]; [EOL]         hash += (hash >>> 3); [EOL]         hash ^= (hash << 7); [EOL]     } [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash << 9); [EOL]     return hash; [EOL] }
public int calcHash(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     int hash = quads[0] ^ _hashSeed; [EOL]     hash += (hash >>> 9); [EOL]     hash *= MULT; [EOL]     hash += quads[1]; [EOL]     hash *= MULT2; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= quads[2]; [EOL]     hash += (hash >>> 17); [EOL]     for (int i = 3; i < qlen; ++i) { [EOL]         hash = (hash * MULT3) ^ quads[i]; [EOL]         hash += (hash >>> 3); [EOL]         hash ^= (hash << 7); [EOL]     } [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash << 9); [EOL]     return hash; [EOL] }
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] }
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] }
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] }
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] }
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] }
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] }
private void _addSymbol(int hash, Name symbol) { [EOL]     if (_mainHashShared) { [EOL]         unshareMain(); [EOL]     } [EOL]     if (_needRehash) { [EOL]         rehash(); [EOL]     } [EOL]     ++_count; [EOL]     int ix = (hash & _mainHashMask); [EOL]     if (_mainNames[ix] == null) { [EOL]         _mainHash[ix] = (hash << 8); [EOL]         if (_mainNamesShared) { [EOL]             unshareNames(); [EOL]         } [EOL]         _mainNames[ix] = symbol; [EOL]     } else { [EOL]         if (_collListShared) { [EOL]             unshareCollision(); [EOL]         } [EOL]         ++_collCount; [EOL]         int entryValue = _mainHash[ix]; [EOL]         int bucket = entryValue & 0xFF; [EOL]         if (bucket == 0) { [EOL]             if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                 bucket = _collEnd; [EOL]                 ++_collEnd; [EOL]                 if (bucket >= _collList.length) { [EOL]                     expandCollision(); [EOL]                 } [EOL]             } else { [EOL]                 bucket = findBestBucket(); [EOL]             } [EOL]             _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL]         } else { [EOL]             --bucket; [EOL]         } [EOL]         Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]         _collList[bucket] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     { [EOL]         int hashSize = _mainHash.length; [EOL]         if (_count > (hashSize >> 1)) { [EOL]             int hashQuarter = (hashSize >> 2); [EOL]             if (_count > (hashSize - hashQuarter)) { [EOL]                 _needRehash = true; [EOL]             } else if (_collCount >= hashQuarter) { [EOL]                 _needRehash = true; [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL]     } [EOL] }
private int findBestBucket() { [EOL]     Bucket[] buckets = _collList; [EOL]     int bestCount = Integer.MAX_VALUE; [EOL]     int bestIx = -1; [EOL]     for (int i = 0, len = _collEnd; i < len; ++i) { [EOL]         int count = buckets[i].length(); [EOL]         if (count < bestCount) { [EOL]             if (count == 1) { [EOL]                 return i; [EOL]             } [EOL]             bestCount = count; [EOL]             bestIx = i; [EOL]         } [EOL]     } [EOL]     return bestIx; [EOL] }
private void expandCollision() { [EOL]     final Bucket[] old = _collList; [EOL]     _collList = Arrays.copyOf(old, old.length * 2); [EOL] }
private void expandCollision() { [EOL]     final Bucket[] old = _collList; [EOL]     _collList = Arrays.copyOf(old, old.length * 2); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
ByteBufferType(int size) { [EOL]     this.size = size; [EOL] }
ByteBufferType(int size) { [EOL]     this.size = size; [EOL] }
ByteBufferType(int size) { [EOL]     this.size = size; [EOL] }
CharBufferType(int size) { [EOL]     this.size = size; [EOL] }
CharBufferType(int size) { [EOL]     this.size = size; [EOL] }
CharBufferType(int size) { [EOL]     this.size = size; [EOL] }
public BufferRecycler() { [EOL] }
public static int outputInt(int value, char[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (char) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, char[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (char) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputInt(int value, byte[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (byte) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputLong(long value, char[] buffer, int offset) { [EOL]     if (value < 0L) { [EOL]         if (value > MIN_INT_AS_LONG) { [EOL]             return outputInt((int) value, buffer, offset); [EOL]         } [EOL]         if (value == Long.MIN_VALUE) { [EOL]             int len = SMALLEST_LONG.length(); [EOL]             SMALLEST_LONG.getChars(0, len, buffer, offset); [EOL]             return (offset + len); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } else { [EOL]         if (value <= MAX_INT_AS_LONG) { [EOL]             return outputInt((int) value, buffer, offset); [EOL]         } [EOL]     } [EOL]     int origOffset = offset; [EOL]     offset += calcLongStrLength(value); [EOL]     int ptr = offset; [EOL]     while (value > MAX_INT_AS_LONG) { [EOL]         ptr -= 3; [EOL]         long newValue = value / THOUSAND_L; [EOL]         int triplet = (int) (value - newValue * THOUSAND_L); [EOL]         outputFullTriplet(triplet, buffer, ptr); [EOL]         value = newValue; [EOL]     } [EOL]     int ivalue = (int) value; [EOL]     while (ivalue >= 1000) { [EOL]         ptr -= 3; [EOL]         int newValue = ivalue / 1000; [EOL]         int triplet = ivalue - (newValue * 1000); [EOL]         outputFullTriplet(triplet, buffer, ptr); [EOL]         ivalue = newValue; [EOL]     } [EOL]     outputLeadingTriplet(ivalue, buffer, origOffset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
private static int outputLeadingTriplet(int triplet, char[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     char c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = c; [EOL]     } [EOL]     c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = c; [EOL]     } [EOL]     buffer[offset++] = LEADING_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     char c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = (byte) c; [EOL]     } [EOL]     c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = (byte) c; [EOL]     } [EOL]     buffer[offset++] = (byte) LEADING_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
private static int outputFullTriplet(int triplet, char[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset++]; [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset++]; [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
private static int outputFullTriplet(int triplet, char[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset++]; [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset++]; [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
private static int outputFullTriplet(int triplet, char[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset++]; [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset++]; [EOL]     buffer[offset++] = FULL_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
@Override [EOL] public Version version() { [EOL]     return VERSION; [EOL] }
public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { [EOL]     super(ctxt, features); [EOL]     _inputStream = in; [EOL]     _objectCodec = codec; [EOL]     _symbols = sym; [EOL]     _inputBuffer = inputBuffer; [EOL]     _inputPtr = start; [EOL]     _inputEnd = end; [EOL]     _bufferRecyclable = bufferRecyclable; [EOL] }
@Override [EOL] protected void _closeInput() throws IOException { [EOL]     if (_inputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { [EOL]             _inputStream.close(); [EOL]         } [EOL]         _inputStream = null; [EOL]     } [EOL] }
@Override [EOL] protected void _closeInput() throws IOException { [EOL]     if (_inputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { [EOL]             _inputStream.close(); [EOL]         } [EOL]         _inputStream = null; [EOL]     } [EOL] }
@Override [EOL] protected void _releaseBuffers() throws IOException { [EOL]     super._releaseBuffers(); [EOL]     if (_bufferRecyclable) { [EOL]         byte[] buf = _inputBuffer; [EOL]         if (buf != null) { [EOL]             _inputBuffer = null; [EOL]             _ioContext.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     _symbols.release(); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     _symbols.release(); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] }
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     if ((_inputPtr + 9) > _inputEnd) { [EOL]         return slowParseFieldName(); [EOL]     } [EOL]     final byte[] input = _inputBuffer; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int q = input[_inputPtr++] & 0xFF; [EOL]     if (codes[q] == 0) { [EOL]         i = input[_inputPtr++] & 0xFF; [EOL]         if (codes[i] == 0) { [EOL]             q = (q << 8) | i; [EOL]             i = input[_inputPtr++] & 0xFF; [EOL]             if (codes[i] == 0) { [EOL]                 q = (q << 8) | i; [EOL]                 i = input[_inputPtr++] & 0xFF; [EOL]                 if (codes[i] == 0) { [EOL]                     q = (q << 8) | i; [EOL]                     i = input[_inputPtr++] & 0xFF; [EOL]                     if (codes[i] == 0) { [EOL]                         _quad1 = q; [EOL]                         return parseMediumFieldName(i, codes); [EOL]                     } [EOL]                     if (i == INT_QUOTE) { [EOL]                         return findName(q, 4); [EOL]                     } [EOL]                     return parseFieldName(q, i, 4); [EOL]                 } [EOL]                 if (i == INT_QUOTE) { [EOL]                     return findName(q, 3); [EOL]                 } [EOL]                 return parseFieldName(q, i, 3); [EOL]             } [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(q, 2); [EOL]             } [EOL]             return parseFieldName(q, i, 2); [EOL]         } [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(q, 1); [EOL]         } [EOL]         return parseFieldName(q, i, 1); [EOL]     } [EOL]     if (q == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseFieldName(0, q, 0); [EOL] }
protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 1); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 1); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 2); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 2); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 3); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 3); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 4); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 4); [EOL]     } [EOL]     _quadBuffer[0] = _quad1; [EOL]     _quadBuffer[1] = q2; [EOL]     return parseLongFieldName(i); [EOL] }
protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] }
protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (codes[ch] != 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, "name"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name findName(int q1, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     return addName(_quadBuffer, 1, lastQuadBytes); [EOL] }
private Name findName(int q1, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     return addName(_quadBuffer, 1, lastQuadBytes); [EOL] }
private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1, q2); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     _quadBuffer[1] = q2; [EOL]     return addName(_quadBuffer, 2, lastQuadBytes); [EOL] }
private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1, q2); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     _quadBuffer[1] = q2; [EOL]     return addName(_quadBuffer, 2, lastQuadBytes); [EOL] }
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         int c; [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             int max = _inputEnd; [EOL]             if (ptr >= max) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]                 max = _inputEnd; [EOL]             } [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 _skipUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 _skipUtf8_3(c); [EOL]                 break; [EOL]             case 4: [EOL]                 _skipUtf8_4(c); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]     } [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException { [EOL]     _reportInvalidToken(matchedPart, "'null', 'true', 'false' or NaN"); [EOL] }
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             break; [EOL]         } [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         char c = (char) _decodeCharForError(i); [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting " + msg); [EOL] }
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             break; [EOL]         } [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         char c = (char) _decodeCharForError(i); [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting " + msg); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException { [EOL]     int c = (int) firstByte; [EOL]     if (c < 0) { [EOL]         int needed; [EOL]         if ((c & 0xE0) == 0xC0) { [EOL]             c &= 0x1F; [EOL]             needed = 1; [EOL]         } else if ((c & 0xF0) == 0xE0) { [EOL]             c &= 0x0F; [EOL]             needed = 2; [EOL]         } else if ((c & 0xF8) == 0xF0) { [EOL]             c &= 0x07; [EOL]             needed = 3; [EOL]         } else { [EOL]             _reportInvalidInitial(c & 0xFF); [EOL]             needed = 1; [EOL]         } [EOL]         int d = nextByte(); [EOL]         if ((d & 0xC0) != 0x080) { [EOL]             _reportInvalidOther(d & 0xFF); [EOL]         } [EOL]         c = (c << 6) | (d & 0x3F); [EOL]         if (needed > 1) { [EOL]             d = nextByte(); [EOL]             if ((d & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(d & 0xFF); [EOL]             } [EOL]             c = (c << 6) | (d & 0x3F); [EOL]             if (needed > 2) { [EOL]                 d = nextByte(); [EOL]                 if ((d & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(d & 0xFF); [EOL]                 } [EOL]                 c = (c << 6) | (d & 0x3F); [EOL]             } [EOL]         } [EOL]     } [EOL]     return c; [EOL] }
protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException { [EOL]     int c = (int) firstByte; [EOL]     if (c < 0) { [EOL]         int needed; [EOL]         if ((c & 0xE0) == 0xC0) { [EOL]             c &= 0x1F; [EOL]             needed = 1; [EOL]         } else if ((c & 0xF0) == 0xE0) { [EOL]             c &= 0x0F; [EOL]             needed = 2; [EOL]         } else if ((c & 0xF8) == 0xF0) { [EOL]             c &= 0x07; [EOL]             needed = 3; [EOL]         } else { [EOL]             _reportInvalidInitial(c & 0xFF); [EOL]             needed = 1; [EOL]         } [EOL]         int d = nextByte(); [EOL]         if ((d & 0xC0) != 0x080) { [EOL]             _reportInvalidOther(d & 0xFF); [EOL]         } [EOL]         c = (c << 6) | (d & 0x3F); [EOL]         if (needed > 1) { [EOL]             d = nextByte(); [EOL]             if ((d & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(d & 0xFF); [EOL]             } [EOL]             c = (c << 6) | (d & 0x3F); [EOL]             if (needed > 2) { [EOL]                 d = nextByte(); [EOL]                 if ((d & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(d & 0xFF); [EOL]                 } [EOL]                 c = (c << 6) | (d & 0x3F); [EOL]             } [EOL]         } [EOL]     } [EOL]     return c; [EOL] }
protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException { [EOL]     int c = (int) firstByte; [EOL]     if (c < 0) { [EOL]         int needed; [EOL]         if ((c & 0xE0) == 0xC0) { [EOL]             c &= 0x1F; [EOL]             needed = 1; [EOL]         } else if ((c & 0xF0) == 0xE0) { [EOL]             c &= 0x0F; [EOL]             needed = 2; [EOL]         } else if ((c & 0xF8) == 0xF0) { [EOL]             c &= 0x07; [EOL]             needed = 3; [EOL]         } else { [EOL]             _reportInvalidInitial(c & 0xFF); [EOL]             needed = 1; [EOL]         } [EOL]         int d = nextByte(); [EOL]         if ((d & 0xC0) != 0x080) { [EOL]             _reportInvalidOther(d & 0xFF); [EOL]         } [EOL]         c = (c << 6) | (d & 0x3F); [EOL]         if (needed > 1) { [EOL]             d = nextByte(); [EOL]             if ((d & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(d & 0xFF); [EOL]             } [EOL]             c = (c << 6) | (d & 0x3F); [EOL]             if (needed > 2) { [EOL]                 d = nextByte(); [EOL]                 if ((d & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(d & 0xFF); [EOL]                 } [EOL]                 c = (c << 6) | (d & 0x3F); [EOL]             } [EOL]         } [EOL]     } [EOL]     return c; [EOL] }
private int _decodeUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = ((c & 0x07) << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c << 6) | (d & 0x3F)) - 0x10000; [EOL] }
private int _decodeUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = ((c & 0x07) << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c << 6) | (d & 0x3F)) - 0x10000; [EOL] }
private int _decodeUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = ((c & 0x07) << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c << 6) | (d & 0x3F)) - 0x10000; [EOL] }
private int _decodeUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = ((c & 0x07) << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c << 6) | (d & 0x3F)) - 0x10000; [EOL] }
private void _skipUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL] }
private void _skipUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL] }
private void _skipUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL] }
protected void _skipLF() throws IOException { [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
public Version(int major, int minor, int patchLevel, String snapshotInfo, String groupId, String artifactId) { [EOL]     _majorVersion = major; [EOL]     _minorVersion = minor; [EOL]     _patchLevel = patchLevel; [EOL]     _snapshotInfo = snapshotInfo; [EOL]     _groupId = (groupId == null) ? "" : groupId; [EOL]     _artifactId = (artifactId == null) ? "" : artifactId; [EOL] }
public Version(int major, int minor, int patchLevel, String snapshotInfo, String groupId, String artifactId) { [EOL]     _majorVersion = major; [EOL]     _minorVersion = minor; [EOL]     _patchLevel = patchLevel; [EOL]     _snapshotInfo = snapshotInfo; [EOL]     _groupId = (groupId == null) ? "" : groupId; [EOL]     _artifactId = (artifactId == null) ? "" : artifactId; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     Version other = (Version) o; [EOL]     return (other._majorVersion == _majorVersion) && (other._minorVersion == _minorVersion) && (other._patchLevel == _patchLevel) && other._artifactId.equals(_artifactId) && other._groupId.equals(_groupId); [EOL] }
@Override [EOL] public Writer append(char c) throws IOException { [EOL]     write(c); [EOL]     return this; [EOL] }
@Override [EOL] public Writer append(char c) throws IOException { [EOL]     write(c); [EOL]     return this; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str) throws IOException { [EOL]     write(str, 0, str.length()); [EOL] }
@Override [EOL] public void write(String str) throws IOException { [EOL]     write(str, 0, str.length()); [EOL] }
@Override [EOL] public void write(String str) throws IOException { [EOL]     write(str, 0, str.length()); [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] }
public Object getSourceReference() { [EOL]     return _sourceRef; [EOL] }
public Object getSourceReference() { [EOL]     return _sourceRef; [EOL] }
public void releaseWriteEncodingBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _writeEncodingBuffer); [EOL]         _writeEncodingBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf); [EOL]     } [EOL] }
public void releaseWriteEncodingBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _writeEncodingBuffer); [EOL]         _writeEncodingBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf); [EOL]     } [EOL] }
public void releaseNameCopyBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _nameCopyBuffer); [EOL]         _nameCopyBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf); [EOL]     } [EOL] }
public void releaseNameCopyBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _nameCopyBuffer); [EOL]         _nameCopyBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf); [EOL]     } [EOL] }
NameN(String name, int hash, int[] quads, int quadLen) { [EOL]     super(name, hash); [EOL]     if (quadLen < 3) { [EOL]         throw new IllegalArgumentException("Qlen must >= 3"); [EOL]     } [EOL]     mQuads = quads; [EOL]     mQuadLen = quadLen; [EOL] }
NameN(String name, int hash, int[] quads, int quadLen) { [EOL]     super(name, hash); [EOL]     if (quadLen < 3) { [EOL]         throw new IllegalArgumentException("Qlen must >= 3"); [EOL]     } [EOL]     mQuads = quads; [EOL]     mQuadLen = quadLen; [EOL] }
public static int collectDefaults() { [EOL]     int flags = 0; [EOL]     for (Feature f : values()) { [EOL]         if (f.enabledByDefault()) { [EOL]             flags |= f.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] }
private Feature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
private Feature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName()); [EOL] }
public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName()); [EOL] }
public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName()); [EOL] }
public boolean getBooleanValue() throws IOException, JsonParseException { [EOL]     JsonToken t = getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) [EOL]         return true; [EOL]     if (t == JsonToken.VALUE_FALSE) [EOL]         return false; [EOL]     throw new JsonParseException("Current token (" + t + ") not of boolean type", getCurrentLocation()); [EOL] }
public boolean getBooleanValue() throws IOException, JsonParseException { [EOL]     JsonToken t = getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) [EOL]         return true; [EOL]     if (t == JsonToken.VALUE_FALSE) [EOL]         return false; [EOL]     throw new JsonParseException("Current token (" + t + ") not of boolean type", getCurrentLocation()); [EOL] }
public boolean getBooleanValue() throws IOException, JsonParseException { [EOL]     JsonToken t = getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) [EOL]         return true; [EOL]     if (t == JsonToken.VALUE_FALSE) [EOL]         return false; [EOL]     throw new JsonParseException("Current token (" + t + ") not of boolean type", getCurrentLocation()); [EOL] }
protected JsonParseException _constructError(String msg) { [EOL]     return new JsonParseException(msg, getCurrentLocation()); [EOL] }
@Override [EOL] public JsonGenerator setRootValueSeparator(SerializableString sep) { [EOL]     _rootValueSeparator = sep; [EOL]     return this; [EOL] }
@Override [EOL] public JsonGenerator setRootValueSeparator(SerializableString sep) { [EOL]     _rootValueSeparator = sep; [EOL]     return this; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] }
public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] }
public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] }
public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] }
@Override [EOL] public JsonGenerator useDefaultPrettyPrinter() { [EOL]     if (getPrettyPrinter() != null) { [EOL]         return this; [EOL]     } [EOL]     return setPrettyPrinter(new DefaultPrettyPrinter()); [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] }
protected void _reportError(String msg) throws JsonGenerationException { [EOL]     throw new JsonGenerationException(msg); [EOL] }
protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]         return; [EOL]     } [EOL]     if (value instanceof String) { [EOL]         writeString((String) value); [EOL]         return; [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         Number n = (Number) value; [EOL]         if (n instanceof Integer) { [EOL]             writeNumber(n.intValue()); [EOL]             return; [EOL]         } else if (n instanceof Long) { [EOL]             writeNumber(n.longValue()); [EOL]             return; [EOL]         } else if (n instanceof Double) { [EOL]             writeNumber(n.doubleValue()); [EOL]             return; [EOL]         } else if (n instanceof Float) { [EOL]             writeNumber(n.floatValue()); [EOL]             return; [EOL]         } else if (n instanceof Short) { [EOL]             writeNumber(n.shortValue()); [EOL]             return; [EOL]         } else if (n instanceof Byte) { [EOL]             writeNumber(n.byteValue()); [EOL]             return; [EOL]         } else if (n instanceof BigInteger) { [EOL]             writeNumber((BigInteger) n); [EOL]             return; [EOL]         } else if (n instanceof BigDecimal) { [EOL]             writeNumber((BigDecimal) n); [EOL]             return; [EOL]         } else if (n instanceof AtomicInteger) { [EOL]             writeNumber(((AtomicInteger) n).get()); [EOL]             return; [EOL]         } else if (n instanceof AtomicLong) { [EOL]             writeNumber(((AtomicLong) n).get()); [EOL]             return; [EOL]         } [EOL]     } else if (value instanceof byte[]) { [EOL]         writeBinary((byte[]) value); [EOL]         return; [EOL]     } else if (value instanceof Boolean) { [EOL]         writeBoolean((Boolean) value); [EOL]         return; [EOL]     } else if (value instanceof AtomicBoolean) { [EOL]         writeBoolean(((AtomicBoolean) value).get()); [EOL]         return; [EOL]     } [EOL]     throw new IllegalStateException("No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed " + value.getClass().getName() + ")"); [EOL] }
protected void reset(int type, int lineNr, int colNr) { [EOL]     _type = type; [EOL]     _index = -1; [EOL]     _lineNr = lineNr; [EOL]     _columnNr = colNr; [EOL]     _currentName = null; [EOL] }
public JsonReadContext createChildArrayContext(int lineNr, int colNr) { [EOL]     JsonReadContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonReadContext(this, TYPE_ARRAY, lineNr, colNr); [EOL]         return ctxt; [EOL]     } [EOL]     ctxt.reset(TYPE_ARRAY, lineNr, colNr); [EOL]     return ctxt; [EOL] }
public JsonReadContext createChildArrayContext(int lineNr, int colNr) { [EOL]     JsonReadContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonReadContext(this, TYPE_ARRAY, lineNr, colNr); [EOL]         return ctxt; [EOL]     } [EOL]     ctxt.reset(TYPE_ARRAY, lineNr, colNr); [EOL]     return ctxt; [EOL] }
public JsonReadContext createChildObjectContext(int lineNr, int colNr) { [EOL]     JsonReadContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonReadContext(this, TYPE_OBJECT, lineNr, colNr); [EOL]         return ctxt; [EOL]     } [EOL]     ctxt.reset(TYPE_OBJECT, lineNr, colNr); [EOL]     return ctxt; [EOL] }
public JsonReadContext createChildObjectContext(int lineNr, int colNr) { [EOL]     JsonReadContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonReadContext(this, TYPE_OBJECT, lineNr, colNr); [EOL]         return ctxt; [EOL]     } [EOL]     ctxt.reset(TYPE_OBJECT, lineNr, colNr); [EOL]     return ctxt; [EOL] }
public static Version versionFor(Class<?> cls) { [EOL]     Version packageVersion = packageVersionFor(cls); [EOL]     if (packageVersion != null) { [EOL]         return packageVersion; [EOL]     } [EOL]     final InputStream in = cls.getResourceAsStream(VERSION_FILE); [EOL]     if (in == null) [EOL]         return Version.unknownVersion(); [EOL]     try { [EOL]         InputStreamReader reader = new InputStreamReader(in, "UTF-8"); [EOL]         try { [EOL]             return doReadVersion(reader); [EOL]         } finally { [EOL]             try { [EOL]                 reader.close(); [EOL]             } catch (IOException ignored) { [EOL]             } [EOL]         } [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         return Version.unknownVersion(); [EOL]     } finally { [EOL]         try { [EOL]             in.close(); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]     } [EOL] }
public static Version versionFor(Class<?> cls) { [EOL]     Version packageVersion = packageVersionFor(cls); [EOL]     if (packageVersion != null) { [EOL]         return packageVersion; [EOL]     } [EOL]     final InputStream in = cls.getResourceAsStream(VERSION_FILE); [EOL]     if (in == null) [EOL]         return Version.unknownVersion(); [EOL]     try { [EOL]         InputStreamReader reader = new InputStreamReader(in, "UTF-8"); [EOL]         try { [EOL]             return doReadVersion(reader); [EOL]         } finally { [EOL]             try { [EOL]                 reader.close(); [EOL]             } catch (IOException ignored) { [EOL]             } [EOL]         } [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         return Version.unknownVersion(); [EOL]     } finally { [EOL]         try { [EOL]             in.close(); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]     } [EOL] }
public static Version versionFor(Class<?> cls) { [EOL]     Version packageVersion = packageVersionFor(cls); [EOL]     if (packageVersion != null) { [EOL]         return packageVersion; [EOL]     } [EOL]     final InputStream in = cls.getResourceAsStream(VERSION_FILE); [EOL]     if (in == null) [EOL]         return Version.unknownVersion(); [EOL]     try { [EOL]         InputStreamReader reader = new InputStreamReader(in, "UTF-8"); [EOL]         try { [EOL]             return doReadVersion(reader); [EOL]         } finally { [EOL]             try { [EOL]                 reader.close(); [EOL]             } catch (IOException ignored) { [EOL]             } [EOL]         } [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         return Version.unknownVersion(); [EOL]     } finally { [EOL]         try { [EOL]             in.close(); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]     } [EOL] }
public static Version versionFor(Class<?> cls) { [EOL]     Version packageVersion = packageVersionFor(cls); [EOL]     if (packageVersion != null) { [EOL]         return packageVersion; [EOL]     } [EOL]     final InputStream in = cls.getResourceAsStream(VERSION_FILE); [EOL]     if (in == null) [EOL]         return Version.unknownVersion(); [EOL]     try { [EOL]         InputStreamReader reader = new InputStreamReader(in, "UTF-8"); [EOL]         try { [EOL]             return doReadVersion(reader); [EOL]         } finally { [EOL]             try { [EOL]                 reader.close(); [EOL]             } catch (IOException ignored) { [EOL]             } [EOL]         } [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         return Version.unknownVersion(); [EOL]     } finally { [EOL]         try { [EOL]             in.close(); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]     } [EOL] }
public static Version versionFor(Class<?> cls) { [EOL]     Version packageVersion = packageVersionFor(cls); [EOL]     if (packageVersion != null) { [EOL]         return packageVersion; [EOL]     } [EOL]     final InputStream in = cls.getResourceAsStream(VERSION_FILE); [EOL]     if (in == null) [EOL]         return Version.unknownVersion(); [EOL]     try { [EOL]         InputStreamReader reader = new InputStreamReader(in, "UTF-8"); [EOL]         try { [EOL]             return doReadVersion(reader); [EOL]         } finally { [EOL]             try { [EOL]                 reader.close(); [EOL]             } catch (IOException ignored) { [EOL]             } [EOL]         } [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         return Version.unknownVersion(); [EOL]     } finally { [EOL]         try { [EOL]             in.close(); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]     } [EOL] }
public static Version packageVersionFor(Class<?> cls) { [EOL]     Class<?> versionInfoClass = null; [EOL]     try { [EOL]         Package p = cls.getPackage(); [EOL]         String versionInfoClassName = new StringBuilder(p.getName()).append(".").append(PACKAGE_VERSION_CLASS_NAME).toString(); [EOL]         versionInfoClass = Class.forName(versionInfoClassName, true, cls.getClassLoader()); [EOL]     } catch (Exception e) { [EOL]         return null; [EOL]     } [EOL]     if (versionInfoClass == null) { [EOL]         return null; [EOL]     } [EOL]     Object v; [EOL]     try { [EOL]         v = versionInfoClass.newInstance(); [EOL]     } catch (RuntimeException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Failed to instantiate " + versionInfoClass.getName() + " to find version information, problem: " + e.getMessage(), e); [EOL]     } [EOL]     if (!(v instanceof Versioned)) { [EOL]         throw new IllegalArgumentException("Bad version class " + versionInfoClass.getName() + ": does not implement " + Versioned.class.getName()); [EOL]     } [EOL]     return ((Versioned) v).version(); [EOL] }
public static Version packageVersionFor(Class<?> cls) { [EOL]     Class<?> versionInfoClass = null; [EOL]     try { [EOL]         Package p = cls.getPackage(); [EOL]         String versionInfoClassName = new StringBuilder(p.getName()).append(".").append(PACKAGE_VERSION_CLASS_NAME).toString(); [EOL]         versionInfoClass = Class.forName(versionInfoClassName, true, cls.getClassLoader()); [EOL]     } catch (Exception e) { [EOL]         return null; [EOL]     } [EOL]     if (versionInfoClass == null) { [EOL]         return null; [EOL]     } [EOL]     Object v; [EOL]     try { [EOL]         v = versionInfoClass.newInstance(); [EOL]     } catch (RuntimeException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Failed to instantiate " + versionInfoClass.getName() + " to find version information, problem: " + e.getMessage(), e); [EOL]     } [EOL]     if (!(v instanceof Versioned)) { [EOL]         throw new IllegalArgumentException("Bad version class " + versionInfoClass.getName() + ": does not implement " + Versioned.class.getName()); [EOL]     } [EOL]     return ((Versioned) v).version(); [EOL] }
public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) { [EOL]     InputStream pomPoperties = classLoader.getResourceAsStream("META-INF/maven/" + groupId.replaceAll("\\.", "/") + "/" + artifactId + "/pom.properties"); [EOL]     if (pomPoperties != null) { [EOL]         try { [EOL]             Properties props = new Properties(); [EOL]             props.load(pomPoperties); [EOL]             String versionStr = props.getProperty("version"); [EOL]             String pomPropertiesArtifactId = props.getProperty("artifactId"); [EOL]             String pomPropertiesGroupId = props.getProperty("groupId"); [EOL]             return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId); [EOL]         } catch (IOException e) { [EOL]         } finally { [EOL]             try { [EOL]                 pomPoperties.close(); [EOL]             } catch (IOException e) { [EOL]             } [EOL]         } [EOL]     } [EOL]     return Version.unknownVersion(); [EOL] }
public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) { [EOL]     InputStream pomPoperties = classLoader.getResourceAsStream("META-INF/maven/" + groupId.replaceAll("\\.", "/") + "/" + artifactId + "/pom.properties"); [EOL]     if (pomPoperties != null) { [EOL]         try { [EOL]             Properties props = new Properties(); [EOL]             props.load(pomPoperties); [EOL]             String versionStr = props.getProperty("version"); [EOL]             String pomPropertiesArtifactId = props.getProperty("artifactId"); [EOL]             String pomPropertiesGroupId = props.getProperty("groupId"); [EOL]             return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId); [EOL]         } catch (IOException e) { [EOL]         } finally { [EOL]             try { [EOL]                 pomPoperties.close(); [EOL]             } catch (IOException e) { [EOL]             } [EOL]         } [EOL]     } [EOL]     return Version.unknownVersion(); [EOL] }
public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) { [EOL]     InputStream pomPoperties = classLoader.getResourceAsStream("META-INF/maven/" + groupId.replaceAll("\\.", "/") + "/" + artifactId + "/pom.properties"); [EOL]     if (pomPoperties != null) { [EOL]         try { [EOL]             Properties props = new Properties(); [EOL]             props.load(pomPoperties); [EOL]             String versionStr = props.getProperty("version"); [EOL]             String pomPropertiesArtifactId = props.getProperty("artifactId"); [EOL]             String pomPropertiesGroupId = props.getProperty("groupId"); [EOL]             return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId); [EOL]         } catch (IOException e) { [EOL]         } finally { [EOL]             try { [EOL]                 pomPoperties.close(); [EOL]             } catch (IOException e) { [EOL]             } [EOL]         } [EOL]     } [EOL]     return Version.unknownVersion(); [EOL] }
public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) { [EOL]     InputStream pomPoperties = classLoader.getResourceAsStream("META-INF/maven/" + groupId.replaceAll("\\.", "/") + "/" + artifactId + "/pom.properties"); [EOL]     if (pomPoperties != null) { [EOL]         try { [EOL]             Properties props = new Properties(); [EOL]             props.load(pomPoperties); [EOL]             String versionStr = props.getProperty("version"); [EOL]             String pomPropertiesArtifactId = props.getProperty("artifactId"); [EOL]             String pomPropertiesGroupId = props.getProperty("groupId"); [EOL]             return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId); [EOL]         } catch (IOException e) { [EOL]         } finally { [EOL]             try { [EOL]                 pomPoperties.close(); [EOL]             } catch (IOException e) { [EOL]             } [EOL]         } [EOL]     } [EOL]     return Version.unknownVersion(); [EOL] }
public static Version parseVersion(String versionStr, String groupId, String artifactId) { [EOL]     if (versionStr == null) { [EOL]         return null; [EOL]     } [EOL]     versionStr = versionStr.trim(); [EOL]     if (versionStr.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     String[] parts = VERSION_SEPARATOR.split(versionStr); [EOL]     int major = parseVersionPart(parts[0]); [EOL]     int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0; [EOL]     int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0; [EOL]     String snapshot = (parts.length > 3) ? parts[3] : null; [EOL]     return new Version(major, minor, patch, snapshot, groupId, artifactId); [EOL] }
public static Version parseVersion(String versionStr, String groupId, String artifactId) { [EOL]     if (versionStr == null) { [EOL]         return null; [EOL]     } [EOL]     versionStr = versionStr.trim(); [EOL]     if (versionStr.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     String[] parts = VERSION_SEPARATOR.split(versionStr); [EOL]     int major = parseVersionPart(parts[0]); [EOL]     int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0; [EOL]     int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0; [EOL]     String snapshot = (parts.length > 3) ? parts[3] : null; [EOL]     return new Version(major, minor, patch, snapshot, groupId, artifactId); [EOL] }
public static Version parseVersion(String versionStr, String groupId, String artifactId) { [EOL]     if (versionStr == null) { [EOL]         return null; [EOL]     } [EOL]     versionStr = versionStr.trim(); [EOL]     if (versionStr.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     String[] parts = VERSION_SEPARATOR.split(versionStr); [EOL]     int major = parseVersionPart(parts[0]); [EOL]     int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0; [EOL]     int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0; [EOL]     String snapshot = (parts.length > 3) ? parts[3] : null; [EOL]     return new Version(major, minor, patch, snapshot, groupId, artifactId); [EOL] }
public static Version parseVersion(String versionStr, String groupId, String artifactId) { [EOL]     if (versionStr == null) { [EOL]         return null; [EOL]     } [EOL]     versionStr = versionStr.trim(); [EOL]     if (versionStr.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     String[] parts = VERSION_SEPARATOR.split(versionStr); [EOL]     int major = parseVersionPart(parts[0]); [EOL]     int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0; [EOL]     int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0; [EOL]     String snapshot = (parts.length > 3) ? parts[3] : null; [EOL]     return new Version(major, minor, patch, snapshot, groupId, artifactId); [EOL] }
public static Version parseVersion(String versionStr, String groupId, String artifactId) { [EOL]     if (versionStr == null) { [EOL]         return null; [EOL]     } [EOL]     versionStr = versionStr.trim(); [EOL]     if (versionStr.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     String[] parts = VERSION_SEPARATOR.split(versionStr); [EOL]     int major = parseVersionPart(parts[0]); [EOL]     int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0; [EOL]     int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0; [EOL]     String snapshot = (parts.length > 3) ? parts[3] : null; [EOL]     return new Version(major, minor, patch, snapshot, groupId, artifactId); [EOL] }
public static Version parseVersion(String versionStr, String groupId, String artifactId) { [EOL]     if (versionStr == null) { [EOL]         return null; [EOL]     } [EOL]     versionStr = versionStr.trim(); [EOL]     if (versionStr.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     String[] parts = VERSION_SEPARATOR.split(versionStr); [EOL]     int major = parseVersionPart(parts[0]); [EOL]     int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0; [EOL]     int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0; [EOL]     String snapshot = (parts.length > 3) ? parts[3] : null; [EOL]     return new Version(major, minor, patch, snapshot, groupId, artifactId); [EOL] }
protected static int parseVersionPart(String partStr) { [EOL]     partStr = partStr.toString(); [EOL]     int len = partStr.length(); [EOL]     int number = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char c = partStr.charAt(i); [EOL]         if (c > '9' || c < '0') [EOL]             break; [EOL]         number = (number * 10) + (c - '0'); [EOL]     } [EOL]     return number; [EOL] }
protected static int parseVersionPart(String partStr) { [EOL]     partStr = partStr.toString(); [EOL]     int len = partStr.length(); [EOL]     int number = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char c = partStr.charAt(i); [EOL]         if (c > '9' || c < '0') [EOL]             break; [EOL]         number = (number * 10) + (c - '0'); [EOL]     } [EOL]     return number; [EOL] }
protected static int parseVersionPart(String partStr) { [EOL]     partStr = partStr.toString(); [EOL]     int len = partStr.length(); [EOL]     int number = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char c = partStr.charAt(i); [EOL]         if (c > '9' || c < '0') [EOL]             break; [EOL]         number = (number * 10) + (c - '0'); [EOL]     } [EOL]     return number; [EOL] }
protected static int parseVersionPart(String partStr) { [EOL]     partStr = partStr.toString(); [EOL]     int len = partStr.length(); [EOL]     int number = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char c = partStr.charAt(i); [EOL]         if (c > '9' || c < '0') [EOL]             break; [EOL]         number = (number * 10) + (c - '0'); [EOL]     } [EOL]     return number; [EOL] }
protected static int parseVersionPart(String partStr) { [EOL]     partStr = partStr.toString(); [EOL]     int len = partStr.length(); [EOL]     int number = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char c = partStr.charAt(i); [EOL]         if (c > '9' || c < '0') [EOL]             break; [EOL]         number = (number * 10) + (c - '0'); [EOL]     } [EOL]     return number; [EOL] }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     if (len <= _outputMaxContiguous) { [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(text, offset, len); [EOL]     } else { [EOL]         _writeStringSegments(text, offset, len); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         byte b; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 b = BYTE_COMMA; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 b = BYTE_COLON; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL]                     if (raw.length > 0) { [EOL]                         _writeBytes(raw); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = b; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void flush() throws IOException { [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in) { [EOL]     _context = ctxt; [EOL]     _in = in; [EOL]     _inputBuffer = ctxt.allocReadIOBuffer(); [EOL]     _inputEnd = _inputPtr = 0; [EOL]     _inputProcessed = 0; [EOL]     _bufferRecyclable = true; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
@SuppressWarnings("resource") [EOL] public Reader constructReader() throws IOException { [EOL]     JsonEncoding enc = _context.getEncoding(); [EOL]     switch(enc) { [EOL]         case UTF32_BE: [EOL]         case UTF32_LE: [EOL]             return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian()); [EOL]         case UTF16_BE: [EOL]         case UTF16_LE: [EOL]         case UTF8: [EOL]             { [EOL]                 InputStream in = _in; [EOL]                 if (in == null) { [EOL]                     in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd); [EOL]                 } else { [EOL]                     if (_inputPtr < _inputEnd) { [EOL]                         in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd); [EOL]                     } [EOL]                 } [EOL]                 return new InputStreamReader(in, enc.getJavaName()); [EOL]             } [EOL]     } [EOL]     throw new RuntimeException("Internal error"); [EOL] }
public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException { [EOL]     JsonEncoding enc = detectEncoding(); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (canonicalize) { [EOL]             BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern); [EOL]             return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable); [EOL]         } [EOL]     } [EOL]     return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec, rootCharSymbols.makeChild(canonicalize, intern)); [EOL] }
public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException { [EOL]     JsonEncoding enc = detectEncoding(); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (canonicalize) { [EOL]             BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern); [EOL]             return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable); [EOL]         } [EOL]     } [EOL]     return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec, rootCharSymbols.makeChild(canonicalize, intern)); [EOL] }
public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException { [EOL]     JsonEncoding enc = detectEncoding(); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (canonicalize) { [EOL]             BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern); [EOL]             return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable); [EOL]         } [EOL]     } [EOL]     return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec, rootCharSymbols.makeChild(canonicalize, intern)); [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean checkUTF32(int quad) throws IOException { [EOL]     if ((quad >> 8) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((quad & 0x00FFFFFF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else if ((quad & ~0x00FF0000) == 0) { [EOL]         reportWeirdUCS4("3412"); [EOL]     } else if ((quad & ~0x0000FF00) == 0) { [EOL]         reportWeirdUCS4("2143"); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 4; [EOL]     return true; [EOL] }
private boolean checkUTF32(int quad) throws IOException { [EOL]     if ((quad >> 8) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((quad & 0x00FFFFFF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else if ((quad & ~0x00FF0000) == 0) { [EOL]         reportWeirdUCS4("3412"); [EOL]     } else if ((quad & ~0x0000FF00) == 0) { [EOL]         reportWeirdUCS4("2143"); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 4; [EOL]     return true; [EOL] }
private boolean checkUTF32(int quad) throws IOException { [EOL]     if ((quad >> 8) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((quad & 0x00FFFFFF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else if ((quad & ~0x00FF0000) == 0) { [EOL]         reportWeirdUCS4("3412"); [EOL]     } else if ((quad & ~0x0000FF00) == 0) { [EOL]         reportWeirdUCS4("2143"); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 4; [EOL]     return true; [EOL] }
private boolean checkUTF32(int quad) throws IOException { [EOL]     if ((quad >> 8) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((quad & 0x00FFFFFF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else if ((quad & ~0x00FF0000) == 0) { [EOL]         reportWeirdUCS4("3412"); [EOL]     } else if ((quad & ~0x0000FF00) == 0) { [EOL]         reportWeirdUCS4("2143"); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 4; [EOL]     return true; [EOL] }
private boolean checkUTF32(int quad) throws IOException { [EOL]     if ((quad >> 8) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((quad & 0x00FFFFFF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else if ((quad & ~0x00FF0000) == 0) { [EOL]         reportWeirdUCS4("3412"); [EOL]     } else if ((quad & ~0x0000FF00) == 0) { [EOL]         reportWeirdUCS4("2143"); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 4; [EOL]     return true; [EOL] }
private boolean checkUTF16(int i16) { [EOL]     if ((i16 & 0xFF00) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((i16 & 0x00FF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 2; [EOL]     return true; [EOL] }
private boolean checkUTF16(int i16) { [EOL]     if ((i16 & 0xFF00) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((i16 & 0x00FF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 2; [EOL]     return true; [EOL] }
private boolean checkUTF16(int i16) { [EOL]     if ((i16 & 0xFF00) == 0) { [EOL]         _bigEndian = true; [EOL]     } else if ((i16 & 0x00FF) == 0) { [EOL]         _bigEndian = false; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     _bytesPerChar = 2; [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
public DefaultPrettyPrinter() { [EOL]     this(DEFAULT_ROOT_VALUE_SEPARATOR); [EOL] }
public DefaultPrettyPrinter(String rootSeparator) { [EOL]     this((rootSeparator == null) ? null : new SerializedString(rootSeparator)); [EOL] }
public DefaultPrettyPrinter(String rootSeparator) { [EOL]     this((rootSeparator == null) ? null : new SerializedString(rootSeparator)); [EOL] }
public DefaultPrettyPrinter(SerializableString rootSeparator) { [EOL]     _rootSeparator = rootSeparator; [EOL] }
public DefaultPrettyPrinter(SerializableString rootSeparator) { [EOL]     _rootSeparator = rootSeparator; [EOL] }
@Override [EOL] public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     if (_rootSeparator != null) { [EOL]         jg.writeRaw(_rootSeparator); [EOL]     } [EOL] }
@Override [EOL] public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     if (_rootSeparator != null) { [EOL]         jg.writeRaw(_rootSeparator); [EOL]     } [EOL] }
@Override [EOL] public void writeStartObject(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw('{'); [EOL]     if (!_objectIndenter.isInline()) { [EOL]         ++_nesting; [EOL]     } [EOL] }
@Override [EOL] public void writeStartObject(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw('{'); [EOL]     if (!_objectIndenter.isInline()) { [EOL]         ++_nesting; [EOL]     } [EOL] }
@Override [EOL] public void beforeObjectEntries(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     _objectIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void beforeObjectEntries(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     _objectIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     if (_spacesInObjectEntries) { [EOL]         jg.writeRaw(" : "); [EOL]     } else { [EOL]         jg.writeRaw(':'); [EOL]     } [EOL] }
@Override [EOL] public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     if (_spacesInObjectEntries) { [EOL]         jg.writeRaw(" : "); [EOL]     } else { [EOL]         jg.writeRaw(':'); [EOL]     } [EOL] }
@Override [EOL] public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(','); [EOL]     _objectIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(','); [EOL]     _objectIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { [EOL]     if (!_objectIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfEntries > 0) { [EOL]         _objectIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw('}'); [EOL] }
@Override [EOL] public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { [EOL]     if (!_objectIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfEntries > 0) { [EOL]         _objectIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw('}'); [EOL] }
@Override [EOL] public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { [EOL]     if (!_objectIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfEntries > 0) { [EOL]         _objectIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw('}'); [EOL] }
@Override [EOL] public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { [EOL]     if (!_objectIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfEntries > 0) { [EOL]         _objectIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw('}'); [EOL] }
@Override [EOL] public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         ++_nesting; [EOL]     } [EOL]     jg.writeRaw('['); [EOL] }
@Override [EOL] public void writeStartArray(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         ++_nesting; [EOL]     } [EOL]     jg.writeRaw('['); [EOL] }
@Override [EOL] public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     _arrayIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     _arrayIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void writeArrayValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(','); [EOL]     _arrayIndenter.writeIndentation(jg, _nesting); [EOL] }
@Override [EOL] public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfValues > 0) { [EOL]         _arrayIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw(']'); [EOL] }
@Override [EOL] public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfValues > 0) { [EOL]         _arrayIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw(']'); [EOL] }
@Override [EOL] public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfValues > 0) { [EOL]         _arrayIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw(']'); [EOL] }
@Override [EOL] public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { [EOL]     if (!_arrayIndenter.isInline()) { [EOL]         --_nesting; [EOL]     } [EOL]     if (nrOfValues > 0) { [EOL]         _arrayIndenter.writeIndentation(jg, _nesting); [EOL]     } else { [EOL]         jg.writeRaw(' '); [EOL]     } [EOL]     jg.writeRaw(']'); [EOL] }
@Override [EOL] public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(' '); [EOL] }
@Override [EOL] public boolean isInline() { [EOL]     return true; [EOL] }
public Lf2SpacesIndenter() { [EOL]     this(SYS_LF); [EOL] }
public Lf2SpacesIndenter(String lf) { [EOL]     _lf = lf; [EOL] }
public Lf2SpacesIndenter(String lf) { [EOL]     _lf = lf; [EOL] }
public Lf2SpacesIndenter(String lf) { [EOL]     _lf = lf; [EOL] }
@Override [EOL] public boolean isInline() { [EOL]     return false; [EOL] }
@Override [EOL] public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(_lf); [EOL]     if (level > 0) { [EOL]         level += level; [EOL]         while (level > SPACE_COUNT) { [EOL]             jg.writeRaw(SPACES, 0, SPACE_COUNT); [EOL]             level -= SPACES.length; [EOL]         } [EOL]         jg.writeRaw(SPACES, 0, level); [EOL]     } [EOL] }
@Override [EOL] public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(_lf); [EOL]     if (level > 0) { [EOL]         level += level; [EOL]         while (level > SPACE_COUNT) { [EOL]             jg.writeRaw(SPACES, 0, SPACE_COUNT); [EOL]             level -= SPACES.length; [EOL]         } [EOL]         jg.writeRaw(SPACES, 0, level); [EOL]     } [EOL] }
@Override [EOL] public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(_lf); [EOL]     if (level > 0) { [EOL]         level += level; [EOL]         while (level > SPACE_COUNT) { [EOL]             jg.writeRaw(SPACES, 0, SPACE_COUNT); [EOL]             level -= SPACES.length; [EOL]         } [EOL]         jg.writeRaw(SPACES, 0, level); [EOL]     } [EOL] }
@Override [EOL] public void writeIndentation(JsonGenerator jg, int level) throws IOException, JsonGenerationException { [EOL]     jg.writeRaw(_lf); [EOL]     if (level > 0) { [EOL]         level += level; [EOL]         while (level > SPACE_COUNT) { [EOL]             jg.writeRaw(SPACES, 0, SPACE_COUNT); [EOL]             level -= SPACES.length; [EOL]         } [EOL]         jg.writeRaw(SPACES, 0, level); [EOL]     } [EOL] }
public String getJavaName() { [EOL]     return _javaName; [EOL] }
public boolean isBigEndian() { [EOL]     return _bigEndian; [EOL] }
public boolean isBigEndian() { [EOL]     return _bigEndian; [EOL] }
public PrettyPrinter getPrettyPrinter() { [EOL]     return _cfgPrettyPrinter; [EOL] }
public PrettyPrinter getPrettyPrinter() { [EOL]     return _cfgPrettyPrinter; [EOL] }
public final void writeBooleanField(String fieldName, boolean value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeBoolean(value); [EOL] }
public final void writeBooleanField(String fieldName, boolean value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeBoolean(value); [EOL] }
public final void writeNullField(String fieldName) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNull(); [EOL] }
public final void writeNullField(String fieldName) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNull(); [EOL] }
public final void writeNumberField(String fieldName, int value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, int value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, int value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, BigDecimal value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, BigDecimal value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, BigDecimal value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeArrayFieldStart(String fieldName) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeStartArray(); [EOL] }
public final void writeArrayFieldStart(String fieldName) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeStartArray(); [EOL] }
public final void writeObjectFieldStart(String fieldName) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeStartObject(); [EOL] }
public final void writeObjectFieldStart(String fieldName) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeStartObject(); [EOL] }
public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] }
public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] }
public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]     } [EOL]     int intLen = 0; [EOL]     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL]     if (c == '0') { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     boolean eof = false; [EOL]     int_loop: while (c >= '0' && c <= '9') { [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             c = CHAR_NULL; [EOL]             eof = true; [EOL]             break int_loop; [EOL]         } [EOL]         c = _inputBuffer[_inputPtr++]; [EOL]     } [EOL]     if (intLen == 0) { [EOL]         reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL]     } [EOL]     int fractLen = 0; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return reset(negative, intLen, fractLen, expLen); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
public JsonGenerationException(String msg) { [EOL]     super(msg, (JsonLocation) null); [EOL] }
protected Name(String name, int hashCode) { [EOL]     _name = name; [EOL]     _hashCode = hashCode; [EOL] }
public String getName() { [EOL]     return _name; [EOL] }
public String getName() { [EOL]     return _name; [EOL] }
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an object"); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartObject(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '{'; [EOL]     } [EOL] }
@Override [EOL] public void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an object"); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartObject(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '{'; [EOL]     } [EOL] }
@Override [EOL] public void writeEndObject() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inObject()) { [EOL]         _reportError("Current context not an object but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '}'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeEndObject() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inObject()) { [EOL]         _reportError("Current context not an object but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '}'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]         _writeString(name); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         _writeString(name); [EOL]     } [EOL] }
protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]         _writeString(name); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         _writeString(name); [EOL]     } [EOL] }
protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]         _writeString(name); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         _writeString(name); [EOL]     } [EOL] }
protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]         _writeString(name); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         _writeString(name); [EOL]     } [EOL] }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(text, offset, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { [EOL]     writeRaw(text.getValue()); [EOL] }
@Override [EOL] public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (len < SHORT_WRITE) { [EOL]         int room = _outputEnd - _outputTail; [EOL]         if (len > room) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         System.arraycopy(text, offset, _outputBuffer, _outputTail, len); [EOL]         _outputTail += len; [EOL]         return; [EOL]     } [EOL]     _flushBuffer(); [EOL]     _writer.write(text, offset, len); [EOL] }
@Override [EOL] public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (len < SHORT_WRITE) { [EOL]         int room = _outputEnd - _outputTail; [EOL]         if (len > room) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         System.arraycopy(text, offset, _outputBuffer, _outputTail, len); [EOL]         _outputTail += len; [EOL]         return; [EOL]     } [EOL]     _flushBuffer(); [EOL]     _writer.write(text, offset, len); [EOL] }
@Override [EOL] public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (len < SHORT_WRITE) { [EOL]         int room = _outputEnd - _outputTail; [EOL]         if (len > room) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         System.arraycopy(text, offset, _outputBuffer, _outputTail, len); [EOL]         _outputTail += len; [EOL]         return; [EOL]     } [EOL]     _flushBuffer(); [EOL]     _writer.write(text, offset, len); [EOL] }
@Override [EOL] public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (len < SHORT_WRITE) { [EOL]         int room = _outputEnd - _outputTail; [EOL]         if (len > room) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         System.arraycopy(text, offset, _outputBuffer, _outputTail, len); [EOL]         _outputTail += len; [EOL]         return; [EOL]     } [EOL]     _flushBuffer(); [EOL]     _writer.write(text, offset, len); [EOL] }
@Override [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedShort(s); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 6) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedShort(s); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 6) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedShort(s); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 6) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write boolean value"); [EOL]     if ((_outputTail + 5) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     if (state) { [EOL]         buf[ptr] = 't'; [EOL]         buf[++ptr] = 'r'; [EOL]         buf[++ptr] = 'u'; [EOL]         buf[++ptr] = 'e'; [EOL]     } else { [EOL]         buf[ptr] = 'f'; [EOL]         buf[++ptr] = 'a'; [EOL]         buf[++ptr] = 'l'; [EOL]         buf[++ptr] = 's'; [EOL]         buf[++ptr] = 'e'; [EOL]     } [EOL]     _outputTail = ptr + 1; [EOL] }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write boolean value"); [EOL]     if ((_outputTail + 5) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     if (state) { [EOL]         buf[ptr] = 't'; [EOL]         buf[++ptr] = 'r'; [EOL]         buf[++ptr] = 'u'; [EOL]         buf[++ptr] = 'e'; [EOL]     } else { [EOL]         buf[ptr] = 'f'; [EOL]         buf[++ptr] = 'a'; [EOL]         buf[++ptr] = 'l'; [EOL]         buf[++ptr] = 's'; [EOL]         buf[++ptr] = 'e'; [EOL]     } [EOL]     _outputTail = ptr + 1; [EOL] }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write boolean value"); [EOL]     if ((_outputTail + 5) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     if (state) { [EOL]         buf[ptr] = 't'; [EOL]         buf[++ptr] = 'r'; [EOL]         buf[++ptr] = 'u'; [EOL]         buf[++ptr] = 'e'; [EOL]     } else { [EOL]         buf[ptr] = 'f'; [EOL]         buf[++ptr] = 'a'; [EOL]         buf[++ptr] = 'l'; [EOL]         buf[++ptr] = 's'; [EOL]         buf[++ptr] = 'e'; [EOL]     } [EOL]     _outputTail = ptr + 1; [EOL] }
@Override [EOL] public void writeNull() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write null value"); [EOL]     _writeNull(); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
@Override [EOL] public void flush() throws IOException { [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void flush() throws IOException { [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void flush() throws IOException { [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] }
private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] }
private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] }
private void _writeStringCustom(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break escape_loop; [EOL]                 } [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] }
private void _writeStringCustom(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break escape_loop; [EOL]                 } [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] }
private void _writeStringCustom(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break escape_loop; [EOL]                 } [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] }
private void _writeNull() throws IOException { [EOL]     if ((_outputTail + 4) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     buf[ptr] = 'n'; [EOL]     buf[++ptr] = 'u'; [EOL]     buf[++ptr] = 'l'; [EOL]     buf[++ptr] = 'l'; [EOL]     _outputTail = ptr + 1; [EOL] }
private void _writeNull() throws IOException { [EOL]     if ((_outputTail + 4) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     buf[ptr] = 'n'; [EOL]     buf[++ptr] = 'u'; [EOL]     buf[++ptr] = 'l'; [EOL]     buf[++ptr] = 'l'; [EOL]     _outputTail = ptr + 1; [EOL] }
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] }
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] }
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] }
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] }
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] }
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] }
public static void appendQuoted(StringBuilder sb, String content) { [EOL]     final int[] escCodes = sOutputEscapes128; [EOL]     int escLen = escCodes.length; [EOL]     for (int i = 0, len = content.length(); i < len; ++i) { [EOL]         char c = content.charAt(i); [EOL]         if (c >= escLen || escCodes[c] == 0) { [EOL]             sb.append(c); [EOL]             continue; [EOL]         } [EOL]         sb.append('\\'); [EOL]         int escCode = escCodes[c]; [EOL]         if (escCode < 0) { [EOL]             sb.append('u'); [EOL]             sb.append('0'); [EOL]             sb.append('0'); [EOL]             int value = c; [EOL]             sb.append(HEX_CHARS[value >> 4]); [EOL]             sb.append(HEX_CHARS[value & 0xF]); [EOL]         } else { [EOL]             sb.append((char) escCode); [EOL]         } [EOL]     } [EOL] }
public static void appendQuoted(StringBuilder sb, String content) { [EOL]     final int[] escCodes = sOutputEscapes128; [EOL]     int escLen = escCodes.length; [EOL]     for (int i = 0, len = content.length(); i < len; ++i) { [EOL]         char c = content.charAt(i); [EOL]         if (c >= escLen || escCodes[c] == 0) { [EOL]             sb.append(c); [EOL]             continue; [EOL]         } [EOL]         sb.append('\\'); [EOL]         int escCode = escCodes[c]; [EOL]         if (escCode < 0) { [EOL]             sb.append('u'); [EOL]             sb.append('0'); [EOL]             sb.append('0'); [EOL]             int value = c; [EOL]             sb.append(HEX_CHARS[value >> 4]); [EOL]             sb.append(HEX_CHARS[value & 0xF]); [EOL]         } else { [EOL]             sb.append((char) escCode); [EOL]         } [EOL]     } [EOL] }
public static char[] copyHexChars() { [EOL]     return (char[]) HEX_CHARS.clone(); [EOL] }
public static byte[] copyHexBytes() { [EOL]     return (byte[]) HEX_BYTES.clone(); [EOL] }
public static JsonStringEncoder getInstance() { [EOL]     SoftReference<JsonStringEncoder> ref = _threadEncoder.get(); [EOL]     JsonStringEncoder enc = (ref == null) ? null : ref.get(); [EOL]     if (enc == null) { [EOL]         enc = new JsonStringEncoder(); [EOL]         _threadEncoder.set(new SoftReference<JsonStringEncoder>(enc)); [EOL]     } [EOL]     return enc; [EOL] }
public static JsonStringEncoder getInstance() { [EOL]     SoftReference<JsonStringEncoder> ref = _threadEncoder.get(); [EOL]     JsonStringEncoder enc = (ref == null) ? null : ref.get(); [EOL]     if (enc == null) { [EOL]         enc = new JsonStringEncoder(); [EOL]         _threadEncoder.set(new SoftReference<JsonStringEncoder>(enc)); [EOL]     } [EOL]     return enc; [EOL] }
private int _appendNumericEscape(int value, char[] quoteBuffer) { [EOL]     quoteBuffer[1] = 'u'; [EOL]     quoteBuffer[4] = HEX_CHARS[value >> 4]; [EOL]     quoteBuffer[5] = HEX_CHARS[value & 0xF]; [EOL]     return 6; [EOL] }
private int _appendNumericEscape(int value, char[] quoteBuffer) { [EOL]     quoteBuffer[1] = 'u'; [EOL]     quoteBuffer[4] = HEX_CHARS[value >> 4]; [EOL]     quoteBuffer[5] = HEX_CHARS[value & 0xF]; [EOL]     return 6; [EOL] }
protected final void _reportError(String msg) throws JsonParseException { [EOL]     throw _constructError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
public final JsonWriteContext createChildArrayContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_ARRAY); [EOL] }
public final JsonWriteContext createChildArrayContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_ARRAY); [EOL] }
public final JsonWriteContext createChildObjectContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_OBJECT); [EOL] }
public final JsonWriteContext createChildObjectContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_OBJECT); [EOL] }
public MergedStream(IOContext context, InputStream in, byte[] buf, int start, int end) { [EOL]     _context = context; [EOL]     _in = in; [EOL]     _buffer = buf; [EOL]     _ptr = start; [EOL]     _end = end; [EOL] }
@Override [EOL] public int available() throws IOException { [EOL]     if (_buffer != null) { [EOL]         return _end - _ptr; [EOL]     } [EOL]     return _in.available(); [EOL] }
@Override [EOL] public int available() throws IOException { [EOL]     if (_buffer != null) { [EOL]         return _end - _ptr; [EOL]     } [EOL]     return _in.available(); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     freeMergedBuffer(); [EOL]     _in.close(); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     freeMergedBuffer(); [EOL]     _in.close(); [EOL] }
@Override [EOL] public void mark(int readlimit) { [EOL]     if (_buffer == null) { [EOL]         _in.mark(readlimit); [EOL]     } [EOL] }
@Override [EOL] public void mark(int readlimit) { [EOL]     if (_buffer == null) { [EOL]         _in.mark(readlimit); [EOL]     } [EOL] }
@Override [EOL] public boolean markSupported() { [EOL]     return (_buffer == null) && _in.markSupported(); [EOL] }
@Override [EOL] public boolean markSupported() { [EOL]     return (_buffer == null) && _in.markSupported(); [EOL] }
@Override [EOL] public int read() throws IOException { [EOL]     if (_buffer != null) { [EOL]         int c = _buffer[_ptr++] & 0xFF; [EOL]         if (_ptr >= _end) { [EOL]             freeMergedBuffer(); [EOL]         } [EOL]         return c; [EOL]     } [EOL]     return _in.read(); [EOL] }
@Override [EOL] public int read() throws IOException { [EOL]     if (_buffer != null) { [EOL]         int c = _buffer[_ptr++] & 0xFF; [EOL]         if (_ptr >= _end) { [EOL]             freeMergedBuffer(); [EOL]         } [EOL]         return c; [EOL]     } [EOL]     return _in.read(); [EOL] }
@Override [EOL] public int read() throws IOException { [EOL]     if (_buffer != null) { [EOL]         int c = _buffer[_ptr++] & 0xFF; [EOL]         if (_ptr >= _end) { [EOL]             freeMergedBuffer(); [EOL]         } [EOL]         return c; [EOL]     } [EOL]     return _in.read(); [EOL] }
@Override [EOL] public int read(byte[] b, int off, int len) throws IOException { [EOL]     if (_buffer != null) { [EOL]         int avail = _end - _ptr; [EOL]         if (len > avail) { [EOL]             len = avail; [EOL]         } [EOL]         System.arraycopy(_buffer, _ptr, b, off, len); [EOL]         _ptr += len; [EOL]         if (_ptr >= _end) { [EOL]             freeMergedBuffer(); [EOL]         } [EOL]         return len; [EOL]     } [EOL]     return _in.read(b, off, len); [EOL] }
@Override [EOL] public int read(byte[] b, int off, int len) throws IOException { [EOL]     if (_buffer != null) { [EOL]         int avail = _end - _ptr; [EOL]         if (len > avail) { [EOL]             len = avail; [EOL]         } [EOL]         System.arraycopy(_buffer, _ptr, b, off, len); [EOL]         _ptr += len; [EOL]         if (_ptr >= _end) { [EOL]             freeMergedBuffer(); [EOL]         } [EOL]         return len; [EOL]     } [EOL]     return _in.read(b, off, len); [EOL] }
@Override [EOL] public int read(byte[] b, int off, int len) throws IOException { [EOL]     if (_buffer != null) { [EOL]         int avail = _end - _ptr; [EOL]         if (len > avail) { [EOL]             len = avail; [EOL]         } [EOL]         System.arraycopy(_buffer, _ptr, b, off, len); [EOL]         _ptr += len; [EOL]         if (_ptr >= _end) { [EOL]             freeMergedBuffer(); [EOL]         } [EOL]         return len; [EOL]     } [EOL]     return _in.read(b, off, len); [EOL] }
@Override [EOL] public long skip(long n) throws IOException { [EOL]     long count = 0L; [EOL]     if (_buffer != null) { [EOL]         int amount = _end - _ptr; [EOL]         if (amount > n) { [EOL]             _ptr += (int) n; [EOL]             return n; [EOL]         } [EOL]         freeMergedBuffer(); [EOL]         count += amount; [EOL]         n -= amount; [EOL]     } [EOL]     if (n > 0) { [EOL]         count += _in.skip(n); [EOL]     } [EOL]     return count; [EOL] }
@Override [EOL] public long skip(long n) throws IOException { [EOL]     long count = 0L; [EOL]     if (_buffer != null) { [EOL]         int amount = _end - _ptr; [EOL]         if (amount > n) { [EOL]             _ptr += (int) n; [EOL]             return n; [EOL]         } [EOL]         freeMergedBuffer(); [EOL]         count += amount; [EOL]         n -= amount; [EOL]     } [EOL]     if (n > 0) { [EOL]         count += _in.skip(n); [EOL]     } [EOL]     return count; [EOL] }
@Override [EOL] public long skip(long n) throws IOException { [EOL]     long count = 0L; [EOL]     if (_buffer != null) { [EOL]         int amount = _end - _ptr; [EOL]         if (amount > n) { [EOL]             _ptr += (int) n; [EOL]             return n; [EOL]         } [EOL]         freeMergedBuffer(); [EOL]         count += amount; [EOL]         n -= amount; [EOL]     } [EOL]     if (n > 0) { [EOL]         count += _in.skip(n); [EOL]     } [EOL]     return count; [EOL] }
@Override [EOL] public long skip(long n) throws IOException { [EOL]     long count = 0L; [EOL]     if (_buffer != null) { [EOL]         int amount = _end - _ptr; [EOL]         if (amount > n) { [EOL]             _ptr += (int) n; [EOL]             return n; [EOL]         } [EOL]         freeMergedBuffer(); [EOL]         count += amount; [EOL]         n -= amount; [EOL]     } [EOL]     if (n > 0) { [EOL]         count += _in.skip(n); [EOL]     } [EOL]     return count; [EOL] }
private void freeMergedBuffer() { [EOL]     byte[] buf = _buffer; [EOL]     if (buf != null) { [EOL]         _buffer = null; [EOL]         if (_context != null) { [EOL]             _context.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] }
private void freeMergedBuffer() { [EOL]     byte[] buf = _buffer; [EOL]     if (buf != null) { [EOL]         _buffer = null; [EOL]         if (_context != null) { [EOL]             _context.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] }
private void freeMergedBuffer() { [EOL]     byte[] buf = _buffer; [EOL]     if (buf != null) { [EOL]         _buffer = null; [EOL]         if (_context != null) { [EOL]             _context.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     InputStream in = _in; [EOL]     if (in != null) { [EOL]         _in = null; [EOL]         freeBuffers(); [EOL]         in.close(); [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     InputStream in = _in; [EOL]     if (in != null) { [EOL]         _in = null; [EOL]         freeBuffers(); [EOL]         in.close(); [EOL]     } [EOL] }
public final void freeBuffers() { [EOL]     byte[] buf = _buffer; [EOL]     if (buf != null) { [EOL]         _buffer = null; [EOL]         _context.releaseReadIOBuffer(buf); [EOL]     } [EOL] }
public final void freeBuffers() { [EOL]     byte[] buf = _buffer; [EOL]     if (buf != null) { [EOL]         _buffer = null; [EOL]         _context.releaseReadIOBuffer(buf); [EOL]     } [EOL] }
public JsonFactory() { [EOL]     this((ObjectCodec) null); [EOL] }
public JsonFactory(ObjectCodec oc) { [EOL]     _objectCodec = oc; [EOL] }
public JsonFactory(ObjectCodec oc) { [EOL]     _objectCodec = oc; [EOL] }
protected JsonFactory(JsonFactory src, ObjectCodec codec) { [EOL]     _objectCodec = null; [EOL]     _factoryFeatures = src._factoryFeatures; [EOL]     _parserFeatures = src._parserFeatures; [EOL]     _generatorFeatures = src._generatorFeatures; [EOL]     _characterEscapes = src._characterEscapes; [EOL]     _inputDecorator = src._inputDecorator; [EOL]     _outputDecorator = src._outputDecorator; [EOL]     _rootValueSeparator = src._rootValueSeparator; [EOL] }
protected Object readResolve() { [EOL]     return new JsonFactory(this, _objectCodec); [EOL] }
public final boolean isEnabled(JsonFactory.Feature f) { [EOL]     return (_factoryFeatures & f.getMask()) != 0; [EOL] }
public final boolean isEnabled(JsonFactory.Feature f) { [EOL]     return (_factoryFeatures & f.getMask()) != 0; [EOL] }
public JsonParser createParser(String content) throws IOException, JsonParseException { [EOL]     Reader r = new StringReader(content); [EOL]     IOContext ctxt = _createContext(r, true); [EOL]     if (_inputDecorator != null) { [EOL]         r = _inputDecorator.decorate(ctxt, r); [EOL]     } [EOL]     return _createParser(r, ctxt); [EOL] }
public JsonParser createParser(String content) throws IOException, JsonParseException { [EOL]     Reader r = new StringReader(content); [EOL]     IOContext ctxt = _createContext(r, true); [EOL]     if (_inputDecorator != null) { [EOL]         r = _inputDecorator.decorate(ctxt, r); [EOL]     } [EOL]     return _createParser(r, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     ctxt.setEncoding(enc); [EOL]     if (enc == JsonEncoding.UTF8) { [EOL]         if (_outputDecorator != null) { [EOL]             out = _outputDecorator.decorate(ctxt, out); [EOL]         } [EOL]         return _createUTF8Generator(out, ctxt); [EOL]     } [EOL]     Writer w = _createWriter(out, enc, ctxt); [EOL]     if (_outputDecorator != null) { [EOL]         w = _outputDecorator.decorate(ctxt, w); [EOL]     } [EOL]     return _createGenerator(w, ctxt); [EOL] }
public JsonGenerator createGenerator(OutputStream out) throws IOException { [EOL]     return createGenerator(out, JsonEncoding.UTF8); [EOL] }
public JsonGenerator createGenerator(OutputStream out) throws IOException { [EOL]     return createGenerator(out, JsonEncoding.UTF8); [EOL] }
public JsonGenerator createGenerator(Writer out) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     if (_outputDecorator != null) { [EOL]         out = _outputDecorator.decorate(ctxt, out); [EOL]     } [EOL]     return _createGenerator(out, ctxt); [EOL] }
public JsonGenerator createGenerator(Writer out) throws IOException { [EOL]     IOContext ctxt = _createContext(out, false); [EOL]     if (_outputDecorator != null) { [EOL]         out = _outputDecorator.decorate(ctxt, out); [EOL]     } [EOL]     return _createGenerator(out, ctxt); [EOL] }
protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec, _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES))); [EOL] }
protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException { [EOL]     WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out); [EOL]     if (_characterEscapes != null) { [EOL]         gen.setCharacterEscapes(_characterEscapes); [EOL]     } [EOL]     SerializableString rootSep = _rootValueSeparator; [EOL]     if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) { [EOL]         gen.setRootValueSeparator(rootSep); [EOL]     } [EOL]     return gen; [EOL] }
protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException { [EOL]     WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out); [EOL]     if (_characterEscapes != null) { [EOL]         gen.setCharacterEscapes(_characterEscapes); [EOL]     } [EOL]     SerializableString rootSep = _rootValueSeparator; [EOL]     if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) { [EOL]         gen.setRootValueSeparator(rootSep); [EOL]     } [EOL]     return gen; [EOL] }
protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException { [EOL]     WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out); [EOL]     if (_characterEscapes != null) { [EOL]         gen.setCharacterEscapes(_characterEscapes); [EOL]     } [EOL]     SerializableString rootSep = _rootValueSeparator; [EOL]     if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) { [EOL]         gen.setRootValueSeparator(rootSep); [EOL]     } [EOL]     return gen; [EOL] }
protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException { [EOL]     UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out); [EOL]     if (_characterEscapes != null) { [EOL]         gen.setCharacterEscapes(_characterEscapes); [EOL]     } [EOL]     SerializableString rootSep = _rootValueSeparator; [EOL]     if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) { [EOL]         gen.setRootValueSeparator(rootSep); [EOL]     } [EOL]     return gen; [EOL] }
protected IOContext _createContext(Object srcRef, boolean resourceManaged) { [EOL]     return new IOContext(_getBufferRecycler(), srcRef, resourceManaged); [EOL] }
protected IOContext _createContext(Object srcRef, boolean resourceManaged) { [EOL]     return new IOContext(_getBufferRecycler(), srcRef, resourceManaged); [EOL] }
public BufferRecycler _getBufferRecycler() { [EOL]     SoftReference<BufferRecycler> ref = _recyclerRef.get(); [EOL]     BufferRecycler br = (ref == null) ? null : ref.get(); [EOL]     if (br == null) { [EOL]         br = new BufferRecycler(); [EOL]         _recyclerRef.set(new SoftReference<BufferRecycler>(br)); [EOL]     } [EOL]     return br; [EOL] }
public BufferRecycler _getBufferRecycler() { [EOL]     SoftReference<BufferRecycler> ref = _recyclerRef.get(); [EOL]     BufferRecycler br = (ref == null) ? null : ref.get(); [EOL]     if (br == null) { [EOL]         br = new BufferRecycler(); [EOL]         _recyclerRef.set(new SoftReference<BufferRecycler>(br)); [EOL]     } [EOL]     return br; [EOL] }
