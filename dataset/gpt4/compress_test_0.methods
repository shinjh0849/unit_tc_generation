public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException { [EOL]     out = new GZIPOutputStream(outputStream); [EOL] }
public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException { [EOL]     out = new GZIPOutputStream(outputStream); [EOL] }
public void write(int b) throws IOException { [EOL]     out.write(b); [EOL] }
public void close() throws IOException { [EOL]     out.close(); [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException cnfe) { [EOL]         throw new RuntimeException(cnfe); [EOL]     } [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException cnfe) { [EOL]         throw new RuntimeException(cnfe); [EOL]     } [EOL] }
public ZipShort(int value) { [EOL]     this.value = value; [EOL] }
public byte[] getBytes() { [EOL]     byte[] result = new byte[2]; [EOL]     result[0] = (byte) (value & BYTE_MASK); [EOL]     result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [EOL]     return result; [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] }
public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void close() throws IOException { [EOL]     archive.close(); [EOL] }
public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] }
public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] }
public Enumeration getEntries() { [EOL]     return Collections.enumeration(entries.keySet()); [EOL] }
public Enumeration getEntries() { [EOL]     return Collections.enumeration(entries.keySet()); [EOL] }
private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] }
private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] }
private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] }
protected AbstractUnicodeExtraField() { [EOL] }
protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] }
protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] }
protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] }
private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] }
private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] }
public long getNameCRC32() { [EOL]     return nameCRC32; [EOL] }
public byte[] getUnicodeName() { [EOL]     return unicodeName; [EOL] }
public byte[] getCentralDirectoryData() { [EOL]     if (data == null) { [EOL]         this.assembleData(); [EOL]     } [EOL]     return data; [EOL] }
public byte[] getCentralDirectoryData() { [EOL]     if (data == null) { [EOL]         this.assembleData(); [EOL]     } [EOL]     return data; [EOL] }
public ZipShort getCentralDirectoryLength() { [EOL]     if (data == null) { [EOL]         assembleData(); [EOL]     } [EOL]     return new ZipShort(data.length); [EOL] }
public ZipShort getCentralDirectoryLength() { [EOL]     if (data == null) { [EOL]         assembleData(); [EOL]     } [EOL]     return new ZipShort(data.length); [EOL] }
public byte[] getLocalFileDataData() { [EOL]     return getCentralDirectoryData(); [EOL] }
public ZipShort getLocalFileDataLength() { [EOL]     return getCentralDirectoryLength(); [EOL] }
public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] }
public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] }
public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] }
public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     parseFromLocalFileData(buffer, offset, length); [EOL] }
public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     parseFromLocalFileData(buffer, offset, length); [EOL] }
public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] }
public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] }
public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] }
public FallbackZipEncoding(String charset) { [EOL]     this.charset = charset; [EOL] }
public FallbackZipEncoding(String charset) { [EOL]     this.charset = charset; [EOL] }
public FallbackZipEncoding(String charset) { [EOL]     this.charset = charset; [EOL] }
public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] }
public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] }
public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] }
public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] }
public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] }
public void setHeaderId(ZipShort headerId) { [EOL]     this.headerId = headerId; [EOL] }
public void setHeaderId(ZipShort headerId) { [EOL]     this.headerId = headerId; [EOL] }
public ZipShort getHeaderId() { [EOL]     return headerId; [EOL] }
public void setLocalFileDataData(byte[] data) { [EOL]     localData = copy(data); [EOL] }
public void setLocalFileDataData(byte[] data) { [EOL]     localData = copy(data); [EOL] }
public ZipShort getLocalFileDataLength() { [EOL]     return new ZipShort(localData.length); [EOL] }
public ZipShort getLocalFileDataLength() { [EOL]     return new ZipShort(localData.length); [EOL] }
public byte[] getLocalFileDataData() { [EOL]     return copy(localData); [EOL] }
public byte[] getLocalFileDataData() { [EOL]     return copy(localData); [EOL] }
private static byte[] copy(byte[] from) { [EOL]     if (from != null) { [EOL]         byte[] to = new byte[from.length]; [EOL]         System.arraycopy(from, 0, to, 0, to.length); [EOL]         return to; [EOL]     } [EOL]     return null; [EOL] }
public GzipCompressorInputStream(InputStream inputStream) throws IOException { [EOL]     in = new GZIPInputStream(inputStream); [EOL] }
public GzipCompressorInputStream(InputStream inputStream) throws IOException { [EOL]     in = new GZIPInputStream(inputStream); [EOL] }
public int read() throws IOException { [EOL]     return in.read(); [EOL] }
public ZipShort getHeaderId() { [EOL]     return HEADER_ID; [EOL] }
public ZipShort getCentralDirectoryLength() { [EOL]     return getLocalFileDataLength(); [EOL] }
public byte[] getCentralDirectoryData() { [EOL]     return getLocalFileDataData(); [EOL] }
SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
public synchronized Simple8BitZipEncoding getEncoding() { [EOL]     if (this.encoding == null) { [EOL]         this.encoding = new Simple8BitZipEncoding(this.highChars); [EOL]     } [EOL]     return this.encoding; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
public synchronized Simple8BitZipEncoding getEncoding() { [EOL]     if (this.encoding == null) { [EOL]         this.encoding = new Simple8BitZipEncoding(this.highChars); [EOL]     } [EOL]     return this.encoding; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }
public JarArchiveEntry(String name) { [EOL]     super(name); [EOL] }
public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] }
public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] }
public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] }
public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] }
public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] }
Simple8BitChar(byte code, char unicode) { [EOL]     this.code = code; [EOL]     this.unicode = unicode; [EOL] }
public int compareTo(Object o) { [EOL]     Simple8BitChar a = (Simple8BitChar) o; [EOL]     return this.unicode - a.unicode; [EOL] }
public int compareTo(Object o) { [EOL]     Simple8BitChar a = (Simple8BitChar) o; [EOL]     return this.unicode - a.unicode; [EOL] }
public int compareTo(Object o) { [EOL]     Simple8BitChar a = (Simple8BitChar) o; [EOL]     return this.unicode - a.unicode; [EOL] }
public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }
public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }
public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }
public char decodeByte(byte b) { [EOL]     if (b >= 0) { [EOL]         return (char) b; [EOL]     } [EOL]     return this.highChars[128 + b]; [EOL] }
public char decodeByte(byte b) { [EOL]     if (b >= 0) { [EOL]         return (char) b; [EOL]     } [EOL]     return this.highChars[128 + b]; [EOL] }
public boolean canEncodeChar(char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     return r != null; [EOL] }
public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }
public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }
private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }
public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }
public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }
public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }
public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }
public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }
public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] }
public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] }
public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] }
public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] }
public ArchiveEntry getNextEntry() throws IOException { [EOL]     return getNextArEntry(); [EOL] }
public int read(byte[] b) throws IOException { [EOL]     final int ret = read(b, 0, b.length); [EOL]     offset = offset + b.length; [EOL]     return ret; [EOL] }
public int read(byte[] b) throws IOException { [EOL]     final int ret = read(b, 0, b.length); [EOL]     offset = offset + b.length; [EOL]     return ret; [EOL] }
public int read(byte[] b) throws IOException { [EOL]     final int ret = read(b, 0, b.length); [EOL]     offset = offset + b.length; [EOL]     return ret; [EOL] }
public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] }
public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] }
public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] }
public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] }
public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] }
public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] }
public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] }
public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] }
public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] }
public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] }
public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] }
public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] }
public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] }
public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] }
public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] }
public UnicodePathExtraField() { [EOL] }
public UnicodePathExtraField(String text, byte[] bytes, int off, int len) { [EOL]     super(text, bytes, off, len); [EOL] }
public UnicodePathExtraField(String text, byte[] bytes, int off, int len) { [EOL]     super(text, bytes, off, len); [EOL] }
public ZipShort getHeaderId() { [EOL]     return UPATH_ID; [EOL] }
