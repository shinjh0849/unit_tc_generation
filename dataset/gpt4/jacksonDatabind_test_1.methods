@Override [EOL] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class); [EOL]     if (ref1 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.managed(ref1.value()); [EOL]     } [EOL]     JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); [EOL]     if (ref2 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.back(ref2.value()); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class); [EOL]     if (ref1 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.managed(ref1.value()); [EOL]     } [EOL]     JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); [EOL]     if (ref2 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.back(ref2.value()); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class); [EOL]     if (ref1 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.managed(ref1.value()); [EOL]     } [EOL]     JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); [EOL]     if (ref2 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.back(ref2.value()); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class); [EOL]     if (ann == null || !ann.enabled()) { [EOL]         return null; [EOL]     } [EOL]     String prefix = ann.prefix(); [EOL]     String suffix = ann.suffix(); [EOL]     return NameTransformer.simpleTransformer(prefix, suffix); [EOL] }
@Override [EOL] public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class); [EOL]     if (ann == null || !ann.enabled()) { [EOL]         return null; [EOL]     } [EOL]     String prefix = ann.prefix(); [EOL]     String suffix = ann.suffix(); [EOL]     return NameTransformer.simpleTransformer(prefix, suffix); [EOL] }
@Override [EOL] public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class); [EOL]     if (ann == null || !ann.enabled()) { [EOL]         return null; [EOL]     } [EOL]     String prefix = ann.prefix(); [EOL]     String suffix = ann.suffix(); [EOL]     return NameTransformer.simpleTransformer(prefix, suffix); [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public List<NamedType> findSubtypes(Annotated a) { [EOL]     JsonSubTypes t = a.getAnnotation(JsonSubTypes.class); [EOL]     if (t == null) [EOL]         return null; [EOL]     JsonSubTypes.Type[] types = t.value(); [EOL]     ArrayList<NamedType> result = new ArrayList<NamedType>(types.length); [EOL]     for (JsonSubTypes.Type type : types) { [EOL]         result.add(new NamedType(type.value(), type.name())); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<NamedType> findSubtypes(Annotated a) { [EOL]     JsonSubTypes t = a.getAnnotation(JsonSubTypes.class); [EOL]     if (t == null) [EOL]         return null; [EOL]     JsonSubTypes.Type[] types = t.value(); [EOL]     ArrayList<NamedType> result = new ArrayList<NamedType>(types.length); [EOL]     for (JsonSubTypes.Type type : types) { [EOL]         result.add(new NamedType(type.value(), type.name())); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<NamedType> findSubtypes(Annotated a) { [EOL]     JsonSubTypes t = a.getAnnotation(JsonSubTypes.class); [EOL]     if (t == null) [EOL]         return null; [EOL]     JsonSubTypes.Type[] types = t.value(); [EOL]     ArrayList<NamedType> result = new ArrayList<NamedType>(types.length); [EOL]     for (JsonSubTypes.Type type : types) { [EOL]         result.add(new NamedType(type.value(), type.name())); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class); [EOL]     if (info == null || info.generator() == ObjectIdGenerators.None.class) { [EOL]         return null; [EOL]     } [EOL]     return new ObjectIdInfo(info.property(), info.scope(), info.generator()); [EOL] }
@Override [EOL] public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class); [EOL]     if (info == null || info.generator() == ObjectIdGenerators.None.class) { [EOL]         return null; [EOL]     } [EOL]     return new ObjectIdInfo(info.property(), info.scope(), info.generator()); [EOL] }
@Override [EOL] public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class); [EOL]     if (info == null || info.generator() == ObjectIdGenerators.None.class) { [EOL]         return null; [EOL]     } [EOL]     return new ObjectIdInfo(info.property(), info.scope(), info.generator()); [EOL] }
@Override [EOL] public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { [EOL]     JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class); [EOL]     if (ref != null) { [EOL]         objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); [EOL]     } [EOL]     return objectIdInfo; [EOL] }
@Override [EOL] public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { [EOL]     JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class); [EOL]     if (ref != null) { [EOL]         objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); [EOL]     } [EOL]     return objectIdInfo; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL]     TypeResolverBuilder<?> b; [EOL]     JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL]     JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL]     if (resAnn != null) { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL]     } else { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         if (info.use() == JsonTypeInfo.Id.NONE) { [EOL]             return _constructNoTypeResolverBuilder(); [EOL]         } [EOL]         b = _constructStdTypeResolverBuilder(); [EOL]     } [EOL]     JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL]     TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL]     if (idRes != null) { [EOL]         idRes.init(baseType); [EOL]     } [EOL]     b = b.init(info.use(), idRes); [EOL]     JsonTypeInfo.As inclusion = info.include(); [EOL]     if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL]         inclusion = JsonTypeInfo.As.PROPERTY; [EOL]     } [EOL]     b = b.inclusion(inclusion); [EOL]     b = b.typeProperty(info.property()); [EOL]     Class<?> defaultImpl = info.defaultImpl(); [EOL]     if (defaultImpl != JsonTypeInfo.None.class) { [EOL]         b = b.defaultImpl(defaultImpl); [EOL]     } [EOL]     b = b.typeIdVisibility(info.visible()); [EOL]     return b; [EOL] }
@Override [EOL] public final Class<?> getActiveView() { [EOL]     return _view; [EOL] }
@Override [EOL] public final Class<?> getActiveView() { [EOL]     return _view; [EOL] }
public TimeZone getTimeZone() { [EOL]     return _config.getTimeZone(); [EOL] }
public final ArrayBuilders getArrayBuilders() { [EOL]     if (_arrayBuilders == null) { [EOL]         _arrayBuilders = new ArrayBuilders(); [EOL]     } [EOL]     return _arrayBuilders; [EOL] }
public final ArrayBuilders getArrayBuilders() { [EOL]     if (_arrayBuilders == null) { [EOL]         _arrayBuilders = new ArrayBuilders(); [EOL]     } [EOL]     return _arrayBuilders; [EOL] }
@Override [EOL] public Object clone() { [EOL]     return this; [EOL] }
protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType != Integer.TYPE && rawType != Boolean.TYPE && rawType != Double.TYPE) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (rawType != String.class && rawType != Integer.class && rawType != Boolean.class && rawType != Double.class) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return isDefaultSerializer(ser); [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
public void addAll(POJOPropertyBuilder src) { [EOL]     _fields = merge(_fields, src._fields); [EOL]     _ctorParameters = merge(_ctorParameters, src._ctorParameters); [EOL]     _getters = merge(_getters, src._getters); [EOL]     _setters = merge(_setters, src._setters); [EOL] }
private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2) { [EOL]     if (chain1 == null) { [EOL]         return chain2; [EOL]     } [EOL]     if (chain2 == null) { [EOL]         return chain1; [EOL]     } [EOL]     return chain1.append(chain2); [EOL] }
private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2) { [EOL]     if (chain1 == null) { [EOL]         return chain2; [EOL]     } [EOL]     if (chain2 == null) { [EOL]         return chain1; [EOL]     } [EOL]     return chain1.append(chain2); [EOL] }
private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2) { [EOL]     if (chain1 == null) { [EOL]         return chain2; [EOL]     } [EOL]     if (chain2 == null) { [EOL]         return chain1; [EOL]     } [EOL]     return chain1.append(chain2); [EOL] }
private static <T> Linked<T> merge(Linked<T> chain1, Linked<T> chain2) { [EOL]     if (chain1 == null) { [EOL]         return chain2; [EOL]     } [EOL]     if (chain2 == null) { [EOL]         return chain1; [EOL]     } [EOL]     return chain1.append(chain2); [EOL] }
public Linked<T> withNext(Linked<T> newNext) { [EOL]     if (newNext == next) { [EOL]         return this; [EOL]     } [EOL]     return new Linked<T>(value, newNext, explicitName, isVisible, isMarkedIgnored); [EOL] }
public Linked<T> withNext(Linked<T> newNext) { [EOL]     if (newNext == next) { [EOL]         return this; [EOL]     } [EOL]     return new Linked<T>(value, newNext, explicitName, isVisible, isMarkedIgnored); [EOL] }
private Linked<T> append(Linked<T> appendable) { [EOL]     if (next == null) { [EOL]         return withNext(appendable); [EOL]     } [EOL]     return withNext(next.append(appendable)); [EOL] }
private Linked<T> append(Linked<T> appendable) { [EOL]     if (next == null) { [EOL]         return withNext(appendable); [EOL]     } [EOL]     return withNext(next.append(appendable)); [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
private NullSerializer() { [EOL]     super(Object.class); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNull(); [EOL] }
@Override [EOL] public final boolean isMissingNode() { [EOL]     return getNodeType() == JsonNodeType.MISSING; [EOL] }
@Override [EOL] public final boolean isMissingNode() { [EOL]     return getNodeType() == JsonNodeType.MISSING; [EOL] }
public final boolean isPojo() { [EOL]     return getNodeType() == JsonNodeType.POJO; [EOL] }
public final boolean isPojo() { [EOL]     return getNodeType() == JsonNodeType.POJO; [EOL] }
public boolean isLong() { [EOL]     return false; [EOL] }
public boolean isDouble() { [EOL]     return false; [EOL] }
public final boolean isNull() { [EOL]     return getNodeType() == JsonNodeType.NULL; [EOL] }
public final boolean isNull() { [EOL]     return getNodeType() == JsonNodeType.NULL; [EOL] }
public String textValue() { [EOL]     return null; [EOL] }
public static void throwAsIAE(Throwable t) { [EOL]     throwAsIAE(t, t.getMessage()); [EOL] }
public static void throwAsIAE(Throwable t) { [EOL]     throwAsIAE(t, t.getMessage()); [EOL] }
public static void unwrapAndThrowAsIAE(Throwable t) { [EOL]     throwAsIAE(getRootCause(t)); [EOL] }
public static void unwrapAndThrowAsIAE(Throwable t) { [EOL]     throwAsIAE(getRootCause(t)); [EOL] }
public static void unwrapAndThrowAsIAE(Throwable t) { [EOL]     throwAsIAE(getRootCause(t)); [EOL] }
public static Class<? extends Enum<?>> findEnumType(EnumMap<?, ?> m) { [EOL]     if (!m.isEmpty()) { [EOL]         return findEnumType(m.keySet().iterator().next()); [EOL]     } [EOL]     return EnumTypeLocator.instance.enumTypeFor(m); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Class<?> cls) { [EOL]     if (cls.getSuperclass() != Enum.class) { [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) cls; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Class<?> cls) { [EOL]     if (cls.getSuperclass() != Enum.class) { [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) cls; [EOL] }
protected TypeNameIdResolver(MapperConfig<?> config, JavaType baseType, HashMap<String, String> typeToId, HashMap<String, JavaType> idToType) { [EOL]     super(baseType, config.getTypeFactory()); [EOL]     _config = config; [EOL]     _typeToId = typeToId; [EOL]     _idToType = idToType; [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public JavaType typeFromId(String id) throws IllegalArgumentException { [EOL]     JavaType t = _idToType.get(id); [EOL]     return t; [EOL] }
@Override [EOL] public JavaType typeFromId(String id) throws IllegalArgumentException { [EOL]     JavaType t = _idToType.get(id); [EOL]     return t; [EOL] }
protected static String _defaultTypeId(Class<?> cls) { [EOL]     String n = cls.getName(); [EOL]     int ix = n.lastIndexOf('.'); [EOL]     return (ix < 0) ? n : n.substring(ix + 1); [EOL] }
protected static String _defaultTypeId(Class<?> cls) { [EOL]     String n = cls.getName(); [EOL]     int ix = n.lastIndexOf('.'); [EOL]     return (ix < 0) ? n : n.substring(ix + 1); [EOL] }
@Override [EOL] public CollectionType withTypeHandler(Object h) { [EOL]     return new CollectionType(_class, _elementType, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public CollectionType withTypeHandler(Object h) { [EOL]     return new CollectionType(_class, _elementType, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public void serializeWithType(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     if (!value.isEmpty()) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     if (!value.isEmpty()) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public JsonSerializer<?> findCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { [EOL]     return findSerializer(config, type, beanDesc); [EOL] }
@Override [EOL] public JsonSerializer<?> findCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { [EOL]     return findSerializer(config, type, beanDesc); [EOL] }
protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer) { [EOL]     super(cls, false); [EOL]     _elementType = et; [EOL]     _staticTyping = staticTyping || (et != null && et.isFinal()); [EOL]     _valueTypeSerializer = vts; [EOL]     _property = property; [EOL]     _elementSerializer = elementSerializer; [EOL]     _dynamicSerializers = PropertySerializerMap.emptyMap(); [EOL] }
protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer) { [EOL]     super(cls, false); [EOL]     _elementType = et; [EOL]     _staticTyping = staticTyping || (et != null && et.isFinal()); [EOL]     _valueTypeSerializer = vts; [EOL]     _property = property; [EOL]     _elementSerializer = elementSerializer; [EOL]     _dynamicSerializers = PropertySerializerMap.emptyMap(); [EOL] }
protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer) { [EOL]     super(cls, false); [EOL]     _elementType = et; [EOL]     _staticTyping = staticTyping || (et != null && et.isFinal()); [EOL]     _valueTypeSerializer = vts; [EOL]     _property = property; [EOL]     _elementSerializer = elementSerializer; [EOL]     _dynamicSerializers = PropertySerializerMap.emptyMap(); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
private DeserializationConfig(DeserializationConfig src, Class<?> view) { [EOL]     super(src, view); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _problemHandlers = src._problemHandlers; [EOL]     _nodeFactory = src._nodeFactory; [EOL] }
private DeserializationConfig(DeserializationConfig src, Class<?> view) { [EOL]     super(src, view); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _problemHandlers = src._problemHandlers; [EOL]     _nodeFactory = src._nodeFactory; [EOL] }
@Override [EOL] public DeserializationConfig with(ClassIntrospector ci) { [EOL]     return _withBase(_base.withClassIntrospector(ci)); [EOL] }
@Override [EOL] public DeserializationConfig with(VisibilityChecker<?> vc) { [EOL]     return _withBase(_base.withVisibilityChecker(vc)); [EOL] }
@Override [EOL] public DeserializationConfig with(VisibilityChecker<?> vc) { [EOL]     return _withBase(_base.withVisibilityChecker(vc)); [EOL] }
@Override [EOL] public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     return _withBase(_base.withVisibility(forMethod, visibility)); [EOL] }
@Override [EOL] public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     return _withBase(_base.withVisibility(forMethod, visibility)); [EOL] }
@Override [EOL] public DeserializationConfig with(TypeFactory tf) { [EOL]     return _withBase(_base.withTypeFactory(tf)); [EOL] }
@Override [EOL] public DeserializationConfig with(DateFormat df) { [EOL]     return _withBase(_base.withDateFormat(df)); [EOL] }
@Override [EOL] public DeserializationConfig with(DateFormat df) { [EOL]     return _withBase(_base.withDateFormat(df)); [EOL] }
@Override [EOL] public DeserializationConfig withView(Class<?> view) { [EOL]     return (_view == view) ? this : new DeserializationConfig(this, view); [EOL] }
@Override [EOL] public DeserializationConfig withView(Class<?> view) { [EOL]     return (_view == view) ? this : new DeserializationConfig(this, view); [EOL] }
@Override [EOL] public DeserializationConfig with(TimeZone tz) { [EOL]     return _withBase(_base.with(tz)); [EOL] }
@Override [EOL] public DeserializationConfig with(TimeZone tz) { [EOL]     return _withBase(_base.with(tz)); [EOL] }
public DeserializationConfig with(JsonNodeFactory f) { [EOL]     if (_nodeFactory == f) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, f); [EOL] }
public DeserializationConfig with(JsonNodeFactory f) { [EOL]     if (_nodeFactory == f) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, f); [EOL] }
@Override [EOL] public int size() { [EOL]     return (_annotations == null) ? 0 : _annotations.size(); [EOL] }
@Override [EOL] public int size() { [EOL]     return (_annotations == null) ? 0 : _annotations.size(); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsArrayTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsArrayTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public As getTypeInclusion() { [EOL]     return As.WRAPPER_ARRAY; [EOL] }
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
public TokenBufferSerializer() { [EOL]     super(TokenBuffer.class); [EOL] }
@Override [EOL] public void serialize(TokenBuffer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     value.serialize(jgen); [EOL] }
@Override [EOL] public void serialize(TokenBuffer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     value.serialize(jgen); [EOL] }
@Override [EOL] public final void serializeWithType(TokenBuffer value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
@Override [EOL] public final void serializeWithType(TokenBuffer value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintISO8601Format() { [EOL]     return DATE_FORMAT_ISO8601; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getISO8601Format(TimeZone tz) { [EOL]     return _cloneFormat(DATE_FORMAT_ISO8601, tz); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getISO8601Format(TimeZone tz) { [EOL]     return _cloneFormat(DATE_FORMAT_ISO8601, tz); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getBlueprintRFC1123Format() { [EOL]     return DATE_FORMAT_RFC1123; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getRFC1123Format(TimeZone tz) { [EOL]     return _cloneFormat(DATE_FORMAT_RFC1123, tz); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public static DateFormat getRFC1123Format(TimeZone tz) { [EOL]     return _cloneFormat(DATE_FORMAT_RFC1123, tz); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static DateFormat _cloneFormat(DateFormat df, TimeZone tz) { [EOL]     df = (DateFormat) df.clone(); [EOL]     if (tz != null) { [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return df; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static DateFormat _cloneFormat(DateFormat df, TimeZone tz) { [EOL]     df = (DateFormat) df.clone(); [EOL]     if (tz != null) { [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return df; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected SettableBeanProperty(SettableBeanProperty src) { [EOL]     _propName = src._propName; [EOL]     _type = src._type; [EOL]     _wrapperName = src._wrapperName; [EOL]     _isRequired = src._isRequired; [EOL]     _contextAnnotations = src._contextAnnotations; [EOL]     _valueDeserializer = src._valueDeserializer; [EOL]     _valueTypeDeserializer = src._valueTypeDeserializer; [EOL]     _nullProvider = src._nullProvider; [EOL]     _managedReferenceName = src._managedReferenceName; [EOL]     _propertyIndex = src._propertyIndex; [EOL]     _viewMatcher = src._viewMatcher; [EOL] }
public void setManagedReferenceName(String n) { [EOL]     _managedReferenceName = n; [EOL] }
public void setViews(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         _viewMatcher = null; [EOL]     } else { [EOL]         _viewMatcher = ViewMatcher.construct(views); [EOL]     } [EOL] }
public void setViews(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         _viewMatcher = null; [EOL]     } else { [EOL]         _viewMatcher = ViewMatcher.construct(views); [EOL]     } [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     return _isRequired; [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     return _wrapperName; [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     return _wrapperName; [EOL] }
public JsonDeserializer<Object> getValueDeserializer() { [EOL]     JsonDeserializer<Object> deser = _valueDeserializer; [EOL]     if (deser == MISSING_VALUE_DESERIALIZER) { [EOL]         return null; [EOL]     } [EOL]     return deser; [EOL] }
public JsonDeserializer<Object> getValueDeserializer() { [EOL]     JsonDeserializer<Object> deser = _valueDeserializer; [EOL]     if (deser == MISSING_VALUE_DESERIALIZER) { [EOL]         return null; [EOL]     } [EOL]     return deser; [EOL] }
public boolean visibleInView(Class<?> activeView) { [EOL]     return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView); [EOL] }
public boolean visibleInView(Class<?> activeView) { [EOL]     return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView); [EOL] }
public boolean visibleInView(Class<?> activeView) { [EOL]     return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView); [EOL] }
protected MethodProperty(MethodProperty src, Method m) { [EOL]     super(src); [EOL]     _annotated = src._annotated; [EOL]     _setter = m; [EOL] }
protected MethodProperty(MethodProperty src, Method m) { [EOL]     super(src); [EOL]     _annotated = src._annotated; [EOL]     _setter = m; [EOL] }
Object readResolve() { [EOL]     return new MethodProperty(this, _annotated.getAnnotated()); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeNull(); [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
protected AnnotatedField(Serialization ser) { [EOL]     super(null); [EOL]     _field = null; [EOL]     _serialization = ser; [EOL] }
protected AnnotatedField(Serialization ser) { [EOL]     super(null); [EOL]     _field = null; [EOL]     _serialization = ser; [EOL] }
@Override [EOL] public void setValue(Object pojo, Object value) throws IllegalArgumentException { [EOL]     try { [EOL]         _field.set(pojo, value); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() for field " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public void setValue(Object pojo, Object value) throws IllegalArgumentException { [EOL]     try { [EOL]         _field.set(pojo, value); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() for field " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
Object writeReplace() { [EOL]     return new AnnotatedField(new Serialization(_field)); [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Field f = clazz.getDeclaredField(_serialization.name); [EOL]         if (!f.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(f); [EOL]         } [EOL]         return new AnnotatedField(f, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find method '" + _serialization.name + "' from Class '" + clazz.getName()); [EOL]     } [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Field f = clazz.getDeclaredField(_serialization.name); [EOL]         if (!f.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(f); [EOL]         } [EOL]         return new AnnotatedField(f, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find method '" + _serialization.name + "' from Class '" + clazz.getName()); [EOL]     } [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Field f = clazz.getDeclaredField(_serialization.name); [EOL]         if (!f.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(f); [EOL]         } [EOL]         return new AnnotatedField(f, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find method '" + _serialization.name + "' from Class '" + clazz.getName()); [EOL]     } [EOL] }
public Serialization(Field f) { [EOL]     clazz = f.getDeclaringClass(); [EOL]     name = f.getName(); [EOL] }
public Serialization(Field f) { [EOL]     clazz = f.getDeclaringClass(); [EOL]     name = f.getName(); [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected BeanSerializer(BeanSerializerBase src, String[] toIgnore) { [EOL]     super(src, toIgnore); [EOL] }
@Override [EOL] protected BeanSerializer withIgnorals(String[] toIgnore) { [EOL]     return new BeanSerializer(this, toIgnore); [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public final DateFormat getDateFormat() { [EOL]     return _base.getDateFormat(); [EOL] }
public final TimeZone getTimeZone() { [EOL]     return _base.getTimeZone(); [EOL] }
public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers()); [EOL] }
public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers()); [EOL] }
public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers()); [EOL] }
public SimpleValueInstantiators() { [EOL]     _classMappings = new HashMap<ClassKey, ValueInstantiator>(); [EOL] }
public SimpleValueInstantiators addValueInstantiator(Class<?> forType, ValueInstantiator inst) { [EOL]     _classMappings.put(new ClassKey(forType), inst); [EOL]     return this; [EOL] }
public SimpleValueInstantiators addValueInstantiator(Class<?> forType, ValueInstantiator inst) { [EOL]     _classMappings.put(new ClassKey(forType), inst); [EOL]     return this; [EOL] }
public SimpleValueInstantiators addValueInstantiator(Class<?> forType, ValueInstantiator inst) { [EOL]     _classMappings.put(new ClassKey(forType), inst); [EOL]     return this; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationConfig config, BeanDescription beanDesc, ValueInstantiator defaultInstantiator) { [EOL]     ValueInstantiator inst = _classMappings.get(new ClassKey(beanDesc.getBeanClass())); [EOL]     return (inst == null) ? defaultInstantiator : inst; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationConfig config, BeanDescription beanDesc, ValueInstantiator defaultInstantiator) { [EOL]     ValueInstantiator inst = _classMappings.get(new ClassKey(beanDesc.getBeanClass())); [EOL]     return (inst == null) ? defaultInstantiator : inst; [EOL] }
@Override [EOL] public final JsonNode get(int index) { [EOL]     return null; [EOL] }
@Override [EOL] public final JsonNode get(int index) { [EOL]     return null; [EOL] }
@Override [EOL] public final JsonNode path(int index) { [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public final JsonNode get(String fieldName) { [EOL]     return null; [EOL] }
@Override [EOL] public final JsonNode get(String fieldName) { [EOL]     return null; [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) { [EOL]     _defaultImpl = defaultImpl; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) { [EOL]     _defaultImpl = defaultImpl; [EOL]     return this; [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public ArrayType withContentValueHandler(Object h) { [EOL]     if (h == _componentType.<Object>getValueHandler()) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType.withValueHandler(h), _emptyArray, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public ArrayType withContentValueHandler(Object h) { [EOL]     if (h == _componentType.<Object>getValueHandler()) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType.withValueHandler(h), _emptyArray, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public ArrayType withStaticTyping() { [EOL]     if (_asStatic) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType.withStaticTyping(), _emptyArray, _valueHandler, _typeHandler, true); [EOL] }
@Override [EOL] public ArrayType withStaticTyping() { [EOL]     if (_asStatic) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType.withStaticTyping(), _emptyArray, _valueHandler, _typeHandler, true); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _componentType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return construct(_componentType.narrowBy(contentClass), _valueHandler, _typeHandler); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _componentType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return construct(_componentType.narrowBy(contentClass), _valueHandler, _typeHandler); [EOL] }
@Override [EOL] public boolean isArrayType() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean isAbstract() { [EOL]     return false; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     return true; [EOL] }
@Override [EOL] public JavaType getContentType() { [EOL]     return _componentType; [EOL] }
protected StringArraySerializer() { [EOL]     super(String[].class, null); [EOL]     _elementSerializer = null; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public boolean isEmpty(String[] value) { [EOL]     return (value == null) || (value.length == 0); [EOL] }
@Override [EOL] public boolean isEmpty(String[] value) { [EOL]     return (value == null) || (value.length == 0); [EOL] }
@Override [EOL] public boolean isEmpty(String[] value) { [EOL]     return (value == null) || (value.length == 0); [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     o.put("items", createSchemaNode("string")); [EOL]     return o; [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
@Override [EOL] public byte[] binaryValue() throws IOException { [EOL]     return getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] }
@Override [EOL] public byte[] binaryValue() throws IOException { [EOL]     return getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     if (_value == null) { [EOL]         jg.writeNull(); [EOL]     } else { [EOL]         jg.writeString(_value); [EOL]     } [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     if (_value == null) { [EOL]         jg.writeNull(); [EOL]     } else { [EOL]         jg.writeString(_value); [EOL]     } [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex) throws JsonParseException { [EOL]     _reportInvalidBase64(b64variant, ch, bindex, null); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] }
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
public void addBackReferenceProperty(String referenceName, SettableBeanProperty prop) { [EOL]     if (_backRefProperties == null) { [EOL]         _backRefProperties = new HashMap<String, SettableBeanProperty>(4); [EOL]     } [EOL]     _backRefProperties.put(referenceName, prop); [EOL]     if (_properties != null) { [EOL]         _properties.remove(prop.getName()); [EOL]     } [EOL] }
public void addBackReferenceProperty(String referenceName, SettableBeanProperty prop) { [EOL]     if (_backRefProperties == null) { [EOL]         _backRefProperties = new HashMap<String, SettableBeanProperty>(4); [EOL]     } [EOL]     _backRefProperties.put(referenceName, prop); [EOL]     if (_properties != null) { [EOL]         _properties.remove(prop.getName()); [EOL]     } [EOL] }
public void addBackReferenceProperty(String referenceName, SettableBeanProperty prop) { [EOL]     if (_backRefProperties == null) { [EOL]         _backRefProperties = new HashMap<String, SettableBeanProperty>(4); [EOL]     } [EOL]     _backRefProperties.put(referenceName, prop); [EOL]     if (_properties != null) { [EOL]         _properties.remove(prop.getName()); [EOL]     } [EOL] }
public void addInjectable(String propertyName, JavaType propertyType, Annotations contextAnnotations, AnnotatedMember member, Object valueId) { [EOL]     if (_injectables == null) { [EOL]         _injectables = new ArrayList<ValueInjector>(); [EOL]     } [EOL]     _injectables.add(new ValueInjector(propertyName, propertyType, contextAnnotations, member, valueId)); [EOL] }
public void addInjectable(String propertyName, JavaType propertyType, Annotations contextAnnotations, AnnotatedMember member, Object valueId) { [EOL]     if (_injectables == null) { [EOL]         _injectables = new ArrayList<ValueInjector>(); [EOL]     } [EOL]     _injectables.add(new ValueInjector(propertyName, propertyType, contextAnnotations, member, valueId)); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(provider)) { [EOL]         serializeAsArray(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeAsArray(bean, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(provider)) { [EOL]         serializeAsArray(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeAsArray(bean, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(provider)) { [EOL]         serializeAsArray(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeAsArray(bean, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT) { [EOL]     return new MapLikeType(rawType, keyT, valueT, null, null, false); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_keyType != null) { [EOL]         sb.append('<'); [EOL]         sb.append(_keyType.toCanonical()); [EOL]         sb.append(','); [EOL]         sb.append(_valueType.toCanonical()); [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_keyType != null) { [EOL]         sb.append('<'); [EOL]         sb.append(_keyType.toCanonical()); [EOL]         sb.append(','); [EOL]         sb.append(_valueType.toCanonical()); [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public SimpleModule(String name, Version version) { [EOL]     _name = name; [EOL]     _version = version; [EOL] }
public SimpleModule setSerializerModifier(BeanSerializerModifier mod) { [EOL]     _serializerModifier = mod; [EOL]     return this; [EOL] }
public SimpleModule setSerializerModifier(BeanSerializerModifier mod) { [EOL]     _serializerModifier = mod; [EOL]     return this; [EOL] }
public <T> SimpleModule addAbstractTypeMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (_abstractTypes == null) { [EOL]         _abstractTypes = new SimpleAbstractTypeResolver(); [EOL]     } [EOL]     _abstractTypes = _abstractTypes.addMapping(superType, subType); [EOL]     return this; [EOL] }
public <T> SimpleModule addAbstractTypeMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (_abstractTypes == null) { [EOL]         _abstractTypes = new SimpleAbstractTypeResolver(); [EOL]     } [EOL]     _abstractTypes = _abstractTypes.addMapping(superType, subType); [EOL]     return this; [EOL] }
public SimpleModule setMixInAnnotation(Class<?> targetType, Class<?> mixinClass) { [EOL]     if (_mixins == null) { [EOL]         _mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     } [EOL]     _mixins.put(targetType, mixinClass); [EOL]     return this; [EOL] }
public SimpleModule setMixInAnnotation(Class<?> targetType, Class<?> mixinClass) { [EOL]     if (_mixins == null) { [EOL]         _mixins = new HashMap<Class<?>, Class<?>>(); [EOL]     } [EOL]     _mixins.put(targetType, mixinClass); [EOL]     return this; [EOL] }
@Override [EOL] public String getModuleName() { [EOL]     return _name; [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public Version version() { [EOL]     return _version; [EOL] }
@Override [EOL] public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeArrayFieldStart(idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeArrayFieldStart(idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndArray(); [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeObjectFieldStart(typeId); [EOL] }
@Override [EOL] public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     writeTypeSuffixForObject(value, jgen); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
@Override [EOL] public SimpleType withValueHandler(Object h) { [EOL]     if (h == _valueHandler) { [EOL]         return this; [EOL]     } [EOL]     return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic); [EOL] }
protected TypeFactory(TypeParser p, TypeModifier[] mods) { [EOL]     _parser = p; [EOL]     _modifiers = mods; [EOL] }
protected TypeFactory(TypeParser p, TypeModifier[] mods) { [EOL]     _parser = p; [EOL]     _modifiers = mods; [EOL] }
protected TypeFactory(TypeParser p, TypeModifier[] mods) { [EOL]     _parser = p; [EOL]     _modifiers = mods; [EOL] }
public TypeFactory withModifier(TypeModifier mod) { [EOL]     if (_modifiers == null) { [EOL]         return new TypeFactory(_parser, new TypeModifier[] { mod }); [EOL]     } [EOL]     return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod)); [EOL] }
public TypeFactory withModifier(TypeModifier mod) { [EOL]     if (_modifiers == null) { [EOL]         return new TypeFactory(_parser, new TypeModifier[] { mod }); [EOL]     } [EOL]     return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod)); [EOL] }
public static JavaType unknownType() { [EOL]     return defaultInstance()._unknownType(); [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { [EOL]     return CollectionLikeType.construct(collectionClass, elementType); [EOL] }
public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { [EOL]     return CollectionLikeType.construct(collectionClass, elementType); [EOL] }
public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { [EOL]     return CollectionLikeType.construct(collectionClass, elementType); [EOL] }
public MapType constructRawMapType(Class<? extends Map> mapClass) { [EOL]     return MapType.construct(mapClass, unknownType(), unknownType()); [EOL] }
public MapType constructRawMapType(Class<? extends Map> mapClass) { [EOL]     return MapType.construct(mapClass, unknownType(), unknownType()); [EOL] }
public MapType constructRawMapType(Class<? extends Map> mapClass) { [EOL]     return MapType.construct(mapClass, unknownType(), unknownType()); [EOL] }
public MapLikeType constructRawMapLikeType(Class<?> mapClass) { [EOL]     return MapLikeType.construct(mapClass, unknownType(), unknownType()); [EOL] }
public MapLikeType constructRawMapLikeType(Class<?> mapClass) { [EOL]     return MapLikeType.construct(mapClass, unknownType(), unknownType()); [EOL] }
protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context) { [EOL]     JavaType compType = _constructType(type.getGenericComponentType(), context); [EOL]     return ArrayType.construct(compType, null, null); [EOL] }
protected JavaType _unknownType() { [EOL]     return new SimpleType(Object.class); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsPropertyTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsPropertyTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
public TokenBuffer(ObjectCodec codec) { [EOL]     _objectCodec = codec; [EOL]     _generatorFeatures = DEFAULT_PARSER_FEATURES; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _first = _last = new Segment(); [EOL]     _appendOffset = 0; [EOL] }
public TokenBuffer(ObjectCodec codec) { [EOL]     _objectCodec = codec; [EOL]     _generatorFeatures = DEFAULT_PARSER_FEATURES; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _first = _last = new Segment(); [EOL]     _appendOffset = 0; [EOL] }
public JsonParser asParser() { [EOL]     return asParser(_objectCodec); [EOL] }
public JsonParser asParser(ObjectCodec codec) { [EOL]     return new Parser(_first, codec); [EOL] }
public JsonParser asParser(ObjectCodec codec) { [EOL]     return new Parser(_first, codec); [EOL] }
public JsonToken firstToken() { [EOL]     if (_first != null) { [EOL]         return _first.type(0); [EOL]     } [EOL]     return null; [EOL] }
public JsonToken firstToken() { [EOL]     if (_first != null) { [EOL]         return _first.type(0); [EOL]     } [EOL]     return null; [EOL] }
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { [EOL]     JsonParser jp = other.asParser(); [EOL]     while (jp.nextToken() != null) { [EOL]         this.copyCurrentEvent(jp); [EOL]     } [EOL]     return this; [EOL] }
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { [EOL]     JsonParser jp = other.asParser(); [EOL]     while (jp.nextToken() != null) { [EOL]         this.copyCurrentEvent(jp); [EOL]     } [EOL]     return this; [EOL] }
public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { [EOL]     Segment segment = _first; [EOL]     int ptr = -1; [EOL]     while (true) { [EOL]         if (++ptr >= Segment.TOKENS_PER_SEGMENT) { [EOL]             ptr = 0; [EOL]             segment = segment.next(); [EOL]             if (segment == null) [EOL]                 break; [EOL]         } [EOL]         JsonToken t = segment.type(ptr); [EOL]         if (t == null) [EOL]             break; [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 jgen.writeStartObject(); [EOL]                 break; [EOL]             case END_OBJECT: [EOL]                 jgen.writeEndObject(); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 jgen.writeStartArray(); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 jgen.writeEndArray(); [EOL]                 break; [EOL]             case FIELD_NAME: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeFieldName((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeFieldName((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeString((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeString((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_INT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Integer) { [EOL]                         jgen.writeNumber((Integer) n); [EOL]                     } else if (n instanceof BigInteger) { [EOL]                         jgen.writeNumber((BigInteger) n); [EOL]                     } else if (n instanceof Long) { [EOL]                         jgen.writeNumber((Long) n); [EOL]                     } else if (n instanceof Short) { [EOL]                         jgen.writeNumber((Short) n); [EOL]                     } else { [EOL]                         jgen.writeNumber(((Number) n).intValue()); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Double) { [EOL]                         jgen.writeNumber(((Double) n).doubleValue()); [EOL]                     } else if (n instanceof BigDecimal) { [EOL]                         jgen.writeNumber((BigDecimal) n); [EOL]                     } else if (n instanceof Float) { [EOL]                         jgen.writeNumber(((Float) n).floatValue()); [EOL]                     } else if (n == null) { [EOL]                         jgen.writeNull(); [EOL]                     } else if (n instanceof String) { [EOL]                         jgen.writeNumber((String) n); [EOL]                     } else { [EOL]                         throw new JsonGenerationException("Unrecognized value type for VALUE_NUMBER_FLOAT: " + n.getClass().getName() + ", can not serialize"); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_TRUE: [EOL]                 jgen.writeBoolean(true); [EOL]                 break; [EOL]             case VALUE_FALSE: [EOL]                 jgen.writeBoolean(false); [EOL]                 break; [EOL]             case VALUE_NULL: [EOL]                 jgen.writeNull(); [EOL]                 break; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 jgen.writeObject(segment.get(ptr)); [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public final JsonWriteContext getOutputContext() { [EOL]     return _writeContext; [EOL] }
@Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.START_ARRAY); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL] }
@Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.END_ARRAY); [EOL]     JsonWriteContext c = _writeContext.getParent(); [EOL]     if (c != null) { [EOL]         _writeContext = c; [EOL]     } [EOL] }
@Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.END_ARRAY); [EOL]     JsonWriteContext c = _writeContext.getParent(); [EOL]     if (c != null) { [EOL]         _writeContext = c; [EOL]     } [EOL] }
@Override [EOL] public final void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.START_OBJECT); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL] }
@Override [EOL] public final void writeEndObject() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.END_OBJECT); [EOL]     JsonWriteContext c = _writeContext.getParent(); [EOL]     if (c != null) { [EOL]         _writeContext = c; [EOL]     } [EOL] }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.FIELD_NAME, name); [EOL]     _writeContext.writeFieldName(name); [EOL] }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.FIELD_NAME, name); [EOL]     _writeContext.writeFieldName(name); [EOL] }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     writeString(new String(text, offset, len)); [EOL] }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     writeString(new String(text, offset, len)); [EOL] }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     writeString(new String(text, offset, len)); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); [EOL] }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); [EOL] }
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); [EOL] }
@Override [EOL] public void writeNull() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NULL); [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     byte[] copy = new byte[len]; [EOL]     System.arraycopy(data, offset, copy, 0, len); [EOL]     writeObject(copy); [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     byte[] copy = new byte[len]; [EOL]     System.arraycopy(data, offset, copy, 0, len); [EOL]     writeObject(copy); [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     byte[] copy = new byte[len]; [EOL]     System.arraycopy(data, offset, copy, 0, len); [EOL]     writeObject(copy); [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     byte[] copy = new byte[len]; [EOL]     System.arraycopy(data, offset, copy, 0, len); [EOL]     writeObject(copy); [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     byte[] copy = new byte[len]; [EOL]     System.arraycopy(data, offset, copy, 0, len); [EOL]     writeObject(copy); [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
protected final void _append(JsonToken type) { [EOL]     Segment next = _last.append(_appendOffset, type); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] }
protected final void _append(JsonToken type) { [EOL]     Segment next = _last.append(_appendOffset, type); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] }
protected final void _append(JsonToken type, Object value) { [EOL]     Segment next = _last.append(_appendOffset, type, value); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] }
protected final void _append(JsonToken type, Object value) { [EOL]     Segment next = _last.append(_appendOffset, type, value); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] }
public Parser(Segment firstSeg, ObjectCodec codec) { [EOL]     super(0); [EOL]     _segment = firstSeg; [EOL]     _segmentPtr = -1; [EOL]     _codec = codec; [EOL]     _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL] }
public Parser(Segment firstSeg, ObjectCodec codec) { [EOL]     super(0); [EOL]     _segment = firstSeg; [EOL]     _segmentPtr = -1; [EOL]     _codec = codec; [EOL]     _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]     } [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonStreamContext getParsingContext() { [EOL]     return _parsingContext; [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof String) { [EOL]             return (String) ob; [EOL]         } [EOL]         return (ob == null) ? null : ob.toString(); [EOL]     } [EOL]     if (_currToken == null) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             Object ob = _currentObject(); [EOL]             return (ob == null) ? null : ob.toString(); [EOL]         default: [EOL]             return _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof String) { [EOL]             return (String) ob; [EOL]         } [EOL]         return (ob == null) ? null : ob.toString(); [EOL]     } [EOL]     if (_currToken == null) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             Object ob = _currentObject(); [EOL]             return (ob == null) ? null : ob.toString(); [EOL]         default: [EOL]             return _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public char[] getTextCharacters() { [EOL]     String str = getText(); [EOL]     return (str == null) ? null : str.toCharArray(); [EOL] }
@Override [EOL] public int getTextLength() { [EOL]     String str = getText(); [EOL]     return (str == null) ? 0 : str.length(); [EOL] }
@Override [EOL] public int getTextLength() { [EOL]     String str = getText(); [EOL]     return (str == null) ? 0 : str.length(); [EOL] }
@Override [EOL] public int getTextOffset() { [EOL]     return 0; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         return ((Number) _currentObject()).intValue(); [EOL]     } [EOL]     return getNumberValue().intValue(); [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         return ((Number) _currentObject()).intValue(); [EOL]     } [EOL]     return getNumberValue().intValue(); [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] }
@Override [EOL] public final Number getNumberValue() throws IOException, JsonParseException { [EOL]     _checkIsNumber(); [EOL]     return (Number) _currentObject(); [EOL] }
@Override [EOL] public final Number getNumberValue() throws IOException, JsonParseException { [EOL]     _checkIsNumber(); [EOL]     return (Number) _currentObject(); [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return _currentObject(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (_currToken != JsonToken.VALUE_STRING) { [EOL]         throw _constructError("Current token (" + _currToken + ") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary"); [EOL]     } [EOL]     final String str = getText(); [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     ByteArrayBuilder builder = _byteBuilder; [EOL]     if (builder == null) { [EOL]         _byteBuilder = builder = new ByteArrayBuilder(100); [EOL]     } else { [EOL]         _byteBuilder.reset(); [EOL]     } [EOL]     _decodeBase64(str, builder, b64variant); [EOL]     return builder.toByteArray(); [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (_currToken != JsonToken.VALUE_STRING) { [EOL]         throw _constructError("Current token (" + _currToken + ") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary"); [EOL]     } [EOL]     final String str = getText(); [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     ByteArrayBuilder builder = _byteBuilder; [EOL]     if (builder == null) { [EOL]         _byteBuilder = builder = new ByteArrayBuilder(100); [EOL]     } else { [EOL]         _byteBuilder.reset(); [EOL]     } [EOL]     _decodeBase64(str, builder, b64variant); [EOL]     return builder.toByteArray(); [EOL] }
protected final Object _currentObject() { [EOL]     return _segment.get(_segmentPtr); [EOL] }
protected final void _checkIsNumber() throws JsonParseException { [EOL]     if (_currToken == null || !_currToken.isNumeric()) { [EOL]         throw _constructError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL] }
protected final void _checkIsNumber() throws JsonParseException { [EOL]     if (_currToken == null || !_currToken.isNumeric()) { [EOL]         throw _constructError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL] }
protected final void _checkIsNumber() throws JsonParseException { [EOL]     if (_currToken == null || !_currToken.isNumeric()) { [EOL]         throw _constructError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL] }
public Segment() { [EOL] }
public JsonToken type(int index) { [EOL]     long l = _tokenTypes; [EOL]     if (index > 0) { [EOL]         l >>= (index << 2); [EOL]     } [EOL]     int ix = ((int) l) & 0xF; [EOL]     return TOKEN_TYPES_BY_INDEX[ix]; [EOL] }
public JsonToken type(int index) { [EOL]     long l = _tokenTypes; [EOL]     if (index > 0) { [EOL]         l >>= (index << 2); [EOL]     } [EOL]     int ix = ((int) l) & 0xF; [EOL]     return TOKEN_TYPES_BY_INDEX[ix]; [EOL] }
public JsonToken type(int index) { [EOL]     long l = _tokenTypes; [EOL]     if (index > 0) { [EOL]         l >>= (index << 2); [EOL]     } [EOL]     int ix = ((int) l) & 0xF; [EOL]     return TOKEN_TYPES_BY_INDEX[ix]; [EOL] }
public Object get(int index) { [EOL]     return _tokens[index]; [EOL] }
public Object get(int index) { [EOL]     return _tokens[index]; [EOL] }
public Object get(int index) { [EOL]     return _tokens[index]; [EOL] }
public Segment next() { [EOL]     return _next; [EOL] }
public Segment next() { [EOL]     return _next; [EOL] }
public Segment append(int index, JsonToken tokenType) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, tokenType); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, tokenType); [EOL]     return _next; [EOL] }
public Segment append(int index, JsonToken tokenType) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, tokenType); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, tokenType); [EOL]     return _next; [EOL] }
public Segment append(int index, JsonToken tokenType, Object value) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, tokenType, value); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, tokenType, value); [EOL]     return _next; [EOL] }
public Segment append(int index, JsonToken tokenType, Object value) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, tokenType, value); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, tokenType, value); [EOL]     return _next; [EOL] }
public void set(int index, JsonToken tokenType) { [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] }
public void set(int index, JsonToken tokenType) { [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] }
public void set(int index, JsonToken tokenType, Object value) { [EOL]     _tokens[index] = value; [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] }
public void set(int index, JsonToken tokenType, Object value) { [EOL]     _tokens[index] = value; [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof Date) { [EOL]         provider.defaultSerializeDateKey((Date) value, jgen); [EOL]     } else { [EOL]         jgen.writeFieldName(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof Date) { [EOL]         provider.defaultSerializeDateKey((Date) value, jgen); [EOL]     } else { [EOL]         jgen.writeFieldName(value.toString()); [EOL]     } [EOL] }
public JavaType forcedNarrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType forcedNarrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType forcedNarrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public POJONode(Object v) { [EOL]     _value = v; [EOL] }
public POJONode(Object v) { [EOL]     _value = v; [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.POJO; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_EMBEDDED_OBJECT; [EOL] }
@Override [EOL] public byte[] binaryValue() throws IOException { [EOL]     if (_value instanceof byte[]) { [EOL]         return (byte[]) _value; [EOL]     } [EOL]     return super.binaryValue(); [EOL] }
@Override [EOL] public byte[] binaryValue() throws IOException { [EOL]     if (_value instanceof byte[]) { [EOL]         return (byte[]) _value; [EOL]     } [EOL]     return super.binaryValue(); [EOL] }
public Object getPojo() { [EOL]     return _value; [EOL] }
@Override [EOL] public JsonParser traverse() { [EOL]     return new TreeTraversingParser(this); [EOL] }
public ObjectMapper() { [EOL]     this(null, null, null); [EOL] }
public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { [EOL]     if (jf == null) { [EOL]         _jsonFactory = new MappingJsonFactory(this); [EOL]     } else { [EOL]         _jsonFactory = jf; [EOL]         if (jf.getCodec() == null) { [EOL]             _jsonFactory.setCodec(this); [EOL]         } [EOL]     } [EOL]     _subtypeResolver = new StdSubtypeResolver(); [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = TypeFactory.defaultInstance(); [EOL]     _serializationConfig = new SerializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _deserializationConfig = new DeserializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; [EOL]     _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; [EOL]     _serializerFactory = BeanSerializerFactory.instance; [EOL] }
public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { [EOL]     if (jf == null) { [EOL]         _jsonFactory = new MappingJsonFactory(this); [EOL]     } else { [EOL]         _jsonFactory = jf; [EOL]         if (jf.getCodec() == null) { [EOL]             _jsonFactory.setCodec(this); [EOL]         } [EOL]     } [EOL]     _subtypeResolver = new StdSubtypeResolver(); [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = TypeFactory.defaultInstance(); [EOL]     _serializationConfig = new SerializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _deserializationConfig = new DeserializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; [EOL]     _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; [EOL]     _serializerFactory = BeanSerializerFactory.instance; [EOL] }
public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { [EOL]     if (jf == null) { [EOL]         _jsonFactory = new MappingJsonFactory(this); [EOL]     } else { [EOL]         _jsonFactory = jf; [EOL]         if (jf.getCodec() == null) { [EOL]             _jsonFactory.setCodec(this); [EOL]         } [EOL]     } [EOL]     _subtypeResolver = new StdSubtypeResolver(); [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = TypeFactory.defaultInstance(); [EOL]     _serializationConfig = new SerializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _deserializationConfig = new DeserializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; [EOL]     _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; [EOL]     _serializerFactory = BeanSerializerFactory.instance; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public SerializationConfig getSerializationConfig() { [EOL]     return _serializationConfig; [EOL] }
public DeserializationConfig getDeserializationConfig() { [EOL]     return _deserializationConfig; [EOL] }
public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) { [EOL]     _mixInAnnotations.clear(); [EOL]     if (sourceMixins != null && sourceMixins.size() > 0) { [EOL]         for (Map.Entry<Class<?>, Class<?>> en : sourceMixins.entrySet()) { [EOL]             _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue()); [EOL]         } [EOL]     } [EOL] }
public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) { [EOL]     _mixInAnnotations.clear(); [EOL]     if (sourceMixins != null && sourceMixins.size() > 0) { [EOL]         for (Map.Entry<Class<?>, Class<?>> en : sourceMixins.entrySet()) { [EOL]             _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue()); [EOL]         } [EOL]     } [EOL] }
public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) { [EOL]     _mixInAnnotations.clear(); [EOL]     if (sourceMixins != null && sourceMixins.size() > 0) { [EOL]         for (Map.Entry<Class<?>, Class<?>> en : sourceMixins.entrySet()) { [EOL]             _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue()); [EOL]         } [EOL]     } [EOL] }
public VisibilityChecker<?> getVisibilityChecker() { [EOL]     return _serializationConfig.getDefaultVisibilityChecker(); [EOL] }
public void setVisibilityChecker(VisibilityChecker<?> vc) { [EOL]     _deserializationConfig = _deserializationConfig.with(vc); [EOL]     _serializationConfig = _serializationConfig.with(vc); [EOL] }
public void setVisibilityChecker(VisibilityChecker<?> vc) { [EOL]     _deserializationConfig = _deserializationConfig.with(vc); [EOL]     _serializationConfig = _serializationConfig.with(vc); [EOL] }
public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility); [EOL]     _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility); [EOL]     return this; [EOL] }
public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility); [EOL]     _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility); [EOL]     return this; [EOL] }
public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility); [EOL]     _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility); [EOL]     return this; [EOL] }
public TypeFactory getTypeFactory() { [EOL]     return _typeFactory; [EOL] }
public ObjectMapper setTypeFactory(TypeFactory f) { [EOL]     _typeFactory = f; [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public ObjectMapper setTypeFactory(TypeFactory f) { [EOL]     _typeFactory = f; [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public ObjectMapper setNodeFactory(JsonNodeFactory f) { [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     return this; [EOL] }
@Override [EOL] public JsonFactory getFactory() { [EOL]     return _jsonFactory; [EOL] }
public ObjectMapper setDateFormat(DateFormat dateFormat) { [EOL]     _deserializationConfig = _deserializationConfig.with(dateFormat); [EOL]     _serializationConfig = _serializationConfig.with(dateFormat); [EOL]     return this; [EOL] }
public ObjectMapper setDateFormat(DateFormat dateFormat) { [EOL]     _deserializationConfig = _deserializationConfig.with(dateFormat); [EOL]     _serializationConfig = _serializationConfig.with(dateFormat); [EOL]     return this; [EOL] }
public ObjectMapper setTimeZone(TimeZone tz) { [EOL]     _deserializationConfig = _deserializationConfig.with(tz); [EOL]     _serializationConfig = _serializationConfig.with(tz); [EOL]     return this; [EOL] }
public ObjectMapper setTimeZone(TimeZone tz) { [EOL]     _deserializationConfig = _deserializationConfig.with(tz); [EOL]     _serializationConfig = _serializationConfig.with(tz); [EOL]     return this; [EOL] }
public ObjectMapper configure(SerializationFeature f, boolean state) { [EOL]     _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper disable(MapperFeature... f) { [EOL]     _deserializationConfig = _deserializationConfig.without(f); [EOL]     _serializationConfig = _serializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper disable(MapperFeature... f) { [EOL]     _deserializationConfig = _deserializationConfig.without(f); [EOL]     _serializationConfig = _serializationConfig.without(f); [EOL]     return this; [EOL] }
public boolean isEnabled(SerializationFeature f) { [EOL]     return _serializationConfig.isEnabled(f); [EOL] }
public boolean isEnabled(SerializationFeature f) { [EOL]     return _serializationConfig.isEnabled(f); [EOL] }
public JsonNodeFactory getNodeFactory() { [EOL]     return _deserializationConfig.getNodeFactory(); [EOL] }
public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig config = getDeserializationConfig(); [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, config); [EOL]     JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType); [EOL]     return new MappingIterator<T>(valueType, jp, ctxt, deser, false, null); [EOL] }
public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig config = getDeserializationConfig(); [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, config); [EOL]     JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType); [EOL]     return new MappingIterator<T>(valueType, jp, ctxt, deser, false, null); [EOL] }
public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig config = getDeserializationConfig(); [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, config); [EOL]     JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType); [EOL]     return new MappingIterator<T>(valueType, jp, ctxt, deser, false, null); [EOL] }
@Override [EOL] public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException { [EOL]     return readValues(jp, _typeFactory.constructType(valueType)); [EOL] }
@Override [EOL] public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException { [EOL]     return readValues(jp, _typeFactory.constructType(valueType)); [EOL] }
@Override [EOL] public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType) throws IOException, JsonProcessingException { [EOL]     return readValues(jp, _typeFactory.constructType(valueType)); [EOL] }
public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     _serializerProvider(config).serializeValue(jgen, rootNode); [EOL]     if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]         jgen.flush(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { [EOL]     try { [EOL]         if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { [EOL]             return (T) n; [EOL]         } [EOL]         return readValue(treeAsTokens(n), valueType); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String content, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType)); [EOL] }
public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(w), value); [EOL] }
public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(w), value); [EOL] }
public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(w), value); [EOL] }
public ObjectWriter writerWithType(JavaType rootType) { [EOL]     return new ObjectWriter(this, getSerializationConfig(), rootType, null); [EOL] }
public ObjectWriter writerWithType(JavaType rootType) { [EOL]     return new ObjectWriter(this, getSerializationConfig(), rootType, null); [EOL] }
public ObjectWriter writer(FormatSchema schema) { [EOL]     _verifySchemaType(schema); [EOL]     return new ObjectWriter(this, getSerializationConfig(), schema); [EOL] }
public ObjectWriter writer(FormatSchema schema) { [EOL]     _verifySchemaType(schema); [EOL]     return new ObjectWriter(this, getSerializationConfig(), schema); [EOL] }
public ObjectReader readerForUpdating(Object valueToUpdate) { [EOL]     JavaType t = _typeFactory.constructType(valueToUpdate.getClass()); [EOL]     return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate, null, _injectableValues); [EOL] }
public ObjectReader readerForUpdating(Object valueToUpdate) { [EOL]     JavaType t = _typeFactory.constructType(valueToUpdate.getClass()); [EOL]     return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate, null, _injectableValues); [EOL] }
public ObjectReader reader(JavaType type) { [EOL]     return new ObjectReader(this, getDeserializationConfig(), type, null, null, _injectableValues); [EOL] }
public ObjectReader reader(JavaType type) { [EOL]     return new ObjectReader(this, getDeserializationConfig(), type, null, null, _injectableValues); [EOL] }
public ObjectReader reader(Class<?> type) { [EOL]     return reader(_typeFactory.constructType(type)); [EOL] }
public ObjectReader reader(Class<?> type) { [EOL]     return reader(_typeFactory.constructType(type)); [EOL] }
protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { [EOL]     return _serializerProvider.createInstance(config, _serializerFactory); [EOL] }
protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { [EOL]     return _serializerProvider.createInstance(config, _serializerFactory); [EOL] }
protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { [EOL]     return _deserializationContext.createInstance(cfg, jp, _injectableValues); [EOL] }
protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { [EOL]     return _deserializationContext.createInstance(cfg, jp, _injectableValues); [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, "No content to map due to end-of-input"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] }
protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, "No content to map due to end-of-input"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] }
protected JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, "No content to map due to end-of-input"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
private BooleanNode(boolean v) { [EOL]     _value = v; [EOL] }
private BooleanNode(boolean v) { [EOL]     _value = v; [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     return _value ? 1 : 0; [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     return _value ? 1 : 0; [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeBoolean(_value); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeBoolean(_value); [EOL] }
public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2) { [EOL]     return new Chained(t1, t2); [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2) { [EOL]     return new Chained(t1, t2); [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2) { [EOL]     return new Chained(t1, t2); [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public Chained(NameTransformer t1, NameTransformer t2) { [EOL]     _t1 = t1; [EOL]     _t2 = t2; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public Chained(NameTransformer t1, NameTransformer t2) { [EOL]     _t1 = t1; [EOL]     _t2 = t2; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public Chained(NameTransformer t1, NameTransformer t2) { [EOL]     _t1 = t1; [EOL]     _t2 = t2; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public Chained(NameTransformer t1, NameTransformer t2) { [EOL]     _t1 = t1; [EOL]     _t2 = t2; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
@Override [EOL] public String transform(String name) { [EOL]     return _t1.transform(_t2.transform(name)); [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
@Override [EOL] public String transform(String name) { [EOL]     return _t1.transform(_t2.transform(name)); [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
@Override [EOL] public String transform(String name) { [EOL]     return _t1.transform(_t2.transform(name)); [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return (deserializer != null && deserializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return (deserializer != null && deserializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return (deserializer != null && deserializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String value = jp.getValueAsString(); [EOL]     if (value != null) { [EOL]         return value; [EOL]     } [EOL]     throw ctxt.mappingException(String.class, jp.getCurrentToken()); [EOL] }
protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String value = jp.getValueAsString(); [EOL]     if (value != null) { [EOL]         return value; [EOL]     } [EOL]     throw ctxt.mappingException(String.class, jp.getCurrentToken()); [EOL] }
@Override [EOL] public SerializationConfig with(TypeResolverBuilder<?> trb) { [EOL]     return _withBase(_base.withTypeResolverBuilder(trb)); [EOL] }
@Override [EOL] public SerializationConfig with(TypeResolverBuilder<?> trb) { [EOL]     return _withBase(_base.withTypeResolverBuilder(trb)); [EOL] }
@Override [EOL] public SerializationConfig with(VisibilityChecker<?> vc) { [EOL]     return _withBase(_base.withVisibilityChecker(vc)); [EOL] }
@Override [EOL] public SerializationConfig with(VisibilityChecker<?> vc) { [EOL]     return _withBase(_base.withVisibilityChecker(vc)); [EOL] }
@Override [EOL] public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     return _withBase(_base.withVisibility(forMethod, visibility)); [EOL] }
@Override [EOL] public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     return _withBase(_base.withVisibility(forMethod, visibility)); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public URIDeserializer() { [EOL]     super(URI.class); [EOL] }
@Override [EOL] protected URI _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return URI.create(value); [EOL] }
@Override [EOL] protected URI _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return URI.create(value); [EOL] }
public CurrencyDeserializer() { [EOL]     super(Currency.class); [EOL] }
@Override [EOL] protected Currency _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return Currency.getInstance(value); [EOL] }
@Override [EOL] protected Currency _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return Currency.getInstance(value); [EOL] }
public PatternDeserializer() { [EOL]     super(Pattern.class); [EOL] }
@Override [EOL] protected Pattern _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return Pattern.compile(value); [EOL] }
@Override [EOL] protected Pattern _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return Pattern.compile(value); [EOL] }
public FileDeserializer() { [EOL]     super(File.class); [EOL] }
@Override [EOL] protected File _deserialize(String value, DeserializationContext ctxt) { [EOL]     return new File(value); [EOL] }
@Override [EOL] public AsPropertyTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName); [EOL] }
@Override [EOL] public AsPropertyTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName); [EOL] }
@Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeStringField(_typePropertyName, idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeStringField(_typePropertyName, idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL] }
protected FieldProperty(FieldProperty src, Field f) { [EOL]     super(src); [EOL]     _annotated = src._annotated; [EOL]     if (f == null) { [EOL]         throw new IllegalArgumentException("No Field passed for property '" + src.getName() + "' (class " + src.getDeclaringClass().getName() + ")"); [EOL]     } [EOL]     _field = f; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _field.set(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL]     return instance; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _field.set(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL]     return instance; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _field.set(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL]     return instance; [EOL] }
Object readResolve() { [EOL]     return new FieldProperty(this, _annotated.getAnnotated()); [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src) { [EOL]     this(src, src._ignoreAllUnknown); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
public SettableBeanProperty findBackReference(String logicalName) { [EOL]     if (_backRefs == null) { [EOL]         return null; [EOL]     } [EOL]     return _backRefs.get(logicalName); [EOL] }
public SettableBeanProperty findBackReference(String logicalName) { [EOL]     if (_backRefs == null) { [EOL]         return null; [EOL]     } [EOL]     return _backRefs.get(logicalName); [EOL] }
public SettableBeanProperty findBackReference(String logicalName) { [EOL]     if (_backRefs == null) { [EOL]         return null; [EOL]     } [EOL]     return _backRefs.get(logicalName); [EOL] }
protected void injectValues(DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (ValueInjector injector : _injectables) { [EOL]         injector.inject(ctxt, bean); [EOL]     } [EOL] }
protected void injectValues(DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (ValueInjector injector : _injectables) { [EOL]         injector.inject(ctxt, bean); [EOL]     } [EOL] }
protected void injectValues(DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (ValueInjector injector : _injectables) { [EOL]         injector.inject(ctxt, bean); [EOL]     } [EOL] }
protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     unknownTokens.writeEndObject(); [EOL]     JsonParser bufferParser = unknownTokens.asParser(); [EOL]     while (bufferParser.nextToken() != JsonToken.END_OBJECT) { [EOL]         String propName = bufferParser.getCurrentName(); [EOL]         bufferParser.nextToken(); [EOL]         handleUnknownProperty(bufferParser, ctxt, bean, propName); [EOL]     } [EOL]     return bean; [EOL] }
protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     unknownTokens.writeEndObject(); [EOL]     JsonParser bufferParser = unknownTokens.asParser(); [EOL]     while (bufferParser.nextToken() != JsonToken.END_OBJECT) { [EOL]         String propName = bufferParser.getCurrentName(); [EOL]         bufferParser.nextToken(); [EOL]         handleUnknownProperty(bufferParser, ctxt, bean, propName); [EOL]     } [EOL]     return bean; [EOL] }
protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     unknownTokens.writeEndObject(); [EOL]     JsonParser bufferParser = unknownTokens.asParser(); [EOL]     while (bufferParser.nextToken() != JsonToken.END_OBJECT) { [EOL]         String propName = bufferParser.getCurrentName(); [EOL]         bufferParser.nextToken(); [EOL]         handleUnknownProperty(bufferParser, ctxt, bean, propName); [EOL]     } [EOL]     return bean; [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         throw (IOException) t; [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw ctxt.instantiationException(_beanType.getRawClass(), t); [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL]     if (refs != null) { [EOL]         for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL]             String name = en.getKey(); [EOL]             AnnotatedMember m = en.getValue(); [EOL]             Type genericType; [EOL]             if (m instanceof AnnotatedMethod) { [EOL]                 genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL]             } else { [EOL]                 genericType = m.getRawType(); [EOL]             } [EOL]             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL]             builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL]     if (refs != null) { [EOL]         for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL]             String name = en.getKey(); [EOL]             AnnotatedMember m = en.getValue(); [EOL]             Type genericType; [EOL]             if (m instanceof AnnotatedMethod) { [EOL]                 genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL]             } else { [EOL]                 genericType = m.getRawType(); [EOL]             } [EOL]             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL]             builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL]     if (refs != null) { [EOL]         for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL]             String name = en.getKey(); [EOL]             AnnotatedMember m = en.getValue(); [EOL]             Type genericType; [EOL]             if (m instanceof AnnotatedMethod) { [EOL]                 genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL]             } else { [EOL]                 genericType = m.getRawType(); [EOL]             } [EOL]             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL]             builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<Object, AnnotatedMember> raw = beanDesc.findInjectables(); [EOL]     if (raw != null) { [EOL]         boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]         for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) { [EOL]             AnnotatedMember m = entry.getValue(); [EOL]             if (fixAccess) { [EOL]                 m.fixAccess(); [EOL]             } [EOL]             builder.addInjectable(m.getName(), beanDesc.resolveType(m.getGenericType()), beanDesc.getClassAnnotations(), m, entry.getKey()); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL]     AnnotatedMember mutator = propDef.getMutator(); [EOL]     if (ctxt.canOverrideAccessModifiers()) { [EOL]         mutator.fixAccess(); [EOL]     } [EOL]     JavaType t0 = beanDesc.resolveType(jdkType); [EOL]     BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL]     type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL]     TypeDeserializer typeDeser = type.getTypeHandler(); [EOL]     SettableBeanProperty prop; [EOL]     if (mutator instanceof AnnotatedMethod) { [EOL]         prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL]     } else { [EOL]         prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL]     } [EOL]     if (propDeser != null) { [EOL]         prop = prop.withValueDeserializer(propDeser); [EOL]     } [EOL]     AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL]     if (ref != null && ref.isManagedReference()) { [EOL]         prop.setManagedReferenceName(ref.getName()); [EOL]     } [EOL]     return prop; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL]             JavaType keyType = type.getKeyType(); [EOL]             EnumValues enums = null; [EOL]             if (keyType.isEnumType()) { [EOL]                 @SuppressWarnings("unchecked") [EOL]                 Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL]                 enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL]             } [EOL]             ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL]         } else { [EOL]             ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL]             JavaType keyType = type.getKeyType(); [EOL]             EnumValues enums = null; [EOL]             if (keyType.isEnumType()) { [EOL]                 @SuppressWarnings("unchecked") [EOL]                 Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL]                 enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL]             } [EOL]             ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL]         } else { [EOL]             ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL]             JavaType keyType = type.getKeyType(); [EOL]             EnumValues enums = null; [EOL]             if (keyType.isEnumType()) { [EOL]                 @SuppressWarnings("unchecked") [EOL]                 Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL]                 enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL]             } [EOL]             ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL]         } else { [EOL]             ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]             if (String[].class == raw) { [EOL]                 ser = StringArraySerializer.instance; [EOL]             } else { [EOL]                 ser = StdArraySerializers.findStandardImpl(raw); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); [EOL]     if (superclass != null) { [EOL]         try { [EOL]             type = (T) type.widenBy(superclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new IllegalArgumentException("Failed to widen type " + type + " with concrete-type annotation (value " + superclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage()); [EOL]         } [EOL]     } [EOL]     return modifySecondaryTypesByAnnotation(config, a, type); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations) { [EOL]     _class = cls; [EOL]     _superTypes = superTypes; [EOL]     _annotationIntrospector = aintr; [EOL]     _mixInResolver = mir; [EOL]     _primaryMixIn = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(_class); [EOL]     _classAnnotations = classAnnotations; [EOL] }
private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations) { [EOL]     _class = cls; [EOL]     _superTypes = superTypes; [EOL]     _annotationIntrospector = aintr; [EOL]     _mixInResolver = mir; [EOL]     _primaryMixIn = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(_class); [EOL]     _classAnnotations = classAnnotations; [EOL] }
public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) { [EOL]     return new AnnotatedClass(cls, ClassUtil.findSuperTypes(cls, null), aintr, mir, null); [EOL] }
public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) { [EOL]     return new AnnotatedClass(cls, ClassUtil.findSuperTypes(cls, null), aintr, mir, null); [EOL] }
public boolean hasAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.size() > 0; [EOL] }
public boolean hasAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.size() > 0; [EOL] }
public boolean hasAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.size() > 0; [EOL] }
public int getFieldCount() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields.size(); [EOL] }
public int getFieldCount() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields.size(); [EOL] }
public Iterable<AnnotatedField> fields() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields; [EOL] }
public Iterable<AnnotatedField> fields() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields; [EOL] }
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] }
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] }
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] }
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFactoryMixIns(Class<?> mixin) { [EOL]     MemberKey[] methodKeys = null; [EOL]     int methodCount = _creatorMethods.size(); [EOL]     for (Method m : mixin.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (m.getParameterTypes().length == 0) { [EOL]             continue; [EOL]         } [EOL]         if (methodKeys == null) { [EOL]             methodKeys = new MemberKey[methodCount]; [EOL]             for (int i = 0; i < methodCount; ++i) { [EOL]                 methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated()); [EOL]             } [EOL]         } [EOL]         MemberKey key = new MemberKey(m); [EOL]         for (int i = 0; i < methodCount; ++i) { [EOL]             if (!key.equals(methodKeys[i])) { [EOL]                 continue; [EOL]             } [EOL]             _addMixOvers(m, _creatorMethods.get(i), true); [EOL]             break; [EOL]         } [EOL]     } [EOL] }
protected void _addFactoryMixIns(Class<?> mixin) { [EOL]     MemberKey[] methodKeys = null; [EOL]     int methodCount = _creatorMethods.size(); [EOL]     for (Method m : mixin.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (m.getParameterTypes().length == 0) { [EOL]             continue; [EOL]         } [EOL]         if (methodKeys == null) { [EOL]             methodKeys = new MemberKey[methodCount]; [EOL]             for (int i = 0; i < methodCount; ++i) { [EOL]                 methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated()); [EOL]             } [EOL]         } [EOL]         MemberKey key = new MemberKey(m); [EOL]         for (int i = 0; i < methodCount; ++i) { [EOL]             if (!key.equals(methodKeys[i])) { [EOL]                 continue; [EOL]             } [EOL]             _addMixOvers(m, _creatorMethods.get(i), true); [EOL]             break; [EOL]         } [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected AnnotatedField _constructField(Field f) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedField(f, _emptyAnnotationMap()); [EOL]     } [EOL]     return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations())); [EOL] }
protected AnnotatedField _constructField(Field f) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedField(f, _emptyAnnotationMap()); [EOL]     } [EOL]     return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations())); [EOL] }
private boolean _isIncludableField(Field f) { [EOL]     if (f.isSynthetic()) { [EOL]         return false; [EOL]     } [EOL]     int mods = f.getModifiers(); [EOL]     if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean _isIncludableField(Field f) { [EOL]     if (f.isSynthetic()) { [EOL]         return false; [EOL]     } [EOL]     int mods = f.getModifiers(); [EOL]     if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns) { [EOL]     AnnotationMap annMap = new AnnotationMap(); [EOL]     _addAnnotationsIfNotPresent(annMap, anns); [EOL]     return annMap; [EOL] }
protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns) { [EOL]     AnnotationMap annMap = new AnnotationMap(); [EOL]     _addAnnotationsIfNotPresent(annMap, anns); [EOL]     return annMap; [EOL] }
protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns) { [EOL]     AnnotationMap annMap = new AnnotationMap(); [EOL]     _addAnnotationsIfNotPresent(annMap, anns); [EOL]     return annMap; [EOL] }
private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 result.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(result, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 result.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(result, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 result.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(result, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 result.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(result, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final boolean _isAnnotationBundle(Annotation ann) { [EOL]     return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann); [EOL] }
private final boolean _isAnnotationBundle(Annotation ann) { [EOL]     return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann); [EOL] }
private final boolean _isAnnotationBundle(Annotation ann) { [EOL]     return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann); [EOL] }
protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     _baseType = baseType; [EOL]     _idResolver = idRes; [EOL]     _typePropertyName = typePropertyName; [EOL]     _typeIdVisible = typeIdVisible; [EOL]     _deserializers = new HashMap<String, JsonDeserializer<Object>>(); [EOL]     if (defaultImpl == null) { [EOL]         _defaultImpl = null; [EOL]     } else { [EOL]         _defaultImpl = baseType.forcedNarrowBy(defaultImpl); [EOL]     } [EOL]     _property = null; [EOL] }
protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     _baseType = baseType; [EOL]     _idResolver = idRes; [EOL]     _typePropertyName = typePropertyName; [EOL]     _typeIdVisible = typeIdVisible; [EOL]     _deserializers = new HashMap<String, JsonDeserializer<Object>>(); [EOL]     if (defaultImpl == null) { [EOL]         _defaultImpl = null; [EOL]     } else { [EOL]         _defaultImpl = baseType.forcedNarrowBy(defaultImpl); [EOL]     } [EOL]     _property = null; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
public EnumDeserializer(EnumResolver<?> res) { [EOL]     super(Enum.class); [EOL]     _resolver = res; [EOL] }
public EnumDeserializer(EnumResolver<?> res) { [EOL]     super(Enum.class); [EOL]     _resolver = res; [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected StringCollectionSerializer() { [EOL]     this(null); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StringCollectionSerializer(JsonSerializer<?> ser) { [EOL]     super(Collection.class); [EOL]     _serializer = (JsonSerializer<String>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StringCollectionSerializer(JsonSerializer<?> ser) { [EOL]     super(Collection.class); [EOL]     _serializer = (JsonSerializer<String>) ser; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionSerializer(ser); [EOL] }
@Override [EOL] public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForArray(value, jgen); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL]     typeSer.writeTypeSuffixForArray(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForArray(value, jgen); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL]     typeSer.writeTypeSuffixForArray(value, jgen); [EOL] }
private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer != null) { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     for (String str : value) { [EOL]         try { [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]             ++i; [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer != null) { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     for (String str : value) { [EOL]         try { [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]             ++i; [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer != null) { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     for (String str : value) { [EOL]         try { [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]             ++i; [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) { [EOL]     if (_visibilityChecker == vc) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) { [EOL]     if (_visibilityChecker == vc) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker.withVisibility(forMethod, visibility), _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) { [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker.withVisibility(forMethod, visibility), _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withTypeFactory(TypeFactory tf) { [EOL]     if (_typeFactory == tf) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withTypeFactory(TypeFactory tf) { [EOL]     if (_typeFactory == tf) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withDateFormat(DateFormat df) { [EOL]     if (_dateFormat == df) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withDateFormat(DateFormat df) { [EOL]     if (_dateFormat == df) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings with(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     DateFormat df = _dateFormat; [EOL]     if (df instanceof StdDateFormat) { [EOL]         df = ((StdDateFormat) df).withTimeZone(tz); [EOL]     } else { [EOL]         df = (DateFormat) df.clone(); [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); [EOL] }
public BaseSettings with(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     DateFormat df = _dateFormat; [EOL]     if (df instanceof StdDateFormat) { [EOL]         df = ((StdDateFormat) df).withTimeZone(tz); [EOL]     } else { [EOL]         df = (DateFormat) df.clone(); [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); [EOL] }
public BaseSettings with(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     DateFormat df = _dateFormat; [EOL]     if (df instanceof StdDateFormat) { [EOL]         df = ((StdDateFormat) df).withTimeZone(tz); [EOL]     } else { [EOL]         df = (DateFormat) df.clone(); [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); [EOL] }
public DateFormat getDateFormat() { [EOL]     return _dateFormat; [EOL] }
public TimeZone getTimeZone() { [EOL]     return _timeZone; [EOL] }
public TimeZone getTimeZone() { [EOL]     return _timeZone; [EOL] }
public ArrayBuilders() { [EOL] }
public IntBuilder getIntBuilder() { [EOL]     if (_intBuilder == null) { [EOL]         _intBuilder = new IntBuilder(); [EOL]     } [EOL]     return _intBuilder; [EOL] }
public IntBuilder getIntBuilder() { [EOL]     if (_intBuilder == null) { [EOL]         _intBuilder = new IntBuilder(); [EOL]     } [EOL]     return _intBuilder; [EOL] }
public FloatBuilder getFloatBuilder() { [EOL]     if (_floatBuilder == null) { [EOL]         _floatBuilder = new FloatBuilder(); [EOL]     } [EOL]     return _floatBuilder; [EOL] }
public FloatBuilder getFloatBuilder() { [EOL]     if (_floatBuilder == null) { [EOL]         _floatBuilder = new FloatBuilder(); [EOL]     } [EOL]     return _floatBuilder; [EOL] }
public IntBuilder() { [EOL] }
@Override [EOL] public final int[] _constructArray(int len) { [EOL]     return new int[len]; [EOL] }
public FloatBuilder() { [EOL] }
@Override [EOL] public final float[] _constructArray(int len) { [EOL]     return new float[len]; [EOL] }
@Override [EOL] public final float[] _constructArray(int len) { [EOL]     return new float[len]; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> setAndArray(Set<T> set, T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (set != null) { [EOL]         result.addAll(set); [EOL]     } [EOL]     if (elements != null) { [EOL]         for (T value : elements) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> setAndArray(Set<T> set, T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (set != null) { [EOL]         result.addAll(set); [EOL]     } [EOL]     if (elements != null) { [EOL]         for (T value : elements) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> setAndArray(Set<T> set, T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (set != null) { [EOL]         result.addAll(set); [EOL]     } [EOL]     if (elements != null) { [EOL]         for (T value : elements) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> setAndArray(Set<T> set, T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (set != null) { [EOL]         result.addAll(set); [EOL]     } [EOL]     if (elements != null) { [EOL]         for (T value : elements) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private UnwrappingBeanPropertyWriter(UnwrappingBeanPropertyWriter base, NameTransformer transformer, SerializedString name) { [EOL]     super(base, name); [EOL]     _nameTransformer = transformer; [EOL] }
private UnwrappingBeanPropertyWriter(UnwrappingBeanPropertyWriter base, NameTransformer transformer, SerializedString name) { [EOL]     super(base, name); [EOL]     _nameTransformer = transformer; [EOL] }
@Override [EOL] public UnwrappingBeanPropertyWriter rename(NameTransformer transformer) { [EOL]     String oldName = _name.getValue(); [EOL]     String newName = transformer.transform(oldName); [EOL]     transformer = NameTransformer.chainedTransformer(transformer, _nameTransformer); [EOL]     return new UnwrappingBeanPropertyWriter(this, transformer, new SerializedString(newName)); [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore) { [EOL]     super(src._handledType); [EOL]     HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore); [EOL]     final BeanPropertyWriter[] propsIn = src._props; [EOL]     final BeanPropertyWriter[] fpropsIn = src._filteredProps; [EOL]     final int len = propsIn.length; [EOL]     ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len); [EOL]     ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = propsIn[i]; [EOL]         if (ignoredSet.contains(bpw.getName())) { [EOL]             continue; [EOL]         } [EOL]         propsOut.add(bpw); [EOL]         if (fpropsIn != null) { [EOL]             fpropsOut.add(fpropsIn[i]); [EOL]         } [EOL]     } [EOL]     _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]); [EOL]     _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]); [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = src._objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore) { [EOL]     super(src._handledType); [EOL]     HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore); [EOL]     final BeanPropertyWriter[] propsIn = src._props; [EOL]     final BeanPropertyWriter[] fpropsIn = src._filteredProps; [EOL]     final int len = propsIn.length; [EOL]     ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len); [EOL]     ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = propsIn[i]; [EOL]         if (ignoredSet.contains(bpw.getName())) { [EOL]             continue; [EOL]         } [EOL]         propsOut.add(bpw); [EOL]         if (fpropsIn != null) { [EOL]             fpropsOut.add(fpropsIn[i]); [EOL]         } [EOL]     } [EOL]     _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]); [EOL]     _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]); [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = src._objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore) { [EOL]     super(src._handledType); [EOL]     HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore); [EOL]     final BeanPropertyWriter[] propsIn = src._props; [EOL]     final BeanPropertyWriter[] fpropsIn = src._filteredProps; [EOL]     final int len = propsIn.length; [EOL]     ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len); [EOL]     ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = propsIn[i]; [EOL]         if (ignoredSet.contains(bpw.getName())) { [EOL]             continue; [EOL]         } [EOL]         propsOut.add(bpw); [EOL]         if (fpropsIn != null) { [EOL]             fpropsOut.add(fpropsIn[i]); [EOL]         } [EOL]     } [EOL]     _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]); [EOL]     _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]); [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = src._objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore) { [EOL]     super(src._handledType); [EOL]     HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore); [EOL]     final BeanPropertyWriter[] propsIn = src._props; [EOL]     final BeanPropertyWriter[] fpropsIn = src._filteredProps; [EOL]     final int len = propsIn.length; [EOL]     ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len); [EOL]     ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = propsIn[i]; [EOL]         if (ignoredSet.contains(bpw.getName())) { [EOL]             continue; [EOL]         } [EOL]         propsOut.add(bpw); [EOL]         if (fpropsIn != null) { [EOL]             fpropsOut.add(fpropsIn[i]); [EOL]         } [EOL]     } [EOL]     _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]); [EOL]     _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]); [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = src._objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length; [EOL]     for (int i = 0, len = _props.length; i < len; ++i) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) { [EOL]             JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop); [EOL]             if (nullSer != null) { [EOL]                 prop.assignNullSerializer(nullSer); [EOL]                 if (i < filteredCount) { [EOL]                     BeanPropertyWriter w2 = _filteredProps[i]; [EOL]                     if (w2 != null) { [EOL]                         w2.assignNullSerializer(nullSer); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (prop.hasSerializer()) { [EOL]             continue; [EOL]         } [EOL]         JsonSerializer<Object> ser = findConvertingSerializer(provider, prop); [EOL]         if (ser == null) { [EOL]             JavaType type = prop.getSerializationType(); [EOL]             if (type == null) { [EOL]                 type = provider.constructType(prop.getGenericPropertyType()); [EOL]                 if (!type.isFinal()) { [EOL]                     if (type.isContainerType() || type.containedTypeCount() > 0) { [EOL]                         prop.setNonTrivialBaseType(type); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             ser = provider.findValueSerializer(type, prop); [EOL]             if (type.isContainerType()) { [EOL]                 TypeSerializer typeSer = type.getContentType().getTypeHandler(); [EOL]                 if (typeSer != null) { [EOL]                     if (ser instanceof ContainerSerializer<?>) { [EOL]                         @SuppressWarnings("unchecked") [EOL]                         JsonSerializer<Object> ser2 = (JsonSerializer<Object>) ((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer); [EOL]                         ser = ser2; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop.assignSerializer(ser); [EOL]         if (i < filteredCount) { [EOL]             BeanPropertyWriter w2 = _filteredProps[i]; [EOL]             if (w2 != null) { [EOL]                 w2.assignSerializer(ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anyGetterWriter != null) { [EOL]         _anyGetterWriter.resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length; [EOL]     for (int i = 0, len = _props.length; i < len; ++i) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) { [EOL]             JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop); [EOL]             if (nullSer != null) { [EOL]                 prop.assignNullSerializer(nullSer); [EOL]                 if (i < filteredCount) { [EOL]                     BeanPropertyWriter w2 = _filteredProps[i]; [EOL]                     if (w2 != null) { [EOL]                         w2.assignNullSerializer(nullSer); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (prop.hasSerializer()) { [EOL]             continue; [EOL]         } [EOL]         JsonSerializer<Object> ser = findConvertingSerializer(provider, prop); [EOL]         if (ser == null) { [EOL]             JavaType type = prop.getSerializationType(); [EOL]             if (type == null) { [EOL]                 type = provider.constructType(prop.getGenericPropertyType()); [EOL]                 if (!type.isFinal()) { [EOL]                     if (type.isContainerType() || type.containedTypeCount() > 0) { [EOL]                         prop.setNonTrivialBaseType(type); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             ser = provider.findValueSerializer(type, prop); [EOL]             if (type.isContainerType()) { [EOL]                 TypeSerializer typeSer = type.getContentType().getTypeHandler(); [EOL]                 if (typeSer != null) { [EOL]                     if (ser instanceof ContainerSerializer<?>) { [EOL]                         @SuppressWarnings("unchecked") [EOL]                         JsonSerializer<Object> ser2 = (JsonSerializer<Object>) ((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer); [EOL]                         ser = ser2; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop.assignSerializer(ser); [EOL]         if (i < filteredCount) { [EOL]             BeanPropertyWriter w2 = _filteredProps[i]; [EOL]             if (w2 != null) { [EOL]                 w2.assignSerializer(ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anyGetterWriter != null) { [EOL]         _anyGetterWriter.resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length; [EOL]     for (int i = 0, len = _props.length; i < len; ++i) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) { [EOL]             JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop); [EOL]             if (nullSer != null) { [EOL]                 prop.assignNullSerializer(nullSer); [EOL]                 if (i < filteredCount) { [EOL]                     BeanPropertyWriter w2 = _filteredProps[i]; [EOL]                     if (w2 != null) { [EOL]                         w2.assignNullSerializer(nullSer); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (prop.hasSerializer()) { [EOL]             continue; [EOL]         } [EOL]         JsonSerializer<Object> ser = findConvertingSerializer(provider, prop); [EOL]         if (ser == null) { [EOL]             JavaType type = prop.getSerializationType(); [EOL]             if (type == null) { [EOL]                 type = provider.constructType(prop.getGenericPropertyType()); [EOL]                 if (!type.isFinal()) { [EOL]                     if (type.isContainerType() || type.containedTypeCount() > 0) { [EOL]                         prop.setNonTrivialBaseType(type); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             ser = provider.findValueSerializer(type, prop); [EOL]             if (type.isContainerType()) { [EOL]                 TypeSerializer typeSer = type.getContentType().getTypeHandler(); [EOL]                 if (typeSer != null) { [EOL]                     if (ser instanceof ContainerSerializer<?>) { [EOL]                         @SuppressWarnings("unchecked") [EOL]                         JsonSerializer<Object> ser2 = (JsonSerializer<Object>) ((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer); [EOL]                         ser = ser2; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop.assignSerializer(ser); [EOL]         if (i < filteredCount) { [EOL]             BeanPropertyWriter w2 = _filteredProps[i]; [EOL]             if (w2 != null) { [EOL]                 w2.assignSerializer(ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anyGetterWriter != null) { [EOL]         _anyGetterWriter.resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length; [EOL]     for (int i = 0, len = _props.length; i < len; ++i) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) { [EOL]             JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop); [EOL]             if (nullSer != null) { [EOL]                 prop.assignNullSerializer(nullSer); [EOL]                 if (i < filteredCount) { [EOL]                     BeanPropertyWriter w2 = _filteredProps[i]; [EOL]                     if (w2 != null) { [EOL]                         w2.assignNullSerializer(nullSer); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (prop.hasSerializer()) { [EOL]             continue; [EOL]         } [EOL]         JsonSerializer<Object> ser = findConvertingSerializer(provider, prop); [EOL]         if (ser == null) { [EOL]             JavaType type = prop.getSerializationType(); [EOL]             if (type == null) { [EOL]                 type = provider.constructType(prop.getGenericPropertyType()); [EOL]                 if (!type.isFinal()) { [EOL]                     if (type.isContainerType() || type.containedTypeCount() > 0) { [EOL]                         prop.setNonTrivialBaseType(type); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             ser = provider.findValueSerializer(type, prop); [EOL]             if (type.isContainerType()) { [EOL]                 TypeSerializer typeSer = type.getContentType().getTypeHandler(); [EOL]                 if (typeSer != null) { [EOL]                     if (ser instanceof ContainerSerializer<?>) { [EOL]                         @SuppressWarnings("unchecked") [EOL]                         JsonSerializer<Object> ser2 = (JsonSerializer<Object>) ((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer); [EOL]                         ser = ser2; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop.assignSerializer(ser); [EOL]         if (i < filteredCount) { [EOL]             BeanPropertyWriter w2 = _filteredProps[i]; [EOL]             if (w2 != null) { [EOL]                 w2.assignSerializer(ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anyGetterWriter != null) { [EOL]         _anyGetterWriter.resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
public JsonSerializer<?> modifyMapSerializer(SerializationConfig config, MapType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) { [EOL]     return serializer; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (Duration.class.isAssignableFrom(raw) || QName.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     if (XMLGregorianCalendar.class.isAssignableFrom(raw)) { [EOL]         return XMLGregorianCalendarSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (Duration.class.isAssignableFrom(raw) || QName.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     if (XMLGregorianCalendar.class.isAssignableFrom(raw)) { [EOL]         return XMLGregorianCalendarSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (Duration.class.isAssignableFrom(raw) || QName.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     if (XMLGregorianCalendar.class.isAssignableFrom(raw)) { [EOL]         return XMLGregorianCalendarSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (Duration.class.isAssignableFrom(raw) || QName.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     if (XMLGregorianCalendar.class.isAssignableFrom(raw)) { [EOL]         return XMLGregorianCalendarSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public XMLGregorianCalendarSerializer() { [EOL]     super(XMLGregorianCalendar.class); [EOL] }
@Override [EOL] public void serialize(XMLGregorianCalendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     CalendarSerializer.instance.serialize(value.toGregorianCalendar(), jgen, provider); [EOL] }
@Override [EOL] public void serialize(XMLGregorianCalendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     CalendarSerializer.instance.serialize(value.toGregorianCalendar(), jgen, provider); [EOL] }
public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn) { [EOL]     if (viewsToIncludeIn.length == 1) { [EOL]         return new SingleView(base, viewsToIncludeIn[0]); [EOL]     } [EOL]     return new MultiView(base, viewsToIncludeIn); [EOL] }
public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn) { [EOL]     if (viewsToIncludeIn.length == 1) { [EOL]         return new SingleView(base, viewsToIncludeIn[0]); [EOL]     } [EOL]     return new MultiView(base, viewsToIncludeIn); [EOL] }
public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn) { [EOL]     if (viewsToIncludeIn.length == 1) { [EOL]         return new SingleView(base, viewsToIncludeIn[0]); [EOL]     } [EOL]     return new MultiView(base, viewsToIncludeIn); [EOL] }
protected SingleView(BeanPropertyWriter delegate, Class<?> view) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _view = view; [EOL] }
protected SingleView(BeanPropertyWriter delegate, Class<?> view) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _view = view; [EOL] }
protected SingleView(BeanPropertyWriter delegate, Class<?> view) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _view = view; [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsField(bean, jgen, prov); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsField(bean, jgen, prov); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsField(bean, jgen, prov); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsColumn(bean, jgen, prov); [EOL]     } else { [EOL]         _delegate.serializeAsPlaceholder(bean, jgen, prov); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsColumn(bean, jgen, prov); [EOL]     } else { [EOL]         _delegate.serializeAsPlaceholder(bean, jgen, prov); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView == null || _view.isAssignableFrom(activeView)) { [EOL]         _delegate.serializeAsColumn(bean, jgen, prov); [EOL]     } else { [EOL]         _delegate.serializeAsPlaceholder(bean, jgen, prov); [EOL]     } [EOL] }
public ObjectIdInfo getObjectIdInfo() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef); [EOL]     if (info != null) { [EOL]         info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info); [EOL]     } [EOL]     return info; [EOL] }
public ObjectIdInfo getObjectIdInfo() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef); [EOL]     if (info != null) { [EOL]         info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info); [EOL]     } [EOL]     return info; [EOL] }
public ObjectIdInfo getObjectIdInfo() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef); [EOL]     if (info != null) { [EOL]         info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info); [EOL]     } [EOL]     return info; [EOL] }
protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             return; [EOL]         } [EOL]         visible = _visibilityChecker.isSetterVisible(m); [EOL]     } else { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addSetter(m, explName, visible, ignore); [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingToString(Class<ET> enumCls) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (int i = enumValues.length; --i >= 0; ) { [EOL]         ET e = enumValues[i]; [EOL]         map.put(e.toString(), e); [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] }
public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingToString(Class<ET> enumCls) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (int i = enumValues.length; --i >= 0; ) { [EOL]         ET e = enumValues[i]; [EOL]         map.put(e.toString(), e); [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafeUsingToString(Class<?> rawEnumCls) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructUsingToString(enumCls); [EOL] }
public T getEnum(int index) { [EOL]     if (index < 0 || index >= _enums.length) { [EOL]         return null; [EOL]     } [EOL]     return _enums[index]; [EOL] }
public T getEnum(int index) { [EOL]     if (index < 0 || index >= _enums.length) { [EOL]         return null; [EOL]     } [EOL]     return _enums[index]; [EOL] }
public T getEnum(int index) { [EOL]     if (index < 0 || index >= _enums.length) { [EOL]         return null; [EOL]     } [EOL]     return _enums[index]; [EOL] }
public Class<T> getEnumClass() { [EOL]     return _enumClass; [EOL] }
protected StaticListSerializerBase(Class<?> cls) { [EOL]     super(cls, false); [EOL] }
@Override [EOL] public boolean isEmpty(T value) { [EOL]     return (value == null) || (value.size() == 0); [EOL] }
@Override [EOL] public boolean isEmpty(T value) { [EOL]     return (value == null) || (value.size() == 0); [EOL] }
@Override [EOL] public boolean isEmpty(T value) { [EOL]     return (value == null) || (value.size() == 0); [EOL] }
protected ObjectReader(ObjectMapper mapper, DeserializationConfig config, JavaType valueType, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues) { [EOL]     _config = config; [EOL]     _context = mapper._deserializationContext; [EOL]     _rootDeserializers = mapper._rootDeserializers; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     _rootNames = mapper._rootNames; [EOL]     _valueType = valueType; [EOL]     _valueToUpdate = valueToUpdate; [EOL]     if (valueToUpdate != null && valueType.isArrayType()) { [EOL]         throw new IllegalArgumentException("Can not update an array value"); [EOL]     } [EOL]     _schema = schema; [EOL]     _injectableValues = injectableValues; [EOL]     _unwrapRoot = config.useRootWrapping(); [EOL]     _rootDeserializer = _prefetchRootDeserializer(config, valueType); [EOL]     _dataFormatReaders = null; [EOL] }
public ObjectReader withType(Class<?> valueType) { [EOL]     return withType(_config.constructType(valueType)); [EOL] }
public ObjectReader withType(Class<?> valueType) { [EOL]     return withType(_config.constructType(valueType)); [EOL] }
public ObjectReader withView(Class<?> activeView) { [EOL]     return _with(_config.withView(activeView)); [EOL] }
public ObjectReader withView(Class<?> activeView) { [EOL]     return _with(_config.withView(activeView)); [EOL] }
public ObjectReader withFormatDetection(ObjectReader... readers) { [EOL]     return withFormatDetection(new DataFormatReaders(readers)); [EOL] }
public ObjectReader withFormatDetection(ObjectReader... readers) { [EOL]     return withFormatDetection(new DataFormatReaders(readers)); [EOL] }
public ObjectReader withFormatDetection(ObjectReader... readers) { [EOL]     return withFormatDetection(new DataFormatReaders(readers)); [EOL] }
public ObjectReader withFormatDetection(ObjectReader... readers) { [EOL]     return withFormatDetection(new DataFormatReaders(readers)); [EOL] }
public ObjectReader withFormatDetection(DataFormatReaders readers) { [EOL]     return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate, _schema, _injectableValues, readers); [EOL] }
public ObjectReader withFormatDetection(DataFormatReaders readers) { [EOL]     return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate, _schema, _injectableValues, readers); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(src); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(src); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         return (T) _detectBindAndClose(src, 0, src.length); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         return (T) _detectBindAndClose(src, 0, src.length); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, "No content to map due to end-of-input"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] }
protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, "No content to map due to end-of-input"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] }
protected static JsonToken _initForReading(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw JsonMappingException.from(jp, "No content to map due to end-of-input"); [EOL]         } [EOL]     } [EOL]     return t; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     if (_rootDeserializer != null) { [EOL]         return _rootDeserializer; [EOL]     } [EOL]     if (valueType == null) { [EOL]         throw new JsonMappingException("No value type configured for ObjectReader"); [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     if (_rootDeserializer != null) { [EOL]         return _rootDeserializer; [EOL]     } [EOL]     if (valueType == null) { [EOL]         throw new JsonMappingException("No value type configured for ObjectReader"); [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     if (_rootDeserializer != null) { [EOL]         return _rootDeserializer; [EOL]     } [EOL]     if (valueType == null) { [EOL]         throw new JsonMappingException("No value type configured for ObjectReader"); [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     if (_rootDeserializer != null) { [EOL]         return _rootDeserializer; [EOL]     } [EOL]     if (valueType == null) { [EOL]         throw new JsonMappingException("No value type configured for ObjectReader"); [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     if (_rootDeserializer != null) { [EOL]         return _rootDeserializer; [EOL]     } [EOL]     if (valueType == null) { [EOL]         throw new JsonMappingException("No value type configured for ObjectReader"); [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException { [EOL]     DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length); [EOL]     if (!match.hasMatch()) { [EOL]         _reportUnkownFormat(_dataFormatReaders, match); [EOL]     } [EOL]     JsonParser jp = match.createParserWithMatch(); [EOL]     return match.getReader()._bindAndClose(jp, _valueToUpdate); [EOL] }
protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException { [EOL]     DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length); [EOL]     if (!match.hasMatch()) { [EOL]         _reportUnkownFormat(_dataFormatReaders, match); [EOL]     } [EOL]     JsonParser jp = match.createParserWithMatch(); [EOL]     return match.getReader()._bindAndClose(jp, _valueToUpdate); [EOL] }
protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException { [EOL]     throw new JsonParseException("Can not detect format from input, does not look like any of detectable formats " + detector.toString(), JsonLocation.NA); [EOL] }
protected DefaultDeserializationContext createDeserializationContext(JsonParser jp, DeserializationConfig cfg) { [EOL]     return _context.createInstance(cfg, jp, _injectableValues); [EOL] }
public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) { [EOL]     return new CollectionLikeType(rawType, elemT, null, null, false); [EOL] }
public static CollectionLikeType construct(Class<?> rawType, JavaType elemT) { [EOL]     return new CollectionLikeType(rawType, elemT, null, null, false); [EOL] }
protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, FormatSchema s) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     _rootType = null; [EOL]     _rootSerializer = null; [EOL]     _prettyPrinter = null; [EOL]     _schema = s; [EOL] }
protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, FormatSchema s) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     _rootType = null; [EOL]     _rootSerializer = null; [EOL]     _prettyPrinter = null; [EOL]     _schema = s; [EOL] }
public ObjectWriter with(SerializationFeature feature) { [EOL]     SerializationConfig newConfig = _config.with(feature); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public ObjectWriter with(SerializationFeature feature) { [EOL]     SerializationConfig newConfig = _config.with(feature); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
Object writeReplace() { [EOL]     _incompleteDeserializers.clear(); [EOL]     return this; [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected AnnotatedMethod(Serialization ser) { [EOL]     super(null, null); [EOL]     _method = null; [EOL]     _serialization = ser; [EOL] }
public AnnotatedMethod withMethod(Method m) { [EOL]     return new AnnotatedMethod(m, _annotations, _paramAnnotations); [EOL] }
public AnnotatedMethod withMethod(Method m) { [EOL]     return new AnnotatedMethod(m, _annotations, _paramAnnotations); [EOL] }
@Override [EOL] public void setValue(Object pojo, Object value) throws IllegalArgumentException { [EOL]     try { [EOL]         _method.invoke(pojo, value); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public void setValue(Object pojo, Object value) throws IllegalArgumentException { [EOL]     try { [EOL]         _method.invoke(pojo, value); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public void setValue(Object pojo, Object value) throws IllegalArgumentException { [EOL]     try { [EOL]         _method.invoke(pojo, value); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new IllegalArgumentException("Failed to setValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
Object writeReplace() { [EOL]     return new AnnotatedMethod(new Serialization(_method)); [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Method m = clazz.getDeclaredMethod(_serialization.name, _serialization.args); [EOL]         if (!m.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new AnnotatedMethod(m, null, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find method '" + _serialization.name + "' from Class '" + clazz.getName()); [EOL]     } [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Method m = clazz.getDeclaredMethod(_serialization.name, _serialization.args); [EOL]         if (!m.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new AnnotatedMethod(m, null, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find method '" + _serialization.name + "' from Class '" + clazz.getName()); [EOL]     } [EOL] }
public Serialization(Method setter) { [EOL]     clazz = setter.getDeclaringClass(); [EOL]     name = setter.getName(); [EOL]     args = setter.getParameterTypes(); [EOL] }
public TreeTraversingParser(JsonNode n) { [EOL]     this(n, null); [EOL] }
public TreeTraversingParser(JsonNode n) { [EOL]     this(n, null); [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]         _nodeCursor = null; [EOL]         _currToken = null; [EOL]     } [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] }
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n != null) { [EOL]         byte[] data = n.binaryValue(); [EOL]         if (data != null) { [EOL]             return data; [EOL]         } [EOL]         if (n.isPojo()) { [EOL]             Object ob = ((POJONode) n).getPojo(); [EOL]             if (ob instanceof byte[]) { [EOL]                 return (byte[]) ob; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n != null) { [EOL]         byte[] data = n.binaryValue(); [EOL]         if (data != null) { [EOL]             return data; [EOL]         } [EOL]         if (n.isPojo()) { [EOL]             Object ob = ((POJONode) n).getPojo(); [EOL]             if (ob instanceof byte[]) { [EOL]                 return (byte[]) ob; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n != null) { [EOL]         byte[] data = n.binaryValue(); [EOL]         if (data != null) { [EOL]             return data; [EOL]         } [EOL]         if (n.isPojo()) { [EOL]             Object ob = ((POJONode) n).getPojo(); [EOL]             if (ob instanceof byte[]) { [EOL]                 return (byte[]) ob; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n != null) { [EOL]         byte[] data = n.binaryValue(); [EOL]         if (data != null) { [EOL]             return data; [EOL]         } [EOL]         if (n.isPojo()) { [EOL]             Object ob = ((POJONode) n).getPojo(); [EOL]             if (ob instanceof byte[]) { [EOL]                 return (byte[]) ob; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonNode currentNode() { [EOL]     if (_closed || _nodeCursor == null) { [EOL]         return null; [EOL]     } [EOL]     return _nodeCursor.currentNode(); [EOL] }
protected JsonNode currentNode() { [EOL]     if (_closed || _nodeCursor == null) { [EOL]         return null; [EOL]     } [EOL]     return _nodeCursor.currentNode(); [EOL] }
protected JsonNode currentNode() { [EOL]     if (_closed || _nodeCursor == null) { [EOL]         return null; [EOL]     } [EOL]     return _nodeCursor.currentNode(); [EOL] }
protected ArraySerializerBase(Class<T> cls) { [EOL]     super(cls); [EOL]     _property = null; [EOL] }
public LongNode(long v) { [EOL]     _value = v; [EOL] }
public static LongNode valueOf(long l) { [EOL]     return new LongNode(l); [EOL] }
public static LongNode valueOf(long l) { [EOL]     return new LongNode(l); [EOL] }
public static LongNode valueOf(long l) { [EOL]     return new LongNode(l); [EOL] }
@Override [EOL] public boolean isIntegralNumber() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean isLong() { [EOL]     return true; [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return Long.valueOf(_value); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((LongNode) o)._value == _value; [EOL] }
private void readObject(ObjectInputStream in) throws IOException { [EOL]     _jdkSerializeMaxEntries = in.readInt(); [EOL] }
private void writeObject(ObjectOutputStream out) throws IOException { [EOL]     out.writeInt(_jdkSerializeMaxEntries); [EOL] }
protected Object readResolve() { [EOL]     return new LRUMap<Object, Object>(_jdkSerializeMaxEntries, _jdkSerializeMaxEntries); [EOL] }
public StringCollectionDeserializer(JavaType collectionType, JsonDeserializer<?> valueDeser, ValueInstantiator valueInstantiator) { [EOL]     this(collectionType, valueInstantiator, null, valueDeser); [EOL] }
public StringCollectionDeserializer(JavaType collectionType, JsonDeserializer<?> valueDeser, ValueInstantiator valueInstantiator) { [EOL]     this(collectionType, valueInstantiator, null, valueDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StringCollectionDeserializer(JavaType collectionType, ValueInstantiator valueInstantiator, JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser) { [EOL]     super(collectionType.getRawClass()); [EOL]     _collectionType = collectionType; [EOL]     _valueDeserializer = (JsonDeserializer<String>) valueDeser; [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _delegateDeserializer = (JsonDeserializer<Object>) delegateDeser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StringCollectionDeserializer(JavaType collectionType, ValueInstantiator valueInstantiator, JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser) { [EOL]     super(collectionType.getRawClass()); [EOL]     _collectionType = collectionType; [EOL]     _valueDeserializer = (JsonDeserializer<String>) valueDeser; [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _delegateDeserializer = (JsonDeserializer<Object>) delegateDeser; [EOL] }
protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser) { [EOL]     if ((_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionDeserializer(_collectionType, _valueInstantiator, delegateDeser, valueDeser); [EOL] }
protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser, JsonDeserializer<?> valueDeser) { [EOL]     if ((_valueDeserializer == valueDeser) && (_delegateDeserializer == delegateDeser)) { [EOL]         return this; [EOL]     } [EOL]     return new StringCollectionDeserializer(_collectionType, _valueInstantiator, delegateDeser, valueDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegate = null; [EOL]     if (_valueInstantiator != null) { [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         if (delegateCreator != null) { [EOL]             JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]             delegate = findDeserializer(ctxt, delegateType, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     if (valueDeser == null) { [EOL]         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]         if (valueDeser == null) { [EOL]             valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]         } [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (isDefaultDeserializer(valueDeser)) { [EOL]         valueDeser = null; [EOL]     } [EOL]     return withResolved(delegate, valueDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegate = null; [EOL]     if (_valueInstantiator != null) { [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         if (delegateCreator != null) { [EOL]             JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]             delegate = findDeserializer(ctxt, delegateType, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     if (valueDeser == null) { [EOL]         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]         if (valueDeser == null) { [EOL]             valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]         } [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (isDefaultDeserializer(valueDeser)) { [EOL]         valueDeser = null; [EOL]     } [EOL]     return withResolved(delegate, valueDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegate = null; [EOL]     if (_valueInstantiator != null) { [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         if (delegateCreator != null) { [EOL]             JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]             delegate = findDeserializer(ctxt, delegateType, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     if (valueDeser == null) { [EOL]         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]         if (valueDeser == null) { [EOL]             valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]         } [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (isDefaultDeserializer(valueDeser)) { [EOL]         valueDeser = null; [EOL]     } [EOL]     return withResolved(delegate, valueDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegate = null; [EOL]     if (_valueInstantiator != null) { [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         if (delegateCreator != null) { [EOL]             JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]             delegate = findDeserializer(ctxt, delegateType, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     if (valueDeser == null) { [EOL]         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]         if (valueDeser == null) { [EOL]             valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]         } [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (isDefaultDeserializer(valueDeser)) { [EOL]         valueDeser = null; [EOL]     } [EOL]     return withResolved(delegate, valueDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegate = null; [EOL]     if (_valueInstantiator != null) { [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         if (delegateCreator != null) { [EOL]             JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]             delegate = findDeserializer(ctxt, delegateType, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     if (valueDeser == null) { [EOL]         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]         if (valueDeser == null) { [EOL]             valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]         } [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (isDefaultDeserializer(valueDeser)) { [EOL]         valueDeser = null; [EOL]     } [EOL]     return withResolved(delegate, valueDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<String>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     final Collection<String> result = (Collection<String>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     return deserialize(jp, ctxt, result); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<String>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     final Collection<String> result = (Collection<String>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     return deserialize(jp, ctxt, result); [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return typeDeserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }
public POJONode POJONode(Object pojo) { [EOL]     return new POJONode(pojo); [EOL] }
public POJONode POJONode(Object pojo) { [EOL]     return new POJONode(pojo); [EOL] }
protected void _resolve() { [EOL]     _resolveBindings(_contextClass); [EOL]     if (_contextType != null) { [EOL]         int count = _contextType.containedTypeCount(); [EOL]         if (count > 0) { [EOL]             for (int i = 0; i < count; ++i) { [EOL]                 String name = _contextType.containedTypeName(i); [EOL]                 JavaType type = _contextType.containedType(i); [EOL]                 addBinding(name, type); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_bindings == null) { [EOL]         _bindings = Collections.emptyMap(); [EOL]     } [EOL] }
protected void _resolve() { [EOL]     _resolveBindings(_contextClass); [EOL]     if (_contextType != null) { [EOL]         int count = _contextType.containedTypeCount(); [EOL]         if (count > 0) { [EOL]             for (int i = 0; i < count; ++i) { [EOL]                 String name = _contextType.containedTypeName(i); [EOL]                 JavaType type = _contextType.containedType(i); [EOL]                 addBinding(name, type); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_bindings == null) { [EOL]         _bindings = Collections.emptyMap(); [EOL]     } [EOL] }
protected void _resolve() { [EOL]     _resolveBindings(_contextClass); [EOL]     if (_contextType != null) { [EOL]         int count = _contextType.containedTypeCount(); [EOL]         if (count > 0) { [EOL]             for (int i = 0; i < count; ++i) { [EOL]                 String name = _contextType.containedTypeName(i); [EOL]                 JavaType type = _contextType.containedType(i); [EOL]                 addBinding(name, type); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_bindings == null) { [EOL]         _bindings = Collections.emptyMap(); [EOL]     } [EOL] }
protected void _resolveBindings(Type t) { [EOL]     if (t == null) [EOL]         return; [EOL]     Class<?> raw; [EOL]     if (t instanceof ParameterizedType) { [EOL]         ParameterizedType pt = (ParameterizedType) t; [EOL]         Type[] args = pt.getActualTypeArguments(); [EOL]         if (args != null && args.length > 0) { [EOL]             Class<?> rawType = (Class<?>) pt.getRawType(); [EOL]             TypeVariable<?>[] vars = rawType.getTypeParameters(); [EOL]             if (vars.length != args.length) { [EOL]                 throw new IllegalArgumentException("Strange parametrized type (in class " + rawType.getName() + "): number of type arguments != number of type parameters (" + args.length + " vs " + vars.length + ")"); [EOL]             } [EOL]             for (int i = 0, len = args.length; i < len; ++i) { [EOL]                 TypeVariable<?> var = vars[i]; [EOL]                 String name = var.getName(); [EOL]                 if (_bindings == null) { [EOL]                     _bindings = new LinkedHashMap<String, JavaType>(); [EOL]                 } else { [EOL]                     if (_bindings.containsKey(name)) [EOL]                         continue; [EOL]                 } [EOL]                 _addPlaceholder(name); [EOL]                 _bindings.put(name, _typeFactory._constructType(args[i], this)); [EOL]             } [EOL]         } [EOL]         raw = (Class<?>) pt.getRawType(); [EOL]     } else if (t instanceof Class<?>) { [EOL]         raw = (Class<?>) t; [EOL]         Class<?> decl = raw.getDeclaringClass(); [EOL]         if (decl != null && !decl.isAssignableFrom(raw)) { [EOL]             _resolveBindings(raw.getDeclaringClass()); [EOL]         } [EOL]         TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]         if (vars != null && vars.length > 0) { [EOL]             JavaType[] typeParams = null; [EOL]             if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) { [EOL]                 typeParams = _typeFactory.findTypeParameters(_contextType, raw); [EOL]             } [EOL]             for (int i = 0; i < vars.length; i++) { [EOL]                 TypeVariable<?> var = vars[i]; [EOL]                 String name = var.getName(); [EOL]                 Type varType = var.getBounds()[0]; [EOL]                 if (varType != null) { [EOL]                     if (_bindings == null) { [EOL]                         _bindings = new LinkedHashMap<String, JavaType>(); [EOL]                     } else { [EOL]                         if (_bindings.containsKey(name)) [EOL]                             continue; [EOL]                     } [EOL]                     _addPlaceholder(name); [EOL]                     if (typeParams != null) { [EOL]                         _bindings.put(name, typeParams[i]); [EOL]                     } else { [EOL]                         _bindings.put(name, _typeFactory._constructType(varType, this)); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return; [EOL]     } [EOL]     _resolveBindings(raw.getGenericSuperclass()); [EOL]     for (Type intType : raw.getGenericInterfaces()) { [EOL]         _resolveBindings(intType); [EOL]     } [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
protected boolean isDefaultSerializer(JsonSerializer<?> serializer) { [EOL]     return (serializer != null && serializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected boolean isDefaultSerializer(JsonSerializer<?> serializer) { [EOL]     return (serializer != null && serializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected boolean isDefaultSerializer(JsonSerializer<?> serializer) { [EOL]     return (serializer != null && serializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) { [EOL]     Class<?> collectionClass = type.getRawClass(); [EOL]     collectionClass = _collectionFallbacks.get(collectionClass.getName()); [EOL]     if (collectionClass == null) { [EOL]         return null; [EOL]     } [EOL]     return (CollectionType) config.constructSpecializedType(type, collectionClass); [EOL] }
protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) { [EOL]     Class<?> collectionClass = type.getRawClass(); [EOL]     collectionClass = _collectionFallbacks.get(collectionClass.getName()); [EOL]     if (collectionClass == null) { [EOL]         return null; [EOL]     } [EOL]     return (CollectionType) config.constructSpecializedType(type, collectionClass); [EOL] }
protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.deserializerInstance(ann, deserDef); [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.deserializerInstance(ann, deserDef); [EOL] }
public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] }
public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] }
public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] }
@Override [EOL] protected BeanDeserializerBase asArrayDeserializer() { [EOL]     SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder(); [EOL]     return new BeanAsArrayDeserializer(this, props); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     bean = null; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         bean = null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (!prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (!prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (!prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (!prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt, Object bean, Class<?> activeView) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (!prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
public EnumValues getEnumValues() { [EOL]     return _values; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public SettableBeanProperty[] getPropertiesInInsertionOrder() { [EOL]     int len = _nextBucketIndex; [EOL]     SettableBeanProperty[] result = new SettableBeanProperty[len]; [EOL]     for (Bucket root : _buckets) { [EOL]         for (Bucket bucket = root; bucket != null; bucket = bucket.next) { [EOL]             result[bucket.index] = bucket.value; [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public SettableBeanProperty[] getPropertiesInInsertionOrder() { [EOL]     int len = _nextBucketIndex; [EOL]     SettableBeanProperty[] result = new SettableBeanProperty[len]; [EOL]     for (Bucket root : _buckets) { [EOL]         for (Bucket bucket = root; bucket != null; bucket = bucket.next) { [EOL]             result[bucket.index] = bucket.value; [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public SettableBeanProperty[] getPropertiesInInsertionOrder() { [EOL]     int len = _nextBucketIndex; [EOL]     SettableBeanProperty[] result = new SettableBeanProperty[len]; [EOL]     for (Bucket root : _buckets) { [EOL]         for (Bucket bucket = root; bucket != null; bucket = bucket.next) { [EOL]             result[bucket.index] = bucket.value; [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public int size() { [EOL]     return _size; [EOL] }
public int size() { [EOL]     return _size; [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
protected PrimitiveArrayDeserializers(Class<T> cls) { [EOL]     super(cls); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public ByteDeser() { [EOL]     super(byte[].class); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public IndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer) { [EOL]     super(List.class, elemType, staticTyping, vts, property, valueSerializer); [EOL] }
public IndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer) { [EOL]     super(List.class, elemType, staticTyping, vts, property, valueSerializer); [EOL] }
@Override [EOL] public boolean isEmpty(List<?> value) { [EOL]     return (value == null) || value.isEmpty(); [EOL] }
@Override [EOL] public boolean isEmpty(List<?> value) { [EOL]     return (value == null) || value.isEmpty(); [EOL] }
@Override [EOL] public boolean isEmpty(List<?> value) { [EOL]     return (value == null) || value.isEmpty(); [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValue(value)); [EOL]     jgen.writeStartArray(); [EOL] }
@Override [EOL] public void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValue(value)); [EOL]     jgen.writeStartArray(); [EOL] }
@Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndArray(); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndArray(); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public boolean isEmpty(String value) { [EOL]     return (value == null) || (value.length() == 0); [EOL] }
@Override [EOL] public boolean isEmpty(String value) { [EOL]     return (value == null) || (value.length() == 0); [EOL] }
@Override [EOL] public boolean isEmpty(String value) { [EOL]     return (value == null) || (value.length() == 0); [EOL] }
public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser) { [EOL]     super(); [EOL]     _typeDeserializer = typeDeser; [EOL]     _deserializer = deser; [EOL] }
public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser) { [EOL]     super(); [EOL]     _typeDeserializer = typeDeser; [EOL]     _deserializer = deser; [EOL] }
public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser) { [EOL]     super(); [EOL]     _typeDeserializer = typeDeser; [EOL]     _deserializer = deser; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
public Class<?> getType() { [EOL]     return _class; [EOL] }
public String getName() { [EOL]     return _name; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public boolean isEmpty(Object[] value) { [EOL]     return (value == null) || (value.length == 0); [EOL] }
@Override [EOL] public boolean isEmpty(Object[] value) { [EOL]     return (value == null) || (value.length == 0); [EOL] }
@Override [EOL] public boolean isEmpty(Object[] value) { [EOL]     return (value == null) || (value.length == 0); [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public BeanAsArrayDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _orderedProperties = ordered; [EOL] }
public BeanAsArrayDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _orderedProperties = ordered; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return _deserializeFromNonArray(jp, ctxt); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return _deserializeNonVanilla(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return _deserializeFromNonArray(jp, ctxt); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return _deserializeNonVanilla(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return _deserializeFromNonArray(jp, ctxt); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return _deserializeNonVanilla(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return _deserializeFromNonArray(jp, ctxt); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return _deserializeNonVanilla(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return _deserializeFromNonArray(jp, ctxt); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return _deserializeNonVanilla(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeAndSet(jp, ctxt, bean); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
protected SerializableSerializer() { [EOL]     super(JsonSerializable.class); [EOL] }
@Override [EOL] public void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     value.serialize(jgen, provider); [EOL] }
@Override [EOL] public void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     value.serialize(jgen, provider); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         if (!type.isEnumType()) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return constructBeanSerializer(prov, beanDesc); [EOL] }
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         if (!type.isEnumType()) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return constructBeanSerializer(prov, beanDesc); [EOL] }
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         if (!type.isEnumType()) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return constructBeanSerializer(prov, beanDesc); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     String[] ignored = intr.findPropertiesToIgnore(ac); [EOL]     if (ignored != null && ignored.length > 0) { [EOL]         HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored); [EOL]         Iterator<BeanPropertyWriter> it = props.iterator(); [EOL]         while (it.hasNext()) { [EOL]             if (ignoredSet.contains(it.next().getName())) { [EOL]                 it.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return props; [EOL] }
protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     String[] ignored = intr.findPropertiesToIgnore(ac); [EOL]     if (ignored != null && ignored.length > 0) { [EOL]         HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored); [EOL]         Iterator<BeanPropertyWriter> it = props.iterator(); [EOL]         while (it.hasNext()) { [EOL]             if (ignoredSet.contains(it.next().getName())) { [EOL]                 it.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return props; [EOL] }
public ValueInjector(String propertyName, JavaType type, Annotations contextAnnotations, AnnotatedMember mutator, Object valueId) { [EOL]     super(propertyName, type, null, contextAnnotations, mutator, false); [EOL]     _valueId = valueId; [EOL] }
public Object findValue(DeserializationContext context, Object beanInstance) { [EOL]     return context.findInjectableValue(_valueId, this, beanInstance); [EOL] }
public Object findValue(DeserializationContext context, Object beanInstance) { [EOL]     return context.findInjectableValue(_valueId, this, beanInstance); [EOL] }
public Object findValue(DeserializationContext context, Object beanInstance) { [EOL]     return context.findInjectableValue(_valueId, this, beanInstance); [EOL] }
public void inject(DeserializationContext context, Object beanInstance) throws IOException { [EOL]     _member.setValue(beanInstance, findValue(context, beanInstance)); [EOL] }
public void inject(DeserializationContext context, Object beanInstance) throws IOException { [EOL]     _member.setValue(beanInstance, findValue(context, beanInstance)); [EOL] }
public void inject(DeserializationContext context, Object beanInstance) throws IOException { [EOL]     _member.setValue(beanInstance, findValue(context, beanInstance)); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getConfig().constructSpecializedType(baseType, subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getConfig().constructSpecializedType(baseType, subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getConfig().constructSpecializedType(baseType, subclass); [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> converterInstance(Annotated annotated, Object converterDef) throws JsonMappingException { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(config, annotated, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
protected AnnotatedConstructor(Serialization ser) { [EOL]     super(null, null); [EOL]     _constructor = null; [EOL]     _serialization = ser; [EOL] }
@Override [EOL] public final Object call1(Object arg) throws Exception { [EOL]     return _constructor.newInstance(arg); [EOL] }
@Override [EOL] public final Object call1(Object arg) throws Exception { [EOL]     return _constructor.newInstance(arg); [EOL] }
@Override [EOL] public final Object call1(Object arg) throws Exception { [EOL]     return _constructor.newInstance(arg); [EOL] }
Object writeReplace() { [EOL]     return new AnnotatedConstructor(new Serialization(_constructor)); [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Constructor<?> ctor = clazz.getDeclaredConstructor(_serialization.args); [EOL]         if (!ctor.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new AnnotatedConstructor(ctor, null, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find constructor with " + _serialization.args.length + " args from Class '" + clazz.getName()); [EOL]     } [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Constructor<?> ctor = clazz.getDeclaredConstructor(_serialization.args); [EOL]         if (!ctor.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new AnnotatedConstructor(ctor, null, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find constructor with " + _serialization.args.length + " args from Class '" + clazz.getName()); [EOL]     } [EOL] }
Object readResolve() { [EOL]     Class<?> clazz = _serialization.clazz; [EOL]     try { [EOL]         Constructor<?> ctor = clazz.getDeclaredConstructor(_serialization.args); [EOL]         if (!ctor.isAccessible()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new AnnotatedConstructor(ctor, null, null); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Could not find constructor with " + _serialization.args.length + " args from Class '" + clazz.getName()); [EOL]     } [EOL] }
public Serialization(Constructor<?> ctor) { [EOL]     clazz = ctor.getDeclaringClass(); [EOL]     args = ctor.getParameterTypes(); [EOL] }
public Serialization(Constructor<?> ctor) { [EOL]     clazz = ctor.getDeclaringClass(); [EOL]     args = ctor.getParameterTypes(); [EOL] }
public static ContainerSerializer<?> indexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     return new IndexedListSerializer(elemType, staticTyping, vts, null, valueSerializer); [EOL] }
public static ContainerSerializer<?> indexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     return new IndexedListSerializer(elemType, staticTyping, vts, null, valueSerializer); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
public DoubleDeserializer(Class<Double> cls, Double nvl) { [EOL]     super(cls, nvl); [EOL] }
public DoubleDeserializer(Class<Double> cls, Double nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseDouble(jp, ctxt); [EOL] }
@Override [EOL] public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseDouble(jp, ctxt); [EOL] }
@Override [EOL] public Double deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseDouble(jp, ctxt); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory) { [EOL]     super(er.getEnumClass()); [EOL]     _resolver = er; [EOL]     _factory = factory; [EOL] }
protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory) { [EOL]     super(er.getEnumClass()); [EOL]     _resolver = er; [EOL]     _factory = factory; [EOL] }
protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory) { [EOL]     super(er.getEnumClass()); [EOL]     _resolver = er; [EOL]     _factory = factory; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
public StringFactoryKeyDeserializer(Method fm) { [EOL]     super(fm.getDeclaringClass()); [EOL]     _factoryMethod = fm; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws Exception { [EOL]     return _factoryMethod.invoke(null, key); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws Exception { [EOL]     return _factoryMethod.invoke(null, key); [EOL] }
public NodeCursor(int contextType, NodeCursor p) { [EOL]     super(); [EOL]     _type = contextType; [EOL]     _index = -1; [EOL]     _parent = p; [EOL] }
public NodeCursor(int contextType, NodeCursor p) { [EOL]     super(); [EOL]     _type = contextType; [EOL]     _index = -1; [EOL]     _parent = p; [EOL] }
@Override [EOL] public final NodeCursor getParent() { [EOL]     return _parent; [EOL] }
@Override [EOL] public final NodeCursor getParent() { [EOL]     return _parent; [EOL] }
public RootValue(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_ROOT, p); [EOL]     _node = n; [EOL] }
public RootValue(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_ROOT, p); [EOL]     _node = n; [EOL] }
public RootValue(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_ROOT, p); [EOL]     _node = n; [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (!_done) { [EOL]         _done = true; [EOL]         return _node.asToken(); [EOL]     } [EOL]     _node = null; [EOL]     return null; [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (!_done) { [EOL]         _done = true; [EOL]         return _node.asToken(); [EOL]     } [EOL]     _node = null; [EOL]     return null; [EOL] }
@Override [EOL] public JsonToken endToken() { [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode currentNode() { [EOL]     return _node; [EOL] }
@Override [EOL] public JsonNode currentNode() { [EOL]     return _node; [EOL] }
public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer)); [EOL] }
public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer)); [EOL] }
public final SerializerAndMapResult findAndAddSerializer(JavaType type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer)); [EOL] }
public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver, AnnotatedMethod factory) { [EOL]     return new StdKeyDeserializer.EnumKD(enumResolver, factory); [EOL] }
public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver, AnnotatedMethod factory) { [EOL]     return new StdKeyDeserializer.EnumKD(enumResolver, factory); [EOL] }
public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type) { [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class); [EOL]     if (ctor != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor); [EOL]     } [EOL]     Method m = beanDesc.findFactoryMethod(String.class); [EOL]     if (m != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new StdKeyDeserializer.StringFactoryKeyDeserializer(m); [EOL]     } [EOL]     return null; [EOL] }
public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type) { [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class); [EOL]     if (ctor != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor); [EOL]     } [EOL]     Method m = beanDesc.findFactoryMethod(String.class); [EOL]     if (m != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new StdKeyDeserializer.StringFactoryKeyDeserializer(m); [EOL]     } [EOL]     return null; [EOL] }
public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type) { [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class); [EOL]     if (ctor != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor); [EOL]     } [EOL]     Method m = beanDesc.findFactoryMethod(String.class); [EOL]     if (m != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new StdKeyDeserializer.StringFactoryKeyDeserializer(m); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public ClassKey(Class<?> clz) { [EOL]     _class = clz; [EOL]     _className = clz.getName(); [EOL]     _hashCode = _className.hashCode(); [EOL] }
@Override [EOL] public int compareTo(ClassKey other) { [EOL]     return _className.compareTo(other._className); [EOL] }
@Override [EOL] public int compareTo(ClassKey other) { [EOL]     return _className.compareTo(other._className); [EOL] }
@Override [EOL] public int compareTo(ClassKey other) { [EOL]     return _className.compareTo(other._className); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     ClassKey other = (ClassKey) o; [EOL]     return other._class == _class; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     ClassKey other = (ClassKey) o; [EOL]     return other._class == _class; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     ClassKey other = (ClassKey) o; [EOL]     return other._class == _class; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     ClassKey other = (ClassKey) o; [EOL]     return other._class == _class; [EOL] }
@Override [EOL] public String toString() { [EOL]     return _className; [EOL] }
public UnrecognizedPropertyException(String msg, JsonLocation loc, Class<?> referringClass, String propName, Collection<Object> propertyIds) { [EOL]     super(msg, loc); [EOL]     _referringClass = referringClass; [EOL]     _unrecognizedPropertyName = propName; [EOL]     _propertyIds = propertyIds; [EOL] }
public UnrecognizedPropertyException(String msg, JsonLocation loc, Class<?> referringClass, String propName, Collection<Object> propertyIds) { [EOL]     super(msg, loc); [EOL]     _referringClass = referringClass; [EOL]     _unrecognizedPropertyName = propName; [EOL]     _propertyIds = propertyIds; [EOL] }
public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName, Collection<Object> propertyIds) { [EOL]     if (fromObjectOrClass == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     Class<?> ref; [EOL]     if (fromObjectOrClass instanceof Class<?>) { [EOL]         ref = (Class<?>) fromObjectOrClass; [EOL]     } else { [EOL]         ref = fromObjectOrClass.getClass(); [EOL]     } [EOL]     String msg = "Unrecognized field \"" + propertyName + "\" (class " + ref.getName() + "), not marked as ignorable"; [EOL]     UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg, jp.getCurrentLocation(), ref, propertyName, propertyIds); [EOL]     e.prependPath(fromObjectOrClass, propertyName); [EOL]     return e; [EOL] }
public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName, Collection<Object> propertyIds) { [EOL]     if (fromObjectOrClass == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     Class<?> ref; [EOL]     if (fromObjectOrClass instanceof Class<?>) { [EOL]         ref = (Class<?>) fromObjectOrClass; [EOL]     } else { [EOL]         ref = fromObjectOrClass.getClass(); [EOL]     } [EOL]     String msg = "Unrecognized field \"" + propertyName + "\" (class " + ref.getName() + "), not marked as ignorable"; [EOL]     UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg, jp.getCurrentLocation(), ref, propertyName, propertyIds); [EOL]     e.prependPath(fromObjectOrClass, propertyName); [EOL]     return e; [EOL] }
public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName, Collection<Object> propertyIds) { [EOL]     if (fromObjectOrClass == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     Class<?> ref; [EOL]     if (fromObjectOrClass instanceof Class<?>) { [EOL]         ref = (Class<?>) fromObjectOrClass; [EOL]     } else { [EOL]         ref = fromObjectOrClass.getClass(); [EOL]     } [EOL]     String msg = "Unrecognized field \"" + propertyName + "\" (class " + ref.getName() + "), not marked as ignorable"; [EOL]     UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg, jp.getCurrentLocation(), ref, propertyName, propertyIds); [EOL]     e.prependPath(fromObjectOrClass, propertyName); [EOL]     return e; [EOL] }
@Override [EOL] public String getMessageSuffix() { [EOL]     String suffix = _propertiesAsString; [EOL]     if (suffix == null && _propertyIds != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         int len = _propertyIds.size(); [EOL]         if (len == 1) { [EOL]             sb.append(" (one known property: \""); [EOL]             sb.append(String.valueOf(_propertyIds.iterator().next())); [EOL]             sb.append('"'); [EOL]         } else { [EOL]             sb.append(" (").append(len).append(" known properties: "); [EOL]             Iterator<Object> it = _propertyIds.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 sb.append(", \""); [EOL]                 sb.append(String.valueOf(it.next())); [EOL]                 sb.append('"'); [EOL]                 if (sb.length() > MAX_DESC_LENGTH) { [EOL]                     sb.append(" [truncated]"); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append("])"); [EOL]         _propertiesAsString = suffix = sb.toString(); [EOL]     } [EOL]     return suffix; [EOL] }
@Override [EOL] public String getMessageSuffix() { [EOL]     String suffix = _propertiesAsString; [EOL]     if (suffix == null && _propertyIds != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         int len = _propertyIds.size(); [EOL]         if (len == 1) { [EOL]             sb.append(" (one known property: \""); [EOL]             sb.append(String.valueOf(_propertyIds.iterator().next())); [EOL]             sb.append('"'); [EOL]         } else { [EOL]             sb.append(" (").append(len).append(" known properties: "); [EOL]             Iterator<Object> it = _propertyIds.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 sb.append(", \""); [EOL]                 sb.append(String.valueOf(it.next())); [EOL]                 sb.append('"'); [EOL]                 if (sb.length() > MAX_DESC_LENGTH) { [EOL]                     sb.append(" [truncated]"); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append("])"); [EOL]         _propertiesAsString = suffix = sb.toString(); [EOL]     } [EOL]     return suffix; [EOL] }
@Override [EOL] public String getMessageSuffix() { [EOL]     String suffix = _propertiesAsString; [EOL]     if (suffix == null && _propertyIds != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         int len = _propertyIds.size(); [EOL]         if (len == 1) { [EOL]             sb.append(" (one known property: \""); [EOL]             sb.append(String.valueOf(_propertyIds.iterator().next())); [EOL]             sb.append('"'); [EOL]         } else { [EOL]             sb.append(" (").append(len).append(" known properties: "); [EOL]             Iterator<Object> it = _propertyIds.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 sb.append(", \""); [EOL]                 sb.append(String.valueOf(it.next())); [EOL]                 sb.append('"'); [EOL]                 if (sb.length() > MAX_DESC_LENGTH) { [EOL]                     sb.append(" [truncated]"); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append("])"); [EOL]         _propertiesAsString = suffix = sb.toString(); [EOL]     } [EOL]     return suffix; [EOL] }
@Override [EOL] public String getMessageSuffix() { [EOL]     String suffix = _propertiesAsString; [EOL]     if (suffix == null && _propertyIds != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         int len = _propertyIds.size(); [EOL]         if (len == 1) { [EOL]             sb.append(" (one known property: \""); [EOL]             sb.append(String.valueOf(_propertyIds.iterator().next())); [EOL]             sb.append('"'); [EOL]         } else { [EOL]             sb.append(" (").append(len).append(" known properties: "); [EOL]             Iterator<Object> it = _propertyIds.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 sb.append(", \""); [EOL]                 sb.append(String.valueOf(it.next())); [EOL]                 sb.append('"'); [EOL]                 if (sb.length() > MAX_DESC_LENGTH) { [EOL]                     sb.append(" [truncated]"); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append("])"); [EOL]         _propertiesAsString = suffix = sb.toString(); [EOL]     } [EOL]     return suffix; [EOL] }
@Override [EOL] public String getMessageSuffix() { [EOL]     String suffix = _propertiesAsString; [EOL]     if (suffix == null && _propertyIds != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         int len = _propertyIds.size(); [EOL]         if (len == 1) { [EOL]             sb.append(" (one known property: \""); [EOL]             sb.append(String.valueOf(_propertyIds.iterator().next())); [EOL]             sb.append('"'); [EOL]         } else { [EOL]             sb.append(" (").append(len).append(" known properties: "); [EOL]             Iterator<Object> it = _propertyIds.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 sb.append(", \""); [EOL]                 sb.append(String.valueOf(it.next())); [EOL]                 sb.append('"'); [EOL]                 if (sb.length() > MAX_DESC_LENGTH) { [EOL]                     sb.append(" [truncated]"); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append("])"); [EOL]         _propertiesAsString = suffix = sb.toString(); [EOL]     } [EOL]     return suffix; [EOL] }
public Class<?> getReferringClass() { [EOL]     return _referringClass; [EOL] }
public String getUnrecognizedPropertyName() { [EOL]     return _unrecognizedPropertyName; [EOL] }
public String getUnrecognizedPropertyName() { [EOL]     return _unrecognizedPropertyName; [EOL] }
protected IndexedStringListSerializer() { [EOL]     this(null); [EOL] }
@SuppressWarnings("unchecked") [EOL] public IndexedStringListSerializer(JsonSerializer<?> ser) { [EOL]     super(List.class); [EOL]     _serializer = (JsonSerializer<String>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public IndexedStringListSerializer(JsonSerializer<?> ser) { [EOL]     super(List.class); [EOL]     _serializer = (JsonSerializer<String>) ser; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public FileSerializer() { [EOL]     super(File.class); [EOL] }
@Override [EOL] public void serialize(File value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.getAbsolutePath()); [EOL] }
@Override [EOL] public void serialize(File value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.getAbsolutePath()); [EOL] }
public ClassSerializer() { [EOL]     super(Class.class, false); [EOL] }
@Override [EOL] public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.getName()); [EOL] }
@Override [EOL] public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.getName()); [EOL] }
@Override [EOL] public JsonNode path(int index) { [EOL]     return MissingNode.getInstance(); [EOL] }
public JsonNode set(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _children.put(fieldName, value); [EOL]     return this; [EOL] }
public JsonNode set(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _children.put(fieldName, value); [EOL]     return this; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public String getFormatName() { [EOL]     return FORMAT_NAME_JSON; [EOL] }
public Value(JsonPOJOBuilder ann) { [EOL]     buildMethodName = ann.buildMethodName(); [EOL]     withPrefix = ann.withPrefix(); [EOL] }
public Value(JsonPOJOBuilder ann) { [EOL]     buildMethodName = ann.buildMethodName(); [EOL]     withPrefix = ann.withPrefix(); [EOL] }
@Override [EOL] public boolean isInt() { [EOL]     return true; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) _value; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((IntNode) o)._value == _value; [EOL] }
public void addIntCreator(AnnotatedWithParams creator) { [EOL]     _intCreator = verifyNonDup(creator, _intCreator, "int"); [EOL] }
public void addIntCreator(AnnotatedWithParams creator) { [EOL]     _intCreator = verifyNonDup(creator, _intCreator, "int"); [EOL] }
public void addIntCreator(AnnotatedWithParams creator) { [EOL]     _intCreator = verifyNonDup(creator, _intCreator, "int"); [EOL] }
@SuppressWarnings("unchecked") [EOL] public TypeWrappedSerializer(TypeSerializer typeSer, JsonSerializer<?> ser) { [EOL]     super(); [EOL]     _typeSerializer = typeSer; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public TypeWrappedSerializer(TypeSerializer typeSer, JsonSerializer<?> ser) { [EOL]     super(); [EOL]     _typeSerializer = typeSer; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public TypeWrappedSerializer(TypeSerializer typeSer, JsonSerializer<?> ser) { [EOL]     super(); [EOL]     _typeSerializer = typeSer; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     _serializer.serializeWithType(value, jgen, provider, _typeSerializer); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     _serializer.serializeWithType(value, jgen, provider, _typeSerializer); [EOL] }
public DataFormatReaders(ObjectReader... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
public DataFormatReaders(ObjectReader... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
public DataFormatReaders(ObjectReader... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
public DataFormatReaders(ObjectReader... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
private DataFormatReaders(ObjectReader[] detectors, MatchStrength optMatch, MatchStrength minMatch, int maxInputLookahead) { [EOL]     _readers = detectors; [EOL]     _optimalMatch = optMatch; [EOL]     _minimalMatch = minMatch; [EOL]     _maxInputLookahead = maxInputLookahead; [EOL] }
public Match findFormat(byte[] fullInputData, int offset, int len) throws IOException { [EOL]     return _findFormat(new AccessorForReader(fullInputData, offset, len)); [EOL] }
public Match findFormat(byte[] fullInputData, int offset, int len) throws IOException { [EOL]     return _findFormat(new AccessorForReader(fullInputData, offset, len)); [EOL] }
public Match findFormat(byte[] fullInputData, int offset, int len) throws IOException { [EOL]     return _findFormat(new AccessorForReader(fullInputData, offset, len)); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     final int len = _readers.length; [EOL]     if (len > 0) { [EOL]         sb.append(_readers[0].getFactory().getFormatName()); [EOL]         for (int i = 1; i < len; ++i) { [EOL]             sb.append(", "); [EOL]             sb.append(_readers[i].getFactory().getFormatName()); [EOL]         } [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     final int len = _readers.length; [EOL]     if (len > 0) { [EOL]         sb.append(_readers[0].getFactory().getFormatName()); [EOL]         for (int i = 1; i < len; ++i) { [EOL]             sb.append(", "); [EOL]             sb.append(_readers[i].getFactory().getFormatName()); [EOL]         } [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     final int len = _readers.length; [EOL]     if (len > 0) { [EOL]         sb.append(_readers[0].getFactory().getFormatName()); [EOL]         for (int i = 1; i < len; ++i) { [EOL]             sb.append(", "); [EOL]             sb.append(_readers[i].getFactory().getFormatName()); [EOL]         } [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
public AccessorForReader(byte[] inputDocument, int start, int len) { [EOL]     super(inputDocument, start, len); [EOL] }
public AccessorForReader(byte[] inputDocument, int start, int len) { [EOL]     super(inputDocument, start, len); [EOL] }
public AccessorForReader(byte[] inputDocument, int start, int len) { [EOL]     super(inputDocument, start, len); [EOL] }
public AccessorForReader(byte[] inputDocument, int start, int len) { [EOL]     super(inputDocument, start, len); [EOL] }
public AccessorForReader(byte[] inputDocument, int start, int len) { [EOL]     super(inputDocument, start, len); [EOL] }
public Match createMatcher(ObjectReader match, MatchStrength matchStrength) { [EOL]     return new Match(_in, _buffer, _bufferedStart, (_bufferedEnd - _bufferedStart), match, matchStrength); [EOL] }
public Match createMatcher(ObjectReader match, MatchStrength matchStrength) { [EOL]     return new Match(_in, _buffer, _bufferedStart, (_bufferedEnd - _bufferedStart), match, matchStrength); [EOL] }
protected Match(InputStream in, byte[] buffered, int bufferedStart, int bufferedLength, ObjectReader match, MatchStrength strength) { [EOL]     _originalStream = in; [EOL]     _bufferedData = buffered; [EOL]     _bufferedStart = bufferedStart; [EOL]     _bufferedLength = bufferedLength; [EOL]     _match = match; [EOL]     _matchStrength = strength; [EOL] }
public boolean hasMatch() { [EOL]     return _match != null; [EOL] }
public boolean hasMatch() { [EOL]     return _match != null; [EOL] }
public final void addOrOverrideParam(int paramIndex, Annotation a) { [EOL]     AnnotationMap old = _paramAnnotations[paramIndex]; [EOL]     if (old == null) { [EOL]         old = new AnnotationMap(); [EOL]         _paramAnnotations[paramIndex] = old; [EOL]     } [EOL]     old.add(a); [EOL] }
public final void addOrOverrideParam(int paramIndex, Annotation a) { [EOL]     AnnotationMap old = _paramAnnotations[paramIndex]; [EOL]     if (old == null) { [EOL]         old = new AnnotationMap(); [EOL]         _paramAnnotations[paramIndex] = old; [EOL]     } [EOL]     old.add(a); [EOL] }
public boolean removeProperty(String propName) { [EOL]     Iterator<BeanPropertyDefinition> it = _properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition prop = it.next(); [EOL]         if (prop.getName().equals(propName)) { [EOL]             it.remove(); [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean removeProperty(String propName) { [EOL]     Iterator<BeanPropertyDefinition> it = _properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition prop = it.next(); [EOL]         if (prop.getName().equals(propName)) { [EOL]             it.remove(); [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean hasKnownClassAnnotations() { [EOL]     return _classInfo.hasAnnotations(); [EOL] }
@Override [EOL] public boolean hasKnownClassAnnotations() { [EOL]     return _classInfo.hasAnnotations(); [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Method findFactoryMethod(Class<?>... expArgTypes) { [EOL]     for (AnnotatedMethod am : _classInfo.getStaticMethods()) { [EOL]         if (isFactoryMethod(am)) { [EOL]             Class<?> actualArgType = am.getRawParameterType(0); [EOL]             for (Class<?> expArgType : expArgTypes) { [EOL]                 if (actualArgType.isAssignableFrom(expArgType)) { [EOL]                     return am.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Method findFactoryMethod(Class<?>... expArgTypes) { [EOL]     for (AnnotatedMethod am : _classInfo.getStaticMethods()) { [EOL]         if (isFactoryMethod(am)) { [EOL]             Class<?> actualArgType = am.getRawParameterType(0); [EOL]             for (Class<?> expArgType : expArgTypes) { [EOL]                 if (actualArgType.isAssignableFrom(expArgType)) { [EOL]                     return am.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Method findFactoryMethod(Class<?>... expArgTypes) { [EOL]     for (AnnotatedMethod am : _classInfo.getStaticMethods()) { [EOL]         if (isFactoryMethod(am)) { [EOL]             Class<?> actualArgType = am.getRawParameterType(0); [EOL]             for (Class<?> expArgType : expArgTypes) { [EOL]                 if (actualArgType.isAssignableFrom(expArgType)) { [EOL]                     return am.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
protected JsonMappingException wrapException(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof JsonMappingException) { [EOL]         return (JsonMappingException) t; [EOL]     } [EOL]     return new JsonMappingException("Instantiation of " + getValueTypeDesc() + " value failed: " + t.getMessage(), t); [EOL] }
protected JsonMappingException wrapException(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof JsonMappingException) { [EOL]         return (JsonMappingException) t; [EOL]     } [EOL]     return new JsonMappingException("Instantiation of " + getValueTypeDesc() + " value failed: " + t.getMessage(), t); [EOL] }
protected JsonMappingException wrapException(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof JsonMappingException) { [EOL]         return (JsonMappingException) t; [EOL]     } [EOL]     return new JsonMappingException("Instantiation of " + getValueTypeDesc() + " value failed: " + t.getMessage(), t); [EOL] }
public static JsonSerializer<?> findStandardImpl(Class<?> cls) { [EOL]     return _arraySerializers.get(cls.getName()); [EOL] }
public static JsonSerializer<?> findStandardImpl(Class<?> cls) { [EOL]     return _arraySerializers.get(cls.getName()); [EOL] }
protected TypedPrimitiveArraySerializer(Class<T> cls) { [EOL]     super(cls); [EOL]     _valueTypeSerializer = null; [EOL] }
public BooleanArraySerializer() { [EOL]     super(boolean[].class, null); [EOL] }
public ByteArraySerializer() { [EOL]     super(byte[].class); [EOL] }
@Override [EOL] public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeBinary(provider.getConfig().getBase64Variant(), value, 0, value.length); [EOL] }
public ShortArraySerializer() { [EOL]     super(short[].class); [EOL] }
public CharArraySerializer() { [EOL]     super(char[].class); [EOL] }
public IntArraySerializer() { [EOL]     super(int[].class, null); [EOL] }
public LongArraySerializer() { [EOL]     super(long[].class); [EOL] }
public FloatArraySerializer() { [EOL]     super(float[].class); [EOL] }
@Override [EOL] public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         for (int i = 0, len = value.length; i < len; ++i) { [EOL]             _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Float.TYPE); [EOL]             jgen.writeNumber(value[i]); [EOL]             _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         for (int i = 0, len = value.length; i < len; ++i) { [EOL]             _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Float.TYPE); [EOL]             jgen.writeNumber(value[i]); [EOL]             _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
public DoubleArraySerializer() { [EOL]     super(double[].class, null); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _valueType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType, _valueType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _valueType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType, _valueType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowKey(Class<?> keySubclass) { [EOL]     if (keySubclass == _keyType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowKey(Class<?> keySubclass) { [EOL]     if (keySubclass == _keyType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
public BeanPropertyWriter rename(NameTransformer transformer) { [EOL]     String newName = transformer.transform(_name.getValue()); [EOL]     if (newName.equals(_name.toString())) { [EOL]         return this; [EOL]     } [EOL]     return new BeanPropertyWriter(this, new SerializedString(newName)); [EOL] }
public void setNonTrivialBaseType(JavaType t) { [EOL]     _nonTrivialBaseType = t; [EOL] }
@Override [EOL] public <A extends Annotation> A getContextAnnotation(Class<A> acls) { [EOL]     return _contextAnnotations.get(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getContextAnnotation(Class<A> acls) { [EOL]     return _contextAnnotations.get(acls); [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     if (_nullSerializer != null) { [EOL]         _nullSerializer.serialize(null, jgen, prov); [EOL]     } else { [EOL]         jgen.writeNull(); [EOL]     } [EOL] }
public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     if (_nullSerializer != null) { [EOL]         _nullSerializer.serialize(null, jgen, prov); [EOL]     } else { [EOL]         jgen.writeNull(); [EOL]     } [EOL] }
protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result; [EOL]     if (_nonTrivialBaseType != null) { [EOL]         JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type); [EOL]         result = map.findAndAddSerializer(t, provider, this); [EOL]     } else { [EOL]         result = map.findAndAddSerializer(type, provider, this); [EOL]     } [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result; [EOL]     if (_nonTrivialBaseType != null) { [EOL]         JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type); [EOL]         result = map.findAndAddSerializer(t, provider, this); [EOL]     } else { [EOL]         result = map.findAndAddSerializer(type, provider, this); [EOL]     } [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException { [EOL]     if (ser.usesObjectId()) { [EOL]         return; [EOL]     } [EOL]     throw new JsonMappingException("Direct self-reference leading to cycle"); [EOL] }
protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException { [EOL]     if (ser.usesObjectId()) { [EOL]         return; [EOL]     } [EOL]     throw new JsonMappingException("Direct self-reference leading to cycle"); [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser) { [EOL]     if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArrayDeserializer(_arrayType, (JsonDeserializer<Object>) elemDeser, elemTypeDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser) { [EOL]     if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArrayDeserializer(_arrayType, (JsonDeserializer<Object>) elemDeser, elemTypeDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser) { [EOL]     if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArrayDeserializer(_arrayType, (JsonDeserializer<Object>) elemDeser, elemTypeDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<Object> getContentDeserializer() { [EOL]     return _elementDeserializer; [EOL] }
@Override [EOL] public JsonDeserializer<Object> getContentDeserializer() { [EOL]     return _elementDeserializer; [EOL] }
public ReferenceProperty(Type t, String n) { [EOL]     _type = t; [EOL]     _name = n; [EOL] }
public ReferenceProperty(Type t, String n) { [EOL]     _type = t; [EOL]     _name = n; [EOL] }
public static ReferenceProperty managed(String name) { [EOL]     return new ReferenceProperty(Type.MANAGED_REFERENCE, name); [EOL] }
public static ReferenceProperty back(String name) { [EOL]     return new ReferenceProperty(Type.BACK_REFERENCE, name); [EOL] }
public boolean isManagedReference() { [EOL]     return _type == Type.MANAGED_REFERENCE; [EOL] }
public boolean isManagedReference() { [EOL]     return _type == Type.MANAGED_REFERENCE; [EOL] }
public boolean isBackReference() { [EOL]     return _type == Type.BACK_REFERENCE; [EOL] }
public boolean isBackReference() { [EOL]     return _type == Type.BACK_REFERENCE; [EOL] }
public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { [EOL]     return null; [EOL] }
public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod remove(Method m) { [EOL]     if (_methods != null) { [EOL]         return _methods.remove(new MemberKey(m)); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod remove(Method m) { [EOL]     if (_methods != null) { [EOL]         return _methods.remove(new MemberKey(m)); [EOL]     } [EOL]     return null; [EOL] }
private static HashSet<String> toSet(String[] ignoredEntries) { [EOL]     if (ignoredEntries == null || ignoredEntries.length == 0) { [EOL]         return null; [EOL]     } [EOL]     HashSet<String> result = new HashSet<String>(ignoredEntries.length); [EOL]     for (String prop : ignoredEntries) { [EOL]         result.add(prop); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public boolean isEmpty(Map<?, ?> value) { [EOL]     return (value == null) || value.isEmpty(); [EOL] }
@Override [EOL] public boolean isEmpty(Map<?, ?> value) { [EOL]     return (value == null) || value.isEmpty(); [EOL] }
@Override [EOL] public boolean isEmpty(Map<?, ?> value) { [EOL]     return (value == null) || value.isEmpty(); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected OptionalHandlerFactory() { [EOL] }
public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = SERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Serializers) ob).findSerializer(config, type, beanDesc); [EOL] }
public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = SERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Serializers) ob).findSerializer(config, type, beanDesc); [EOL] }
public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = SERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Serializers) ob).findSerializer(config, type, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
private Object instantiate(String className) { [EOL]     try { [EOL]         return Class.forName(className).newInstance(); [EOL]     } catch (LinkageError e) { [EOL]     } catch (Exception e) { [EOL]     } [EOL]     return null; [EOL] }
private Object instantiate(String className) { [EOL]     try { [EOL]         return Class.forName(className).newInstance(); [EOL]     } catch (LinkageError e) { [EOL]     } catch (Exception e) { [EOL]     } [EOL]     return null; [EOL] }
private Object instantiate(String className) { [EOL]     try { [EOL]         return Class.forName(className).newInstance(); [EOL]     } catch (LinkageError e) { [EOL]     } catch (Exception e) { [EOL]     } [EOL]     return null; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Std(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) { [EOL]         _getterMinLevel = DEFAULT._getterMinLevel; [EOL]         _isGetterMinLevel = DEFAULT._isGetterMinLevel; [EOL]         _setterMinLevel = DEFAULT._setterMinLevel; [EOL]         _creatorMinLevel = DEFAULT._creatorMinLevel; [EOL]         _fieldMinLevel = DEFAULT._fieldMinLevel; [EOL]     } else { [EOL]         _getterMinLevel = v; [EOL]         _isGetterMinLevel = v; [EOL]         _setterMinLevel = v; [EOL]         _creatorMinLevel = v; [EOL]         _fieldMinLevel = v; [EOL]     } [EOL] }
public Std(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) { [EOL]         _getterMinLevel = DEFAULT._getterMinLevel; [EOL]         _isGetterMinLevel = DEFAULT._isGetterMinLevel; [EOL]         _setterMinLevel = DEFAULT._setterMinLevel; [EOL]         _creatorMinLevel = DEFAULT._creatorMinLevel; [EOL]         _fieldMinLevel = DEFAULT._fieldMinLevel; [EOL]     } else { [EOL]         _getterMinLevel = v; [EOL]         _isGetterMinLevel = v; [EOL]         _setterMinLevel = v; [EOL]         _creatorMinLevel = v; [EOL]         _fieldMinLevel = v; [EOL]     } [EOL] }
@Override [EOL] public Std with(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) { [EOL]         return DEFAULT; [EOL]     } [EOL]     return new Std(v); [EOL] }
@Override [EOL] public Std with(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) { [EOL]         return DEFAULT; [EOL]     } [EOL]     return new Std(v); [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withVisibility(PropertyAccessor method, Visibility v) { [EOL]     switch(method) { [EOL]         case GETTER: [EOL]             return withGetterVisibility(v); [EOL]         case SETTER: [EOL]             return withSetterVisibility(v); [EOL]         case CREATOR: [EOL]             return withCreatorVisibility(v); [EOL]         case FIELD: [EOL]             return withFieldVisibility(v); [EOL]         case IS_GETTER: [EOL]             return withIsGetterVisibility(v); [EOL]         case ALL: [EOL]             return with(v); [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
@Override [EOL] public Std withGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._getterMinLevel; [EOL]     if (_getterMinLevel == v) [EOL]         return this; [EOL]     return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._getterMinLevel; [EOL]     if (_getterMinLevel == v) [EOL]         return this; [EOL]     return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._getterMinLevel; [EOL]     if (_getterMinLevel == v) [EOL]         return this; [EOL]     return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public TokenBufferDeserializer() { [EOL]     super(TokenBuffer.class); [EOL] }
@Override [EOL] public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     TokenBuffer tb = new TokenBuffer(jp.getCodec()); [EOL]     tb.copyCurrentStructure(jp); [EOL]     return tb; [EOL] }
@Override [EOL] public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     TokenBuffer tb = new TokenBuffer(jp.getCodec()); [EOL]     tb.copyCurrentStructure(jp); [EOL]     return tb; [EOL] }
@Override [EOL] public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     TokenBuffer tb = new TokenBuffer(jp.getCodec()); [EOL]     tb.copyCurrentStructure(jp); [EOL]     return tb; [EOL] }
public Reference(Object from, String fieldName) { [EOL]     _from = from; [EOL]     if (fieldName == null) { [EOL]         throw new NullPointerException("Can not pass null fieldName"); [EOL]     } [EOL]     _fieldName = fieldName; [EOL] }
public Reference(Object from, String fieldName) { [EOL]     _from = from; [EOL]     if (fieldName == null) { [EOL]         throw new NullPointerException("Can not pass null fieldName"); [EOL]     } [EOL]     _fieldName = fieldName; [EOL] }
public Reference(Object from, int index) { [EOL]     _from = from; [EOL]     _index = index; [EOL] }
public Reference(Object from, int index) { [EOL]     _from = from; [EOL]     _index = index; [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     Class<?> cls = (_from instanceof Class<?>) ? ((Class<?>) _from) : _from.getClass(); [EOL]     Package pkg = cls.getPackage(); [EOL]     if (pkg != null) { [EOL]         sb.append(pkg.getName()); [EOL]         sb.append('.'); [EOL]     } [EOL]     sb.append(cls.getSimpleName()); [EOL]     sb.append('['); [EOL]     if (_fieldName != null) { [EOL]         sb.append('"'); [EOL]         sb.append(_fieldName); [EOL]         sb.append('"'); [EOL]     } else if (_index >= 0) { [EOL]         sb.append(_index); [EOL]     } else { [EOL]         sb.append('?'); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     Class<?> cls = (_from instanceof Class<?>) ? ((Class<?>) _from) : _from.getClass(); [EOL]     Package pkg = cls.getPackage(); [EOL]     if (pkg != null) { [EOL]         sb.append(pkg.getName()); [EOL]         sb.append('.'); [EOL]     } [EOL]     sb.append(cls.getSimpleName()); [EOL]     sb.append('['); [EOL]     if (_fieldName != null) { [EOL]         sb.append('"'); [EOL]         sb.append(_fieldName); [EOL]         sb.append('"'); [EOL]     } else if (_index >= 0) { [EOL]         sb.append(_index); [EOL]     } else { [EOL]         sb.append('?'); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     Class<?> cls = (_from instanceof Class<?>) ? ((Class<?>) _from) : _from.getClass(); [EOL]     Package pkg = cls.getPackage(); [EOL]     if (pkg != null) { [EOL]         sb.append(pkg.getName()); [EOL]         sb.append('.'); [EOL]     } [EOL]     sb.append(cls.getSimpleName()); [EOL]     sb.append('['); [EOL]     if (_fieldName != null) { [EOL]         sb.append('"'); [EOL]         sb.append(_fieldName); [EOL]         sb.append('"'); [EOL]     } else if (_index >= 0) { [EOL]         sb.append(_index); [EOL]     } else { [EOL]         sb.append('?'); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
public JsonMappingException(String msg, Throwable rootCause) { [EOL]     super(msg, rootCause); [EOL] }
public JsonMappingException(String msg, JsonLocation loc) { [EOL]     super(msg, loc); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, int index) { [EOL]     return wrapWithPath(src, new Reference(refFrom, index)); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public StringBuilder getPathReference(StringBuilder sb) { [EOL]     _appendPathDesc(sb); [EOL]     return sb; [EOL] }
public StringBuilder getPathReference(StringBuilder sb) { [EOL]     _appendPathDesc(sb); [EOL]     return sb; [EOL] }
public void prependPath(Object referrer, String fieldName) { [EOL]     Reference ref = new Reference(referrer, fieldName); [EOL]     prependPath(ref); [EOL] }
public void prependPath(Object referrer, String fieldName) { [EOL]     Reference ref = new Reference(referrer, fieldName); [EOL]     prependPath(ref); [EOL] }
public void prependPath(Reference r) { [EOL]     if (_path == null) { [EOL]         _path = new LinkedList<Reference>(); [EOL]     } [EOL]     if (_path.size() < MAX_REFS_TO_LIST) { [EOL]         _path.addFirst(r); [EOL]     } [EOL] }
public void prependPath(Reference r) { [EOL]     if (_path == null) { [EOL]         _path = new LinkedList<Reference>(); [EOL]     } [EOL]     if (_path.size() < MAX_REFS_TO_LIST) { [EOL]         _path.addFirst(r); [EOL]     } [EOL] }
public void prependPath(Reference r) { [EOL]     if (_path == null) { [EOL]         _path = new LinkedList<Reference>(); [EOL]     } [EOL]     if (_path.size() < MAX_REFS_TO_LIST) { [EOL]         _path.addFirst(r); [EOL]     } [EOL] }
protected String _buildMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (_path == null) { [EOL]         return msg; [EOL]     } [EOL]     StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg); [EOL]     sb.append(" (through reference chain: "); [EOL]     sb = getPathReference(sb); [EOL]     sb.append(')'); [EOL]     return sb.toString(); [EOL] }
protected String _buildMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (_path == null) { [EOL]         return msg; [EOL]     } [EOL]     StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg); [EOL]     sb.append(" (through reference chain: "); [EOL]     sb = getPathReference(sb); [EOL]     sb.append(')'); [EOL]     return sb.toString(); [EOL] }
protected void _appendPathDesc(StringBuilder sb) { [EOL]     if (_path == null) { [EOL]         return; [EOL]     } [EOL]     Iterator<Reference> it = _path.iterator(); [EOL]     while (it.hasNext()) { [EOL]         sb.append(it.next().toString()); [EOL]         if (it.hasNext()) { [EOL]             sb.append("->"); [EOL]         } [EOL]     } [EOL] }
protected void _appendPathDesc(StringBuilder sb) { [EOL]     if (_path == null) { [EOL]         return; [EOL]     } [EOL]     Iterator<Reference> it = _path.iterator(); [EOL]     while (it.hasNext()) { [EOL]         sb.append(it.next().toString()); [EOL]         if (it.hasNext()) { [EOL]             sb.append("->"); [EOL]         } [EOL]     } [EOL] }
protected void _appendPathDesc(StringBuilder sb) { [EOL]     if (_path == null) { [EOL]         return; [EOL]     } [EOL]     Iterator<Reference> it = _path.iterator(); [EOL]     while (it.hasNext()) { [EOL]         sb.append(it.next().toString()); [EOL]         if (it.hasNext()) { [EOL]             sb.append("->"); [EOL]         } [EOL]     } [EOL] }
protected void _appendPathDesc(StringBuilder sb) { [EOL]     if (_path == null) { [EOL]         return; [EOL]     } [EOL]     Iterator<Reference> it = _path.iterator(); [EOL]     while (it.hasNext()) { [EOL]         sb.append(it.next().toString()); [EOL]         if (it.hasNext()) { [EOL]             sb.append("->"); [EOL]         } [EOL]     } [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public final void defaultSerializeDateValue(Date date, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) { [EOL]         jgen.writeNumber(date.getTime()); [EOL]     } else { [EOL]         jgen.writeString(_dateFormat().format(date)); [EOL]     } [EOL] }
public final void defaultSerializeDateValue(Date date, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) { [EOL]         jgen.writeNumber(date.getTime()); [EOL]     } else { [EOL]         jgen.writeString(_dateFormat().format(date)); [EOL]     } [EOL] }
public void defaultSerializeDateKey(Date date, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) { [EOL]         jgen.writeFieldName(String.valueOf(date.getTime())); [EOL]     } else { [EOL]         jgen.writeFieldName(_dateFormat().format(date)); [EOL]     } [EOL] }
public void defaultSerializeDateKey(Date date, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) { [EOL]         jgen.writeFieldName(String.valueOf(date.getTime())); [EOL]     } else { [EOL]         jgen.writeFieldName(_dateFormat().format(date)); [EOL]     } [EOL] }
protected final DateFormat _dateFormat() { [EOL]     if (_dateFormat != null) { [EOL]         return _dateFormat; [EOL]     } [EOL]     DateFormat df = _config.getDateFormat(); [EOL]     _dateFormat = df = (DateFormat) df.clone(); [EOL]     return df; [EOL] }
protected final DateFormat _dateFormat() { [EOL]     if (_dateFormat != null) { [EOL]         return _dateFormat; [EOL]     } [EOL]     DateFormat df = _config.getDateFormat(); [EOL]     _dateFormat = df = (DateFormat) df.clone(); [EOL]     return df; [EOL] }
