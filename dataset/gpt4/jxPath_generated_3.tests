public void testComputeContextDependent_SuperTrue() { [EOL] mockSuperComputeContextDependent(true); [EOL] boolean result = instance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionLast() { [EOL] instance.functionCode = Compiler.FUNCTION_LAST; [EOL] boolean result = instance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionBoolean_NoArgs() { [EOL] instance.functionCode = Compiler.FUNCTION_BOOLEAN; [EOL] instance.args = null; [EOL] boolean result = instance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionBoolean_EmptyArgs() { [EOL] instance.functionCode = Compiler.FUNCTION_BOOLEAN; [EOL] instance.args = new Object[0]; [EOL] boolean result = instance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionCount() { [EOL] instance.functionCode = Compiler.FUNCTION_COUNT; [EOL] boolean result = instance.computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependent_FunctionFormatNumber_InvalidArgs() { [EOL] instance.functionCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] instance.args = new Object[1]; // Less than 2 args [EOL] boolean result = instance.computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependent_FunctionFormatNumber_ValidArgs() { [EOL] instance.functionCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] instance.args = new Object[2]; // Exactly 2 args [EOL] boolean result = instance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeValueFunctionLast() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LAST); [EOL] when(functionLast(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionPosition() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_POSITION); [EOL] when(functionPosition(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionCount() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_COUNT); [EOL] when(functionCount(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionLang() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LANG); [EOL] when(functionLang(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionID() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_ID); [EOL] when(functionID(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionLocalName() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LOCAL_NAME); [EOL] when(functionLocalName(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNamespaceURI() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NAMESPACE_URI); [EOL] when(functionNamespaceURI(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionName() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NAME); [EOL] when(functionName(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_STRING); [EOL] when(functionString(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionConcat() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_CONCAT); [EOL] when(functionConcat(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionStartsWith() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_STARTS_WITH); [EOL] when(functionStartsWith(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionContains() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_CONTAINS); [EOL] when(functionContains(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSubstringBefore() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUBSTRING_BEFORE); [EOL] when(functionSubstringBefore(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSubstringAfter() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUBSTRING_AFTER); [EOL] when(functionSubstringAfter(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSubstring() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUBSTRING); [EOL] when(functionSubstring(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionStringLength() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_STRING_LENGTH); [EOL] when(functionStringLength(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNormalizeSpace() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NORMALIZE_SPACE); [EOL] when(functionNormalizeSpace(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionTranslate() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_TRANSLATE); [EOL] when(functionTranslate(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionBoolean() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_BOOLEAN); [EOL] when(functionBoolean(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNot() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NOT); [EOL] when(functionNot(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_TRUE); [EOL] when(functionTrue(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FALSE); [EOL] when(functionFalse(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNull() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NULL); [EOL] when(functionNull(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_NUMBER); [EOL] when(functionNumber(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSum() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_SUM); [EOL] when(functionSum(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFloor() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FLOOR); [EOL] when(functionFloor(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionCeiling() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_CEILING); [EOL] when(functionCeiling(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionRound() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_ROUND); [EOL] when(functionRound(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionKey() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_KEY); [EOL] when(functionKey(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFormatNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FORMAT_NUMBER); [EOL] when(functionFormatNumber(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
protected Object functionCount(EvalContext context) { [EOL] assertArgCount(1); [EOL] Expression arg1 = getArg1(); [EOL] int count = 0; [EOL] Object value = arg1.compute(context); [EOL] if (value instanceof NodePointer) { [EOL] value = ((NodePointer) value).getValue(); [EOL] } [EOL] if (value instanceof EvalContext) { [EOL] EvalContext ctx = (EvalContext) value; [EOL] while (ctx.hasNext()) { [EOL] ctx.next(); [EOL] count++; [EOL] } [EOL] } else if (value instanceof Collection) { [EOL] count = ((Collection) value).size(); [EOL] } else if (value == null) { [EOL] count = 0; [EOL] } else { [EOL] count = 1; [EOL] } [EOL] return new Double(count); [EOL] }
public void testFunctionNamespaceURIWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] when(context.getCurrentNodePointer().getNamespaceURI()).thenReturn(null); [EOL] Object result = functionNamespaceURI(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionNamespaceURIWithNonNullNamespace() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] when(context.getCurrentNodePointer().getNamespaceURI()).thenReturn("http://example.com"); [EOL] Object result = functionNamespaceURI(context); [EOL] assertEquals("http://example.com", result); [EOL] }
public void testFunctionNamespaceURIWithOneArgumentAndNoNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(mock(EvalContext.class)); [EOL] Object result = functionNamespaceURI(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionNamespaceURIWithOneArgumentAndNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext argContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(argContext); [EOL] when(argContext.hasNext()).thenReturn(true); [EOL] when(argContext.next()).thenReturn(nodePointer); [EOL] when(nodePointer.getNamespaceURI()).thenReturn("http://example.com"); [EOL] Object result = functionNamespaceURI(context); [EOL] assertEquals("http://example.com", result); [EOL] }
public void testFunctionLocalNameWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] when(context.getCurrentNodePointer().getName()).thenReturn(mock(QName.class)); [EOL] when(context.getCurrentNodePointer().getName().getName()).thenReturn("localName"); [EOL] Object result = functionLocalName(context); [EOL] assertEquals("localName", result); [EOL] }
public void testFunctionLocalNameWithOneArgumentAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext argContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] QName qName = mock(QName.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(argContext); [EOL] when(argContext.hasNext()).thenReturn(true); [EOL] when(argContext.next()).thenReturn(nodePointer); [EOL] when(nodePointer.getName()).thenReturn(qName); [EOL] when(qName.getName()).thenReturn("localName"); [EOL] Object result = functionLocalName(context); [EOL] assertEquals("localName", result); [EOL] }
public void testFunctionLocalNameWithOneArgumentAndNoNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext argContext = mock(EvalContext.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(argContext); [EOL] when(argContext.hasNext()).thenReturn(false); [EOL] Object result = functionLocalName(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionNameWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] when(context.getCurrentNodePointer().getName()).thenReturn(mock(QName.class)); [EOL] when(context.getCurrentNodePointer().getName().toString()).thenReturn("NodeName"); [EOL] Object result = functionName(context); [EOL] assertEquals("NodeName", result); [EOL] }
public void testFunctionNameWithOneArgumentAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext argContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] QName qName = mock(QName.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(argContext); [EOL] when(argContext.hasNext()).thenReturn(true); [EOL] when(argContext.next()).thenReturn(nodePointer); [EOL] when(nodePointer.getName()).thenReturn(qName); [EOL] when(qName.toString()).thenReturn("NodeName"); [EOL] Object result = functionName(context); [EOL] assertEquals("NodeName", result); [EOL] }
public void testFunctionNameWithOneArgumentAndNoNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext argContext = mock(EvalContext.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(argContext); [EOL] when(argContext.hasNext()).thenReturn(false); [EOL] Object result = functionName(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionStringWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn("testValue"); [EOL] assertEquals("testValue", functionString(context)); [EOL] }
public void testFunctionStringWithOneArgument() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] setArg1(expression); // Assuming there is a method to set the first argument [EOL] when(expression.computeValue(context)).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn("computedValue"); [EOL] assertEquals("computedValue", functionString(context)); [EOL] }
public void testFunctionConcatWithLessThanTwoArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] try { [EOL] functionConcat(context); [EOL] fail("Expected an IllegalArgumentException due to insufficient arguments"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFunctionConcatWithTwoArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] when(arg1.compute(context)).thenReturn("Hello"); [EOL] when(arg2.compute(context)).thenReturn("World"); [EOL] setArguments(new Expression[]{arg1, arg2}); [EOL] Object result = functionConcat(context); [EOL] assertEquals("HelloWorld", result); [EOL] }
public void testFunctionConcatWithMultipleArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] Expression arg3 = mock(Expression.class); [EOL] when(arg1.compute(context)).thenReturn("Hello"); [EOL] when(arg2.compute(context)).thenReturn(","); [EOL] when(arg3.compute(context)).thenReturn("World"); [EOL] setArguments(new Expression[]{arg1, arg2, arg3}); [EOL] Object result = functionConcat(context); [EOL] assertEquals("Hello,World", result); [EOL] }
public void testFunctionStartsWithBothStringsEmpty() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(""); [EOL] when(getArg2().computeValue(context)).thenReturn(""); [EOL] Object result = functionStartsWith(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testFunctionStartsWithFirstStringEmpty() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(""); [EOL] when(getArg2().computeValue(context)).thenReturn("test"); [EOL] Object result = functionStartsWith(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testFunctionStartsWithSecondStringEmpty() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("test"); [EOL] when(getArg2().computeValue(context)).thenReturn(""); [EOL] Object result = functionStartsWith(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testFunctionStartsWithNonEmptyStringsTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("testString"); [EOL] when(getArg2().computeValue(context)).thenReturn("test"); [EOL] Object result = functionStartsWith(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testFunctionStartsWithNonEmptyStringsFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("testString"); [EOL] when(getArg2().computeValue(context)).thenReturn("String"); [EOL] Object result = functionStartsWith(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testFunctionContainsWithContainedString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("Hello World"); [EOL] when(getArg2().computeValue(context)).thenReturn("World"); [EOL] Object result = functionContains(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testFunctionContainsWithNonContainedString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("Hello World"); [EOL] when(getArg2().computeValue(context)).thenReturn("Universe"); [EOL] Object result = functionContains(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testFunctionContainsWithNullContext() { [EOL] EvalContext context = null; [EOL] try { [EOL] functionContains(context); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Context cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testFunctionContainsWithEmptyStrings() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(""); [EOL] when(getArg2().computeValue(context)).thenReturn(""); [EOL] Object result = functionContains(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testFunctionSubstringBeforeWithSubstringPresent() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] when(arg1.computeValue(context)).thenReturn("hello world"); [EOL] when(arg2.computeValue(context)).thenReturn(" world"); [EOL] Object result = functionSubstringBefore(context); [EOL] assertEquals("hello", result); [EOL] }
public void testFunctionSubstringBeforeWithSubstringAbsent() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] when(arg1.computeValue(context)).thenReturn("hello world"); [EOL] when(arg2.computeValue(context)).thenReturn("planet"); [EOL] Object result = functionSubstringBefore(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionSubstringBeforeWithEmptyString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] when(arg1.computeValue(context)).thenReturn(""); [EOL] when(arg2.computeValue(context)).thenReturn("planet"); [EOL] Object result = functionSubstringBefore(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionSubstringBeforeWithSubstringAtStart() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] when(arg1.computeValue(context)).thenReturn("hello world"); [EOL] when(arg2.computeValue(context)).thenReturn("hello"); [EOL] Object result = functionSubstringBefore(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionSubstringAfter_BothStringsPresent() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("hello world"); [EOL] when(getArg2().computeValue(context)).thenReturn("hello"); [EOL] Object result = functionSubstringAfter(context); [EOL] assertEquals(" world", result); [EOL] } [EOL] public void testFunctionSubstringAfter_SecondStringAbsent() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("hello world"); [EOL] when(getArg2().computeValue(context)).thenReturn("planet"); [EOL] Object result = functionSubstringAfter(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionSubstringWithInvalidArgumentCount() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(this.getArgumentCount()).thenReturn(1); // Any value other than 2 or 3 [EOL] Object result = this.functionSubstring(context); [EOL] verify(this).assertArgCount(2); [EOL] assertNull(result); [EOL] }
public void testFunctionSubstringWithNaNFrom() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(this.getArgumentCount()).thenReturn(2); [EOL] when(this.getArg1().computeValue(context)).thenReturn("test string"); [EOL] when(this.getArg2().computeValue(context)).thenReturn(Double.NaN); [EOL] Object result = this.functionSubstring(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionSubstringWithTwoArgumentsAndValidFrom() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(this.getArgumentCount()).thenReturn(2); [EOL] when(this.getArg1().computeValue(context)).thenReturn("test string"); [EOL] when(this.getArg2().computeValue(context)).thenReturn(3.7); // Will be rounded to 4 [EOL] Object result = this.functionSubstring(context); [EOL] assertEquals("st string", result); [EOL] }
public void testFunctionSubstringWithThreeArgumentsAndValidRange() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(this.getArgumentCount()).thenReturn(3); [EOL] when(this.getArg1().computeValue(context)).thenReturn("test string"); [EOL] when(this.getArg2().computeValue(context)).thenReturn(3.7); // Will be rounded to 4 [EOL] when(this.getArg3().computeValue(context)).thenReturn(5.3); // Will be rounded to 5 [EOL] Object result = this.functionSubstring(context); [EOL] assertEquals("st st", result); [EOL] }
public void testFunctionSubstringWithThreeArgumentsAndNegativeLength() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(this.getArgumentCount()).thenReturn(3); [EOL] when(this.getArg1().computeValue(context)).thenReturn("test string"); [EOL] when(this.getArg2().computeValue(context)).thenReturn(3.0); [EOL] when(this.getArg3().computeValue(context)).thenReturn(-1.0); // Negative length [EOL] Object result = this.functionSubstring(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionSubstringWithThreeArgumentsAndOutOfRangeTo() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(this.getArgumentCount()).thenReturn(3); [EOL] when(this.getArg1().computeValue(context)).thenReturn("test string"); [EOL] when(this.getArg2().computeValue(context)).thenReturn(1.0); [EOL] when(this.getArg3().computeValue(context)).thenReturn(20.0); // 'to' will be out of range [EOL] Object result = this.functionSubstring(context); [EOL] assertEquals("test string", result); [EOL] }
public void testFunctionStringLengthWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn("test"); [EOL] Object result = functionStringLength(context); [EOL] assertEquals(new Double("test".length()), result); [EOL] }
public void testFunctionStringLengthWithOneArgument() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1()).thenReturn(expression); [EOL] when(expression.computeValue(context)).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn("example"); [EOL] Object result = functionStringLength(context); [EOL] assertEquals(new Double("example".length()), result); [EOL] }
public void testFunctionNormalizeSpace_EmptyString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("", result); [EOL] } [EOL] public void testFunctionNormalizeSpace_SingleSpace() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(" "); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("", result); [EOL] } [EOL] public void testFunctionNormalizeSpace_MultipleSpaces() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("   "); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("", result); [EOL] } [EOL] public void testFunctionNormalizeSpace_SimpleString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("simple"); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("simple", result); [EOL] } [EOL] public void testFunctionNormalizeSpace_StringWithSpaces() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(" string with  spaces "); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("string with spaces", result); [EOL] } [EOL] public void testFunctionNormalizeSpace_StringWithTabsAndNewlines() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("\tstring\nwith\n\ttabs and newlines\n"); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("string with tabs and newlines", result); [EOL] } [EOL] public void testFunctionNormalizeSpace_StringWithVariousWhitespace() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(" \t\n\rstring with various\t\n\rwhitespace\r\n\t "); [EOL] Object result = functionNormalizeSpace(context); [EOL] assertEquals("string with various whitespace", result); [EOL] }
public void testFunctionTranslateWithReplacement() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("abc"); [EOL] when(getArg2().computeValue(context)).thenReturn("a"); [EOL] when(getArg3().computeValue(context)).thenReturn("x"); [EOL] Object result = functionTranslate(context); [EOL] assertEquals("xbc", result); [EOL] }
public void testFunctionTranslateWithoutReplacement() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("abc"); [EOL] when(getArg2().computeValue(context)).thenReturn("d"); [EOL] when(getArg3().computeValue(context)).thenReturn("x"); [EOL] Object result = functionTranslate(context); [EOL] assertEquals("abc", result); [EOL] }
public void testFunctionTranslateWithPartialReplacement() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("abc"); [EOL] when(getArg2().computeValue(context)).thenReturn("ab"); [EOL] when(getArg3().computeValue(context)).thenReturn("xy"); [EOL] Object result = functionTranslate(context); [EOL] assertEquals("xyc", result); [EOL] }
public void testFunctionTranslateWithExcessReplacementCharacters() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn("abc"); [EOL] when(getArg2().computeValue(context)).thenReturn("ab"); [EOL] when(getArg3().computeValue(context)).thenReturn("xyz"); [EOL] Object result = functionTranslate(context); [EOL] assertEquals("xyc", result); [EOL] }
public void testFunctionNotWithTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] FunctionNot function = new FunctionNot(); [EOL] function.setArg1(new Literal(new Boolean(true))); [EOL] Object result = function.functionNot(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testFunctionNotWithFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] FunctionNot function = new FunctionNot(); [EOL] function.setArg1(new Literal(new Boolean(false))); [EOL] Object result = function.functionNot(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
protected Object functionTrue(EvalContext context) { [EOL] assertArgCount(0); [EOL] return Boolean.TRUE; [EOL] }
public void testFunctionNullWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object result = functionNull(context); [EOL] assertNull(result); [EOL] }
public void testFunctionNumberWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(getArgumentCount()).thenReturn(0); [EOL] Object expected = new Double(123.0); [EOL] when(InfoSetUtil.number(nodePointer)).thenReturn(expected); [EOL] Object result = functionNumber(context); [EOL] assertEquals(expected, result); [EOL] }
public void testFunctionNumberWithOneArgument() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression arg1 = mock(Expression.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1()).thenReturn(arg1); [EOL] Object expected = new Double(456.0); [EOL] when(arg1.computeValue(context)).thenReturn(expected); [EOL] Object result = functionNumber(context); [EOL] assertEquals(expected, result); [EOL] }
public void testFunctionFloorWithPositiveNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Function function = new FunctionFloor(); [EOL] function.addArg(new Literal(new Double(3.7))); [EOL] Object result = function.functionFloor(context); [EOL] assertEquals("Floor of positive number", 3.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testFunctionFloorWithNegativeNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Function function = new FunctionFloor(); [EOL] function.addArg(new Literal(new Double(-2.3))); [EOL] Object result = function.functionFloor(context); [EOL] assertEquals("Floor of negative number", -3.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testFunctionFloorWithZero() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Function function = new FunctionFloor(); [EOL] function.addArg(new Literal(new Double(0.0))); [EOL] Object result = function.functionFloor(context); [EOL] assertEquals("Floor of zero", 0.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testFunctionCeilingWithPositiveNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(1.5); [EOL] Object result = functionCeiling(context); [EOL] assertEquals("Should return the ceiling value of a positive number", 2.0, result); [EOL] }
public void testFunctionCeilingWithNegativeNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(-1.5); [EOL] Object result = functionCeiling(context); [EOL] assertEquals("Should return the ceiling value of a negative number", -1.0, result); [EOL] }
public void testFunctionCeilingWithZero() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(0.0); [EOL] Object result = functionCeiling(context); [EOL] assertEquals("Should return the ceiling value of zero", 0.0, result); [EOL] }
public void testFunctionCeilingWithPositiveInfinity() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(Double.POSITIVE_INFINITY); [EOL] Object result = functionCeiling(context); [EOL] assertEquals("Should return the ceiling value of positive infinity", Double.POSITIVE_INFINITY, result); [EOL] }
public void testFunctionCeilingWithNegativeInfinity() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(Double.NEGATIVE_INFINITY); [EOL] Object result = functionCeiling(context); [EOL] assertEquals("Should return the ceiling value of negative infinity", Double.NEGATIVE_INFINITY, result); [EOL] }
public void testFunctionCeilingWithNaN() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(Double.NaN); [EOL] Object result = functionCeiling(context); [EOL] assertTrue("Should return NaN for NaN input", Double.isNaN((Double) result)); [EOL] }
public void testFunctionRoundWithPositiveValue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(2.5); [EOL] Object result = functionRound(context); [EOL] assertEquals(new Double(3), result); [EOL] }
public void testFunctionRoundWithNegativeValue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(-2.5); [EOL] Object result = functionRound(context); [EOL] assertEquals(new Double(-2), result); [EOL] }
public void testFunctionRoundWithZeroValue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().computeValue(context)).thenReturn(0.0); [EOL] Object result = functionRound(context); [EOL] assertEquals(new Double(0), result); [EOL] }
public void testCollectNamespacesWithParentNode() { [EOL] List attributes = new ArrayList(); [EOL] Node node = mock(Node.class); [EOL] Node parentNode = mock(Node.class); [EOL] when(node.getParentNode()).thenReturn(parentNode); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(parentNode.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] when(node.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] Attr attr = mock(Attr.class); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(attr.getPrefix()).thenReturn("xmlns"); [EOL] when(attr.getLocalName()).thenReturn("localName"); [EOL] collectNamespaces(attributes, node); [EOL] assertTrue(attributes.contains(attr)); [EOL] }
public void testCollectNamespacesWithDocumentNode() { [EOL] List attributes = new ArrayList(); [EOL] Node node = mock(Node.class); [EOL] Document document = mock(Document.class); [EOL] Element documentElement = mock(Element.class); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] when(((Document) node).getDocumentElement()).thenReturn(documentElement); [EOL] when(documentElement.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] when(documentElement.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] Attr attr = mock(Attr.class); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(attr.getPrefix()).thenReturn(null); [EOL] when(attr.getLocalName()).thenReturn("xmlns"); [EOL] collectNamespaces(attributes, node); [EOL] assertTrue(attributes.contains(attr)); [EOL] }
public void testCollectNamespacesWithElementNodeNoNamespace() { [EOL] List attributes = new ArrayList(); [EOL] Node node = mock(Node.class); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] when(node.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] Attr attr = mock(Attr.class); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(attr.getPrefix()).thenReturn("notXmlns"); [EOL] when(attr.getLocalName()).thenReturn("localName"); [EOL] collectNamespaces(attributes, node); [EOL] assertFalse(attributes.contains(attr)); [EOL] }
public void testGetPosition() { [EOL] MyClass instance = new MyClass(); [EOL] int expected = 10; // Assuming 'position' should be 10 for this test case [EOL] instance.position = expected; // Directly setting the position for the purpose of the test [EOL] int result = instance.getPosition(); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateNodePointerWithNullBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] NodePointer result = createNodePointer(parent, name, null); [EOL] assertTrue(result instanceof NullPointer); [EOL] }
public void testCreateNodePointerWithDynamicBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object bean = mock(Object.class); [EOL] JXPathBeanInfo bi = mock(JXPathBeanInfo.class); [EOL] when(JXPathIntrospector.getBeanInfo(bean.getClass())).thenReturn(bi); [EOL] when(bi.isDynamic()).thenReturn(true); [EOL] DynamicPropertyHandler handler = mock(DynamicPropertyHandler.class); [EOL] when(ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass())).thenReturn(handler); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof DynamicPointer); [EOL] }
public void testCreateNodePointerWithStaticBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object bean = mock(Object.class); [EOL] JXPathBeanInfo bi = mock(JXPathBeanInfo.class); [EOL] when(JXPathIntrospector.getBeanInfo(bean.getClass())).thenReturn(bi); [EOL] when(bi.isDynamic()).thenReturn(false); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public void testJDOMNodePointerWithNullParentAndNullNode() { [EOL] NodePointer parent = null; [EOL] Object node = null; [EOL] JDOMNodePointer pointer = new JDOMNodePointer(parent, node); [EOL] assertNull(pointer.getParent()); [EOL] assertNull(pointer.getNode()); [EOL] } [EOL] public void testJDOMNodePointerWithNonNullParentAndNullNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Object node = null; [EOL] JDOMNodePointer pointer = new JDOMNodePointer(parent, node); [EOL] assertNotNull(pointer.getParent()); [EOL] assertNull(pointer.getNode()); [EOL] } [EOL] public void testJDOMNodePointerWithNullParentAndNonNullNode() { [EOL] NodePointer parent = null; [EOL] Object node = new Object(); [EOL] JDOMNodePointer pointer = new JDOMNodePointer(parent, node); [EOL] assertNull(pointer.getParent()); [EOL] assertNotNull(pointer.getNode()); [EOL] } [EOL] public void testJDOMNodePointerWithNonNullParentAndNonNullNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Object node = new Object(); [EOL] JDOMNodePointer pointer = new JDOMNodePointer(parent, node); [EOL] assertNotNull(pointer.getParent()); [EOL] assertNotNull(pointer.getNode()); [EOL] }
public void testChildIteratorWithNullTest() { [EOL] NodeIterator result = childIterator(null, false, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNonNullTestReverseFalse() { [EOL] NodeTest test = mock(NodeTest.class); [EOL] NodeIterator result = childIterator(test, false, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNonNullTestReverseTrue() { [EOL] NodeTest test = mock(NodeTest.class); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNonNullTestAndStartWith() { [EOL] NodeTest test = mock(NodeTest.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] NodeIterator result = childIterator(test, false, startWith); [EOL] assertNotNull(result); [EOL] }
public void testAttributeIteratorWithNonNullName() { [EOL] QName name = new QName("testName"); [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(new Element("element"), Locale.getDefault()); [EOL] NodeIterator iterator = nodePointer.attributeIterator(name); [EOL] assertNotNull(iterator); [EOL] assertTrue(iterator instanceof JDOMAttributeIterator); [EOL] }
public void testAttributeIteratorWithNullName() { [EOL] QName name = null; [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(new Element("element"), Locale.getDefault()); [EOL] try { [EOL] nodePointer.attributeIterator(name); [EOL] fail("Should throw IllegalArgumentException for null QName"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNamespacePointerWithNonNullPrefix() { [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(new Object()); [EOL] String prefix = "testPrefix"; [EOL] NodePointer result = nodePointer.namespacePointer(prefix); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMNamespacePointer); [EOL] assertEquals(prefix, ((JDOMNamespacePointer) result).getPrefix()); [EOL] }
public void testNamespacePointerWithNullPrefix() { [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(new Object()); [EOL] String prefix = null; [EOL] NodePointer result = nodePointer.namespacePointer(prefix); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMNamespacePointer); [EOL] assertNull(((JDOMNamespacePointer) result).getPrefix()); [EOL] }
public String getNamespaceURITest_NullNode() { [EOL] node = null; [EOL] String result = getNamespaceURI(); [EOL] assertNull(result); [EOL] }
public String getNamespaceURITest_ValidNode() { [EOL] String expected = "http://example.com/namespace"; [EOL] when(getNamespaceURI(node)).thenReturn(expected); [EOL] String result = getNamespaceURI(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetNamespaceURIWithElementHavingNamespace() { [EOL] Element element = mock(Element.class); [EOL] when(element.getNamespaceURI()).thenReturn("http://example.com/ns"); [EOL] String ns = getNamespaceURI(element); [EOL] assertEquals("http://example.com/ns", ns); [EOL] }
public void testGetNamespaceURIWithElementHavingEmptyNamespace() { [EOL] Element element = mock(Element.class); [EOL] when(element.getNamespaceURI()).thenReturn(""); [EOL] String ns = getNamespaceURI(element); [EOL] assertNull(ns); [EOL] }
public void testGetNamespaceURIWithElementHavingNullNamespace() { [EOL] Element element = mock(Element.class); [EOL] when(element.getNamespaceURI()).thenReturn(null); [EOL] String ns = getNamespaceURI(element); [EOL] assertNull(ns); [EOL] }
public void testGetNamespaceURIWithNonElement() { [EOL] Object nonElement = new Object(); [EOL] String ns = getNamespaceURI(nonElement); [EOL] assertNull(ns); [EOL] }
public void testGetNamespaceURIDocumentWithValidPrefix() { [EOL] Node node = createMock(Document.class); [EOL] Element element = createMock(Element.class); [EOL] Namespace ns = createMock(Namespace.class); [EOL] expect(((Document) node).getRootElement()).andReturn(element); [EOL] expect(element.getNamespace("validPrefix")).andReturn(ns); [EOL] expect(ns.getURI()).andReturn("http://example.com/namespace"); [EOL] replay(node, element, ns); [EOL] String result = getNamespaceURI("validPrefix"); [EOL] assertEquals("http://example.com/namespace", result); [EOL] verify(node, element, ns); [EOL] }
public void testGetNamespaceURIDocumentWithInvalidPrefix() { [EOL] Node node = createMock(Document.class); [EOL] Element element = createMock(Element.class); [EOL] expect(((Document) node).getRootElement()).andReturn(element); [EOL] expect(element.getNamespace("invalidPrefix")).andReturn(null); [EOL] replay(node, element); [EOL] String result = getNamespaceURI("invalidPrefix"); [EOL] assertNull(result); [EOL] verify(node, element); [EOL] }
public void testGetNamespaceURIElementWithValidPrefix() { [EOL] Node node = createMock(Element.class); [EOL] Namespace ns = createMock(Namespace.class); [EOL] expect(((Element) node).getNamespace("validPrefix")).andReturn(ns); [EOL] expect(ns.getURI()).andReturn("http://example.com/namespace"); [EOL] replay(node, ns); [EOL] String result = getNamespaceURI("validPrefix"); [EOL] assertEquals("http://example.com/namespace", result); [EOL] verify(node, ns); [EOL] }
public void testGetNamespaceURIElementWithInvalidPrefix() { [EOL] Node node = createMock(Element.class); [EOL] expect(((Element) node).getNamespace("invalidPrefix")).andReturn(null); [EOL] replay(node); [EOL] String result = getNamespaceURI("invalidPrefix"); [EOL] assertNull(result); [EOL] verify(node); [EOL] }
public void testGetNamespaceURINonDocumentOrElement() { [EOL] Node node = createMock(Node.class); [EOL] replay(node); [EOL] String result = getNamespaceURI("anyPrefix"); [EOL] assertNull(result); [EOL] verify(node); [EOL] }
public int getLength() { [EOL] return 1; [EOL] }
public void testIsLeafWithElementNodeHavingNoContent() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getContent()).thenReturn(Collections.emptyList()); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testIsLeafWithElementNodeHavingContent() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getContent()).thenReturn(Collections.singletonList(mock(Object.class))); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertFalse(result); [EOL] }
public void testIsLeafWithDocumentNodeHavingNoContent() { [EOL] Node node = mock(Document.class); [EOL] when(((Document) node).getContent()).thenReturn(Collections.emptyList()); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testIsLeafWithDocumentNodeHavingContent() { [EOL] Node node = mock(Document.class); [EOL] when(((Document) node).getContent()).thenReturn(Collections.singletonList(mock(Object.class))); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertFalse(result); [EOL] }
public void testIsLeafWithNonElementOrDocumentNode() { [EOL] Node node = mock(Node.class); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testGetNameWithElementHavingNamespace() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespacePrefix()).thenReturn("ns"); [EOL] when(((Element) node).getName()).thenReturn("localName"); [EOL] QName result = getName(node); // Assuming getName is a method of the current instance [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameWithElementHavingEmptyNamespace() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespacePrefix()).thenReturn(""); [EOL] when(((Element) node).getName()).thenReturn("localName"); [EOL] QName result = getName(node); // Assuming getName is a method of the current instance [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameWithElementNoNamespace() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespacePrefix()).thenReturn(null); [EOL] when(((Element) node).getName()).thenReturn("localName"); [EOL] QName result = getName(node); // Assuming getName is a method of the current instance [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameWithProcessingInstruction() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("target"); [EOL] QName result = getName(node); // Assuming getName is a method of the current instance [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("target", result.getLocalPart()); [EOL] }
public void testGetNameWithOtherNodeType() { [EOL] Node node = mock(Node.class); [EOL] QName result = getName(node); // Assuming getName is a method of the current instance [EOL] assertNull(result.getNamespaceURI()); [EOL] assertNull(result.getLocalPart()); [EOL] }
public Object testGetImmediateNode() { [EOL] YourClass instance = new YourClass(); [EOL] Object expectedNode = new Object(); [EOL] instance.node = expectedNode; [EOL] Object result = instance.getImmediateNode(); [EOL] assertSame("The returned node is not the same as the expected node.", expectedNode, result); [EOL] }
public void testGetValueWithElement() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getTextTrim()).thenReturn("ElementText"); [EOL] Object result = getValue(node); [EOL] assertEquals("ElementText", result); [EOL] }
public void testGetValueWithCommentAndNonNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn(" CommentText "); [EOL] Object result = getValue(node); [EOL] assertEquals("CommentText", result); [EOL] }
public void testGetValueWithCommentAndNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithText() { [EOL] Node node = mock(Text.class); [EOL] when(((Text) node).getTextTrim()).thenReturn("TextContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("TextContent", result); [EOL] }
public void testGetValueWithCdata() { [EOL] Node node = mock(CDATA.class); [EOL] when(((CDATA) node).getTextTrim()).thenReturn("CdataContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("CdataContent", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNonNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn(" Data "); [EOL] Object result = getValue(node); [EOL] assertEquals("Data", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithUnknownNodeType() { [EOL] Node node = mock(Node.class); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public boolean testNode(NodeTest test) { [EOL] return testNode(this, node, test); [EOL] }
public void testTestNodeWithNullTest() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] assertTrue(JxPath.testNode(mockPointer, mockNode, null)); [EOL] }
public void testTestNodeWithNodeNameTestAndElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Element mockElement = mock(Element.class); [EOL] NodeNameTest mockNodeNameTest = mock(NodeNameTest.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockNodeNameTest.getNodeName()).thenReturn(mockQName); [EOL] when(mockNodeNameTest.isWildcard()).thenReturn(false); [EOL] when(mockQName.getName()).thenReturn("testName"); [EOL] when(JDOMNodePointer.getLocalName(mockElement)).thenReturn("testName"); [EOL] when(mockNodeNameTest.getNamespaceURI()).thenReturn("testURI"); [EOL] when(JDOMNodePointer.getNamespaceURI(mockElement)).thenReturn("testURI"); [EOL] assertTrue(JxPath.testNode(mockPointer, mockElement, mockNodeNameTest)); [EOL] }
public void testTestNodeWithNodeNameTestAndNonElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] NodeNameTest mockNodeNameTest = mock(NodeNameTest.class); [EOL] assertFalse(JxPath.testNode(mockPointer, mockNode, mockNodeNameTest)); [EOL] }
public void testTestNodeWithNodeTypeTestAndElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Element mockElement = mock(Element.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] assertTrue(JxPath.testNode(mockPointer, mockElement, mockNodeTypeTest)); [EOL] }
public void testTestNodeWithNodeTypeTestAndTextNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Text mockText = mock(Text.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] assertTrue(JxPath.testNode(mockPointer, mockText, mockNodeTypeTest)); [EOL] }
public void testTestNodeWithNodeTypeTestAndCommentNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Comment mockComment = mock(Comment.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] assertTrue(JxPath.testNode(mockPointer, mockComment, mockNodeTypeTest)); [EOL] }
public void testTestNodeWithNodeTypeTestAndPINode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockPI = mock(ProcessingInstruction.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] assertTrue(JxPath.testNode(mockPointer, mockPI, mockNodeTypeTest)); [EOL] }
public void testTestNodeWithProcessingInstructionTestAndMatchingPI() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockPI = mock(ProcessingInstruction.class); [EOL] ProcessingInstructionTest mockPITest = mock(ProcessingInstructionTest.class); [EOL] when(mockPITest.getTarget()).thenReturn("testTarget"); [EOL] when(mockPI.getTarget()).thenReturn("testTarget"); [EOL] assertTrue(JxPath.testNode(mockPointer, mockPI, mockPITest)); [EOL] }
public void testTestNodeWithProcessingInstructionTestAndNonMatchingPI() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockPI = mock(ProcessingInstruction.class); [EOL] ProcessingInstructionTest mockPITest = mock(ProcessingInstructionTest.class); [EOL] when(mockPITest.getTarget()).thenReturn("testTarget"); [EOL] when(mockPI.getTarget()).thenReturn("differentTarget"); [EOL] assertFalse(JxPath.testNode(mockPointer, mockPI, mockPITest)); [EOL] }
public void testTestNodeWithProcessingInstructionTestAndNonPINode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] ProcessingInstructionTest mockPITest = mock(ProcessingInstructionTest.class); [EOL] assertFalse(JxPath.testNode(mockPointer, mockNode, mockPITest)); [EOL] }
public void testEqualStringsBothNull() { [EOL] boolean result = equalStrings(null, null); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsFirstNull() { [EOL] boolean result = equalStrings(null, "test"); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsSecondNull() { [EOL] boolean result = equalStrings("test", null); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsBothNonTrimmed() { [EOL] boolean result = equalStrings(" test ", " test "); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsDifferentNonTrimmed() { [EOL] boolean result = equalStrings(" test1 ", " test2 "); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsTrimmedDifferent() { [EOL] boolean result = equalStrings("test1", "test2"); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsSameNonTrimmed() { [EOL] boolean result = equalStrings(" test ", "test"); [EOL] assertTrue(result); [EOL] }
public void testGetLocalNameWithElement() { [EOL] Element element = mock(Element.class); [EOL] when(element.getName()).thenReturn("elementName"); [EOL] String result = getLocalName(element); [EOL] assertEquals("elementName", result); [EOL] }
public void testGetLocalNameWithAttribute() { [EOL] Attribute attribute = mock(Attribute.class); [EOL] when(attribute.getName()).thenReturn("attributeName"); [EOL] String result = getLocalName(attribute); [EOL] assertEquals("attributeName", result); [EOL] }
public void testGetLocalNameWithNonRelevantObject() { [EOL] Object nonRelevantObject = new Object(); [EOL] String result = getLocalName(nonRelevantObject); [EOL] assertNull(result); [EOL] }
public void testDynaBeanPointerWithValidArguments() { [EOL] QName name = new QName("test"); [EOL] DynaBean dynaBean = new LazyDynaBean(); [EOL] Locale locale = Locale.ENGLISH; [EOL] DynaBeanPointer dynaBeanPointer = new DynaBeanPointer(name, dynaBean, locale); [EOL] assertNotNull(dynaBeanPointer); [EOL] assertEquals(name, dynaBeanPointer.getName()); [EOL] assertEquals(dynaBean, dynaBeanPointer.getDynaBean()); [EOL] assertEquals(locale, dynaBeanPointer.getLocale()); [EOL] }
public void testGetPropertyPointer() { [EOL] DynaBean dynaBean = createMockDynaBean(); [EOL] DynaBeanPropertyPointerTestable testable = new DynaBeanPropertyPointerTestable(dynaBean); [EOL] PropertyPointer result = testable.getPropertyPointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DynaBeanPropertyPointer); [EOL] assertEquals(dynaBean, ((DynaBeanPropertyPointer) result).getBean()); [EOL] }
public void testGetImmediateNode() { [EOL] Object expected = instance.dynaBean; [EOL] Object actual = instance.getImmediateNode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAsPathWithNonNullParent() { [EOL] instance.setParent(new ParentType()); // Replace ParentType with actual parent class [EOL] String result = instance.asPath(); [EOL] assertEquals("Expected path from super asPath method", result); [EOL] }
public void testAsPathWithNullParent() { [EOL] instance.setParent(null); [EOL] String result = instance.asPath(); [EOL] assertEquals("Expected root path '/'", "/", result); [EOL] }
public void testNCNameWithNCNameToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NCName; [EOL] token.image = "expectedNCName"; [EOL] Parser parser = new Parser(token); [EOL] String result = parser.NCName(); [EOL] assertEquals("expectedNCName", result); [EOL] }
public void testNCNameWithNodeToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NODE; [EOL] Parser parser = new Parser(token); [EOL] parser.NCName(); [EOL] }
public void testNCNameWithTextToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = TEXT; [EOL] Parser parser = new Parser(token); [EOL] parser.NCName(); [EOL] }
public void testNCNameWithCommentToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = COMMENT; [EOL] Parser parser = new Parser(token); [EOL] parser.NCName(); [EOL] }
public void testNCNameWithPIToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = PI; [EOL] Parser parser = new Parser(token); [EOL] parser.NCName(); [EOL] }
public void testNCNameWithFunctionLastToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_LAST; [EOL] Parser parser = new Parser(token); [EOL] parser.NCName(); [EOL] }
public void testNCNameWithInvalidToken() { [EOL] Token token = new Token(); [EOL] token.kind = -1; // Invalid token kind [EOL] Parser parser = new Parser(token); [EOL] assertThrows(ParseException.class, parser::NCName); [EOL] }
public void testCoreFunctionNameWithFunctionLast() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LAST; [EOL] int expectedCode = Compiler.FUNCTION_LAST; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionPosition() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_POSITION; [EOL] int expectedCode = Compiler.FUNCTION_POSITION; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCount() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_COUNT; [EOL] int expectedCode = Compiler.FUNCTION_COUNT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionId() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ID; [EOL] int expectedCode = Compiler.FUNCTION_ID; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLocalName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LOCAL_NAME; [EOL] int expectedCode = Compiler.FUNCTION_LOCAL_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNamespaceUri() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAMESPACE_URI; [EOL] int expectedCode = Compiler.FUNCTION_NAMESPACE_URI; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAME; [EOL] int expectedCode = Compiler.FUNCTION_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionString() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING; [EOL] int expectedCode = Compiler.FUNCTION_STRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionConcat() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONCAT; [EOL] int expectedCode = Compiler.FUNCTION_CONCAT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStartsWith() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STARTS_WITH; [EOL] int expectedCode = Compiler.FUNCTION_STARTS_WITH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionContains() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONTAINS; [EOL] int expectedCode = Compiler.FUNCTION_CONTAINS; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringBefore() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_BEFORE; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringAfter() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_AFTER; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstring() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStringLength() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING_LENGTH; [EOL] int expectedCode = Compiler.FUNCTION_STRING_LENGTH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNormalizeSpace() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NORMALIZE_SPACE; [EOL] int expectedCode = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTranslate() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRANSLATE; [EOL] int expectedCode = Compiler.FUNCTION_TRANSLATE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionBoolean() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_BOOLEAN; [EOL] int expectedCode = Compiler.FUNCTION_BOOLEAN; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNot() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NOT; [EOL] int expectedCode = Compiler.FUNCTION_NOT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTrue() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRUE; [EOL] int expectedCode = Compiler.FUNCTION_TRUE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFalse() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FALSE; [EOL] int expectedCode = Compiler.FUNCTION_FALSE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNull() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NULL; [EOL] int expectedCode = Compiler.FUNCTION_NULL; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLang() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LANG; [EOL] int expectedCode = Compiler.FUNCTION_LANG; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSum() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUM; [EOL] int expectedCode = Compiler.FUNCTION_SUM; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFloor() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FLOOR; [EOL] int expectedCode = Compiler.FUNCTION_FLOOR; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCeiling() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CEILING; [EOL] int expectedCode = Compiler.FUNCTION_CEILING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionRound() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ROUND; [EOL] int expectedCode = Compiler.FUNCTION_ROUND; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionKey() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_KEY; [EOL] int expectedCode = Compiler.FUNCTION_KEY; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFormatNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FORMAT_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithInvalidToken() { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = INVALID_TOKEN_KIND; // Assuming INVALID_TOKEN_KIND is a constant for an invalid token kind [EOL] try { [EOL] CoreFunctionName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object testLocationPathWithRelativeLocationPath() throws ParseException { [EOL] jj_nt.kind = OR; // OR is one of the kinds that lead to RelativeLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming RelativeLocationPath returns a non-null object [EOL] return result; [EOL] }
public Object testLocationPathWithAbsoluteLocationPath() throws ParseException { [EOL] jj_nt.kind = SLASH; // SLASH is one of the kinds that lead to AbsoluteLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming AbsoluteLocationPath returns a non-null object [EOL] return result; [EOL] }
public void testLocationPathWithParseException() { [EOL] jj_nt.kind = 999; // An invalid kind that is not handled by the switch [EOL] assertThrows(ParseException.class, () -> { [EOL] LocationPath(); [EOL] }); [EOL] }
public void testRelativeLocationPathWithSlash() throws ParseException { [EOL] jj_nt.kind = TokenConstants.SLASH; [EOL] Object result = RelativeLocationPath(); [EOL] assertNotNull(result); [EOL] }
public void testRelativeLocationPathWithSlashSlash() throws ParseException { [EOL] jj_nt.kind = TokenConstants.SLASHSLASH; [EOL] Object result = RelativeLocationPath(); [EOL] assertNotNull(result); [EOL] }
public void testRelativeLocationPathWithOtherKind() throws ParseException { [EOL] jj_nt.kind = TokenConstants.OTHER_KIND; [EOL] Object result = RelativeLocationPath(); [EOL] assertNotNull(result); [EOL] }
public void testNodeTestWithNodeType() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NODE; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithProcessingInstruction() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.PI; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithWildcardName() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NCName; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithSelfAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 82; // Assuming 82 corresponds to the correct token kind for AXIS_SELF [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParentAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 83; // Assuming 83 corresponds to the correct token kind for AXIS_PARENT [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithPredicate() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 84; // Assuming 84 corresponds to the correct token kind for a Predicate [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParseException() { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = -1; // Invalid kind to trigger ParseException [EOL] try { [EOL] jjParser.NodeTest(steps); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testAxisSpecifierWithAxisSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithDefault() throws ParseException { [EOL] jj_nt.kind = SOME_OTHER_KIND; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AbbreviatedAxisSpecifier(), result); [EOL] }
public void testAxisNameSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_SELF, result); [EOL] }
public void testAxisNameChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAxisNameParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PARENT, result); [EOL] }
public void testAxisNameAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR, result); [EOL] }
public void testAxisNameAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testAxisNameNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_NAMESPACE, result); [EOL] }
public void testAxisNamePreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING, result); [EOL] }
public void testAxisNameFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING, result); [EOL] }
public void testAxisNameDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT, result); [EOL] }
public void testAxisNameAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR_OR_SELF, result); [EOL] }
public void testAxisNameFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING_SIBLING, result); [EOL] }
public void testAxisNamePrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING_SIBLING, result); [EOL] }
public void testAxisNameDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT_OR_SELF, result); [EOL] }
public void testAxisNameInvalid() { [EOL] jj_nt.kind = INVALID_AXIS; // Assuming INVALID_AXIS is a constant for an invalid axis [EOL] assertThrows(ParseException.class, () -> { [EOL] AxisName(); [EOL] }); [EOL] }
public void testCoreFunctionCallWithNullArguments() throws ParseException { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] when(mockCompiler.function(anyInt(), isNull())).thenReturn(new Object()); [EOL] MyClass myClass = new MyClass(mockCompiler); [EOL] Object result = myClass.CoreFunctionCall(); [EOL] verify(mockCompiler).function(anyInt(), isNull()); [EOL] assertNotNull(result); [EOL] }
public void testCoreFunctionCallWithNonNullArguments() throws ParseException { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] ArrayList<Object> mockArgs = new ArrayList<>(); [EOL] mockArgs.add(new Object()); [EOL] when(mockCompiler.function(anyInt(), any())).thenReturn(new Object()); [EOL] MyClass myClass = new MyClass(mockCompiler); [EOL] myClass.setArgumentList(mockArgs); [EOL] Object result = myClass.CoreFunctionCall(); [EOL] verify(mockCompiler).function(anyInt(), any()); [EOL] assertNotNull(result); [EOL] }
public void testArgumentListWithSingleArgument() throws ParseException { [EOL] setupTokenKind(SLASH); // Replace SLASH with the actual constant value [EOL] jj_consume_token(80); [EOL] ArrayList result = ArgumentList(); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] Object expectedArg = getExpectedArgument(); // Replace with actual method to get expected argument [EOL] assertEquals(expectedArg, result.get(0)); [EOL] }
public void testArgumentListWithMultipleArguments() throws ParseException { [EOL] setupTokenKind(SLASH); // Replace SLASH with the actual constant value [EOL] setupTokenKindForLoop(87); // Replace 87 with the actual constant value for multiple arguments [EOL] jj_consume_token(80); [EOL] ArrayList result = ArgumentList(); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() > 1); [EOL] Object expectedArg = getExpectedArgument(); // Replace with actual method to get expected argument [EOL] for (Object arg : result) { [EOL] assertEquals(expectedArg, arg); [EOL] } [EOL] }
public void testArgumentListWithNoArguments() throws ParseException { [EOL] setupTokenKind(81); // Replace 81 with the actual constant value for no arguments [EOL] jj_consume_token(80); [EOL] ArrayList result = ArgumentList(); [EOL] assertNull(result); [EOL] }
public Object testPathExprWithFilterExpr() throws ParseException { [EOL] setJj_2_6(true); [EOL] Object expected = new Object(); [EOL] when(FilterExpr()).thenReturn(expected); [EOL] Object result = PathExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testPathExprWithLocationPath() throws ParseException { [EOL] setJj_ntKind(SLASH); // SLASH is a placeholder for the actual constant value [EOL] Object expected = new Object(); [EOL] when(LocationPath()).thenReturn(expected); [EOL] Object result = PathExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testPathExprWithParseException() throws ParseException { [EOL] setJj_ntKind(INVALID_KIND); // INVALID_KIND is a placeholder for a value that is not handled by the switch [EOL] doThrow(new ParseException()).when(jj_consume_token(-1)); [EOL] assertThrows(ParseException.class, () -> { [EOL] PathExpr(); [EOL] }); [EOL] }
final public Object OrExpr() throws ParseException { [EOL] Object ex, r; [EOL] ArrayList list = null; [EOL] ex = AndExpr(); [EOL] label_8: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case OR: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[24] = jj_gen; [EOL] break label_8; [EOL] } [EOL] jj_consume_token(OR); [EOL] r = AndExpr(); [EOL] if (list == null) { [EOL] list = new ArrayList(); [EOL] list.add(ex); [EOL] } [EOL] list.add(r); [EOL] } [EOL] if (list != null) { [EOL] ex = compiler.or(list.toArray()); [EOL] } [EOL] { [EOL] if (true) [EOL] return ex; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testAndExprWithNoAnd() throws ParseException { [EOL] Object expected = new Object(); [EOL] when(mockedParser.EqualityExpr()).thenReturn(expected); [EOL] mockedParser.jj_nt.kind = SOME_OTHER_KIND; [EOL] Object result = mockedParser.AndExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testAndExprWithAnd() throws ParseException { [EOL] Object expectedFirst = new Object(); [EOL] Object expectedSecond = new Object(); [EOL] when(mockedParser.EqualityExpr()) [EOL] .thenReturn(expectedFirst) [EOL] .thenReturn(expectedSecond); [EOL] mockedParser.jj_nt.kind = AND; [EOL] doNothing().when(mockedParser).jj_consume_token(AND); [EOL] Object combinedResult = new Object(); [EOL] when(mockedCompiler.and(any())).thenReturn(combinedResult); [EOL] Object result = mockedParser.AndExpr(); [EOL] assertEquals(combinedResult, result); [EOL] }
public Object testEqualityExprWithEQ() throws ParseException { [EOL] jj_nt.kind = EQ; [EOL] Object expected = new Object(); // Expected result after calling compiler.equal() [EOL] when(RelationalExpr()).thenReturn(new Object()); [EOL] when(compiler.equal(any(), any())).thenReturn(expected); [EOL] Object result = EqualityExpr(); [EOL] assertEquals(expected, result); [EOL] verify(jj_consume_token, times(1)).invoke(EQ); [EOL] verify(compiler, times(1)).equal(any(), any()); [EOL] }
public Object testEqualityExprWithNEQ() throws ParseException { [EOL] jj_nt.kind = NEQ; [EOL] Object expected = new Object(); // Expected result after calling compiler.notEqual() [EOL] when(RelationalExpr()).thenReturn(new Object()); [EOL] when(compiler.notEqual(any(), any())).thenReturn(expected); [EOL] Object result = EqualityExpr(); [EOL] assertEquals(expected, result); [EOL] verify(jj_consume_token, times(1)).invoke(NEQ); [EOL] verify(compiler, times(1)).notEqual(any(), any()); [EOL] }
public Object testEqualityExprWithInvalidToken() { [EOL] jj_nt.kind = INVALID_TOKEN; // INVALID_TOKEN is a placeholder for any token that is not EQ or NEQ [EOL] assertThrows(ParseException.class, () -> { [EOL] EqualityExpr(); [EOL] }); [EOL] verify(jj_consume_token, times(1)).invoke(-1); [EOL] }
public Object testRelationalExprWithLT() throws ParseException { [EOL] initParserWithTokenKind(LT); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isLessThanCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithLTE() throws ParseException { [EOL] initParserWithTokenKind(LTE); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isLessThanOrEqualCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithGT() throws ParseException { [EOL] initParserWithTokenKind(GT); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isGreaterThanCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithGTE() throws ParseException { [EOL] initParserWithTokenKind(GTE); [EOL] Object result = parser.RelationalExpr(); [EOL] assertTrue(compiler.isGreaterThanOrEqualCalled()); [EOL] return result; [EOL] }
public Object testRelationalExprWithInvalidToken() { [EOL] initParserWithInvalidToken(); [EOL] try { [EOL] parser.RelationalExpr(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] return null; [EOL] }
public void testSubtractiveExprWithMinus() throws ParseException { [EOL] jj_nt.kind = MINUS; // Assuming jj_nt is accessible and of a type that has a kind field [EOL] Object firstExpr = new Object(); [EOL] Object secondExpr = new Object(); [EOL] Object expectedExpr = new Object(); [EOL] when(MultiplicativeExpr()).thenReturn(firstExpr, secondExpr); [EOL] when(compiler.minus(firstExpr, secondExpr)).thenReturn(expectedExpr); [EOL] Object result = SubtractiveExpr(); [EOL] assertEquals(expectedExpr, result); [EOL] }
public void testSubtractiveExprWithoutMinus() throws ParseException { [EOL] jj_nt.kind = OTHER_KIND; // OTHER_KIND is a placeholder for any kind that is not MINUS [EOL] jj_la1[31] = -1; // Set to a value that will be changed by the method [EOL] int expectedGenValue = jj_gen + 1; // Assuming jj_gen is incremented elsewhere in the code [EOL] Object expectedExpr = new Object(); [EOL] when(MultiplicativeExpr()).thenReturn(expectedExpr); [EOL] Object result = SubtractiveExpr(); [EOL] assertEquals(expectedExpr, result); [EOL] assertEquals(expectedGenValue, jj_la1[31]); [EOL] }
public Object testUnaryExprWithSlash() throws ParseException { [EOL] initParser("/"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithMinus() throws ParseException { [EOL] initParser("-"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testUnaryExprWithInvalidToken() { [EOL] initParser("#"); // Assuming '#' is an invalid token for this parser [EOL] try { [EOL] parser.UnaryExpr(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object wildcardNameCase88() throws ParseException { [EOL] jj_nt.kind = 88; [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object wildcardNameCaseNCName() throws ParseException { [EOL] jj_nt.kind = NCName; [EOL] NCName(); // Assuming this method sets the token.image [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object wildcardNameCaseDefault() throws ParseException { [EOL] jj_nt.kind = -1; // A value that does not match any case [EOL] try { [EOL] WildcardName(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] return null; [EOL] }
public Object wildcardNameCase79() throws ParseException { [EOL] jj_nt.kind = 79; [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object wildcardNameCase79WithNCName() throws ParseException { [EOL] jj_nt.kind = 79; [EOL] jj_nt.kind = NCName; [EOL] NCName(); // Assuming this method sets the token.image [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object wildcardNameCase79Default() throws ParseException { [EOL] jj_nt.kind = 79; [EOL] jj_nt.kind = -1; [EOL] try { [EOL] WildcardName(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] return null; [EOL] }
public void testJj_3R_64_WithFunctionCountToken() { [EOL] initToken(FUNCTION_COUNT); [EOL] boolean result = jj_3R_64(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_64_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_64(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_64_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] assertNotSame(jj_scanpos, jj_lastpos); [EOL] boolean result = jj_3R_64(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_62_TokenIsFunctionLast() { [EOL] boolean result = jj_3R_62(); [EOL] assert(result); [EOL] }
public void testJj_3R_62_AtEndOfInput() { [EOL] boolean result = jj_3R_62(); [EOL] assert(!result); [EOL] }
public void testJj_3R_62_NotAtEndOfInput() { [EOL] boolean result = jj_3R_62(); [EOL] assert(!result); [EOL] }
final private boolean jj_3R_18() { [EOL] Token xsp; [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_62()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_63()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_64()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_65()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_66()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_67()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_68()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_69()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_70()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_71()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_72()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_73()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_74()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_75()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_76()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_77()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_78()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_79()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_80()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_81()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_82()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_83()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_84()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_85()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_86()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_87()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_88()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_89()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_90()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_91()) [EOL] return true; [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] return false; [EOL] }
public void testJj_3R_173_WithTrueMinusToken() { [EOL] when(jj_scan_token(MINUS)).thenReturn(true); [EOL] boolean result = jj_3R_173(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_173_WithFalseMinusTokenAndLaEqualsZero() { [EOL] when(jj_scan_token(MINUS)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Mock the condition to make jj_la == 0 && jj_scanpos == jj_lastpos true [EOL] boolean result = jj_3R_173(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_173_WithFalseMinusTokenAndTrueJj_3R_170() { [EOL] when(jj_scan_token(MINUS)).thenReturn(false); [EOL] jj_la = 1; // Set jj_la to a non-zero value to bypass the first if condition [EOL] when(jj_3R_170()).thenReturn(true); [EOL] boolean result = jj_3R_173(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_173_WithAllConditionsFalse() { [EOL] when(jj_scan_token(MINUS)).thenReturn(false); [EOL] jj_la = 1; // Set jj_la to a non-zero value to bypass the first if condition [EOL] when(jj_3R_170()).thenReturn(false); [EOL] jj_scanpos = new Object(); // Ensure jj_scanpos != jj_lastpos [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_173(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_171_WhenJj_3R_174IsTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] when(jj_3R_174()).thenReturn(true); [EOL] when(jj_3R_175()).thenReturn(false); [EOL] when(jj_3R_176()).thenReturn(false); [EOL] jj_la = 1; // Ensure that the lookahead is not zero to avoid early return [EOL] boolean result = jj_3R_171(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_171_WhenJj_3R_175IsTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] when(jj_3R_174()).thenReturn(false); [EOL] when(jj_3R_175()).thenReturn(true); [EOL] when(jj_3R_176()).thenReturn(false); [EOL] jj_la = 1; // Ensure that the lookahead is not zero to avoid early return [EOL] boolean result = jj_3R_171(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_171_WhenJj_3R_176IsTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] when(jj_3R_174()).thenReturn(false); [EOL] when(jj_3R_175()).thenReturn(true); [EOL] when(jj_3R_176()).thenReturn(true); [EOL] boolean result = jj_3R_171(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_171_WhenAllConditionsAreFalseAndLaIsZero() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = jj_scanpos; // Make scanpos equal to lastpos [EOL] when(jj_3R_174()).thenReturn(false); [EOL] when(jj_3R_175()).thenReturn(false); [EOL] when(jj_3R_176()).thenReturn(false); [EOL] jj_la = 0; // Set lookahead to zero to trigger the condition [EOL] boolean result = jj_3R_171(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningTrue() { [EOL] boolean result = jj_3R_170(); [EOL] assertTrue("Expected jj_3R_170 to return true when jj_3R_172 returns true", result); [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningFalseAndJj_3R_173ReturningTrue() { [EOL] boolean result = jj_3R_170(); [EOL] assertTrue("Expected jj_3R_170 to return true when jj_3R_172 returns false and jj_3R_173 returns true", result); [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningFalseAndJj_3R_173ReturningFalse() { [EOL] boolean result = jj_3R_170(); [EOL] assertFalse("Expected jj_3R_170 to return false when both jj_3R_172 and jj_3R_173 return false", result); [EOL] }
public void testJj_3R_170_WithJjLaZeroAndJjScanposEqualsJjLastposAfterJj_3R_172ReturnsTrue() { [EOL] boolean result = jj_3R_170(); [EOL] assertFalse("Expected jj_3R_170 to return false when jj_la is 0 and jj_scanpos equals jj_lastpos after jj_3R_172 returns true", result); [EOL] }
public void testJj_3R_170_WithJjLaZeroAndJjScanposEqualsJjLastposAfterJj_3R_172ReturnsFalse() { [EOL] boolean result = jj_3R_170(); [EOL] assertFalse("Expected jj_3R_170 to return false when jj_la is 0 and jj_scanpos equals jj_lastpos after jj_3R_172 returns false", result); [EOL] }
public void testJj_3R_175_WithTokenDiv() { [EOL] boolean result = jj_3R_175(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_175_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_175(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_175_WithJj_3R_170ReturningTrue() { [EOL] boolean result = jj_3R_175(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_175_WithJj_3R_170ReturningFalseAndLaZeroAndScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_175(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_42_WithFunctionBooleanToken() { [EOL] boolean result = jj_3R_42(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_42_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_42(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_42_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_42(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_168_WithJj_3R_170ReturningTrue() { [EOL] when(jj_3R_170()).thenReturn(true); [EOL] boolean result = jj_3R_168(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_168_WithJj_3R_170ReturningFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_170()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_168(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_168_WithJj_3R_170ReturningFalseAndJj_3R_171ReturningTrue() { [EOL] when(jj_3R_170()).thenReturn(false); [EOL] jj_la = 1; // any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is a valid type [EOL] jj_lastpos = new Token(); [EOL] when(jj_3R_171()).thenReturn(true); [EOL] boolean result = jj_3R_168(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_168_WithJj_3R_170ReturningFalseAndJj_3R_171ReturningFalse() { [EOL] when(jj_3R_170()).thenReturn(false); [EOL] jj_la = 1; // any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is a valid type [EOL] jj_lastpos = new Token(); [EOL] when(jj_3R_171()).thenReturn(false).thenReturn(false).thenReturn(true); [EOL] boolean result = jj_3R_168(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_169_TokenMinus() { [EOL] initToken(MINUS); [EOL] boolean result = jj_3R_169(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_169_AtEndOfInput() { [EOL] setAtEndOfInput(); [EOL] boolean result = jj_3R_169(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_169_3R_168True() { [EOL] set3R_168True(); [EOL] boolean result = jj_3R_169(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_169_3R_168False() { [EOL] set3R_168False(); [EOL] setAtEndOfInput(); [EOL] boolean result = jj_3R_169(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_27_ScanTokenFunctionCount() { [EOL] boolean result = jj_3R_27(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_27_ScanTokenNotFunctionCountAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_27(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_27_ScanTokenNotFunctionCountAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_27(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_150_ScanTokenFollowingSibling() { [EOL] when(jj_scan_token(AXIS_FOLLOWING_SIBLING)).thenReturn(true); [EOL] boolean result = jj_3R_150(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_150_ScanTokenNotFollowingSiblingAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] when(jj_scan_token(AXIS_FOLLOWING_SIBLING)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = somePosition; [EOL] jj_lastpos = somePosition; [EOL] boolean result = jj_3R_150(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_148_WithTokenAxisDescendant() { [EOL] boolean result = jj_3R_148(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_148_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_148(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_148_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and can be different [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_148(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_146_ScanTokenAxisPreceding() { [EOL] setupToken(AXIS_PRECEDING); [EOL] boolean result = jj_3R_146(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_146_ScanTokenNotAxisPreceding() { [EOL] setupToken(NOT_AXIS_PRECEDING); [EOL] boolean result = jj_3R_146(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_146_AtEndOfInput() { [EOL] setupEndOfInput(); [EOL] boolean result = jj_3R_146(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_145_WithTokenAxisNamespace() { [EOL] mockJj_scan_token(AXIS_NAMESPACE, true); [EOL] boolean result = jj_3R_145(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_145_WithLaZeroAndScanposEqualsLastpos() { [EOL] mockJj_scan_token(AXIS_NAMESPACE, false); [EOL] setJj_la(0); [EOL] setJj_scanposEqualLastpos(); [EOL] boolean result = jj_3R_145(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_145_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] mockJj_scan_token(AXIS_NAMESPACE, false); [EOL] setJj_laNonZeroOrScanposNotEqualLastpos(); [EOL] boolean result = jj_3R_145(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_162_WhenJj_3R_168ReturnsTrue() { [EOL] boolean result = jj_3R_162(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_162_WhenJj_3R_168ReturnsFalseAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_162(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_162_WhenJj_3R_168ReturnsFalseAndJj_3R_169ReturnsTrue() { [EOL] boolean result = jj_3R_162(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_162_WhenJj_3R_168ReturnsFalseAndJj_3R_169NeverReturnsTrue() { [EOL] boolean result = jj_3R_162(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_AllFalse() { [EOL] setupForJj_3R_15(); [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_FirstTrueRestFalse() { [EOL] setupForJj_3R_15(); [EOL] when(mockedObject.jj_3R_20()).thenReturn(true); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }

public void testJj_3R_15_LastTrue() { [EOL] setupForJj_3R_15(); [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_141_WithTokenAxisChild() { [EOL] boolean result = jj_3R_141(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_141_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_141(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_141_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_141(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_129()); [EOL] }
public void testJj_3R_129_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_129()); [EOL] }
public void testJj_3R_129_LastTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_129()); [EOL] }
public void testJj_3R_129_ScanposLastposNotEqual() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_lastpos.next = new Token(); // Make sure jj_scanpos != jj_lastpos [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_129()); [EOL] }
public void testJj_3R_121_WhenJj_3R_129IsTrue() { [EOL] boolean result = jj_3R_121(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_121_WhenJj_3R_129IsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_121(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_121_WhenJj_3R_129IsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_121(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_112_WithJj_3R_121ReturningTrueAndJj_3R_122ReturningTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] boolean result = jj_3R_112(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_112_WithJj_3R_121ReturningTrueAndJj_3R_122ReturningFalse() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] boolean result = jj_3R_112(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_112_WithJj_3R_121ReturningFalse() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] boolean result = jj_3R_112(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_101_Token83() { [EOL] boolean result = jj_3R_101(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_101_EndOfLookahead() { [EOL] boolean result = jj_3R_101(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_100_Token82() { [EOL] assertTrue("Expected jj_3R_100 to return true when jj_scan_token(82) is true", jj_3R_100()); [EOL] }
public void testJj_3R_100_NoToken82AtEndOfInput() { [EOL] assertFalse("Expected jj_3R_100 to return false at the end of input", jj_3R_100()); [EOL] }
public void testJj_3R_113_WhenJj_3R_17IsTrue() { [EOL] boolean result = jj_3R_113(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_113_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_113(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_113_WhenJjScanToken80IsTrue() { [EOL] boolean result = jj_3R_113(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_113_WhenJjScanToken81IsTrue() { [EOL] boolean result = jj_3R_113(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_112IsTrue() { [EOL] when(jj_3R_112()).thenReturn(true); [EOL] boolean result = jj_3R_99(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_112IsFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_99(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsTrueAndJj_3R_114IsTrue() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(true); [EOL] when(jj_3R_114()).thenReturn(true); [EOL] boolean result = jj_3R_99(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsTrueAndJj_3R_114IsFalseAndJj_3R_115IsTrue() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(true); [EOL] when(jj_3R_114()).thenReturn(false); [EOL] when(jj_3R_115()).thenReturn(true); [EOL] boolean result = jj_3R_99(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsTrueAndJj_3R_114IsFalseAndJj_3R_115IsFalse() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(true); [EOL] when(jj_3R_114()).thenReturn(false); [EOL] when(jj_3R_115()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_99(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsFalse() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_99(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99ReturnsFalseAndJj_3R_100ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(true); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99AndJj_3R_100ReturnFalseAndJj_3R_101ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(true); [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenAllConditionsReturnFalseAndJj_3R_102ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(true).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenAllConditionsReturnFalseAndJj_3R_102AlwaysReturnsFalse() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_193_WhenJj_3R_16IsTrue() { [EOL] setJj_3R_16ToTrue(); [EOL] boolean result = jj_3R_193(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_193_WhenJj_3R_16IsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_16ToFalse(); [EOL] setJjLaToZero(); [EOL] setScanposEqualsLastpos(); [EOL] boolean result = jj_3R_193(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_193_WhenJj_3R_16IsFalseAndJjLaIsNotZero() { [EOL] setJj_3R_16ToFalse(); [EOL] setJjLaToNonZero(); [EOL] boolean result = jj_3R_193(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_193_WhenJj_3R_16IsFalseAndScanposNotEqualsLastpos() { [EOL] setJj_3R_16ToFalse(); [EOL] setScanposNotEqualsLastpos(); [EOL] boolean result = jj_3R_193(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_190_WhenJj_3R_16IsTrue() { [EOL] setJj_3R_16Condition(true); [EOL] boolean result = jj_3R_190(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_190_WhenJj_3R_16IsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] setJj_3R_16Condition(false); [EOL] setJjLaAndJjScanposAndJjLastpos(0, someScanpos, someScanpos); [EOL] boolean result = jj_3R_190(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_190_WhenJj_3R_16IsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] setJj_3R_16Condition(false); [EOL] setJjLaAndJjScanposAndJjLastpos(1, someScanpos, someOtherScanpos); [EOL] boolean result = jj_3R_190(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_188_WithJj_3R_57True() { [EOL] when(jj_3R_57()).thenReturn(true); [EOL] boolean result = jj_3R_188(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_188_WithJj_3R_57FalseAndScanAtLastPos() { [EOL] when(jj_3R_57()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_188(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_188_WithJj_3R_57FalseAndJj_3R_190True() { [EOL] when(jj_3R_57()).thenReturn(false); [EOL] jj_la = 1; // Ensure that the loop is entered [EOL] when(jj_3R_190()).thenReturn(true); [EOL] boolean result = jj_3R_188(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_188_WithJj_3R_57FalseAndJj_3R_190NeverTrue() { [EOL] when(jj_3R_57()).thenReturn(false); [EOL] jj_la = 1; // Ensure that the loop is entered [EOL] when(jj_3R_190()).thenReturn(false); [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_scanpos.next = jj_lastpos; // Ensure that the loop continues [EOL] boolean result = jj_3R_188(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_191_WhenJj_3R_16IsTrue() { [EOL] setupJj_3R_16ToReturnTrue(); [EOL] boolean result = jj_3R_191(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_191_WhenJj_3R_16IsFalseAndScanposEqualsLastpos() { [EOL] setupJj_3R_16ToReturnFalse(); [EOL] setupScanposEqualsLastpos(); [EOL] boolean result = jj_3R_191(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_191_WhenJj_3R_16IsFalseAndJj_3R_193IsTrue() { [EOL] setupJj_3R_16ToReturnFalse(); [EOL] setupJj_3R_193ToReturnTrue(); [EOL] boolean result = jj_3R_191(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_191_WhenJj_3R_16IsFalseAndJj_3R_193IsFalseAndScanposEqualsLastpos() { [EOL] setupJj_3R_16ToReturnFalse(); [EOL] setupJj_3R_193ToReturnFalse(); [EOL] setupScanposEqualsLastpos(); [EOL] boolean result = jj_3R_191(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_184_WhenJj_3R_116ReturnsTrue() { [EOL] setJj_3R_116(true); [EOL] boolean result = jj_3R_184(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_184_WhenJj_3R_116ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_116(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_184(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_184_WhenJj_3R_116ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_116(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and not equal [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_184(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningTrue() { [EOL] jj_scanpos = ...; // assign a value [EOL] jj_lastpos = ...; // assign a value [EOL] jj_la = ...; // assign a value [EOL] boolean result = jj_3R_189(); [EOL] assertTrue("Expected jj_3R_189 to return true when jj_3R_191 returns true", result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningFalseAndJjLaEqualsZero() { [EOL] jj_scanpos = ...; // assign a value [EOL] jj_lastpos = jj_scanpos; // make them equal [EOL] jj_la = 0; // assign zero [EOL] boolean result = jj_3R_189(); [EOL] assertFalse("Expected jj_3R_189 to return false when jj_3R_191 returns false and jj_la is 0", result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningFalseAndJjLaNotZero() { [EOL] jj_scanpos = ...; // assign a value [EOL] jj_lastpos = ...; // assign a different value [EOL] jj_la = 1; // assign a non-zero value [EOL] boolean result = jj_3R_189(); [EOL] assertFalse("Expected jj_3R_189 to return false when jj_3R_191 returns false and jj_la is not 0", result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningTrueAndJj_3R_192ReturningTrue() { [EOL] jj_scanpos = ...; // assign a value [EOL] jj_lastpos = ...; // assign a value [EOL] jj_la = ...; // assign a value [EOL] boolean result = jj_3R_189(); [EOL] assertTrue("Expected jj_3R_189 to return true when jj_3R_191 and jj_3R_192 both return true", result); [EOL] }
final private boolean jj_3R_182() { [EOL] if (jj_3R_19()) [EOL] return true; [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] Token xsp; [EOL] while (true) { [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_184()) { [EOL] jj_scanpos = xsp; [EOL] break; [EOL] } [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } [EOL] while (true) { [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_185()) { [EOL] jj_scanpos = xsp; [EOL] break; [EOL] } [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } [EOL] return false; [EOL] }
public void testJj_3R_187_WhenJj_3R_189ReturnsTrue() { [EOL] boolean result = jj_3R_187(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_187_WhenJj_3R_189ReturnsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_187(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_187_WhenJj_3R_189ReturnsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_187(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_186_WhenJj_3R_188ReturnsTrue() { [EOL] boolean result = jj_3R_186(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_186_WhenJj_3R_188ReturnsFalseAndJjLaEqualsZeroAndJjScanposEqualsJjLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_186(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_186_WhenJj_3R_188ReturnsFalseAndJjLaNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_186(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_183_WhenJj_3R_186IsTrueAndJj_3R_187IsTrue() { [EOL] }
public void testJj_3R_183_WhenJj_3R_186IsTrueAndJj_3R_187IsFalse() { [EOL] }
public void testJj_3R_183_WhenJj_3R_186IsFalse() { [EOL] }
public void testJj_3R_181_WhenJj_3R_183IsTrue() { [EOL] boolean result = jj_3R_181(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_181_WhenJj_3R_183IsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_181(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_181_WhenJj_3R_183IsFalseAndJjLaIsNotZero() { [EOL] boolean result = jj_3R_181(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_181_WhenJj_3R_183IsFalseAndJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_181(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_178_WhenJj_3R_180ReturnsTrueAndJj_3R_181ReturnsTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 1; // Set to a non-zero value to avoid the short-circuit [EOL] boolean result = jj_3R_178(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_178_WhenJj_3R_180ReturnsTrueAndJj_3R_181ReturnsFalse() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 1; // Set to a non-zero value to avoid the short-circuit [EOL] boolean result = jj_3R_178(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_178_WhenJj_3R_180ReturnsFalse() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; // Set to zero to trigger the short-circuit [EOL] boolean result = jj_3R_178(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_179_WithTokenUnion() { [EOL] when(jj_scan_token(UNION)).thenReturn(true); [EOL] boolean result = jj_3R_179(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_179_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] when(jj_scan_token(UNION)).thenReturn(false); [EOL] when(jj_3R_178()).thenReturn(false); [EOL] boolean result = jj_3R_179(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_179_WithJj_3R_178ReturningTrue() { [EOL] when(jj_scan_token(UNION)).thenReturn(false); [EOL] when(jj_3R_178()).thenReturn(true); [EOL] boolean result = jj_3R_179(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_179_WithAllConditionsFalse() { [EOL] when(jj_scan_token(UNION)).thenReturn(false); [EOL] jj_la = 1; // any non-zero value [EOL] jj_scanpos = new Object(); // any object that is not equal to jj_lastpos [EOL] jj_lastpos = new Object(); [EOL] when(jj_3R_178()).thenReturn(false); [EOL] boolean result = jj_3R_179(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_177_WhenJj_3R_178ReturnsTrue() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_177_WhenJj_3R_178ReturnsFalseAndScanPositionsMatch() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(false); [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos = new Token(); [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_177_WhenJj_3R_178ReturnsFalseAndJj_3R_179ReturnsTrue() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(false); [EOL] when(mockedObject.jj_3R_179()).thenReturn(true); [EOL] mockedObject.jj_la = 1; // Ensure that jj_la is not 0 to avoid early return [EOL] mockedObject.jj_scanpos = new Token(); [EOL] mockedObject.jj_lastpos = new Token(); // Ensure that jj_scanpos is not equal to jj_lastpos [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_177_WhenJj_3R_178ReturnsFalseAndJj_3R_179NeverReturnsTrue() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(false); [EOL] when(mockedObject.jj_3R_179()).thenReturn(false); [EOL] mockedObject.jj_la = 1; // Ensure that jj_la is not 0 to avoid early return [EOL] mockedObject.jj_scanpos = new Token(); [EOL] mockedObject.jj_lastpos = new Token(); // Ensure that jj_scanpos is not equal to jj_lastpos [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_137_Token87() { [EOL] boolean result = jj_3R_137(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_137_EndOfLookahead() { [EOL] boolean result = jj_3R_137(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_137_Rule136True() { [EOL] boolean result = jj_3R_137(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_137_AllFalse() { [EOL] boolean result = jj_3R_137(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningTrue() { [EOL] when(mockedObject.jj_3R_136()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_127(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningFalseAndScanposEqualsLastpos() { [EOL] when(mockedObject.jj_3R_136()).thenReturn(false); [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_127(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningFalseAndJj_3R_137ReturningTrue() { [EOL] when(mockedObject.jj_3R_136()).thenReturn(false); [EOL] when(mockedObject.jj_3R_137()).thenReturn(true).thenReturn(false); [EOL] mockedObject.jj_la = 1; // Ensure that the loop is entered [EOL] mockedObject.jj_scanpos = new Token(); // Dummy Token instance [EOL] mockedObject.jj_lastpos = new Token(); // Another dummy Token instance [EOL] boolean result = mockedObject.jj_3R_127(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningFalseAndJj_3R_137NeverReturningTrue() { [EOL] when(mockedObject.jj_3R_136()).thenReturn(false); [EOL] when(mockedObject.jj_3R_137()).thenReturn(false); [EOL] mockedObject.jj_la = 1; // Ensure that the loop is entered [EOL] mockedObject.jj_scanpos = new Token(); // Dummy Token instance [EOL] mockedObject.jj_lastpos = new Token(); // Another dummy Token instance [EOL] boolean result = mockedObject.jj_3R_127(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_155_WhenJj_3R_15IsTrue() { [EOL] setJj_3R_15ToReturnTrue(); [EOL] boolean result = jj_3R_155(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_155_WhenJj_3R_15IsFalseAndJj_laIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_15ToReturnFalse(); [EOL] setJj_laToZero(); [EOL] setScanposEqualsLastpos(); [EOL] boolean result = jj_3R_155(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_155_WhenJj_3R_15IsFalseAndJj_laIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_15ToReturnFalse(); [EOL] setJj_laToNonZeroOrScanposNotEqualsLastpos(); [EOL] boolean result = jj_3R_155(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_139_WhenJj_3R_98IsTrue() { [EOL] setJj_3R_98Condition(true); [EOL] boolean result = jj_3R_139(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_139_WhenJj_3R_98IsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_98Condition(false); [EOL] setJjLaAndScanpos(0, true); [EOL] boolean result = jj_3R_139(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_139_WhenJj_3R_98IsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_98Condition(false); [EOL] setJjLaAndScanpos(1, false); [EOL] boolean result = jj_3R_139(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_138_WhenJj_3R_15IsTrue() { [EOL] boolean result = jj_3R_138(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_138_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_138(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_138_WhenJjScanTokenWith79ReturnsTrue() { [EOL] boolean result = jj_3R_138(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_138_WhenAllConditionsFail() { [EOL] boolean result = jj_3R_138(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_154_Token88() { [EOL] setTokenToScan(88, true); [EOL] boolean result = jj_3R_154(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_154_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_154(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_154_NotToken88NorEndOfLookahead() { [EOL] setTokenToScan(88, false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object and not equal to jj_lastpos [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_154(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_133_Token79() { [EOL] setToken(79); [EOL] boolean result = jj_3R_133(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_133_AtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_133(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_133_Jj_3R_154_True() { [EOL] mockJj_3R_154(true); [EOL] boolean result = jj_3R_133(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_133_Jj_3R_155_True() { [EOL] mockJj_3R_154(false); [EOL] mockJj_3R_155(true); [EOL] boolean result = jj_3R_133(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_133_Jj_3R_155_False() { [EOL] mockJj_3R_154(false); [EOL] mockJj_3R_155(false); [EOL] jj_la = 1; // Not at end of input [EOL] boolean result = jj_3R_133(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_128_WithJj_3R_138ReturningTrueAndJj_3R_139ReturningTrue() { [EOL] }
public void testJj_3R_128_WithJj_3R_138ReturningTrueAndJj_3R_139ReturningFalse() { [EOL] }
public void testJj_3R_128_WithJj_3R_138ReturningFalseAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] }
public void testJj_3R_128_WithJj_3R_138ReturningFalseAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] }
public void testJj_3R_131_Token88() { [EOL] assertTrue(jj_3R_131()); [EOL] }
public void testJj_3R_131_EndOfLookahead() { [EOL] assertFalse(jj_3R_131()); [EOL] }
public void testJj_3R_123_WhenJj_3R_131TrueAndJj_3R_132True() { [EOL] jj_scanpos = mock(Token.class); [EOL] when(jj_3R_131()).thenReturn(true); [EOL] when(jj_3R_132()).thenReturn(true); [EOL] boolean result = jj_3R_123(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_123_WhenJj_3R_131TrueAndJj_3R_132FalseAndLaZeroAndScanposEqualsLastpos() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_131()).thenReturn(true); [EOL] when(jj_3R_132()).thenReturn(false); [EOL] boolean result = jj_3R_123(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_123_WhenJj_3R_131FalseAndLaZeroAndScanposEqualsLastpos() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_131()).thenReturn(false); [EOL] boolean result = jj_3R_123(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_123_WhenJj_3R_131FalseAndJj_3R_133True() { [EOL] jj_scanpos = mock(Token.class); [EOL] when(jj_3R_131()).thenReturn(false); [EOL] when(jj_3R_133()).thenReturn(true); [EOL] boolean result = jj_3R_123(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_123_WhenJj_3R_131FalseAndJj_3R_133FalseAndLaZeroAndScanposEqualsLastpos() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] when(jj_3R_131()).thenReturn(false); [EOL] when(jj_3R_133()).thenReturn(false); [EOL] boolean result = jj_3R_123(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningTrue() { [EOL] setJj_3R_120Return(true); [EOL] boolean result = jj_3R_106(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningFalseAndScanposEqualsLastpos() { [EOL] setJj_3R_120Return(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_106(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningFalseAndJj_3R_119ReturningTrue() { [EOL] setJj_3R_120Return(false); [EOL] setJj_3R_119Return(true); [EOL] boolean result = jj_3R_106(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningFalseAndJj_3R_119ReturningFalse() { [EOL] setJj_3R_120Return(false); [EOL] setJj_3R_119Return(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_106(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_85_TokenIsFunctionNumber() { [EOL] boolean result = jj_3R_85(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_85_AtEndOfInput() { [EOL] boolean result = jj_3R_85(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_85_NotAtEndOfInput() { [EOL] boolean result = jj_3R_85(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_83_WithFunctionNullToken() { [EOL] boolean result = jj_3R_83(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_83_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_83(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_83_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_83(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_120_WhenJj_3R_128ReturnsTrue() { [EOL] boolean result = jj_3R_120(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_120_WhenJj_3R_128ReturnsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_120(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_120_WhenJj_3R_128ReturnsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_120(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_79_WithFunctionBooleanToken() { [EOL] boolean result = jj_3R_79(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_79_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_79(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_79_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero value [EOL] jj_scanpos = new Object(); // Assuming jj_scanpos and jj_lastpos are objects and can be different [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_79(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_72_WithFunctionContainsToken() { [EOL] boolean result = jj_3R_72(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_72_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_72(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_72_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_72(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_68_WithFunctionNameToken() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = FUNCTION_NAME; // Assuming FUNCTION_NAME is a constant or can be set [EOL] boolean result = parser.jj_3R_68(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_68_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 0; [EOL] parser.jj_scanpos = parser.jj_lastpos; // Assuming jj_scanpos and jj_lastpos can be set [EOL] boolean result = parser.jj_3R_68(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_68_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 1; // Set to a value other than 0 [EOL] parser.jj_scanpos = new Object(); // Set to a new object assuming jj_scanpos is an Object [EOL] parser.jj_lastpos = new Object(); // Set to a different new object [EOL] boolean result = parser.jj_3R_68(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_67_TokenIsFunctionNamespaceUri() { [EOL] boolean result = jj_3R_67(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_67_AtEndOfInput() { [EOL] boolean result = jj_3R_67(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_67_NotAtEndOfInput() { [EOL] boolean result = jj_3R_67(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_66_TokenIsFunctionLocalName() { [EOL] boolean result = jj_3R_66(); [EOL] assert(result); [EOL] }
public void testJj_3R_66_AtEndOfInput() { [EOL] boolean result = jj_3R_66(); [EOL] assert(!result); [EOL] }
public void testJj_3R_66_NotAtEndOfInput() { [EOL] boolean result = jj_3R_66(); [EOL] assert(!result); [EOL] }
public void testJXPathNotFoundExceptionWithMessage() { [EOL] String expectedMessage = "Test message"; [EOL] JXPathNotFoundException exception = new JXPathNotFoundException(expectedMessage); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] }
public Object compute(EvalContext context) { [EOL] return computeValue(context); [EOL] }
public void testCoreOperationOrConstructor() { [EOL] Expression[] args = new Expression[] { /* mock or real Expression objects */ }; [EOL] CoreOperationOr operationOr = new CoreOperationOr(args); [EOL] assertNotNull(operationOr); [EOL] }
public void testComputeValueAllFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JxPathFunction[] args = new JxPathFunction[2]; [EOL] args[0] = mock(JxPathFunction.class); [EOL] args[1] = mock(JxPathFunction.class); [EOL] when(args[0].computeValue(context)).thenReturn(Boolean.FALSE); [EOL] when(args[1].computeValue(context)).thenReturn(Boolean.FALSE); [EOL] JxPathFunction function = new JxPathFunction(args); [EOL] Object result = function.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testComputeValueFirstTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JxPathFunction[] args = new JxPathFunction[2]; [EOL] args[0] = mock(JxPathFunction.class); [EOL] args[1] = mock(JxPathFunction.class); [EOL] when(args[0].computeValue(context)).thenReturn(Boolean.TRUE); [EOL] when(args[1].computeValue(context)).thenReturn(Boolean.FALSE); [EOL] JxPathFunction function = new JxPathFunction(args); [EOL] Object result = function.computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueSecondTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JxPathFunction[] args = new JxPathFunction[2]; [EOL] args[0] = mock(JxPathFunction.class); [EOL] args[1] = mock(JxPathFunction.class); [EOL] when(args[0].computeValue(context)).thenReturn(Boolean.FALSE); [EOL] when(args[1].computeValue(context)).thenReturn(Boolean.TRUE); [EOL] JxPathFunction function = new JxPathFunction(args); [EOL] Object result = function.computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueEmptyArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JxPathFunction[] args = new JxPathFunction[0]; [EOL] JxPathFunction function = new JxPathFunction(args); [EOL] Object result = function.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
protected int getPrecedence() { [EOL] return 0; [EOL] }
public void testGetSymbol() { [EOL] MyObject obj = new MyObject(); [EOL] String symbol = obj.getSymbol(); [EOL] assertEquals("or", symbol); [EOL] }
public void testJXPathInvalidSyntaxExceptionWithNullMessage() { [EOL] JXPathInvalidSyntaxException exception = new JXPathInvalidSyntaxException(null); [EOL] assertNull("The message should be null", exception.getMessage()); [EOL] }
public void testJXPathInvalidSyntaxExceptionWithEmptyMessage() { [EOL] JXPathInvalidSyntaxException exception = new JXPathInvalidSyntaxException(""); [EOL] assertEquals("The message should be empty", "", exception.getMessage()); [EOL] }
public void testJXPathInvalidSyntaxExceptionWithNonEmptyMessage() { [EOL] String testMessage = "Test Message"; [EOL] JXPathInvalidSyntaxException exception = new JXPathInvalidSyntaxException(testMessage); [EOL] assertEquals("The message should match the input", testMessage, exception.getMessage()); [EOL] }
public void testGetPropertyWithValidKey() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] String key = "testKey"; [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] Object result = getProperty(map, key); [EOL] assertSame("The returned object should be the same as the one associated with the key.", value, result); [EOL] } [EOL] public void testGetPropertyWithInvalidKey() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] String key = "testKey"; [EOL] String invalidKey = "invalidKey"; [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] Object result = getProperty(map, invalidKey); [EOL] assertNull("The returned object should be null as the key does not exist.", result); [EOL] } [EOL] public void testGetPropertyWithNullKey() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] String key = null; [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] Object result = getProperty(map, key); [EOL] assertSame("The returned object should be the same as the one associated with the null key.", value, result); [EOL] } [EOL] public void testGetPropertyWithEmptyMap() { [EOL] Map<String, Object> map = new HashMap<>(); [EOL] String key = "testKey"; [EOL] Object result = getProperty(map, key); [EOL] assertNull("The returned object should be null as the map is empty.", result); [EOL] }
public void testToStringWithPrefix() { [EOL] MyClass obj = new MyClass("prefix", "name"); [EOL] String result = obj.toString(); [EOL] assertEquals("prefix:name", result); [EOL] }
public void testToStringWithoutPrefix() { [EOL] MyClass obj = new MyClass("name"); [EOL] String result = obj.toString(); [EOL] assertEquals("name", result); [EOL] }
public void testHashCode_WithNonNullName() { [EOL] MyClass instance = new MyClass("TestName"); [EOL] int result = instance.hashCode(); [EOL] int expectedHashCode = "TestName".hashCode(); [EOL] assertEquals(expectedHashCode, result); [EOL] }
public void testEqualsWithNonQNameObject() { [EOL] QName qName = new QName("localName", "prefix"); [EOL] Object nonQNameObject = new Object(); [EOL] boolean result = qName.equals(nonQNameObject); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithSelf() { [EOL] QName qName = new QName("localName", "prefix"); [EOL] boolean result = qName.equals(qName); [EOL] assertTrue(result); [EOL] }
public void testEqualsWithDifferentLocalName() { [EOL] QName qName1 = new QName("localName1", "prefix"); [EOL] QName qName2 = new QName("localName2", "prefix"); [EOL] boolean result = qName1.equals(qName2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithDifferentPrefix() { [EOL] QName qName1 = new QName("localName", "prefix1"); [EOL] QName qName2 = new QName("localName", "prefix2"); [EOL] boolean result = qName1.equals(qName2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithNullPrefixInFirstQName() { [EOL] QName qName1 = new QName("localName", null); [EOL] QName qName2 = new QName("localName", "prefix"); [EOL] boolean result = qName1.equals(qName2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithNullPrefixInSecondQName() { [EOL] QName qName1 = new QName("localName", "prefix"); [EOL] QName qName2 = new QName("localName", null); [EOL] boolean result = qName1.equals(qName2); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithBothNullPrefix() { [EOL] QName qName1 = new QName("localName", null); [EOL] QName qName2 = new QName("localName", null); [EOL] boolean result = qName1.equals(qName2); [EOL] assertTrue(result); [EOL] }
public void testEqualsWithEqualQNames() { [EOL] QName qName1 = new QName("localName", "prefix"); [EOL] QName qName2 = new QName("localName", "prefix"); [EOL] boolean result = qName1.equals(qName2); [EOL] assertTrue(result); [EOL] }
public void testDoStepPredicatesPropertyOwnerWithActualChildPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[0]; [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(steps[currentStep].getPredicates()).thenReturn(predicates); [EOL] when(childPointer.isActual()).thenReturn(true); [EOL] NodePointer result = doStepPredicatesPropertyOwner(context, parentPointer, steps, currentStep); [EOL] assertNotNull(result); [EOL] verify(childPointer, times(1)).isActual(); [EOL] }
public void testDoStepPredicatesPropertyOwnerWithNonActualChildPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[0]; [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(steps[currentStep].getPredicates()).thenReturn(predicates); [EOL] when(childPointer.isActual()).thenReturn(false); [EOL] NodePointer result = doStepPredicatesPropertyOwner(context, parentPointer, steps, currentStep); [EOL] assertNull(result); [EOL] verify(childPointer, times(1)).isActual(); [EOL] }
private static NodePointer doStepPredicatesStandard(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL] Step step = steps[currentStep]; [EOL] Expression[] predicates = step.getPredicates(); [EOL] int axis = step.getAxis(); [EOL] if (axis == Compiler.AXIS_SELF) { [EOL] return doPredicate(context, parent, steps, currentStep, predicates, 0); [EOL] } [EOL] Expression predicate = predicates[0]; [EOL] if (predicates.length == 1) { [EOL] NodeIterator it = getNodeIterator(context, parent, step); [EOL] NodePointer pointer = null; [EOL] if (it != null) { [EOL] if (predicate instanceof NameAttributeTest) { [EOL] String key = keyFromPredicate(context, predicate); [EOL] for (int i = 1; it.setPosition(i); i++) { [EOL] NodePointer ptr = it.getNodePointer(); [EOL] if (isNameAttributeEqual(ptr, key)) { [EOL] pointer = ptr; [EOL] break; [EOL] } [EOL] } [EOL] } else { [EOL] int index = indexFromPredicate(context, predicate); [EOL] if (it.setPosition(index + 1)) { [EOL] pointer = it.getNodePointer(); [EOL] } [EOL] } [EOL] } [EOL] if (pointer != null) { [EOL] return doStep(context, pointer, steps, currentStep + 1); [EOL] } [EOL] } else { [EOL] NodeIterator it = getNodeIterator(context, parent, step); [EOL] if (it != null) { [EOL] List list = new ArrayList(); [EOL] for (int i = 1; it.setPosition(i); i++) { [EOL] list.add(it.getNodePointer()); [EOL] } [EOL] NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0); [EOL] if (pointer != null) { [EOL] return pointer; [EOL] } [EOL] } [EOL] } [EOL] return createNullPointer(context, parent, steps, currentStep); [EOL] }
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL] String prefix = qname.getPrefix(); [EOL] String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL] if (namespaceURI != null) { [EOL] nodeTest = new NodeNameTest(qname, namespaceURI); [EOL] } [EOL] return pointer.childIterator(nodeTest, false, null); [EOL] } else { [EOL] if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL] throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL] } [EOL] return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL] } [EOL] }
public void testJXPathBasicBeanInfoWithValidClass() { [EOL] Class<?> clazz = String.class; [EOL] JXPathBasicBeanInfo beanInfo = new JXPathBasicBeanInfo(clazz); [EOL] assertNotNull(beanInfo); [EOL] assertEquals(String.class, beanInfo.getClazz()); [EOL] }
public void testJXPathBasicBeanInfoWithAtomicTrue() { [EOL] Class clazz = Object.class; [EOL] boolean atomic = true; [EOL] JXPathBasicBeanInfo beanInfo = new JXPathBasicBeanInfo(clazz, atomic); [EOL] assertEquals("Class should be Object.class", Object.class, beanInfo.getClazz()); [EOL] assertTrue("Atomic should be true", beanInfo.isAtomic()); [EOL] }
public void testJXPathBasicBeanInfoWithAtomicFalse() { [EOL] Class clazz = String.class; [EOL] boolean atomic = false; [EOL] JXPathBasicBeanInfo beanInfo = new JXPathBasicBeanInfo(clazz, atomic); [EOL] assertEquals("Class should be String.class", String.class, beanInfo.getClazz()); [EOL] assertFalse("Atomic should be false", beanInfo.isAtomic()); [EOL] }
public void testJXPathBasicBeanInfoWithNonNullClasses() { [EOL] Class clazz = String.class; [EOL] Class dynamicPropertyHandlerClass = Integer.class; [EOL] JXPathBasicBeanInfo beanInfo = new JXPathBasicBeanInfo(clazz, dynamicPropertyHandlerClass); [EOL] assertNotNull(beanInfo); [EOL] assertEquals(clazz, beanInfo.getClazz()); [EOL] assertFalse(beanInfo.isAtomic()); [EOL] assertEquals(dynamicPropertyHandlerClass, beanInfo.getDynamicPropertyHandlerClass()); [EOL] }
public void testJXPathBasicBeanInfoWithNullClasses() { [EOL] JXPathBasicBeanInfo beanInfo = new JXPathBasicBeanInfo(null, null); [EOL] assertNotNull(beanInfo); [EOL] assertNull(beanInfo.getClazz()); [EOL] assertFalse(beanInfo.isAtomic()); [EOL] assertNull(beanInfo.getDynamicPropertyHandlerClass()); [EOL] }
public void testGetPropertyDescriptorsWithInterface() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(MyInterface.class); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] List<String> propertyNames = Arrays.stream(result) [EOL] .map(PropertyDescriptor::getName) [EOL] .collect(Collectors.toList()); [EOL] assertTrue(propertyNames.contains("propertyName1")); [EOL] assertTrue(propertyNames.contains("propertyName2")); [EOL] }
public void testGetPropertyDescriptorsWithClass() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(MyRegularClass.class); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] List<String> propertyNames = Arrays.stream(result) [EOL] .map(PropertyDescriptor::getName) [EOL] .collect(Collectors.toList()); [EOL] assertTrue(propertyNames.contains("propertyName1")); [EOL] assertTrue(propertyNames.contains("propertyName2")); [EOL] }
public void testGetPropertyDescriptorsCachesResult() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(MyRegularClass.class); [EOL] PropertyDescriptor[] result1 = instance.getPropertyDescriptors(); [EOL] PropertyDescriptor[] result2 = instance.getPropertyDescriptors(); [EOL] assertSame(result1, result2); // Check if the result is cached [EOL] }
public void testGetPropertyDescriptorsHandlesIntrospectionException() { [EOL] MyClassUnderTest instance = new MyClassUnderTest(ProblematicClass.class); [EOL] PropertyDescriptor[] result = instance.getPropertyDescriptors(); [EOL] assertNull(result); // Assuming the method returns null on exception [EOL] }
public PropertyDescriptor getPropertyDescriptor(String propertyName) { [EOL] if (propertyNames == null) { [EOL] PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL] String[] names = new String[pds.length]; [EOL] for (int i = 0; i < pds.length; i++) { [EOL] names[i] = pds[i].getName(); [EOL] } [EOL] propertyNames = names; [EOL] } [EOL] for (int i = 0; i < propertyNames.length; i++) { [EOL] if (propertyNames[i] == propertyName) { [EOL] return propertyDescriptors[i]; [EOL] } [EOL] } [EOL] for (int i = 0; i < propertyNames.length; i++) { [EOL] if (propertyNames[i].equals(propertyName)) { [EOL] return propertyDescriptors[i]; [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testIsContextDependent_InitiallyUnknown() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.isContextDependent(); [EOL] assertTrue(result); [EOL] assertTrue(instance.contextDependencyKnown); [EOL] }
public void testIsContextDependent_AlreadyKnown() { [EOL] YourClass instance = new YourClass(); [EOL] instance.contextDependencyKnown = true; [EOL] instance.contextDependent = true; // or false, depending on the scenario [EOL] boolean expectedResult = instance.contextDependent; [EOL] boolean result = instance.isContextDependent(); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testIterateWithEvalContextResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext evalContextResult = mock(EvalContext.class); [EOL] when(compute(context)).thenReturn(evalContextResult); [EOL] Iterator resultIterator = iterate(context); [EOL] assertTrue(resultIterator instanceof ValueIterator); [EOL] }
public void testIterateWithNonEvalContextResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object nonEvalContextResult = new Object(); [EOL] when(compute(context)).thenReturn(nonEvalContextResult); [EOL] Iterator resultIterator = iterate(context); [EOL] assertNotNull(resultIterator); [EOL] assertFalse(resultIterator instanceof ValueIterator); [EOL] }
public void testIteratePointersWithNullResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.compute()).thenReturn(null); [EOL] Iterator resultIterator = iteratePointers(context); [EOL] assertFalse(resultIterator.hasNext()); [EOL] }
public void testIteratePointersWithEvalContextResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext computeResult = mock(EvalContext.class); [EOL] when(context.compute()).thenReturn(computeResult); [EOL] Iterator resultIterator = iteratePointers(context); [EOL] assertTrue(resultIterator instanceof EvalContext); [EOL] assertEquals(computeResult, resultIterator); [EOL] }
public void testIteratePointersWithNonEvalContextResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] List<Object> listResult = Arrays.asList("value1", "value2"); [EOL] when(context.compute()).thenReturn(listResult); [EOL] when(context.getRootContext()).thenReturn(mock(RootContext.class)); [EOL] when(context.getRootContext().getCurrentNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] when(context.getRootContext().getCurrentNodePointer().getLocale()).thenReturn(Locale.getDefault()); [EOL] Iterator resultIterator = iteratePointers(context); [EOL] assertTrue(resultIterator instanceof PointerIterator); [EOL] assertTrue(resultIterator.hasNext()); [EOL] assertEquals("value1", ((PointerIterator) resultIterator).next().getValue()); [EOL] }
public void testPointerIteratorWithValidArguments() { [EOL] Iterator mockIterator = mock(Iterator.class); [EOL] QName mockQName = mock(QName.class); [EOL] Locale mockLocale = mock(Locale.class); [EOL] PointerIterator pointerIterator = new PointerIterator(mockIterator, mockQName, mockLocale); [EOL] assertNotNull(pointerIterator.iterator); [EOL] assertEquals(mockIterator, pointerIterator.iterator); [EOL] assertNotNull(pointerIterator.qname); [EOL] assertEquals(mockQName, pointerIterator.qname); [EOL] assertNotNull(pointerIterator.locale); [EOL] assertEquals(mockLocale, pointerIterator.locale); [EOL] }
public void testNextWithNonNullValues() { [EOL] QName qname = new QName("test"); [EOL] Locale locale = Locale.getDefault(); [EOL] List<Object> list = new ArrayList<>(); [EOL] list.add("TestValue"); [EOL] SimpleIterator iterator = new SimpleIterator(list); [EOL] Object result = iterator.next(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] assertEquals("TestValue", ((NodePointer) result).getValue()); [EOL] }
public void testNextWithEmptyIterator() { [EOL] QName qname = new QName("empty"); [EOL] Locale locale = Locale.getDefault(); [EOL] List<Object> emptyList = new ArrayList<>(); [EOL] SimpleIterator iterator = new SimpleIterator(emptyList); [EOL] try { [EOL] iterator.next(); [EOL] fail("Should have thrown NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testValueIteratorWithNonNullIterator() { [EOL] Iterator mockIterator = mock(Iterator.class); [EOL] ValueIterator valueIterator = new ValueIterator(mockIterator); [EOL] assertNotNull(valueIterator.iterator); [EOL] }
public void testValueIteratorWithNullIterator() { [EOL] ValueIterator valueIterator = new ValueIterator(null); [EOL] assertNull(valueIterator.iterator); [EOL] }
public boolean hasNext() { [EOL] return iterator.hasNext(); [EOL] }
public void testNextWithPointer() { [EOL] Iterator iterator = Mockito.mock(Iterator.class); [EOL] Pointer pointer = Mockito.mock(Pointer.class); [EOL] Object expectedValue = new Object(); [EOL] Mockito.when(iterator.next()).thenReturn(pointer); [EOL] Mockito.when(pointer.getValue()).thenReturn(expectedValue); [EOL] Object result = next(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testNextWithNonPointer() { [EOL] Iterator iterator = Mockito.mock(Iterator.class); [EOL] Object expectedValue = new Object(); [EOL] Mockito.when(iterator.next()).thenReturn(expectedValue); [EOL] Object result = next(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testNullPropertyPointerWithNonNullParent() { [EOL] NodePointer parent = new NodePointerMock(); [EOL] NullPropertyPointer nullPropertyPointer = new NullPropertyPointer(parent); [EOL] assertNotNull(nullPropertyPointer.getParent()); [EOL] }
public void testNullPropertyPointerWithNullParent() { [EOL] NullPropertyPointer nullPropertyPointer = new NullPropertyPointer(null); [EOL] assertNull(nullPropertyPointer.getParent()); [EOL] }
public void testGetName() { [EOL] String propertyName = "testProperty"; [EOL] QName expected = new QName(propertyName); [EOL] YourClass instance = new YourClass(propertyName); [EOL] QName result = instance.getName(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetValuePointer() { [EOL] NodePointer result = obj.getValuePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPointer); [EOL] assertEquals(getPropertyName(), result.getName().toString()); [EOL] }
public boolean isActual() { [EOL] return false; [EOL] }
public boolean isContainer() { [EOL] return true; [EOL] }
public void testCreatePathForAttribute() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer newParent = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(newParent); [EOL] when(newParent.createAttribute(context, "attributeName")).thenReturn(newParent); [EOL] AttributeNodePointer testSubject = new AttributeNodePointer(parent, "attributeName"); [EOL] NodePointer result = testSubject.createPath(context); [EOL] assertEquals("Expected newParent to be returned for attribute", newParent, result); [EOL] }
public void testCreatePathForPropertyOwnerPointer() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] PropertyOwnerPointer pop = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(pop); [EOL] when(pop.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.createChild(context, "propertyName", 1)).thenReturn(childPointer); [EOL] PropertyNodePointer testSubject = new PropertyNodePointer(parent, "propertyName", 1); [EOL] NodePointer result = testSubject.createPath(context); [EOL] assertEquals("Expected childPointer to be returned for PropertyOwnerPointer", childPointer, result); [EOL] }
public void testCreatePathForNonPropertyOwnerPointer() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer newParent = mock(NodePointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(newParent); [EOL] when(newParent.createChild(context, "elementName", 0)).thenReturn(childPointer); [EOL] ElementNodePointer testSubject = new ElementNodePointer(parent, "elementName"); [EOL] NodePointer result = testSubject.createPath(context); [EOL] assertEquals("Expected childPointer to be returned for non-PropertyOwnerPointer", childPointer, result); [EOL] }
public void testCreatePathForAttribute() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer newParent = mock(NodePointer.class); [EOL] NodePointer attributePointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(newParent); [EOL] when(newParent.createAttribute(context, "attributeName")).thenReturn(attributePointer); [EOL] TestNodePointer testNodePointer = new TestNodePointer(parent, true, "attributeName"); [EOL] NodePointer result = testNodePointer.createPath(context, "attributeValue"); [EOL] verify(newParent).createAttribute(context, "attributeName"); [EOL] verify(attributePointer).setValue("attributeValue"); [EOL] assertEquals(attributePointer, result); [EOL] }
public void testCreatePathForNonAttributePropertyOwner() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] PropertyOwnerPointer propertyOwnerPointer = mock(PropertyOwnerPointer.class); [EOL] NodePointer propertyPointer = mock(NodePointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.createChild(context, "propertyName", 1, "propertyValue")).thenReturn(childPointer); [EOL] TestNodePointer testNodePointer = new TestNodePointer(parent, false, "propertyName", 1); [EOL] NodePointer result = testNodePointer.createPath(context, "propertyValue"); [EOL] verify(propertyOwnerPointer).getPropertyPointer(); [EOL] verify(propertyPointer).createChild(context, "propertyName", 1, "propertyValue"); [EOL] assertEquals(childPointer, result); [EOL] }
public void testCreatePathForNonAttributeNonPropertyOwner() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer newParent = mock(NodePointer.class); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(newParent); [EOL] when(newParent.createChild(context, "elementName", 0, "elementValue")).thenReturn(childPointer); [EOL] TestNodePointer testNodePointer = new TestNodePointer(parent, false, "elementName"); [EOL] NodePointer result = testNodePointer.createPath(context, "elementValue"); [EOL] verify(newParent).createChild(context, "elementName", 0, "elementValue"); [EOL] assertEquals(childPointer, result); [EOL] }
public String testGetPropertyNameWhenPropertyNameIsNull() { [EOL] JXPathBean jxPathBean = new JXPathBean(null); [EOL] assertNull("Property name should be null", jxPathBean.getPropertyName()); [EOL] }
public String testGetPropertyNameWhenPropertyNameIsSet() { [EOL] String expectedPropertyName = "testProperty"; [EOL] JXPathBean jxPathBean = new JXPathBean(expectedPropertyName); [EOL] assertEquals("Property name should match the expected value", expectedPropertyName, jxPathBean.getPropertyName()); [EOL] }
public void testSetPropertyName() { [EOL] YourClass instance = new YourClass(); [EOL] String expectedPropertyName = "testProperty"; [EOL] instance.setPropertyName(expectedPropertyName); [EOL] assertEquals(expectedPropertyName, instance.getPropertyName()); [EOL] }
public void testSetNameAttributeValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setNameAttributeValue("testAttribute"); [EOL] assertEquals("testAttribute", context.propertyName); [EOL] assertTrue(context.byNameAttribute); [EOL] }
public void testNullPointerConstructorWithNonNullParentAndName() { [EOL] NodePointer parent = new NodePointerMock(); [EOL] QName name = new QName("test"); [EOL] NullPointer nullPointer = new NullPointer(parent, name); [EOL] assertNotNull(nullPointer); [EOL] assertEquals(parent, nullPointer.getParent()); [EOL] assertEquals(name, nullPointer.getName()); [EOL] }
public void testNullPointerConstructorWithNullParent() { [EOL] QName name = new QName("test"); [EOL] NullPointer nullPointer = new NullPointer(null, name); [EOL] assertNotNull(nullPointer); [EOL] assertNull(nullPointer.getParent()); [EOL] assertEquals(name, nullPointer.getName()); [EOL] }
public void testNullPointerConstructorWithNullName() { [EOL] NodePointer parent = new NodePointerMock(); [EOL] NullPointer nullPointer = new NullPointer(parent, null); [EOL] assertNotNull(nullPointer); [EOL] assertEquals(parent, nullPointer.getParent()); [EOL] assertNull(nullPointer.getName()); [EOL] }
public Object getBaseValue() { [EOL] return null; [EOL] }
public void testGetPropertyPointer() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name that contains the 'getPropertyPointer' method [EOL] PropertyPointer result = instance.getPropertyPointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] }
public void testCreatePathWithNonNullParent() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer child = mock(NodePointer.class); [EOL] NodePointer valuePointer = mock(NodePointer.class); [EOL] when(parent.createPath(context)).thenReturn(child); [EOL] when(child.getValuePointer()).thenReturn(valuePointer); [EOL] MyClass myInstance = new MyClass(); [EOL] myInstance.parent = parent; [EOL] NodePointer result = myInstance.createPath(context); [EOL] assertNotNull("Expected non-null result", result); [EOL] assertSame("Expected valuePointer to be returned", valuePointer, result); [EOL] }
public void testCreatePathWithNullParent() { [EOL] MyClass myInstance = new MyClass(); [EOL] myInstance.parent = null; [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] try { [EOL] myInstance.createPath(context); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Cannot create the root object: " + myInstance.asPath(), e.getMessage()); [EOL] } [EOL] }
public void testComputeValueBothArgsPositive() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(5.0); [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueFirstArgNegative() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(-10.0); [EOL] when(args[1].computeValue(context)).thenReturn(5.0); [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testComputeValueBothArgsEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(5.0); [EOL] when(args[1].computeValue(context)).thenReturn(5.0); [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testStringValueWithString() { [EOL] String input = "testString"; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("testString", result); [EOL] }
public void testStringValueWithNumberDouble() { [EOL] Number input = 123.456; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("123.456", result); [EOL] }
public void testStringValueWithNumberLong() { [EOL] Number input = 123L; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("123", result); [EOL] }
public void testStringValueWithBooleanTrue() { [EOL] Boolean input = Boolean.TRUE; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("true", result); [EOL] }
public void testStringValueWithBooleanFalse() { [EOL] Boolean input = Boolean.FALSE; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("false", result); [EOL] }
public void testStringValueWithNull() { [EOL] Object input = null; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("", result); [EOL] }
public void testStringValueWithNodePointer() { [EOL] NodePointer input = mock(NodePointer.class); [EOL] when(input.getValue()).thenReturn("nodeValue"); [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("nodeValue", result); [EOL] }
public void testStringValueWithEvalContextWithNonNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.getValue()).thenReturn("pointerValue"); [EOL] String result = YourClass.stringValue(ctx); [EOL] assertEquals("pointerValue", result); [EOL] }
public void testStringValueWithEvalContextWithNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] String result = YourClass.stringValue(ctx); [EOL] assertEquals("", result); [EOL] }
public void testStringValueWithOtherObject() { [EOL] Object input = new Object(); [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals(input.toString(), result); [EOL] }
public void testNumberWithNumberInput() { [EOL] assertEquals(new Integer(5), number(5)); [EOL] }
public void testNumberWithBooleanInputTrue() { [EOL] assertEquals(ONE, number(true)); [EOL] }
public void testNumberWithBooleanInputFalse() { [EOL] assertEquals(ZERO, number(false)); [EOL] }
public void testNumberWithStringInputValid() { [EOL] assertEquals(new Double("3.14"), number("3.14")); [EOL] }
public void testNumberWithStringInputInvalid() { [EOL] assertEquals(NOT_A_NUMBER, number("not a number")); [EOL] }
public void testNumberWithEvalContextInputNonNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.getValue()).thenReturn(5); [EOL] assertEquals(new Integer(5), number(ctx)); [EOL] }
public void testNumberWithEvalContextInputNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] assertEquals(NOT_A_NUMBER, number(ctx)); [EOL] }
public void testNumberWithNodePointerInput() { [EOL] NodePointer ptr = mock(NodePointer.class); [EOL] when(ptr.getValue()).thenReturn(5); [EOL] assertEquals(new Integer(5), number(ptr)); [EOL] }
public void testNumberWithOtherObjectInput() { [EOL] Object obj = new Object(); [EOL] assertEquals(number(stringValue(obj)), number(obj)); [EOL] }
public void testDoubleValueWithNumber() { [EOL] double expected = 123.456; [EOL] Number number = 123.456; [EOL] double result = doubleValue(number); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithBooleanTrue() { [EOL] double expected = 0.0; [EOL] Boolean bool = true; [EOL] double result = doubleValue(bool); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithBooleanFalse() { [EOL] double expected = 1.0; [EOL] Boolean bool = false; [EOL] double result = doubleValue(bool); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithEmptyString() { [EOL] double expected = 0.0; [EOL] String str = ""; [EOL] double result = doubleValue(str); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithValidString() { [EOL] double expected = 123.456; [EOL] String str = "123.456"; [EOL] double result = doubleValue(str); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithInvalidString() { [EOL] double expected = Double.NaN; [EOL] String str = "notANumber"; [EOL] double result = doubleValue(str); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNodePointer() { [EOL] double expected = 123.456; [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(nodePointer.getValue()).thenReturn(123.456); [EOL] double result = doubleValue(nodePointer); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNonNullEvalContext() { [EOL] double expected = 123.456; [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.getValue()).thenReturn(123.456); [EOL] double result = doubleValue(ctx); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNullEvalContext() { [EOL] double expected = Double.NaN; [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] double result = doubleValue(ctx); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithOtherObject() { [EOL] double expected = Double.NaN; // Assuming stringValue returns a non-numeric string [EOL] Object object = new Object(); [EOL] double result = doubleValue(object); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testBooleanValueWithNumberNonZero() { [EOL] double nonZeroNumber = 1.0; [EOL] assertTrue(JXPath.booleanValue(nonZeroNumber)); [EOL] } [EOL] public void testBooleanValueWithNumberZero() { [EOL] double zeroNumber = 0.0; [EOL] assertFalse(JXPath.booleanValue(zeroNumber)); [EOL] } [EOL] public void testBooleanValueWithNumberNaN() { [EOL] double nanValue = Double.NaN; [EOL] assertFalse(JXPath.booleanValue(nanValue)); [EOL] }
public void testBooleanValueWithBooleanTrue() { [EOL] Boolean trueValue = Boolean.TRUE; [EOL] assertTrue(JXPath.booleanValue(trueValue)); [EOL] } [EOL] public void testBooleanValueWithBooleanFalse() { [EOL] Boolean falseValue = Boolean.FALSE; [EOL] assertFalse(JXPath.booleanValue(falseValue)); [EOL] }
public void testBooleanValueWithEvalContextNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] assertFalse(JXPath.booleanValue(ctx)); [EOL] } [EOL] public void testBooleanValueWithEvalContextNonNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.isActual()).thenReturn(true); // Assuming booleanValue(ptr) returns true [EOL] assertTrue(JXPath.booleanValue(ctx)); [EOL] }
public void testBooleanValueWithStringEmpty() { [EOL] String emptyString = ""; [EOL] assertFalse(JXPath.booleanValue(emptyString)); [EOL] } [EOL] public void testBooleanValueWithStringNonEmpty() { [EOL] String nonEmptyString = "JXPath"; [EOL] assertTrue(JXPath.booleanValue(nonEmptyString)); [EOL] }
public void testBooleanValueWithNodePointerNotVariablePointer() { [EOL] NodePointer pointer = mock(NodePointer.class); [EOL] when(pointer.isActual()).thenReturn(true); [EOL] assertTrue(JXPath.booleanValue(pointer)); [EOL] } [EOL] public void testBooleanValueWithVariablePointer() { [EOL] VariablePointer variablePointer = mock(VariablePointer.class); [EOL] Node node = mock(Node.class); [EOL] when(variablePointer.getNode()).thenReturn(node); [EOL] when(variablePointer.isActual()).thenReturn(true); // Assuming booleanValue(node) returns true [EOL] assertTrue(JXPath.booleanValue(variablePointer)); [EOL] }
public void testBooleanValueWithNull() { [EOL] assertFalse(JXPath.booleanValue(null)); [EOL] }
public void testBooleanValueWithOtherObject() { [EOL] Object otherObject = new Object(); [EOL] assertTrue(JXPath.booleanValue(otherObject)); [EOL] }
public void testGetPropertyPointer() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] AbstractFactory factory = new AbstractFactory() { [EOL] public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index) { [EOL] return false; [EOL] } [EOL] }; [EOL] context.setFactory(factory); [EOL] PropertyPointer propertyPointer = context.getPointer("/property").getPropertyPointer(); [EOL] assertNotNull("PropertyPointer should not be null", propertyPointer); [EOL] assertTrue("PropertyPointer should be instance of BeanPropertyPointer", propertyPointer instanceof BeanPropertyPointer); [EOL] }
public void testGetName() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name that contains getName() [EOL] QName expected = new QName("localPart"); // Replace with the expected QName value [EOL] instance.name = expected; // Directly set the name if it's accessible, otherwise use a constructor or a setter method [EOL] QName actual = instance.getName(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetBaseValue() { [EOL] Object expected = bean; // Replace with the actual expected bean object [EOL] Object actual = instance.getBaseValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCodeWithNameNull() { [EOL] JXPath jxPath = new JXPath(); [EOL] jxPath.setName(null); [EOL] int result = jxPath.hashCode(); [EOL] assertEquals(0, result); [EOL] }
public void testHashCodeWithNameNotNull() { [EOL] JXPath jxPath = new JXPath(); [EOL] jxPath.setName("testName"); [EOL] int result = jxPath.hashCode(); [EOL] assertEquals("testName".hashCode(), result); [EOL] }
public void testEquals_SameObject() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] assertTrue(beanPointer.equals(beanPointer)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] Object other = new Object(); [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_NullParent() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.parent = null; [EOL] other.parent = new Object(); // Assuming parent is of type Object [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualParent() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] Object parent = new Object(); [EOL] beanPointer.parent = parent; [EOL] other.parent = parent; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentName() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.name = "name"; [EOL] other.name = null; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualName() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.name = "name"; [EOL] other.name = "name"; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentIndex() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.index = 1; [EOL] other.index = 2; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualIndex() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.index = 1; [EOL] other.index = 1; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualBeanPrimitive() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = "test"; [EOL] other.bean = "test"; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentBeanPrimitive() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = "test"; [EOL] other.bean = "different"; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_SameBeanReference() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] Object bean = new Object(); [EOL] beanPointer.bean = bean; [EOL] other.bean = bean; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentBeanReference() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = new Object(); [EOL] other.bean = new Object(); [EOL] assertFalse(beanPointer.equals(other)); [EOL] }

public void testAsPathWithParentNotNull() { [EOL] YourObject parentObject = new YourObject(); // Replace with actual parent object [EOL] YourObject testObject = new YourObject(parentObject); // Replace with actual test object constructor that sets the parent [EOL] String result = testObject.asPath(); [EOL] assertEquals(parentObject.asPath(), result); [EOL] }
public void testAsPathWithBeanNull() { [EOL] YourObject testObject = new YourObject(); // Replace with actual test object constructor that sets the bean to null [EOL] String result = testObject.asPath(); [EOL] assertEquals("null()", result); [EOL] }
public void testAsPathWithBeanNumberWithoutDecimal() { [EOL] YourObject testObject = new YourObject(42); // Replace with actual test object constructor that sets the bean to a Number [EOL] String result = testObject.asPath(); [EOL] assertEquals("42", result); [EOL] }
public void testAsPathWithBeanNumberWithDecimal() { [EOL] YourObject testObject = new YourObject(42.0); // Replace with actual test object constructor that sets the bean to a Number [EOL] String result = testObject.asPath(); [EOL] assertEquals("42", result); [EOL] }
public void testAsPathWithBeanBooleanTrue() { [EOL] YourObject testObject = new YourObject(true); // Replace with actual test object constructor that sets the bean to Boolean.TRUE [EOL] String result = testObject.asPath(); [EOL] assertEquals("true()", result); [EOL] }
public void testAsPathWithBeanBooleanFalse() { [EOL] YourObject testObject = new YourObject(false); // Replace with actual test object constructor that sets the bean to Boolean.FALSE [EOL] String result = testObject.asPath(); [EOL] assertEquals("false()", result); [EOL] }
public void testAsPathWithBeanString() { [EOL] YourObject testObject = new YourObject("testString"); // Replace with actual test object constructor that sets the bean to a String [EOL] String result = testObject.asPath(); [EOL] assertEquals("'testString'", result); [EOL] }
public void testAsPathWithBeanNotHandledType() { [EOL] YourObject testObject = new YourObject(new Object()); // Replace with actual test object constructor that sets the bean to an unhandled type [EOL] String result = testObject.asPath(); [EOL] assertEquals("/", result); [EOL] }
public void testCreatePathWithNonNullValue() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer expectedChild = mock(NodePointer.class); [EOL] Object value = new Object(); [EOL] int index = 1; [EOL] when(parent.createChild(context, null, index, value)).thenReturn(expectedChild); [EOL] MyClass myClass = new MyClass(parent, index); [EOL] NodePointer result = myClass.createPath(context, value); [EOL] assertEquals(expectedChild, result); [EOL] }
public void testCreatePathWithNullValue() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodePointer expectedChild = mock(NodePointer.class); [EOL] Object value = null; [EOL] int index = 1; [EOL] when(parent.createChild(context, null, index, value)).thenReturn(expectedChild); [EOL] MyClass myClass = new MyClass(parent, index); [EOL] NodePointer result = myClass.createPath(context, value); [EOL] assertEquals(expectedChild, result); [EOL] }
public void testCoreOperationSubtractWithBothArgsNonNull() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationSubtract subtract = new CoreOperationSubtract(arg1, arg2); [EOL] assertNotNull(subtract); [EOL] }
public void testCoreOperationSubtractWithFirstArgNull() { [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationSubtract subtract = new CoreOperationSubtract(null, arg2); [EOL] assertNotNull(subtract); [EOL] }
public void testCoreOperationSubtractWithSecondArgNull() { [EOL] Expression arg1 = mock(Expression.class); [EOL] CoreOperationSubtract subtract = new CoreOperationSubtract(arg1, null); [EOL] assertNotNull(subtract); [EOL] }
public void testCoreOperationSubtractWithBothArgsNull() { [EOL] CoreOperationSubtract subtract = new CoreOperationSubtract(null, null); [EOL] assertNotNull(subtract); [EOL] }
public void testComputeValueWithPositiveNumbers() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression leftExpression = mock(Expression.class); [EOL] Expression rightExpression = mock(Expression.class); [EOL] when(leftExpression.computeValue(context)).thenReturn(10.0); [EOL] when(rightExpression.computeValue(context)).thenReturn(5.0); [EOL] Expression[] args = new Expression[] {leftExpression, rightExpression}; [EOL] CustomFunction customFunction = new CustomFunction(args); [EOL] Object result = customFunction.computeValue(context); [EOL] assertEquals("Result should be the difference of the two numbers", 5.0, result); [EOL] }
public void testComputeValueWithNegativeNumbers() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression leftExpression = mock(Expression.class); [EOL] Expression rightExpression = mock(Expression.class); [EOL] when(leftExpression.computeValue(context)).thenReturn(-10.0); [EOL] when(rightExpression.computeValue(context)).thenReturn(-20.0); [EOL] Expression[] args = new Expression[] {leftExpression, rightExpression}; [EOL] CustomFunction customFunction = new CustomFunction(args); [EOL] Object result = customFunction.computeValue(context); [EOL] assertEquals("Result should be the difference of the two numbers", 10.0, result); [EOL] }
public void testComputeValueWithZero() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression leftExpression = mock(Expression.class); [EOL] Expression rightExpression = mock(Expression.class); [EOL] when(leftExpression.computeValue(context)).thenReturn(0.0); [EOL] when(rightExpression.computeValue(context)).thenReturn(0.0); [EOL] Expression[] args = new Expression[] {leftExpression, rightExpression}; [EOL] CustomFunction customFunction = new CustomFunction(args); [EOL] Object result = customFunction.computeValue(context); [EOL] assertEquals("Result should be zero", 0.0, result); [EOL] }
protected int getPrecedence() { [EOL] return 4; [EOL] }
protected boolean isSymmetric() { [EOL] return false; [EOL] }
public void testGetSymbol() { [EOL] ClassName instance = new ClassName(); [EOL] String expected = "-"; [EOL] String actual = instance.getSymbol(); [EOL] assertEquals(expected, actual); [EOL] }
public void testDynamicPropertyPointerWithNonNullParentAndHandler() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] DynamicPropertyHandler handler = mock(DynamicPropertyHandler.class); [EOL] DynamicPropertyPointer dynamicPropertyPointer = new DynamicPropertyPointer(parent, handler); [EOL] assertNotNull(dynamicPropertyPointer); [EOL] assertSame(parent, dynamicPropertyPointer.getParent()); [EOL] assertSame(handler, dynamicPropertyPointer.getHandler()); [EOL] }
public void testDynamicPropertyPointerWithNullParent() { [EOL] DynamicPropertyHandler handler = mock(DynamicPropertyHandler.class); [EOL] DynamicPropertyPointer dynamicPropertyPointer = new DynamicPropertyPointer(null, handler); [EOL] assertNotNull(dynamicPropertyPointer); [EOL] assertNull(dynamicPropertyPointer.getParent()); [EOL] assertSame(handler, dynamicPropertyPointer.getHandler()); [EOL] }
public void testDynamicPropertyPointerWithNullHandler() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] try { [EOL] new DynamicPropertyPointer(parent, null); [EOL] fail("Expected an exception due to null handler"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetPropertyNameWithNullNameAndValidIndex() { [EOL] this.name = null; [EOL] this.propertyIndex = 1; // Assuming this is a valid index within the names array [EOL] String result = getPropertyName(); [EOL] assertEquals("Expected name at index 1", names[1], result); [EOL] }
public void testGetPropertyNameWithNullNameAndInvalidIndex() { [EOL] this.name = null; [EOL] this.propertyIndex = -1; // Assuming this is an invalid index [EOL] String result = getPropertyName(); [EOL] assertEquals("Expected name to be *", "*", result); [EOL] }
public void testGetPropertyNameWithNonNullName() { [EOL] this.name = "existingName"; [EOL] String result = getPropertyName(); [EOL] assertEquals("Expected name to be existingName", "existingName", result); [EOL] }
public void testSetPropertyNameWithExistingName() { [EOL] JXPath jxPath = new JXPath(); [EOL] String propertyName = "existingProperty"; [EOL] jxPath.names = new String[]{"existingProperty", "otherProperty"}; [EOL] Arrays.sort(jxPath.names); // Ensure the array is sorted for binarySearch [EOL] jxPath.setPropertyName(propertyName); [EOL] assertEquals("Property name should be set", propertyName, jxPath.name); [EOL] assertNull("Names array should be null", jxPath.names); [EOL] }
public void testSetPropertyNameWithNewName() { [EOL] JXPath jxPath = new JXPath(); [EOL] String propertyName = "newProperty"; [EOL] jxPath.names = new String[]{"existingProperty", "otherProperty"}; [EOL] Arrays.sort(jxPath.names); // Ensure the array is sorted for binarySearch [EOL] jxPath.setPropertyName(propertyName); [EOL] assertEquals("Property name should be set", propertyName, jxPath.name); [EOL] assertNotNull("Names array should not be null", jxPath.names); [EOL] }
public int getPropertyIndex() { [EOL] if (propertyIndex == UNSPECIFIED_PROPERTY) { [EOL] String[] names = getPropertyNames(); [EOL] for (int i = 0; i < names.length; i++) { [EOL] if (names[i].equals(name)) { [EOL] setPropertyIndex(i); [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] return super.getPropertyIndex(); [EOL] }
public void testSetPropertyIndex_NewIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int newIndex = 1; [EOL] instance.setPropertyIndex(newIndex); [EOL] assertEquals("Expected property index to be updated", newIndex, instance.getPropertyIndex()); [EOL] assertNull("Expected name to be null after index update", instance.getName()); [EOL] }
public void testSetPropertyIndex_SameIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int initialIndex = 0; [EOL] instance.setPropertyIndex(initialIndex); [EOL] instance.setPropertyIndex(initialIndex); [EOL] assertEquals("Expected property index to remain the same", initialIndex, instance.getPropertyIndex()); [EOL] assertNotNull("Expected name not to be null when index is unchanged", instance.getName()); [EOL] }
public Object getBaseValue() { [EOL] return handler.getProperty(getBean(), getPropertyName()); [EOL] }
public void testGetImmediateNodeWithWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.index = YourClassUnderTest.WHOLE_COLLECTION; [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNodeWithSpecificIndex() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.index = 1; // Assuming 1 is a valid index that is not WHOLE_COLLECTION [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
protected boolean isActualProperty() { [EOL] return true; [EOL] }
public void testCreatePathWithNullBaseValueAndSuccessfulFactory() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] AbstractFactory factory = mock(AbstractFactory.class); [EOL] when(getBaseValue()).thenReturn(null); [EOL] when(getAbstractFactory(context)).thenReturn(factory); [EOL] when(factory.createObject(context, this, getBean(), getPropertyName(), 0)).thenReturn(true); [EOL] NodePointer result = createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] verify(factory, times(1)).createObject(context, this, getBean(), getPropertyName(), 0); [EOL] }
public void testCreatePathWithNullBaseValueAndUnsuccessfulFactory() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] AbstractFactory factory = mock(AbstractFactory.class); [EOL] when(getBaseValue()).thenReturn(null); [EOL] when(getAbstractFactory(context)).thenReturn(factory); [EOL] when(factory.createObject(context, this, getBean(), getPropertyName(), 0)).thenReturn(false); [EOL] try { [EOL] createPath(context); [EOL] fail("Expected JXPathAbstractFactoryException to be thrown"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] } [EOL] verify(factory, times(1)).createObject(context, this, getBean(), getPropertyName(), 0); [EOL] }
public void testCreatePathWithValidIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] when(getBaseValue()).thenReturn(new Object()); [EOL] when(index).thenReturn(1); [EOL] when(getLength()).thenReturn(2); [EOL] NodePointer result = createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] assertEquals("Expected index to be unchanged", 1, index); [EOL] }
public void testCreatePathWithInvalidNegativeIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] when(getBaseValue()).thenReturn(new Object()); [EOL] when(index).thenReturn(-1); [EOL] try { [EOL] createPath(context); [EOL] fail("Expected JXPathInvalidAccessException to be thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] } [EOL] }
public void testCreatePathWithIndexOutOfBounds() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object collection = new Object(); [EOL] when(getBaseValue()).thenReturn(collection); [EOL] when(index).thenReturn(3); [EOL] when(getLength()).thenReturn(2); [EOL] PropertyHandler handler = mock(PropertyHandler.class); [EOL] when(handler.setProperty(getBean(), getPropertyName(), collection)).thenReturn(null); [EOL] NodePointer result = createPath(context); [EOL] assertNotNull("Expected non-null NodePointer", result); [EOL] verify(handler, times(1)).setProperty(getBean(), getPropertyName(), collection); [EOL] }
public void testRemoveWithWholeCollection() { [EOL] this.index = WHOLE_COLLECTION; [EOL] remove(); [EOL] assertTrue("Expected removeKey to be called", removeKeyCalled); [EOL] }
public void testRemoveWithCollection() { [EOL] this.index = SOME_VALID_INDEX; [EOL] makeIsCollectionReturnTrue(); [EOL] remove(); [EOL] assertTrue("Expected setProperty to be called", setPropertyCalled); [EOL] }
public void testRemoveWithIndexZero() { [EOL] this.index = 0; [EOL] makeIsCollectionReturnFalse(); [EOL] remove(); [EOL] assertTrue("Expected removeKey to be called", removeKeyCalled); [EOL] }
public void testAsPath_ImmediateParentPathNotEmpty() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parentPath"); [EOL] NodePointer nodePointer = new NodePointer(parentPointer); [EOL] nodePointer.setPropertyName("nodeName"); [EOL] nodePointer.setIndex(NodePointer.WHOLE_COLLECTION); // Assuming WHOLE_COLLECTION is a constant representing the whole collection [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/parentPath[@name='nodeName']", result); [EOL] }
public void testAsPath_ImmediateParentPathEmpty() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn(""); [EOL] NodePointer nodePointer = new NodePointer(parentPointer); [EOL] nodePointer.setPropertyName("nodeName"); [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/.[@name='nodeName']", result); [EOL] }
public void testAsPath_ImmediateParentPathEndsWithSlash() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parentPath/"); [EOL] NodePointer nodePointer = new NodePointer(parentPointer); [EOL] nodePointer.setPropertyName("nodeName"); [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/parentPath/.[@name='nodeName']", result); [EOL] }
public void testAsPath_IsCollectionWithIndex() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parentPath"); [EOL] NodePointer nodePointer = new NodePointer(parentPointer); [EOL] nodePointer.setPropertyName("nodeName"); [EOL] nodePointer.setIndex(1); // Assuming index is 0-based [EOL] nodePointer.setIsCollection(true); // Assuming setIsCollection method exists to mark the node as a collection [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/parentPath[@name='nodeName'][2]", result); [EOL] }
public void testEscapeWithSingleQuote() { [EOL] String input = "test'string"; [EOL] String expected = "test&apostring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithDoubleQuote() { [EOL] String input = "test\"string"; [EOL] String expected = "test&quotstring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithBothQuotes() { [EOL] String input = "test'str\"ing"; [EOL] String expected = "test&apostring&quoting"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithoutQuotes() { [EOL] String input = "teststring"; [EOL] String expected = "teststring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAbstractFactoryWithNonNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] AbstractFactory expectedFactory = new AbstractFactory() { [EOL] }; [EOL] context.setFactory(expectedFactory); [EOL] AbstractFactory actualFactory = getAbstractFactory(context); [EOL] assertEquals("Expected factory should be returned", expectedFactory, actualFactory); [EOL] }
public void testGetAbstractFactoryWithNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] try { [EOL] getAbstractFactory(context); [EOL] fail("JXPathException should be thrown when factory is null"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Factory is not set on the JXPathContext - cannot create path: /", e.getMessage()); [EOL] } [EOL] }
public void testCoreOperationAndWithNoArgs() { [EOL] Expression[] args = new Expression[0]; [EOL] CoreOperationAnd operation = new CoreOperationAnd(args); [EOL] assertNotNull(operation); [EOL] }
public void testCoreOperationAndWithOneArg() { [EOL] Expression[] args = new Expression[1]; [EOL] args[0] = mock(Expression.class); [EOL] CoreOperationAnd operation = new CoreOperationAnd(args); [EOL] assertNotNull(operation); [EOL] }
public void testCoreOperationAndWithMultipleArgs() { [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] CoreOperationAnd operation = new CoreOperationAnd(args); [EOL] assertNotNull(operation); [EOL] }
public void testComputeValueAllTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(Boolean.TRUE); [EOL] when(args[1].computeValue(context)).thenReturn(Boolean.TRUE); [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueWithFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(Boolean.FALSE); [EOL] when(args[1].computeValue(context)).thenReturn(Boolean.TRUE); [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testComputeValueEmptyArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[0]; [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
protected int getPrecedence() { [EOL] return 1; [EOL] }
public String getSymbol() { [EOL] return "and"; [EOL] }
public void testRegisterAtomicClassWithValidClass() { [EOL] Class beanClass = String.class; // Use any class for testing [EOL] JXPathIntrospector.registerAtomicClass(beanClass); [EOL] assertTrue(JXPathIntrospector.getBeanInfo(beanClass) instanceof JXPathBasicBeanInfo); [EOL] }
public void testRegisterDynamicClassWithInterface() { [EOL] Class beanClass = SomeInterface.class; [EOL] Class dynamicPropertyHandlerClass = SomeDynamicPropertyHandler.class; [EOL] JXPathIntrospector.registerDynamicClass(beanClass, dynamicPropertyHandlerClass); [EOL] JXPathBasicBeanInfo result = (JXPathBasicBeanInfo) JXPathIntrospector.byInterface.get(beanClass); [EOL] assertNotNull(result); [EOL] assertEquals(dynamicPropertyHandlerClass, result.getDynamicPropertyHandlerClass()); [EOL] }
public void testRegisterDynamicClassWithRegularClass() { [EOL] Class beanClass = SomeBean.class; [EOL] Class dynamicPropertyHandlerClass = SomeDynamicPropertyHandler.class; [EOL] JXPathIntrospector.registerDynamicClass(beanClass, dynamicPropertyHandlerClass); [EOL] JXPathBasicBeanInfo result = (JXPathBasicBeanInfo) JXPathIntrospector.byClass.get(beanClass); [EOL] assertNotNull(result); [EOL] assertEquals(dynamicPropertyHandlerClass, result.getDynamicPropertyHandlerClass()); [EOL] }
public void testGetBeanInfoWithCachedInfo() { [EOL] Class beanClass = SomeBean.class; [EOL] JXPathBeanInfo expectedBeanInfo = new JXPathBasicBeanInfo(beanClass); [EOL] byClass.put(beanClass, expectedBeanInfo); [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertEquals("Should retrieve the cached bean info", expectedBeanInfo, actualBeanInfo); [EOL] }
public void testGetBeanInfoWithDynamicBeanInfo() { [EOL] Class beanClass = SomeOtherBean.class; [EOL] JXPathBeanInfo expectedBeanInfo = findDynamicBeanInfo(beanClass); [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertEquals("Should retrieve the dynamic bean info", expectedBeanInfo, actualBeanInfo); [EOL] }
public void testGetBeanInfoWithInformant() { [EOL] Class beanClass = YetAnotherBean.class; [EOL] JXPathBeanInfo expectedBeanInfo = findInformant(beanClass); [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertEquals("Should retrieve the informant bean info", expectedBeanInfo, actualBeanInfo); [EOL] }
public void testGetBeanInfoWithNewBeanInfo() { [EOL] Class beanClass = NewBean.class; [EOL] JXPathBeanInfo actualBeanInfo = JXPathContext.getBeanInfo(beanClass); [EOL] assertNotNull("Should create a new JXPathBasicBeanInfo", actualBeanInfo); [EOL] assertTrue("Should be an instance of JXPathBasicBeanInfo", actualBeanInfo instanceof JXPathBasicBeanInfo); [EOL] }
private static JXPathBeanInfo findDynamicBeanInfo(Class beanClass) { [EOL] JXPathBeanInfo beanInfo = null; [EOL] if (beanClass.isInterface()) { [EOL] beanInfo = (JXPathBeanInfo) byInterface.get(beanClass); [EOL] if (beanInfo != null && beanInfo.isDynamic()) { [EOL] return beanInfo; [EOL] } [EOL] } [EOL] Class[] interfaces = beanClass.getInterfaces(); [EOL] if (interfaces != null) { [EOL] for (int i = 0; i < interfaces.length; i++) { [EOL] beanInfo = findDynamicBeanInfo(interfaces[i]); [EOL] if (beanInfo != null && beanInfo.isDynamic()) { [EOL] return beanInfo; [EOL] } [EOL] } [EOL] } [EOL] Class sup = beanClass.getSuperclass(); [EOL] if (sup != null) { [EOL] beanInfo = (JXPathBeanInfo) byClass.get(sup); [EOL] if (beanInfo != null && beanInfo.isDynamic()) { [EOL] return beanInfo; [EOL] } [EOL] return findDynamicBeanInfo(sup); [EOL] } [EOL] return null; [EOL] }
public void testFindInformantWithNonExistentBeanInfo() { [EOL] Class beanClass = SomeBean.class; // SomeBean should be a placeholder for an actual bean class [EOL] JXPathBeanInfo result = findInformant(beanClass); [EOL] assertNull("Expected null when no BeanInfo class exists", result); [EOL] }
public void testFindInformantWithExistingBeanInfo() { [EOL] Class beanClass = SomeBeanWithBeanInfo.class; // SomeBeanWithBeanInfo should be a placeholder for an actual bean class with a corresponding BeanInfo class named SomeBeanWithBeanInfoXBeanInfo [EOL] JXPathBeanInfo result = findInformant(beanClass); [EOL] assertNotNull("Expected non-null JXPathBeanInfo", result); [EOL] assertTrue("Result should be instance of JXPathBeanInfo", result instanceof JXPathBeanInfo); [EOL] }
public void testFindInformantAssignableToJXPathBeanInfo() { [EOL] Class beanClass = JXPathBeanInfoImpl.class; // JXPathBeanInfoImpl should be a placeholder for an actual class that implements JXPathBeanInfo [EOL] JXPathBeanInfo result = findInformant(beanClass); [EOL] assertNotNull("Expected non-null JXPathBeanInfo", result); [EOL] assertTrue("Result should be instance of JXPathBeanInfo", result instanceof JXPathBeanInfo); [EOL] }
public void testInstantiateWithNonNullClassLoader() throws Exception { [EOL] Class<?> sibling = this.getClass(); [EOL] String className = "java.lang.Object"; [EOL] Object instance = instantiate(sibling, className); [EOL] assertNotNull(instance); [EOL] assertTrue(instance instanceof java.lang.Object); [EOL] }
public void testInstantiateWithNullClassLoader() throws Exception { [EOL] Class<?> sibling = Class.forName("java.lang.Object", false, null); [EOL] String className = "java.lang.Object"; [EOL] Object instance = instantiate(sibling, className); [EOL] assertNotNull(instance); [EOL] assertTrue(instance instanceof java.lang.Object); [EOL] }
public Pointer getContextNodePointer() { [EOL] return getCurrentNodePointer(); [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=Optional[0]; [EOL] boolean startedSetIteration=Optional[false]; [EOL] boolean done=Optional[false]; [EOL] boolean hasPerformedIteratorStep=Optional[false]; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=Optional[new Comparator() { [EOL] public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] }; [EOL] }
public void testGetDocumentOrder_WithParentContextRequiringChildOrdering() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] when(parentContext.isChildOrderingRequired()).thenReturn(true); [EOL] EvalContext context = new EvalContext(parentContext); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(1, order); [EOL] }
public void testGetDocumentOrder_WithParentContextNotRequiringChildOrdering() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] when(parentContext.isChildOrderingRequired()).thenReturn(false); [EOL] EvalContext context = new EvalContext(parentContext); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(0, order); [EOL] }
public void testGetDocumentOrder_WithoutParentContext() { [EOL] EvalContext context = new EvalContext(null); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(0, order); [EOL] }
public void testIsChildOrderingRequired_DocumentOrderNonZero() { [EOL] EvalContext context = new EvalContext() { [EOL] public int getDocumentOrder() { [EOL] return 1; // Any non-zero value [EOL] } [EOL] }; [EOL] assertTrue(context.isChildOrderingRequired()); [EOL] } [EOL] public void testIsChildOrderingRequired_DocumentOrderZero() { [EOL] EvalContext context = new EvalContext() { [EOL] public int getDocumentOrder() { [EOL] return 0; [EOL] } [EOL] }; [EOL] assertFalse(context.isChildOrderingRequired()); [EOL] }
public void testHasNext_WithNonNullPointerIterator() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.pointerIterator = mock(Iterator.class); [EOL] when(context.pointerIterator.hasNext()).thenReturn(true); [EOL] boolean result = context.hasNext(); [EOL] assertTrue(result); [EOL] }
public void testHasNext_WithNullPointerIteratorAndNonZeroDocumentOrder() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.pointerIterator = null; [EOL] when(context.getDocumentOrder()).thenReturn(1); [EOL] when(context.constructIterator()).thenReturn(true); [EOL] boolean result = context.hasNext(); [EOL] assertTrue(result); [EOL] }
public void testHasNext_WithNullPointerIteratorZeroDocumentOrderAndNotDone() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.pointerIterator = null; [EOL] context.done = false; [EOL] context.hasPerformedIteratorStep = false; [EOL] when(context.getDocumentOrder()).thenReturn(0); [EOL] boolean result = context.hasNext(); [EOL] assertTrue(result); [EOL] }
public void testHasNext_WithNullPointerIteratorZeroDocumentOrderAndDone() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.pointerIterator = null; [EOL] context.done = true; [EOL] context.hasPerformedIteratorStep = false; [EOL] when(context.getDocumentOrder()).thenReturn(0); [EOL] boolean result = context.hasNext(); [EOL] assertFalse(result); [EOL] }
public Object next() { [EOL] if (pointerIterator != null) { [EOL] return pointerIterator.next(); [EOL] } [EOL] if (getDocumentOrder() != 0) { [EOL] if (!constructIterator()) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] return pointerIterator.next(); [EOL] } else { [EOL] if (!done && !hasPerformedIteratorStep) { [EOL] performIteratorStep(); [EOL] } [EOL] if (done) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] hasPerformedIteratorStep = false; [EOL] return getCurrentNodePointer(); [EOL] } [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=0; [EOL] boolean startedSetIteration=false; [EOL] boolean done=false; [EOL] boolean hasPerformedIteratorStep=false; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=new Comparator() { [EOL] public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] } [EOL] }
private void performIteratorStep() { [EOL] done = true; [EOL] if (position != 0 && nextNode()) { [EOL] done = false; [EOL] } else { [EOL] while (nextSet()) { [EOL] if (nextNode()) { [EOL] done = false; [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] hasPerformedIteratorStep = true; [EOL] }
public Pointer getSingleNodePointer() { [EOL] reset(); [EOL] while (nextSet()) { [EOL] if (nextNode()) { [EOL] return getCurrentNodePointer(); [EOL] } [EOL] } [EOL] return null; [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=Optional[0]; [EOL] boolean startedSetIteration=Optional[false]; [EOL] boolean done=Optional[false]; [EOL] boolean hasPerformedIteratorStep=Optional[false]; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=Optional[new Comparator() { [EOL] public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] }; [EOL] }]
public boolean nextSet() { [EOL] reset(); [EOL] if (!startedSetIteration) { [EOL] startedSetIteration = true; [EOL] while (parentContext.nextSet()) { [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] } [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] while (parentContext.nextSet()) { [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] }
public Object compute(EvalContext context) { [EOL] return value; [EOL] }
public void testBeanPropertyPointerWithNullParent() { [EOL] JXPathBeanInfo beanInfo = mock(JXPathBeanInfo.class); // Assuming a mocking framework is used [EOL] BeanPropertyPointer bpp = new BeanPropertyPointer(null, beanInfo); [EOL] assertNull(bpp.getParent()); [EOL] assertEquals(beanInfo, bpp.getBeanInfo()); [EOL] } [EOL] public void testBeanPropertyPointerWithNonNullParent() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] JXPathBeanInfo beanInfo = mock(JXPathBeanInfo.class); [EOL] BeanPropertyPointer bpp = new BeanPropertyPointer(parent, beanInfo); [EOL] assertEquals(parent, bpp.getParent()); [EOL] assertEquals(beanInfo, bpp.getBeanInfo()); [EOL] }
public void testSetPropertyName() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setPropertyName("testName"); [EOL] assertEquals("Property name should be 'testName'", "testName", context.getPropertyName()); [EOL] }

public void testSetPropertyIndex_NewIndex() { [EOL] int newIndex = 1; // Assuming the original propertyIndex is not 1 [EOL] setPropertyIndex(newIndex); [EOL] assertEquals(newIndex, propertyIndex); [EOL] assertNull(propertyName); [EOL] assertNull(propertyDescriptor); [EOL] assertEquals(UNINITIALIZED, baseValue); [EOL] assertEquals(UNINITIALIZED, value); [EOL] }
public void testSetPropertyIndex_SameIndex() { [EOL] int originalIndex = propertyIndex; [EOL] setPropertyIndex(originalIndex); [EOL] assertEquals(originalIndex, propertyIndex); [EOL] assertNotNull(propertyName); [EOL] assertNotNull(propertyDescriptor); [EOL] assertNotEquals(UNINITIALIZED, baseValue); [EOL] assertNotEquals(UNINITIALIZED, value); [EOL] }
public void testGetBaseValue_UninitializedAndPropertyDescriptorIsNull() { [EOL] setBaseValue(UNINITIALIZED); [EOL] mockGetPropertyDescriptor(null); [EOL] Object result = getBaseValue(); [EOL] assertNull(result); [EOL] }
public void testGetBaseValue_UninitializedAndPropertyDescriptorIsNotNull() { [EOL] setBaseValue(UNINITIALIZED); [EOL] PropertyDescriptor pd = new PropertyDescriptor(); // Replace with actual constructor [EOL] mockGetPropertyDescriptor(pd); [EOL] Object expectedValue = new Object(); // Replace with actual expected value [EOL] mockValueUtilsGetValue(expectedValue); [EOL] Object result = getBaseValue(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetBaseValue_Initialized() { [EOL] Object initializedValue = new Object(); // Replace with actual initialized value [EOL] setBaseValue(initializedValue); [EOL] Object result = getBaseValue(); [EOL] assertEquals(initializedValue, result); [EOL] }
public void testSetIndex_NewIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int newIndex = 1; // Assuming 1 is different from the default index [EOL] instance.setIndex(newIndex); [EOL] assertEquals(newIndex, instance.getIndex()); [EOL] }
public void testSetIndex_SameIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int sameIndex = 0; // Assuming 0 is the default index [EOL] instance.setIndex(sameIndex); [EOL] assertEquals(sameIndex, instance.getIndex()); [EOL] }
public void testSetIndex_WholeCollectionToZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION); [EOL] instance.setIndex(0); [EOL] assertTrue(instance.isValueUninitialized()); [EOL] }
public void testSetIndex_WholeCollectionNonZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION); [EOL] int newIndex = 2; // Assuming 2 is a valid index and different from WHOLE_COLLECTION [EOL] instance.setIndex(newIndex); [EOL] assertEquals(newIndex, instance.getIndex()); [EOL] assertTrue(instance.isValueUninitialized()); [EOL] }
public void testSetIndex_FromNonWholeCollectionToZero() { [EOL] YourClass instance = new YourClass(); [EOL] int initialIndex = 1; // Assuming 1 is a valid index and different from WHOLE_COLLECTION [EOL] instance.setIndex(initialIndex); [EOL] instance.setIndex(0); [EOL] assertEquals(0, instance.getIndex()); [EOL] assertFalse(instance.isValueUninitialized()); [EOL] }
public void testGetImmediateNode_UninitializedWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = WHOLE_COLLECTION; [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNode_UninitializedNotWholeCollectionWithNullPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = NOT_WHOLE_COLLECTION; // This should be a valid index that is not WHOLE_COLLECTION [EOL] instance.setPropertyDescriptor(null); // Assuming there is a method to set the PropertyDescriptor [EOL] Object result = instance.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNode_UninitializedNotWholeCollectionWithNonNullPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = NOT_WHOLE_COLLECTION; // This should be a valid index that is not WHOLE_COLLECTION [EOL] PropertyDescriptor pd = new PropertyDescriptor(); // Assuming a constructor for PropertyDescriptor [EOL] instance.setPropertyDescriptor(pd); // Assuming there is a method to set the PropertyDescriptor [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNode_AlreadyInitialized() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] Object expectedValue = new Object(); [EOL] instance.value = expectedValue; [EOL] Object result = instance.getImmediateNode(); [EOL] assertSame(expectedValue, result); [EOL] }
public void testIsActualPropertyWhenPropertyDescriptorIsNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isActualProperty(); [EOL] assert !result; [EOL] } [EOL] public void testIsActualPropertyWhenPropertyDescriptorIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isActualProperty(); [EOL] assert result; [EOL] }
public void testIsCollectionWithNullPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return null; [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithIndexedPropertyDescriptor() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new IndexedPropertyDescriptor(); [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithNegativeHint() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor(); [EOL] } [EOL] @Override [EOL] protected int getCollectionHint(Class<?> propertyType) { [EOL] return -1; [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithPositiveHint() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor(); [EOL] } [EOL] @Override [EOL] protected int getCollectionHint(Class<?> propertyType) { [EOL] return 1; [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithBaseValueNotNullAndIsCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor(); [EOL] } [EOL] @Override [EOL] protected int getCollectionHint(Class<?> propertyType) { [EOL] return 0; // Any value other than -1 or 1 [EOL] } [EOL] @Override [EOL] protected Object getBaseValue() { [EOL] return new ArrayList<>(); // Any collection object [EOL] } [EOL] @Override [EOL] protected boolean isCollection(Object value) { [EOL] return true; [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithBaseValueNotNullAndNotCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] @Override [EOL] protected PropertyDescriptor getPropertyDescriptor() { [EOL] return new PropertyDescriptor(); [EOL] } [EOL] @Override [EOL] protected int getCollectionHint(Class<?> propertyType) { [EOL] return 0; // Any value other than -1 or 1 [EOL] } [EOL] @Override [EOL] protected Object getBaseValue() { [EOL] return new Object(); // Any non-collection object [EOL] } [EOL] @Override [EOL] protected boolean isCollection(Object value) { [EOL] return false; [EOL] } [EOL] }; [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testSetValueWithNullPropertyDescriptor() { [EOL] try { [EOL] setup(); [EOL] setPropertyDescriptor(null); [EOL] instance.setValue("someValue"); [EOL] fail("Expected JXPathInvalidAccessException was not thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] assertEquals("Cannot set property: " + instance.asPath() + " - no such property", e.getMessage()); [EOL] } [EOL] }
public void testSetValueOnWholeCollection() { [EOL] setup(); [EOL] setIndex(WHOLE_COLLECTION); [EOL] setPropertyDescriptor(validPropertyDescriptor); [EOL] Object value = "someValue"; [EOL] instance.setValue(value); [EOL] verifyValueSet(instance.getBean(), validPropertyDescriptor, value); [EOL] }
public void testSetValueOnSpecificIndex() { [EOL] setup(); [EOL] setIndex(1); [EOL] setPropertyDescriptor(validPropertyDescriptor); [EOL] Object value = "someValue"; [EOL] instance.setValue(value); [EOL] verifyValueSetAtIndex(instance.getBean(), validPropertyDescriptor, 1, value); [EOL] }
public void testCreatePathWithNonNullImmediateNode() { [EOL] NodePointer testNodePointer = new ConcreteNodePointer() { [EOL] public Object getImmediateNode() { [EOL] return new Object(); // Return a non-null object to simulate an initialized node [EOL] } [EOL] }; [EOL] NodePointer result = testNodePointer.createPath(null); [EOL] assertSame("Expected the same NodePointer instance", testNodePointer, result); [EOL] }
public void testCreatePathWithNullImmediateNode() { [EOL] NodePointer testNodePointer = new ConcreteNodePointer() { [EOL] public Object getImmediateNode() { [EOL] return null; // Return null to simulate an uninitialized node [EOL] } [EOL] public NodePointer createPath(JXPathContext context) { [EOL] super.createPath(context); [EOL] baseValue = "initialized"; // Set a value to simulate path creation [EOL] value = "initialized"; // Set a value to simulate path creation [EOL] return this; [EOL] } [EOL] }; [EOL] NodePointer result = testNodePointer.createPath(null); [EOL] assertSame("Expected the same NodePointer instance", testNodePointer, result); [EOL] assertEquals("Expected baseValue to be initialized", "initialized", testNodePointer.baseValue); [EOL] assertEquals("Expected value to be initialized", "initialized", testNodePointer.value); [EOL] }
public void testRemoveWithIndexWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.WHOLE_COLLECTION; [EOL] instance.remove(); [EOL] assertNull("Expected value to be set to null", instance.getValue()); [EOL] }
public void testRemoveWithCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = 1; // Assuming 1 is a valid index for a collection [EOL] instance.setBaseValue(createTestCollection()); // You need to implement createTestCollection [EOL] instance.setBean(createTestBean()); // You need to implement createTestBean [EOL] instance.setPropertyDescriptor(createTestPropertyDescriptor()); // You need to implement createTestPropertyDescriptor [EOL] instance.remove(); [EOL] Object expectedCollection = createExpectedCollectionAfterRemoval(); // You need to implement this [EOL] assertEquals("Expected collection after removal", expectedCollection, instance.getBaseValue()); [EOL] }
public void testRemoveWithIndexZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = 0; [EOL] instance.remove(); [EOL] assertEquals("Expected index to be set to WHOLE_COLLECTION", YourClass.WHOLE_COLLECTION, instance.index); [EOL] assertNull("Expected value to be set to null", instance.getValue()); [EOL] }
public void testGetPropertyNameWhenPropertyNameIsNullAndPropertyDescriptorIsNull() { [EOL] YourClassUnderTest testInstance = new YourClassUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] return null; [EOL] } [EOL] }; [EOL] String result = testInstance.getPropertyName(); [EOL] assertEquals("*", result); [EOL] }
public void testGetPropertyNameWhenPropertyNameIsNullAndPropertyDescriptorIsNotNull() { [EOL] final String expectedPropertyName = "testProperty"; [EOL] YourClassUnderTest testInstance = new YourClassUnderTest() { [EOL] @Override [EOL] public PropertyDescriptor getPropertyDescriptor() { [EOL] PropertyDescriptor pd = new PropertyDescriptor(); [EOL] pd.setName(expectedPropertyName); [EOL] return pd; [EOL] } [EOL] }; [EOL] String result = testInstance.getPropertyName(); [EOL] assertEquals(expectedPropertyName, result); [EOL] }
public void testGetPropertyNameWhenPropertyNameIsNotNull() { [EOL] final String expectedPropertyName = "initializedProperty"; [EOL] YourClassUnderTest testInstance = new YourClassUnderTest(); [EOL] testInstance.propertyName = expectedPropertyName; [EOL] String result = testInstance.getPropertyName(); [EOL] assertEquals(expectedPropertyName, result); [EOL] }
public void testGetPropertyDescriptorWhenNull() { [EOL] setPropertyDescriptor(null); [EOL] setPropertyName("someProperty"); [EOL] setBeanInfo(createMockBeanInfoForProperty("someProperty")); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals("someProperty", result.getName()); [EOL] }
public void testGetPropertyDescriptorWhenNotNull() { [EOL] PropertyDescriptor expected = new PropertyDescriptor("someProperty", SomeBean.class); [EOL] setPropertyDescriptor(expected); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertSame(expected, result); [EOL] }
public void testGetPropertyDescriptorWithUnspecifiedProperty() { [EOL] setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL] setPropertyName("someProperty"); [EOL] setBeanInfo(createMockBeanInfoForProperty("someProperty")); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals("someProperty", result.getName()); [EOL] }
public void testGetPropertyDescriptorWithValidIndex() { [EOL] setPropertyIndex(0); [EOL] PropertyDescriptor[] descriptors = {new PropertyDescriptor("someProperty", SomeBean.class)}; [EOL] setPropertyDescriptors(descriptors); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNotNull(result); [EOL] assertEquals("someProperty", result.getName()); [EOL] }
public void testGetPropertyDescriptorWithInvalidIndex() { [EOL] setPropertyIndex(10); // Assuming 10 is out of bounds [EOL] PropertyDescriptor[] descriptors = {new PropertyDescriptor("someProperty", SomeBean.class)}; [EOL] setPropertyDescriptors(descriptors); [EOL] PropertyDescriptor result = getPropertyDescriptor(); [EOL] assertNull(result); [EOL] }
public void testJDOMAttributeIteratorWithElementAndSpecificName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] Namespace ns = Namespace.getNamespace("testPrefix", "testURI"); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", ns)).thenReturn(attribute); [EOL] when(element.getNamespace("testPrefix")).thenReturn(ns); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertTrue(iterator.attributes.contains(attribute)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndWildcardName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("*"); [EOL] Element element = mock(Element.class); [EOL] List<Attribute> allAttributes = new ArrayList<>(); [EOL] Attribute attribute = mock(Attribute.class); [EOL] Namespace ns = Namespace.NO_NAMESPACE; [EOL] allAttributes.add(attribute); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttributes()).thenReturn(allAttributes); [EOL] when(attribute.getNamespace()).thenReturn(ns); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertTrue(iterator.attributes.contains(attribute)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndNullNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName(null, "testName"); [EOL] Element element = mock(Element.class); [EOL] Namespace ns = Namespace.NO_NAMESPACE; [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getNamespace(null)).thenReturn(null); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertTrue(iterator.attributes.isEmpty()); [EOL] }
public void testJDOMAttributeIteratorWithNonElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] when(parent.getNode()).thenReturn(mock(Node.class)); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNull(iterator.attributes); [EOL] }
public void testGetNodePointer_PositionIsZeroAndSetPositionFails() { [EOL] setPosition(0); [EOL] mockSetPosition(1, false); // Mocking setPosition to return false [EOL] NodePointer result = getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionIsZeroAndSetPositionSucceeds() { [EOL] setPosition(0); [EOL] mockSetPosition(1, true); // Mocking setPosition to return true [EOL] NodePointer result = getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMAttributePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] assertEquals(attributes.get(0), ((JDOMAttributePointer) result).getAttribute()); [EOL] }
public void testGetNodePointer_PositionGreaterThanZero() { [EOL] setPosition(2); // Set to a position greater than 0 [EOL] NodePointer result = getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMAttributePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] assertEquals(attributes.get(1), ((JDOMAttributePointer) result).getAttribute()); [EOL] }
public void testSetPosition_AttributesNull() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains setPosition [EOL] instance.attributes = null; [EOL] boolean result = instance.setPosition(1); [EOL] assertFalse(result); [EOL] } [EOL] public void testSetPosition_PositionLessThanOne() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains setPosition [EOL] instance.attributes = new ArrayList(); // Add elements to the list if necessary [EOL] boolean result = instance.setPosition(0); [EOL] assertFalse(result); [EOL] } [EOL] public void testSetPosition_PositionGreaterThanSize() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains setPosition [EOL] instance.attributes = new ArrayList(); // Add elements to the list if necessary [EOL] boolean result = instance.setPosition(instance.attributes.size() + 1); [EOL] assertFalse(result); [EOL] } [EOL] public void testSetPosition_ValidPosition() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains setPosition [EOL] instance.attributes = new ArrayList(); [EOL] instance.attributes.add(new Object()); // Add at least one element to the list [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue(result); [EOL] }

protected boolean equal(EvalContext context, Expression left, Expression right) { [EOL] Object l = left.compute(context); [EOL] Object r = right.compute(context); [EOL] if (l instanceof InitialContext || l instanceof SelfContext) { [EOL] l = ((EvalContext) l).getSingleNodePointer(); [EOL] } [EOL] if (r instanceof InitialContext || r instanceof SelfContext) { [EOL] r = ((EvalContext) r).getSingleNodePointer(); [EOL] } [EOL] if (l instanceof Collection) { [EOL] l = ((Collection) l).iterator(); [EOL] } [EOL] if (r instanceof Collection) { [EOL] r = ((Collection) r).iterator(); [EOL] } [EOL] if ((l instanceof Iterator) && !(r instanceof Iterator)) { [EOL] return contains((Iterator) l, r); [EOL] } else if (!(l instanceof Iterator) && (r instanceof Iterator)) { [EOL] return contains((Iterator) r, l); [EOL] } else if (l instanceof Iterator && r instanceof Iterator) { [EOL] return findMatch((Iterator) l, (Iterator) r); [EOL] } [EOL] return equal(l, r); [EOL] }
public void testEqualWithBothPointersAndEqual() { [EOL] Pointer left = mock(Pointer.class); [EOL] Pointer right = mock(Pointer.class); [EOL] when(left.equals(right)).thenReturn(true); [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithLeftPointerAndRightNonPointer() { [EOL] Pointer left = mock(Pointer.class); [EOL] Object right = new Object(); [EOL] when(left.getValue()).thenReturn(right); [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithRightPointerAndLeftNonPointer() { [EOL] Object left = new Object(); [EOL] Pointer right = mock(Pointer.class); [EOL] when(right.getValue()).thenReturn(left); [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithBothNonPointersAndEqual() { [EOL] Object left = new Object(); [EOL] Object right = left; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithBoolean() { [EOL] Boolean left = true; [EOL] Boolean right = true; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithNumber() { [EOL] Number left = 1.0; [EOL] Number right = 1.0; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithString() { [EOL] String left = "test"; [EOL] String right = "test"; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithNullLeft() { [EOL] Object left = null; [EOL] Object right = null; [EOL] boolean result = equal(left, right); [EOL] assertTrue(result); [EOL] }
public void testEqualWithDifferentNonPointers() { [EOL] Object left = new Object(); [EOL] Object right = new Object(); [EOL] boolean result = equal(left, right); [EOL] assertFalse(result); [EOL] }
public void testPredicateContextWithNullExpression() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] Expression expression = null; [EOL] PredicateContext predicateContext = new PredicateContext(parentContext, expression); [EOL] assertNull(predicateContext.getExpression()); [EOL] }
public void testPredicateContextWithNameAttributeTestExpression() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NameAttributeTest nameAttributeTest = mock(NameAttributeTest.class); [EOL] Expression nameTestExpression = mock(Expression.class); [EOL] when(nameAttributeTest.getNameTestExpression()).thenReturn(nameTestExpression); [EOL] PredicateContext predicateContext = new PredicateContext(parentContext, nameAttributeTest); [EOL] assertSame(nameTestExpression, predicateContext.getNameTestExpression()); [EOL] }
public void testPredicateContextWithNonNameAttributeTestExpression() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] when(expression instanceof NameAttributeTest).thenReturn(false); [EOL] PredicateContext predicateContext = new PredicateContext(parentContext, expression); [EOL] assertNull(predicateContext.getNameTestExpression()); [EOL] }
public boolean nextNode() { [EOL] if (done) { [EOL] return false; [EOL] } [EOL] while (parentContext.nextNode()) { [EOL] if (setupDynamicPropertyPointer()) { [EOL] Object pred = nameTestExpression.computeValue(parentContext); [EOL] String propertyName = InfoSetUtil.stringValue(pred); [EOL] boolean ok = false; [EOL] String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL] for (int i = 0; i < names.length; i++) { [EOL] if (names[i].equals(propertyName)) { [EOL] ok = true; [EOL] break; [EOL] } [EOL] } [EOL] if (ok) { [EOL] dynamicPropertyPointer.setPropertyName(propertyName); [EOL] position++; [EOL] return true; [EOL] } [EOL] } else { [EOL] Object pred = expression.computeValue(parentContext); [EOL] if (pred instanceof Iterator) { [EOL] if (!((Iterator) pred).hasNext()) { [EOL] return false; [EOL] } [EOL] pred = ((Iterator) pred).next(); [EOL] } [EOL] if (pred instanceof NodePointer) { [EOL] pred = ((NodePointer) pred).getNode(); [EOL] } [EOL] if (pred instanceof Number) { [EOL] int pos = (int) InfoSetUtil.doubleValue(pred); [EOL] position++; [EOL] done = true; [EOL] return parentContext.setPosition(pos); [EOL] } else if (InfoSetUtil.booleanValue(pred)) { [EOL] position++; [EOL] return true; [EOL] } [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testSetupDynamicPropertyPointer_NameTestExpressionIsNull() { [EOL] this.nameTestExpression = null; [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_ParentIsNull() { [EOL] this.nameTestExpression = someExpression; [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(null); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_ParentIsNotPropertyOwnerPointer() { [EOL] this.nameTestExpression = someExpression; [EOL] NodePointer nonPropertyOwnerPointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(nonPropertyOwnerPointer); [EOL] when(nonPropertyOwnerPointer.getValuePointer()).thenReturn(nonPropertyOwnerPointer); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_SuccessfulSetup() { [EOL] this.nameTestExpression = someExpression; [EOL] PropertyOwnerPointer propertyOwnerPointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getValuePointer()).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertTrue(result); [EOL] assertEquals(propertyPointer, dynamicPropertyPointer); [EOL] }
public void testAttributeContextWithNonNullParentContextAndNodeTest() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] AttributeContext attributeContext = new AttributeContext(parentContext, nodeTest); [EOL] assertNotNull(attributeContext); [EOL] assertSame(parentContext, attributeContext.getParentContext()); [EOL] assertSame(nodeTest, attributeContext.getNodeTest()); [EOL] }
public void testAttributeContextWithNullParentContextAndNodeTest() { [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] try { [EOL] AttributeContext attributeContext = new AttributeContext(null, nodeTest); [EOL] assertNotNull(attributeContext); [EOL] assertNull(attributeContext.getParentContext()); [EOL] assertSame(nodeTest, attributeContext.getNodeTest()); [EOL] } catch (NullPointerException e) { [EOL] fail("Constructor should handle null parent context"); [EOL] } [EOL] }
public NodePointer getCurrentNodePointer() { [EOL] return currentNodePointer; [EOL] }
public void testReset() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setStarted(true); // Assuming there is a method to set the 'setStarted' field [EOL] instance.setIterator(new IteratorType()); // Assuming there is a method to set the 'iterator' field and IteratorType is a placeholder for the actual iterator type [EOL] instance.reset(); [EOL] assertFalse(instance.isStarted()); // Assuming there is a method to check the 'setStarted' field [EOL] assertNull(instance.getIterator()); // Assuming there is a method to get the 'iterator' field [EOL] }
public void testNextNodeWithSetNotStartedAndNodeTestNotInstanceOfNodeNameTest() { [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(nodeTest instanceof NodeNameTest).thenReturn(false); [EOL] TestContext parentContext = mock(TestContext.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] AttributeIterator iterator = mock(AttributeIterator.class); [EOL] when(currentNodePointer.attributeIterator(any(QName.class))).thenReturn(iterator); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(nodeTest, parentContext); [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] verify(iterator, never()).setPosition(anyInt()); [EOL] }
public void testNextNodeWithSetNotStartedAndNodeTestInstanceOfNodeNameTestButNoAttributes() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] TestContext parentContext = mock(TestContext.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] AttributeIterator iterator = mock(AttributeIterator.class); [EOL] when(currentNodePointer.attributeIterator(name)).thenReturn(null); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(nodeNameTest, parentContext); [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNodeWithSetStartedAndIteratorNotNullButSetPositionFails() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] TestContext parentContext = mock(TestContext.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] AttributeIterator iterator = mock(AttributeIterator.class); [EOL] when(currentNodePointer.attributeIterator(name)).thenReturn(iterator); [EOL] when(iterator.setPosition(anyInt())).thenReturn(false); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(nodeNameTest, parentContext); [EOL] yourObjectUnderTest.setStarted(true); // Manually setting setStarted to true [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNodeWithSetStartedAndIteratorNotNullAndSetPositionSucceeds() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] TestContext parentContext = mock(TestContext.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] AttributeIterator iterator = mock(AttributeIterator.class); [EOL] when(currentNodePointer.attributeIterator(name)).thenReturn(iterator); [EOL] when(iterator.setPosition(anyInt())).thenReturn(true); [EOL] when(iterator.getNodePointer()).thenReturn(currentNodePointer); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(nodeNameTest, parentContext); [EOL] yourObjectUnderTest.setStarted(true); // Manually setting setStarted to true [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertTrue(result); [EOL] assertNotNull(yourObjectUnderTest.getCurrentNodePointer()); [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL] if (object == null) { [EOL] return true; [EOL] } [EOL] if (toType == Object.class) { [EOL] return true; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType)) { [EOL] return true; [EOL] } [EOL] if (toType.isAssignableFrom(fromType)) { [EOL] return true; [EOL] } [EOL] if (toType == String.class) { [EOL] return true; [EOL] } [EOL] if (object instanceof Boolean) { [EOL] if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Number) { [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof String) { [EOL] if (toType.isPrimitive()) { [EOL] return true; [EOL] } [EOL] if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL] return true; [EOL] } [EOL] } else if (fromType.isArray()) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] int length = Array.getLength(object); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (Array.getLength(object) > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] while (it.hasNext()) { [EOL] Object value = it.next(); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (((Collection) object).size() > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return canConvert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return canConvert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL] if (object == null) { [EOL] if (toType.isPrimitive()) { [EOL] return convertNullToPrimitive(toType); [EOL] } [EOL] return null; [EOL] } [EOL] if (toType == Object.class) { [EOL] if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return object; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL] return object; [EOL] } [EOL] if (fromType.isArray()) { [EOL] int length = Array.getLength(object); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] for (int i = 0; i < length; i++) { [EOL] collection.add(Array.get(object, i)); [EOL] } [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] int length = ((Collection) object).size(); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = it.next(); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] collection.addAll((Collection) object); [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } else if (toType == String.class) { [EOL] return object.toString(); [EOL] } else if (object instanceof Boolean) { [EOL] if (toType == boolean.class) { [EOL] return object; [EOL] } [EOL] boolean value = ((Boolean) object).booleanValue(); [EOL] return allocateNumber(toType, value ? 1 : 0); [EOL] } else if (object instanceof Number) { [EOL] double value = ((Number) object).doubleValue(); [EOL] if (toType == boolean.class || toType == Boolean.class) { [EOL] return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL] } [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return allocateNumber(toType, value); [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return object; [EOL] } [EOL] } else if (object instanceof String) { [EOL] Object value = convertStringToPrimitive(object, toType); [EOL] if (value != null) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter converter = ConvertUtils.lookup(toType); [EOL] if (converter != null) { [EOL] return converter.convert(toType, object); [EOL] } [EOL] throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
public void testConvertStringToPrimitiveBooleanTrue() { [EOL] Object result = convertStringToPrimitive("true", boolean.class); [EOL] assertTrue(result instanceof Boolean); [EOL] assertTrue((Boolean) result); [EOL] }
public void testConvertStringToPrimitiveBooleanFalse() { [EOL] Object result = convertStringToPrimitive("false", Boolean.class); [EOL] assertTrue(result instanceof Boolean); [EOL] assertFalse((Boolean) result); [EOL] }
public void testConvertStringToPrimitiveChar() { [EOL] Object result = convertStringToPrimitive("a", char.class); [EOL] assertTrue(result instanceof Character); [EOL] assertEquals('a', ((Character) result).charValue()); [EOL] }
public void testConvertStringToPrimitiveByte() { [EOL] Object result = convertStringToPrimitive("1", byte.class); [EOL] assertTrue(result instanceof Byte); [EOL] assertEquals((byte) 1, ((Byte) result).byteValue()); [EOL] }
public void testConvertStringToPrimitiveShort() { [EOL] Object result = convertStringToPrimitive("1", short.class); [EOL] assertTrue(result instanceof Short); [EOL] assertEquals((short) 1, ((Short) result).shortValue()); [EOL] }
public void testConvertStringToPrimitiveInt() { [EOL] Object result = convertStringToPrimitive("1", int.class); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(1, ((Integer) result).intValue()); [EOL] }
public void testConvertStringToPrimitiveLong() { [EOL] Object result = convertStringToPrimitive("1", long.class); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(1L, ((Long) result).longValue()); [EOL] }
public void testConvertStringToPrimitiveFloat() { [EOL] Object result = convertStringToPrimitive("1.0", float.class); [EOL] assertTrue(result instanceof Float); [EOL] assertEquals(1.0f, ((Float) result).floatValue(), 0.0f); [EOL] }
public void testConvertStringToPrimitiveDouble() { [EOL] Object result = convertStringToPrimitive("1.0", double.class); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(1.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testConvertStringToPrimitiveNull() { [EOL] Object result = convertStringToPrimitive("test", String.class); [EOL] assertNull(result); [EOL] }
public void testAllocateNumberForByte() { [EOL] Number result = allocateNumber(Byte.class, 1.0); [EOL] assertTrue(result instanceof Byte); [EOL] assertEquals((byte) 1, result.byteValue()); [EOL] }
public void testAllocateNumberForShort() { [EOL] Number result = allocateNumber(Short.class, 1.0); [EOL] assertTrue(result instanceof Short); [EOL] assertEquals((short) 1, result.shortValue()); [EOL] }
public void testAllocateNumberForInteger() { [EOL] Number result = allocateNumber(Integer.class, 1.0); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(1, result.intValue()); [EOL] }
public void testAllocateNumberForLong() { [EOL] Number result = allocateNumber(Long.class, 1.0); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(1L, result.longValue()); [EOL] }
public void testAllocateNumberForFloat() { [EOL] Number result = allocateNumber(Float.class, 1.0); [EOL] assertTrue(result instanceof Float); [EOL] assertEquals(1.0f, result.floatValue(), 0.0f); [EOL] }
public void testAllocateNumberForDouble() { [EOL] Number result = allocateNumber(Double.class, 1.0); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(1.0, result.doubleValue(), 0.0); [EOL] }
public void testAllocateNumberForInvalidType() { [EOL] Number result = allocateNumber(String.class, 1.0); [EOL] assertNull(result); [EOL] }
public void testIsDeclaredVariable_WhenVarNameExists() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.getVariables().declareVariable("existingVar", new Object()); [EOL] boolean result = context.isDeclaredVariable("existingVar"); [EOL] assertTrue(result); [EOL] }
public void testIsDeclaredVariable_WhenVarNameDoesNotExist() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isDeclaredVariable("nonExistingVar"); [EOL] assertFalse(result); [EOL] }
public void testGetVariableExisting() { [EOL] context.setVariable("existingVar", "value"); [EOL] Object result = context.getVariable("existingVar"); [EOL] assertEquals("value", result); [EOL] }
public void testGetVariableNonExisting() { [EOL] try { [EOL] context.getVariable("nonExistingVar"); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No such variable: 'nonExistingVar'", e.getMessage()); [EOL] } [EOL] }
public void testComputeValueLessThanOrEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(5.0); [EOL] when(args[1].computeValue(context)).thenReturn(10.0); [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueGreaterThan() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(15.0); [EOL] when(args[1].computeValue(context)).thenReturn(10.0); [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testNamespacePointerWithNullParentAndNullPrefix() { [EOL] NamespacePointer np = new NamespacePointer(null, null); [EOL] assertNull(np.getParent()); [EOL] assertNull(np.getPrefix()); [EOL] }
public void testNamespacePointerWithNonNullParentAndNullPrefix() { [EOL] NodePointer parent = new NodePointerMock(); [EOL] NamespacePointer np = new NamespacePointer(parent, null); [EOL] assertEquals(parent, np.getParent()); [EOL] assertNull(np.getPrefix()); [EOL] }
public void testNamespacePointerWithNullParentAndNonNullPrefix() { [EOL] String prefix = "testPrefix"; [EOL] NamespacePointer np = new NamespacePointer(null, prefix); [EOL] assertNull(np.getParent()); [EOL] assertEquals(prefix, np.getPrefix()); [EOL] }
public void testNamespacePointerWithNonNullParentAndNonNullPrefix() { [EOL] NodePointer parent = new NodePointerMock(); [EOL] String prefix = "testPrefix"; [EOL] NamespacePointer np = new NamespacePointer(parent, prefix); [EOL] assertEquals(parent, np.getParent()); [EOL] assertEquals(prefix, np.getPrefix()); [EOL] }
public Object testGetImmediateNode() { [EOL] Object result = instanceUnderTest.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetNamespaceURI_WithNullNamespaceURI() { [EOL] NamespaceContext parent = mock(NamespaceContext.class); [EOL] when(parent.getNamespaceURI(anyString())).thenReturn("http://example.com/"); [EOL] MyNamespaceContext context = new MyNamespaceContext(parent, "prefix"); [EOL] String result = context.getNamespaceURI(); [EOL] assertEquals("http://example.com/", result); [EOL] }
public void testGetNamespaceURI_WithNonNullNamespaceURI() { [EOL] NamespaceContext parent = mock(NamespaceContext.class); [EOL] MyNamespaceContext context = new MyNamespaceContext(parent, "prefix"); [EOL] context.namespaceURI = "http://example.org/"; [EOL] String result = context.getNamespaceURI(); [EOL] assertEquals("http://example.org/", result); [EOL] }
public void testAsPathWithParent() { [EOL] Node parent = mock(Node.class); [EOL] when(parent.asPath()).thenReturn("parentPath"); [EOL] Node node = new Node(parent, "prefix"); [EOL] String result = node.asPath(); [EOL] assertEquals("parentPath/namespace::prefix", result); [EOL] }
public void testAsPathWithoutParent() { [EOL] Node node = new Node(null, "prefix"); [EOL] String result = node.asPath(); [EOL] assertEquals("namespace::prefix", result); [EOL] }
public void testAsPathWithParentAndTrailingSlash() { [EOL] Node parent = mock(Node.class); [EOL] when(parent.asPath()).thenReturn("parentPath/"); [EOL] Node node = new Node(parent, "prefix"); [EOL] String result = node.asPath(); [EOL] assertEquals("parentPath/namespace::prefix", result); [EOL] }
public void testDynamicPointerConstructorWithNonNullValues() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testNamespace", "testName"); [EOL] Object bean = new Object(); [EOL] DynamicPropertyHandler handler = mock(DynamicPropertyHandler.class); [EOL] DynamicPointer dynamicPointer = new DynamicPointer(parent, name, bean, handler); [EOL] assertNotNull(dynamicPointer); [EOL] assertSame(parent, dynamicPointer.getParent()); [EOL] assertEquals(name, dynamicPointer.getName()); [EOL] assertSame(bean, dynamicPointer.getBean()); [EOL] assertSame(handler, dynamicPointer.getHandler()); [EOL] }
public void testGetPropertyPointer() { [EOL] YourClass instance = new YourClass(handler); [EOL] PropertyPointer result = instance.getPropertyPointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DynamicPropertyPointer); [EOL] }
public void testEquals_SameObject() { [EOL] DynamicPointer pointer = new DynamicPointer(); [EOL] boolean result = pointer.equals(pointer); [EOL] assert result; [EOL] } [EOL] public void testEquals_Null() { [EOL] DynamicPointer pointer = new DynamicPointer(); [EOL] boolean result = pointer.equals(null); [EOL] assert !result; [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] DynamicPointer pointer = new DynamicPointer(); [EOL] Object other = new Object(); [EOL] boolean result = pointer.equals(other); [EOL] assert !result; [EOL] } [EOL] public void testEquals_EqualDynamicPointer() { [EOL] DynamicPointer pointer1 = new DynamicPointer(); [EOL] pointer1.bean = new Object(); [EOL] pointer1.name = "pointer"; [EOL] DynamicPointer pointer2 = new DynamicPointer(); [EOL] pointer2.bean = pointer1.bean; [EOL] pointer2.name = new String("pointer"); // Ensure it's a different instance but equal [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert result; [EOL] } [EOL] public void testEquals_NotEqualDynamicPointer_DifferentBean() { [EOL] DynamicPointer pointer1 = new DynamicPointer(); [EOL] pointer1.bean = new Object(); [EOL] pointer1.name = "pointer"; [EOL] DynamicPointer pointer2 = new DynamicPointer(); [EOL] pointer2.bean = new Object(); // Different bean [EOL] pointer2.name = "pointer"; [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert !result; [EOL] } [EOL] public void testEquals_NotEqualDynamicPointer_DifferentName() { [EOL] DynamicPointer pointer1 = new DynamicPointer(); [EOL] pointer1.bean = new Object(); [EOL] pointer1.name = "pointer"; [EOL] DynamicPointer pointer2 = new DynamicPointer(); [EOL] pointer2.bean = pointer1.bean; [EOL] pointer2.name = "anotherPointer"; // Different name [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert !result; [EOL] }
public Pointer getSingleNodePointer() { [EOL] return nodePointer; [EOL] }
public void testSetPosition_CollectionWithinRange() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = true; [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getLength()).thenReturn(5); [EOL] instance.nodePointer = mockNodePointer; [EOL] boolean result = instance.setPosition(3); [EOL] Mockito.verify(mockNodePointer).setIndex(2); [EOL] assertTrue(result); [EOL] }
public void testSetPosition_CollectionOutOfRange() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = true; [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getLength()).thenReturn(5); [EOL] instance.nodePointer = mockNodePointer; [EOL] boolean result = instance.setPosition(6); [EOL] assertFalse(result); [EOL] }
public void testSetPosition_NotCollectionAndPositionOne() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = false; [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue(result); [EOL] }
public void testSetPosition_NotCollectionAndPositionNotOne() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = false; [EOL] boolean result = instance.setPosition(2); [EOL] assertFalse(result); [EOL] }
public void testNextSet_WhenNotStarted_ShouldStartAndReturnTrue() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name that contains the 'nextSet' method [EOL] boolean result = instance.nextSet(); [EOL] assertTrue(result); [EOL] }
public void testNextSet_WhenAlreadyStarted_ShouldReturnFalse() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name that contains the 'nextSet' method [EOL] instance.nextSet(); // Call once to set 'started' to true [EOL] boolean result = instance.nextSet(); [EOL] assertFalse(result); [EOL] }
public void testPropertyIteratorWithForwardAndStartWithNull() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] String name = "testProperty"; [EOL] boolean reverse = false; [EOL] NodePointer startWith = null; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should match", name, iterator.getName()); [EOL] assertFalse("Iterator should not be in reverse", iterator.isReverse()); [EOL] assertTrue("Iterator should include start", iterator.isIncludeStart()); [EOL] assertEquals("Start index should be 0", 0, iterator.getStartIndex()); [EOL] assertEquals("Start property index should be UNSPECIFIED_PROPERTY", PropertyPointer.UNSPECIFIED_PROPERTY, iterator.getStartPropertyIndex()); [EOL] }
public void testPropertyIteratorWithReverseAndStartWithNull() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] String name = "testProperty"; [EOL] boolean reverse = true; [EOL] NodePointer startWith = null; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should match", name, iterator.getName()); [EOL] assertTrue("Iterator should be in reverse", iterator.isReverse()); [EOL] assertTrue("Iterator should include start", iterator.isIncludeStart()); [EOL] assertEquals("Start index should be -1", -1, iterator.getStartIndex()); [EOL] assertEquals("Start property index should be UNSPECIFIED_PROPERTY", PropertyPointer.UNSPECIFIED_PROPERTY, iterator.getStartPropertyIndex()); [EOL] }
public void testPropertyIteratorWithForwardAndValidStartWith() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] PropertyPointer startWithPropertyPointer = mock(PropertyPointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] when(startWithPropertyPointer.getImmediateParentPointer()).thenReturn(pointer); [EOL] when(startWithPropertyPointer.getPropertyIndex()).thenReturn(1); [EOL] when(startWithPropertyPointer.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] String name = "testProperty"; [EOL] boolean reverse = false; [EOL] NodePointer startWith = startWithPropertyPointer; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should match", name, iterator.getName()); [EOL] assertFalse("Iterator should not be in reverse", iterator.isReverse()); [EOL] assertFalse("Iterator should not include start", iterator.isIncludeStart()); [EOL] assertEquals("Start index should be 0", 0, iterator.getStartIndex()); [EOL] assertEquals("Start property index should be 1", 1, iterator.getStartPropertyIndex()); [EOL] }
public void testPropertyIteratorWithReverseAndValidStartWith() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] PropertyPointer startWithPropertyPointer = mock(PropertyPointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] when(startWithPropertyPointer.getImmediateParentPointer()).thenReturn(pointer); [EOL] when(startWithPropertyPointer.getPropertyIndex()).thenReturn(1); [EOL] when(startWithPropertyPointer.getIndex()).thenReturn(-1); [EOL] String name = "testProperty"; [EOL] boolean reverse = true; [EOL] NodePointer startWith = startWithPropertyPointer; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should match", name, iterator.getName()); [EOL] assertTrue("Iterator should be in reverse", iterator.isReverse()); [EOL] assertTrue("Iterator should include start", iterator.isIncludeStart()); [EOL] assertEquals("Start index should be -1", -1, iterator.getStartIndex()); [EOL] assertEquals("Start property index should be 1", 1, iterator.getStartPropertyIndex()); [EOL] }
public void testPropertyIteratorWithInvalidStartWith() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] NodePointer invalidStartWith = mock(NodePointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] when(invalidStartWith.getImmediateParentPointer()).thenReturn(null); [EOL] String name = "testProperty"; [EOL] boolean reverse = false; [EOL] NodePointer startWith = invalidStartWith; [EOL] try { [EOL] new PropertyIterator(pointer, name, reverse, startWith); [EOL] fail("JXPathException expected due to invalid startWith parameter"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetNodePointer_PositionZero_NameNotNull_TargetNotReady_Empty() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] instance.name = "someName"; [EOL] instance.targetReady = false; [EOL] instance.empty = true; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNotNull_TargetReady_NotEmpty() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] instance.name = "someName"; [EOL] instance.targetReady = true; [EOL] instance.empty = false; [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] instance.propertyNodePointer = mockNodePointer; [EOL] when(mockNodePointer.getValuePointer()).thenReturn(mock(NodePointer.class)); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNull_SetPositionFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] instance.name = null; [EOL] doReturn(false).when(instance).setPosition(1); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionNotZero() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 1; [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] instance.propertyNodePointer = mockNodePointer; [EOL] when(mockNodePointer.getValuePointer()).thenReturn(mock(NodePointer.class)); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_ThrowsException() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 1; [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] instance.propertyNodePointer = mockNodePointer; [EOL] when(mockNodePointer.getValuePointer()).thenThrow(new RuntimeException()); [EOL] NullPropertyPointer mockNullPropertyPointer = mock(NullPropertyPointer.class); [EOL] whenNew(NullPropertyPointer.class).withAnyArguments().thenReturn(mockNullPropertyPointer); [EOL] when(mockNullPropertyPointer.getValuePointer()).thenReturn(mock(NodePointer.class)); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testSetPositionWithNameNotNull() { [EOL] boolean result = instance.setPosition(1); [EOL] assert result == expectedValue; // Replace 'expectedValue' with the actual expected result [EOL] }
public void testSetPositionWithNameNull() { [EOL] boolean result = instance.setPosition(1); [EOL] assert result == expectedValue; // Replace 'expectedValue' with the actual expected result [EOL] }
public void testSetPositionIndividualProperty_PositionLessThanOne() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] boolean result = setPositionIndividualProperty(0); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_TargetNotReady() { [EOL] setTargetReady(false); [EOL] setEmpty(false); [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionIndividualProperty_Empty() { [EOL] setTargetReady(true); [EOL] setEmpty(true); [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_ReverseIndexOutOfBounds() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(true); [EOL] setIncludeStart(false); [EOL] setStartIndex(5); // Assuming length is less than 5 for this test [EOL] boolean result = setPositionIndividualProperty(10); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_NonReverseIndexOutOfBounds() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(false); [EOL] setIncludeStart(true); [EOL] setStartIndex(0); // Assuming length is 5 for this test [EOL] boolean result = setPositionIndividualProperty(6); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_ValidNonReverse() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(false); [EOL] setIncludeStart(true); [EOL] setStartIndex(0); // Assuming length is greater than 2 for this test [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionIndividualProperty_ValidReverse() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(true); [EOL] setIncludeStart(false); [EOL] setStartIndex(-1); // Assuming length is greater than 2 for this test [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_PositionLessThanOne() { [EOL] boolean result = setPositionAllProperties(0); [EOL] assertFalse(result); [EOL] }
public void testSetPositionAllProperties_ForwardTraversal_WithinBounds() { [EOL] boolean result = setPositionAllProperties(2); // Assuming 2 is within bounds [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_ForwardTraversal_OutOfBounds() { [EOL] boolean result = setPositionAllProperties(10); // Assuming 10 is out of bounds [EOL] assertFalse(result); [EOL] }
public void testSetPositionAllProperties_ReverseTraversal_WithinBounds() { [EOL] boolean result = setPositionAllProperties(2); // Assuming 2 is within bounds and reverse is true [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_ReverseTraversal_OutOfBounds() { [EOL] boolean result = setPositionAllProperties(10); // Assuming 10 is out of bounds and reverse is true [EOL] assertFalse(result); [EOL] }
protected void prepareForIndividualProperty(String name) { [EOL] targetReady = true; [EOL] empty = true; [EOL] String[] names = propertyNodePointer.getPropertyNames(); [EOL] if (!reverse) { [EOL] if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL] startPropertyIndex = 0; [EOL] } [EOL] if (startIndex == NodePointer.WHOLE_COLLECTION) { [EOL] startIndex = 0; [EOL] } [EOL] for (int i = startPropertyIndex; i < names.length; i++) { [EOL] if (names[i].equals(name)) { [EOL] propertyNodePointer.setPropertyIndex(i); [EOL] if (i != startPropertyIndex) { [EOL] startIndex = 0; [EOL] includeStart = true; [EOL] } [EOL] empty = false; [EOL] break; [EOL] } [EOL] } [EOL] } else { [EOL] if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL] startPropertyIndex = names.length - 1; [EOL] } [EOL] if (startIndex == NodePointer.WHOLE_COLLECTION) { [EOL] startIndex = -1; [EOL] } [EOL] for (int i = startPropertyIndex; i >= 0; i--) { [EOL] if (names[i].equals(name)) { [EOL] propertyNodePointer.setPropertyIndex(i); [EOL] if (i != startPropertyIndex) { [EOL] startIndex = -1; [EOL] includeStart = true; [EOL] } [EOL] empty = false; [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] }
public void testGetLengthWithValidPropertyNodePointer() { [EOL] PropertyNodePointer mockPropertyNodePointer = Mockito.mock(PropertyNodePointer.class); [EOL] Mockito.when(mockPropertyNodePointer.getLength()).thenReturn(5); [EOL] YourClass instance = new YourClass(mockPropertyNodePointer); [EOL] int result = instance.getLength(); [EOL] assertEquals(5, result); [EOL] }
public void testGetLengthWithException() { [EOL] PropertyNodePointer mockPropertyNodePointer = Mockito.mock(PropertyNodePointer.class); [EOL] Mockito.when(mockPropertyNodePointer.getLength()).thenThrow(new RuntimeException()); [EOL] YourClass instance = new YourClass(mockPropertyNodePointer); [EOL] int result = instance.getLength(); [EOL] assertEquals(0, result); [EOL] }
public void testIsContextDependent() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isContextDependent(); [EOL] assertFalse(result); [EOL] }
public Object computeValueTest_NullContext() { [EOL] try { [EOL] computeValue(null); [EOL] fail("Expected an exception due to null context"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public Object computeValueTest_ValidContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] VariableContext variableContext = mock(VariableContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getVariableContext(anyString())).thenReturn(variableContext); [EOL] Object result = computeValue(context); [EOL] assertNotNull("Expected non-null result", result); [EOL] verify(context).getRootContext(); [EOL] verify(rootContext).getVariableContext(varName); [EOL] }
public void testPrecedingOrFollowingContextWithNonNullParentAndNodeTestAndReverseTrue() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] boolean reverse = true; [EOL] PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(parentContext, nodeTest, reverse); [EOL] assertNotNull(context); [EOL] assertSame(parentContext, context.getParentContext()); [EOL] assertSame(nodeTest, context.getNodeTest()); [EOL] assertTrue(context.isReverse()); [EOL] }
public void testPrecedingOrFollowingContextWithNonNullParentAndNodeTestAndReverseFalse() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] boolean reverse = false; [EOL] PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(parentContext, nodeTest, reverse); [EOL] assertNotNull(context); [EOL] assertSame(parentContext, context.getParentContext()); [EOL] assertSame(nodeTest, context.getNodeTest()); [EOL] assertFalse(context.isReverse()); [EOL] }
public void testGetDocumentOrderWhenReverseIsTrue() { [EOL] instance.setReverse(true); [EOL] int result = instance.getDocumentOrder(); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testGetDocumentOrderWhenReverseIsFalse() { [EOL] instance.setReverse(false); [EOL] int result = instance.getDocumentOrder(); [EOL] assertEquals(1, result); [EOL] }
public void testReset() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.reset(); [EOL] }
public boolean nextNode() { [EOL] if (!setStarted) { [EOL] setStarted = true; [EOL] currentRootLocation = parentContext.getCurrentNodePointer(); [EOL] NodePointer parent = currentRootLocation.getParent(); [EOL] if (parent != null) { [EOL] stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL] } [EOL] } [EOL] while (true) { [EOL] if (stack.isEmpty()) { [EOL] currentRootLocation = currentRootLocation.getParent(); [EOL] if (currentRootLocation == null || currentRootLocation.isRoot()) { [EOL] break; [EOL] } [EOL] NodePointer parent = currentRootLocation.getParent(); [EOL] if (parent != null) { [EOL] stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL] } [EOL] } [EOL] while (!stack.isEmpty()) { [EOL] if (!reverse) { [EOL] NodeIterator it = (NodeIterator) stack.peek(); [EOL] if (it.setPosition(it.getPosition() + 1)) { [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (!currentNodePointer.isLeaf()) { [EOL] stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL] } [EOL] if (currentNodePointer.testNode(nodeTest)) { [EOL] super.setPosition(getCurrentPosition() + 1); [EOL] return true; [EOL] } [EOL] } else { [EOL] stack.pop(); [EOL] } [EOL] } else { [EOL] NodeIterator it = (NodeIterator) stack.peek(); [EOL] if (it.setPosition(it.getPosition() + 1)) { [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (!currentNodePointer.isLeaf()) { [EOL] stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL] } else if (currentNodePointer.testNode(nodeTest)) { [EOL] super.setPosition(getCurrentPosition() + 1); [EOL] return true; [EOL] } [EOL] } else { [EOL] stack.pop(); [EOL] if (!stack.isEmpty()) { [EOL] it = (PropertyIterator) stack.peek(); [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (currentNodePointer.testNode(nodeTest)) { [EOL] super.setPosition(getCurrentPosition() + 1); [EOL] return true; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testIsAbsoluteTrue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] ((JXPathContextReferenceImpl) context).setAbsolute(true); [EOL] assertTrue(context.isAbsolute()); [EOL] }
public void testIsAbsoluteFalse() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] ((JXPathContextReferenceImpl) context).setAbsolute(false); [EOL] assertFalse(context.isAbsolute()); [EOL] }
public void testComputeContextDependentWhenAbsoluteIsFalse() { [EOL] MyXPathClass testInstance = new MyXPathClass(); [EOL] testInstance.absolute = false; [EOL] boolean result = testInstance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependentWhenAbsoluteIsTrue() { [EOL] MyXPathClass testInstance = new MyXPathClass(); [EOL] testInstance.absolute = true; [EOL] MySuperClass mockSuperClass = mock(MySuperClass.class); [EOL] when(mockSuperClass.computeContextDependent()).thenReturn(true); [EOL] testInstance.setSuperClass(mockSuperClass); [EOL] boolean result = testInstance.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testToStringWithNoSteps() { [EOL] YourClass instance = new YourClass(false); // false for non-absolute path [EOL] String result = instance.toString(); [EOL] assertEquals("", result); [EOL] } [EOL] public void testToStringWithSingleStep() { [EOL] YourClass instance = new YourClass(false); // false for non-absolute path [EOL] instance.addStep(new Step("step1")); // Assuming there is a method to add steps [EOL] String result = instance.toString(); [EOL] assertEquals("step1", result); [EOL] } [EOL] public void testToStringWithMultipleSteps() { [EOL] YourClass instance = new YourClass(false); // false for non-absolute path [EOL] instance.addStep(new Step("step1")); // Assuming there is a method to add steps [EOL] instance.addStep(new Step("step2")); [EOL] String result = instance.toString(); [EOL] assertEquals("step1/step2", result); [EOL] } [EOL] public void testToStringWithAbsolute() { [EOL] YourClass instance = new YourClass(true); // true for absolute path [EOL] instance.addStep(new Step("step1")); // Assuming there is a method to add steps [EOL] String result = instance.toString(); [EOL] assertEquals("/step1", result); [EOL] }
public void testToStringWithMultipleStepsAndAbsolute() { [EOL] YourClass instance = new YourClass(true); // true for absolute path [EOL] instance.addStep(new Step("step1")); // Assuming there is a method to add steps [EOL] instance.addStep(new Step("step2")); [EOL] String result = instance.toString(); [EOL] assertEquals("/step1/step2", result); [EOL] }
public void testComputeWithAbsoluteContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext rootContext = mock(EvalContext.class); [EOL] EvalContext absoluteRootContext = mock(EvalContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getAbsoluteRootContext()).thenReturn(absoluteRootContext); [EOL] when(absoluteRootContext.isAbsolute()).thenReturn(true); [EOL] Object expected = new Object(); [EOL] when(absoluteRootContext.evalSteps(any(EvalContext.class))).thenReturn(expected); [EOL] Path path = new Path(); [EOL] Object result = path.compute(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeWithRelativeContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.isAbsolute()).thenReturn(false); [EOL] Object expected = new Object(); [EOL] when(context.evalSteps(any(EvalContext.class))).thenReturn(expected); [EOL] Path path = new Path(); [EOL] Object result = path.compute(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueWithAbsoluteContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext rootContext = mock(EvalContext.class); [EOL] EvalContext absoluteRootContext = mock(EvalContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getAbsoluteRootContext()).thenReturn(absoluteRootContext); [EOL] JXPathContextReferenceImpl jxPath = new JXPathContextReferenceImpl(); [EOL] jxPath.setAbsolute(true); [EOL] Object result = jxPath.computeValue(context); [EOL] verify(context).getRootContext(); [EOL] verify(rootContext).getAbsoluteRootContext(); [EOL] assertNotNull(result); [EOL] }
public void testComputeValueWithRelativeContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JXPathContextReferenceImpl jxPath = new JXPathContextReferenceImpl(); [EOL] jxPath.setAbsolute(false); [EOL] Object result = jxPath.computeValue(context); [EOL] assertNotNull(result); [EOL] }
public void testMinusWithValidExpressions() { [EOL] Expression left = new DefaultExpression(); [EOL] Expression right = new DefaultExpression(); [EOL] Object result = minus(left, right); [EOL] assertTrue(result instanceof CoreOperationSubtract); [EOL] assertEquals(left, ((CoreOperationSubtract) result).getLeft()); [EOL] assertEquals(right, ((CoreOperationSubtract) result).getRight()); [EOL] }
public void testLessThanWithValidExpressions() { [EOL] Expression leftExpr = mock(Expression.class); [EOL] Expression rightExpr = mock(Expression.class); [EOL] Object result = lessThan(leftExpr, rightExpr); [EOL] assertTrue(result instanceof CoreOperationLessThan); [EOL] CoreOperationLessThan operation = (CoreOperationLessThan) result; [EOL] assertEquals(leftExpr, operation.getLeft()); [EOL] assertEquals(rightExpr, operation.getRight()); [EOL] }
public void testLessThanOrEqualWithBothExpressions() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] Object result = lessThanOrEqual(left, right); [EOL] assertTrue(result instanceof CoreOperationLessThanOrEqual); [EOL] CoreOperationLessThanOrEqual operation = (CoreOperationLessThanOrEqual) result; [EOL] assertEquals(left, operation.getLeft()); [EOL] assertEquals(right, operation.getRight()); [EOL] }
public void testGreaterThanWithValidExpressions() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] Object result = greaterThan(left, right); [EOL] assertTrue(result instanceof CoreOperationGreaterThan); [EOL] }
public void testEqualWithNameAttributeTest() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] when(isNameAttributeTest(left)).thenReturn(true); [EOL] Object result = equal(left, right); [EOL] assertTrue(result instanceof NameAttributeTest); [EOL] assertEquals(left, ((NameAttributeTest) result).getLeftExpression()); [EOL] assertEquals(right, ((NameAttributeTest) result).getRightExpression()); [EOL] }
public void testEqualWithCoreOperationEqual() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] when(isNameAttributeTest(left)).thenReturn(false); [EOL] Object result = equal(left, right); [EOL] assertTrue(result instanceof CoreOperationEqual); [EOL] assertEquals(left, ((CoreOperationEqual) result).getLeftExpression()); [EOL] assertEquals(right, ((CoreOperationEqual) result).getRightExpression()); [EOL] }
public void testAndWithNullArguments() { [EOL] try { [EOL] Object result = and(null); [EOL] assertNull("Result should be null when arguments are null", result); [EOL] } catch (Exception e) { [EOL] fail("Should not throw exception when arguments are null"); [EOL] } [EOL] }
public void testAndWithEmptyArguments() { [EOL] Object[] arguments = new Object[0]; [EOL] Object result = and(arguments); [EOL] assertNotNull("Result should not be null when arguments are empty", result); [EOL] assertTrue("Result should be an instance of CoreOperationAnd", result instanceof CoreOperationAnd); [EOL] }
public void testAndWithNonNullArguments() { [EOL] Object[] arguments = new Object[] { "arg1", "arg2" }; [EOL] Object result = and(arguments); [EOL] assertNotNull("Result should not be null when arguments are not null", result); [EOL] assertTrue("Result should be an instance of CoreOperationAnd", result instanceof CoreOperationAnd); [EOL] Expression[] expressions = toExpressionArray(arguments); [EOL] assertEquals("The result should contain the same number of expressions as the input arguments", [EOL] expressions.length, ((CoreOperationAnd) result).getArguments().length); [EOL] }
public void testOrWithNullArguments() { [EOL] try { [EOL] Object result = or(null); [EOL] assertNull("Result should be null when arguments are null", result); [EOL] } catch (Exception e) { [EOL] fail("Should not throw exception when arguments are null"); [EOL] } [EOL] } [EOL] public void testOrWithEmptyArguments() { [EOL] Object[] arguments = new Object[0]; [EOL] Object result = or(arguments); [EOL] assertNotNull("Result should not be null when arguments are empty", result); [EOL] assertEquals("Result should be an instance of CoreOperationOr with empty arguments", [EOL] "CoreOperationOr[]", result.toString()); [EOL] } [EOL] public void testOrWithSingleArgument() { [EOL] Object[] arguments = new Object[]{ "test" }; [EOL] Object result = or(arguments); [EOL] assertNotNull("Result should not be null when arguments have one element", result); [EOL] assertEquals("Result should be an instance of CoreOperationOr with one argument", [EOL] "CoreOperationOr[test]", result.toString()); [EOL] } [EOL] public void testOrWithMultipleArguments() { [EOL] Object[] arguments = new Object[]{ "test1", "test2", "test3" }; [EOL] Object result = or(arguments); [EOL] assertNotNull("Result should not be null when arguments have multiple elements", result); [EOL] assertEquals("Result should be an instance of CoreOperationOr with multiple arguments", [EOL] "CoreOperationOr[test1, test2, test3]", result.toString()); [EOL] }
public void testIsNameAttributeTest_NotInstanceOfLocationPath() { [EOL] Expression arg = mock(Expression.class); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_StepsNotEqualOne() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] when(arg.getSteps()).thenReturn(new Step[2]); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_StepAxisNotAttribute() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NodeTestNotInstanceOfNodeNameTest() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeTest); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NodeNameNotEqualsQNAME_NAME() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class)); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_ValidCase() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(QNAME_NAME); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertTrue(result); [EOL] }
public Object compute(EvalContext context) { [EOL] return expressionPath(context, false); [EOL] }
protected Object expressionPath(EvalContext evalContext, boolean firstMatch) { [EOL] Object value = expression.compute(evalContext); [EOL] EvalContext context; [EOL] if (value instanceof InitialContext) { [EOL] context = (InitialContext) value; [EOL] } else if (value instanceof EvalContext) { [EOL] context = new UnionContext(evalContext, new EvalContext[] { (EvalContext) value }); [EOL] } else { [EOL] context = evalContext.getRootContext().getConstantContext(value); [EOL] } [EOL] if (firstMatch && isSimpleExpressionPath() && !(context instanceof NodeSetContext)) { [EOL] EvalContext ctx = context; [EOL] NodePointer ptr = (NodePointer) ctx.getSingleNodePointer(); [EOL] if (ptr != null && (ptr.getIndex() == NodePointer.WHOLE_COLLECTION || predicates == null || predicates.length == 0)) { [EOL] return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps()); [EOL] } [EOL] } [EOL] if (predicates != null) { [EOL] for (int j = 0; j < predicates.length; j++) { [EOL] if (j != 0) { [EOL] context = new UnionContext(context, new EvalContext[] { context }); [EOL] } [EOL] context = new PredicateContext(context, predicates[j]); [EOL] } [EOL] } [EOL] if (firstMatch) { [EOL] return getSingleNodePointerForSteps(context); [EOL] } else { [EOL] return evalSteps(context); [EOL] } [EOL] }
public void testDynaBeanPropertyPointerWithNullParentAndNullDynaBean() { [EOL] DynaBeanPropertyPointer pointer = new DynaBeanPropertyPointer(null, null); [EOL] assertNull(pointer.getParent()); [EOL] assertNull(pointer.getDynaBean()); [EOL] }
public void testDynaBeanPropertyPointerWithNonNullParentAndNullDynaBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] DynaBeanPropertyPointer pointer = new DynaBeanPropertyPointer(parent, null); [EOL] assertEquals(parent, pointer.getParent()); [EOL] assertNull(pointer.getDynaBean()); [EOL] }
public void testDynaBeanPropertyPointerWithNullParentAndNonNullDynaBean() { [EOL] DynaBean dynaBean = mock(DynaBean.class); [EOL] DynaBeanPropertyPointer pointer = new DynaBeanPropertyPointer(null, dynaBean); [EOL] assertNull(pointer.getParent()); [EOL] assertEquals(dynaBean, pointer.getDynaBean()); [EOL] }
public void testDynaBeanPropertyPointerWithNonNullParentAndNonNullDynaBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] DynaBean dynaBean = mock(DynaBean.class); [EOL] DynaBeanPropertyPointer pointer = new DynaBeanPropertyPointer(parent, dynaBean); [EOL] assertEquals(parent, pointer.getParent()); [EOL] assertEquals(dynaBean, pointer.getDynaBean()); [EOL] }
public Object testGetBaseValueNonNullDynaBean() { [EOL] DynaBean mockDynaBean = Mockito.mock(DynaBean.class); [EOL] String propertyName = "testProperty"; [EOL] Object expectedValue = new Object(); [EOL] Mockito.when(mockDynaBean.get(propertyName)).thenReturn(expectedValue); [EOL] MyClass instance = new MyClass(mockDynaBean, propertyName); [EOL] Object result = instance.getBaseValue(); [EOL] assertEquals(expectedValue, result); [EOL] }
public Object testGetBaseValueWithNullDynaBean() { [EOL] DynaBean mockDynaBean = Mockito.mock(DynaBean.class); [EOL] String propertyName = "testProperty"; [EOL] Mockito.when(mockDynaBean.get(propertyName)).thenReturn(null); [EOL] MyClass instance = new MyClass(mockDynaBean, propertyName); [EOL] Object result = instance.getBaseValue(); [EOL] assertNull(result); [EOL] }
public void testSetPropertyName() { [EOL] YourObject obj = new YourObject(); [EOL] String expectedPropertyName = "testProperty"; [EOL] obj.setPropertyName(expectedPropertyName); [EOL] assertEquals(expectedPropertyName, obj.getPropertyName()); [EOL] assertEquals(YourObject.UNSPECIFIED_PROPERTY, obj.getPropertyIndex()); [EOL] }
public void testGetImmediateNodeWithWildcardName() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("*"); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithWholeCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("validPropertyName"); [EOL] jxPath.setIndex(JxPath.WHOLE_COLLECTION); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyValidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(validIndex); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAtIndex, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyInvalidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(invalidIndex); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyIllegalArgumentException() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(indexThatCausesIllegalArgumentException); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAfterException, result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndNonZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("nonIndexedPropertyName"); [EOL] jxPath.setIndex(nonZeroIndex); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("nonIndexedPropertyName"); [EOL] jxPath.setIndex(0); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValue, result); [EOL] }
protected boolean isActualProperty() { [EOL] DynaClass dynaClass = dynaBean.getDynaClass(); [EOL] return dynaClass.getDynaProperty(getPropertyName()) != null; [EOL] }
public void testIsIndexedPropertyTrue() { [EOL] DynaBean dynaBean = mock(DynaBean.class); [EOL] DynaClass dynaClass = mock(DynaClass.class); [EOL] DynaProperty dynaProperty = mock(DynaProperty.class); [EOL] when(dynaBean.getDynaClass()).thenReturn(dynaClass); [EOL] when(dynaClass.getDynaProperty(anyString())).thenReturn(dynaProperty); [EOL] when(dynaProperty.isIndexed()).thenReturn(true); [EOL] assertTrue(isIndexedProperty(dynaBean, "propertyName")); [EOL] }
public void testIsIndexedPropertyFalse() { [EOL] DynaBean dynaBean = mock(DynaBean.class); [EOL] DynaClass dynaClass = mock(DynaClass.class); [EOL] DynaProperty dynaProperty = mock(DynaProperty.class); [EOL] when(dynaBean.getDynaClass()).thenReturn(dynaClass); [EOL] when(dynaClass.getDynaProperty(anyString())).thenReturn(dynaProperty); [EOL] when(dynaProperty.isIndexed()).thenReturn(false); [EOL] assertFalse(isIndexedProperty(dynaBean, "propertyName")); [EOL] }
public void testSetValueWithValidIndex() { [EOL] Object value = new Object(); [EOL] yourObject.setValue(index, value); [EOL] }
public void testSetValueWithInvalidIndex() { [EOL] Object value = new Object(); [EOL] try { [EOL] yourObject.setValue(-1, value); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_WholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.WHOLE_COLLECTION; [EOL] DynaBean mockDynaBean = mock(DynaBean.class); [EOL] instance.dynaBean = mockDynaBean; [EOL] String propertyName = "testProperty"; [EOL] instance.setPropertyName(propertyName); [EOL] instance.remove(); [EOL] verify(mockDynaBean).set(propertyName, null); [EOL] }
public void testRemove_IndexedProperty() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = 1; // Assuming 1 is a valid index for an indexed property [EOL] instance.setIndexedProperty(true); [EOL] DynaBean mockDynaBean = mock(DynaBean.class); [EOL] instance.dynaBean = mockDynaBean; [EOL] String propertyName = "testProperty"; [EOL] instance.setPropertyName(propertyName); [EOL] instance.remove(); [EOL] verify(mockDynaBean).set(propertyName, instance.index, null); [EOL] }
public void testRemove_Collection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = 1; // Assuming 1 is a valid index for a collection [EOL] instance.setCollection(true); [EOL] DynaBean mockDynaBean = mock(DynaBean.class); [EOL] instance.dynaBean = mockDynaBean; [EOL] String propertyName = "testProperty"; [EOL] instance.setPropertyName(propertyName); [EOL] Object baseValue = new ArrayList<>(); [EOL] instance.setBaseValue(baseValue); [EOL] instance.remove(); [EOL] verify(mockDynaBean).set(eq(propertyName), any()); [EOL] }
public void testRemove_IndexZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = 0; [EOL] instance.setIndexedProperty(false); [EOL] instance.setCollection(false); [EOL] DynaBean mockDynaBean = mock(DynaBean.class); [EOL] instance.dynaBean = mockDynaBean; [EOL] String propertyName = "testProperty"; [EOL] instance.setPropertyName(propertyName); [EOL] instance.remove(); [EOL] verify(mockDynaBean).set(propertyName, null); [EOL] }
public void testSetValueWithWholeCollection() { [EOL] int index = WHOLE_COLLECTION; [EOL] Object value = new Object(); [EOL] setValue(index, value); [EOL] verify(dynaBean).set(getPropertyName(), convert(value, false)); [EOL] }
public void testSetValueWithIndexedProperty() { [EOL] int index = 1; // Assuming 1 is a valid index for an indexed property [EOL] Object value = new Object(); [EOL] setValue(index, value); [EOL] verify(dynaBean).set(getPropertyName(), index, convert(value, true)); [EOL] }
public void testSetValueWithNonIndexedProperty() { [EOL] int index = 1; // Assuming 1 is not a valid index for WHOLE_COLLECTION or an indexed property [EOL] Object value = new Object(); [EOL] setValue(index, value); [EOL] Object baseValue = dynaBean.get(getPropertyName()); [EOL] verify(ValueUtils).setValue(baseValue, index, value); [EOL] }
public void testConvertWithElementAndArrayType() { [EOL] DynaBean dynaBean = createMockDynaBeanWithArrayType(); [EOL] Object value = new int[]{1, 2, 3}; [EOL] boolean element = true; [EOL] Object result = convert(value, element); [EOL] assertTrue(result instanceof Integer); [EOL] } [EOL] public void testConvertWithElementAndNonArrayType() { [EOL] DynaBean dynaBean = createMockDynaBeanWithNonArrayType(); [EOL] Object value = "test"; [EOL] boolean element = true; [EOL] Object result = convert(value, element); [EOL] assertSame(value, result); [EOL] } [EOL] public void testConvertWithoutElement() { [EOL] DynaBean dynaBean = createMockDynaBeanWithAnyType(); [EOL] Object value = "test"; [EOL] boolean element = false; [EOL] Object result = convert(value, element); [EOL] assertNotNull(result); [EOL] } [EOL] public void testConvertWithException() { [EOL] DynaBean dynaBean = createMockDynaBeanWithException(); [EOL] Object value = new Object(); [EOL] boolean element = false; [EOL] try { [EOL] convert(value, element); [EOL] fail("Expected JXPathTypeConversionException was not thrown"); [EOL] } catch (JXPathTypeConversionException ex) { [EOL] assertNotNull(ex.getMessage()); [EOL] } [EOL] }
public void testComputeValueWithPositiveNumbers() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(2.0); [EOL] when(args[1].computeValue(context)).thenReturn(3.0); [EOL] Object result = computeValue(context); [EOL] assertEquals("The result should be the product of the two numbers.", 6.0, result); [EOL] }
public void testComputeValueWithNegativeNumbers() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(-2.0); [EOL] when(args[1].computeValue(context)).thenReturn(-3.0); [EOL] Object result = computeValue(context); [EOL] assertEquals("The result should be the product of the two numbers.", 6.0, result); [EOL] }
public void testComputeValueWithZero() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(0.0); [EOL] when(args[1].computeValue(context)).thenReturn(5.0); [EOL] Object result = computeValue(context); [EOL] assertEquals("The result should be zero.", 0.0, result); [EOL] }
public void testComputeValueWithPositiveNumbers() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(3.0); [EOL] Object result = computeValue(context); [EOL] assertEquals(new Double(10 % 3), result); [EOL] }
public void testComputeValueWithNegativeNumbers() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(-10.0); [EOL] when(args[1].computeValue(context)).thenReturn(-3.0); [EOL] Object result = computeValue(context); [EOL] assertEquals(new Double(-10 % -3), result); [EOL] }
public void testComputeValueWithZeroDivisor() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(0.0); [EOL] Object result = computeValue(context); [EOL] assertEquals(new Double(10 % 0), result); [EOL] }
public void testIsContextDependent_NullPredicates() { [EOL] setupWithNullPredicates(); [EOL] boolean result = isContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testIsContextDependent_EmptyPredicates() { [EOL] setupWithEmptyPredicates(); [EOL] boolean result = isContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testIsContextDependent_NonContextDependentPredicates() { [EOL] setupWithNonContextDependentPredicates(); [EOL] boolean result = isContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testIsContextDependent_WithOneContextDependentPredicate() { [EOL] setupWithOneContextDependentPredicate(); [EOL] boolean result = isContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testRegisterNamespaceWithValidArguments() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.registerNamespace("prefix", "namespaceURI"); [EOL] assertEquals("namespaceURI", context.getNamespaceURI("prefix")); [EOL] }
public void testRegisterNamespaceWithNullPrefix() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] try { [EOL] context.registerNamespace(null, "namespaceURI"); [EOL] } catch (Exception e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testRegisterNamespaceWithNullNamespaceURI() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.registerNamespace("prefix", null); [EOL] assertNull(context.getNamespaceURI("prefix")); [EOL] }
public void testIsSealed() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setSealed(true); // Assuming there is a method to set the sealed variable [EOL] boolean result = instance.isSealed(); [EOL] assertTrue(result); [EOL] instance.setSealed(false); // Assuming there is a method to set the sealed variable [EOL] result = instance.isSealed(); [EOL] assertFalse(result); [EOL] }
public void testClone_Success() throws Exception { [EOL] MyClass instance = new MyClass(); [EOL] Object clonedInstance = instance.clone(); [EOL] assertNotNull(clonedInstance); [EOL] assertNotSame(instance, clonedInstance); [EOL] }
public void testClone_Exception() throws Exception { [EOL] MyClass instance = new MyClass() { [EOL] @Override [EOL] public Object clone() throws CloneNotSupportedException { [EOL] throw new CloneNotSupportedException(); [EOL] } [EOL] }; [EOL] Object clonedInstance = instance.clone(); [EOL] assertNull(clonedInstance); [EOL] }
public void testSetFactoryWithNonNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] AbstractFactory nonNullFactory = new AbstractFactory() { [EOL] public boolean createObject(JXPathContext context, Pointer pointer, [EOL] Object parent, String name, int index) { [EOL] return false; [EOL] } [EOL] }; [EOL] context.setFactory(nonNullFactory); [EOL] assertEquals("Factory should be set to nonNullFactory", nonNullFactory, context.getFactory()); [EOL] }
public void testSetFactoryWithNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFactory(null); [EOL] assertNull("Factory should be set to null", context.getFactory()); [EOL] }
public void testChildIteratorWithNullTest() { [EOL] NodeIterator result = childIterator(null, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestAndDefaultNamespace() { [EOL] NodeTest test = new NodeNameTest(new QName("", "testNode")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestAndNonDefaultNamespace() { [EOL] NodeTest test = new NodeNameTest(new QName("nonDefault", "testNode")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestWildcard() { [EOL] NodeTest test = new NodeNameTest(new QName("", "*")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeTypeTestNode() { [EOL] NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithOtherNodeTypeTest() { [EOL] NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_COMMENT); // Assuming NODE_TYPE_COMMENT is a different node type [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNull(result); [EOL] }
protected PropertyOwnerPointer(NodePointer parent) { [EOL] super(parent); [EOL] }
public void testGetImmediateNode_UninitializedWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = WHOLE_COLLECTION; [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNode_UninitializedNotWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = UNINITIALIZED; [EOL] instance.index = 1; // Any index that is not WHOLE_COLLECTION [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] }
public void testGetImmediateNode_AlreadyInitialized() { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = new Object(); // Already initialized to some object [EOL] Object result = instance.getImmediateNode(); [EOL] assertSame(instance.value, result); [EOL] }
public void testCompareChildNodePointers_DifferentNames() { [EOL] NodePointer pointer1 = mock(NodePointer.class); [EOL] NodePointer pointer2 = mock(NodePointer.class); [EOL] when(pointer1.getName()).thenReturn(new QName("name1")); [EOL] when(pointer2.getName()).thenReturn(new QName("name2")); [EOL] when(pointer1.getIndex()).thenReturn(0); [EOL] when(pointer2.getIndex()).thenReturn(0); [EOL] int result = compareChildNodePointers(pointer1, pointer2); [EOL] assertTrue(result != 0); [EOL] }
public void testCompareChildNodePointers_SameNamesDifferentIndices() { [EOL] NodePointer pointer1 = mock(NodePointer.class); [EOL] NodePointer pointer2 = mock(NodePointer.class); [EOL] when(pointer1.getName()).thenReturn(new QName("name")); [EOL] when(pointer2.getName()).thenReturn(new QName("name")); [EOL] when(pointer1.getIndex()).thenReturn(1); [EOL] when(pointer2.getIndex()).thenReturn(2); [EOL] int result = compareChildNodePointers(pointer1, pointer2); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareChildNodePointers_SameNamesSameIndices() { [EOL] NodePointer pointer1 = mock(NodePointer.class); [EOL] NodePointer pointer2 = mock(NodePointer.class); [EOL] when(pointer1.getName()).thenReturn(new QName("name")); [EOL] when(pointer2.getName()).thenReturn(new QName("name")); [EOL] when(pointer1.getIndex()).thenReturn(1); [EOL] when(pointer2.getIndex()).thenReturn(1); [EOL] int result = compareChildNodePointers(pointer1, pointer2); [EOL] assertEquals(0, result); [EOL] }
public void testCollectNamespacesWithNonNullNamespace() { [EOL] Element element = mock(Element.class); [EOL] Namespace ns = mock(Namespace.class); [EOL] when(element.getNamespace()).thenReturn(ns); [EOL] when(ns.getPrefix()).thenReturn("prefix"); [EOL] when(element.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(element.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.contains(ns)); [EOL] assertTrue(prefixes.contains("prefix")); [EOL] }
public void testCollectNamespacesWithNullNamespace() { [EOL] Element element = mock(Element.class); [EOL] when(element.getNamespace()).thenReturn(null); [EOL] when(element.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(element.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.isEmpty()); [EOL] assertTrue(prefixes.isEmpty()); [EOL] }
public void testCollectNamespacesWithAdditionalNamespaces() { [EOL] Element element = mock(Element.class); [EOL] Namespace ns1 = mock(Namespace.class); [EOL] Namespace ns2 = mock(Namespace.class); [EOL] when(element.getNamespace()).thenReturn(null); [EOL] when(ns1.getPrefix()).thenReturn("prefix1"); [EOL] when(ns2.getPrefix()).thenReturn("prefix2"); [EOL] List<Namespace> additionalNamespaces = Arrays.asList(ns1, ns2); [EOL] when(element.getAdditionalNamespaces()).thenReturn(additionalNamespaces); [EOL] when(element.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.containsAll(additionalNamespaces)); [EOL] assertTrue(prefixes.contains("prefix1")); [EOL] assertTrue(prefixes.contains("prefix2")); [EOL] }
public void testCollectNamespacesWithParentElement() { [EOL] Element element = mock(Element.class); [EOL] Element parentElement = mock(Element.class); [EOL] Namespace ns = mock(Namespace.class); [EOL] when(element.getNamespace()).thenReturn(ns); [EOL] when(ns.getPrefix()).thenReturn("prefix"); [EOL] when(element.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(element.getParent()).thenReturn(parentElement); [EOL] when(parentElement.getNamespace()).thenReturn(ns); [EOL] when(parentElement.getAdditionalNamespaces()).thenReturn(Collections.emptyList()); [EOL] when(parentElement.getParent()).thenReturn(null); [EOL] collectNamespaces(element); [EOL] assertTrue(namespaces.contains(ns)); [EOL] assertTrue(prefixes.contains("prefix")); [EOL] verify(parentElement, times(1)).getNamespace(); [EOL] }
public void testDescendantContextWithIncludeSelfTrue() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] DescendantContext context = new DescendantContext(parentContext, true, nodeTest); [EOL] assertTrue(context.includeSelf); [EOL] assertEquals(nodeTest, context.nodeTest); [EOL] }
public void testDescendantContextWithIncludeSelfFalse() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] DescendantContext context = new DescendantContext(parentContext, false, nodeTest); [EOL] assertFalse(context.includeSelf); [EOL] assertEquals(nodeTest, context.nodeTest); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionFails() { [EOL] setPosition(0); [EOL] mockSetPosition(1, false); // Mocking setPosition to return false [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds() { [EOL] setPosition(0); [EOL] mockSetPosition(1, true); // Mocking setPosition to return true [EOL] NodePointer expectedNodePointer = new NodePointer(); // Assuming a constructor or a way to create a NodePointer [EOL] setCurrentNodePointer(expectedNodePointer); // Assuming a way to set the currentNodePointer [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertSame(expectedNodePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionIsNotZero() { [EOL] setPosition(2); // Assuming a way to set the position [EOL] NodePointer expectedNodePointer = new NodePointer(); // Assuming a constructor or a way to create a NodePointer [EOL] setCurrentNodePointer(expectedNodePointer); // Assuming a way to set the currentNodePointer [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertSame(expectedNodePointer, result); [EOL] }
public void testReset() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.reset(); [EOL] assertFalse("Context should not be started after reset", context.isStarted()); [EOL] }
public boolean nextNode() { [EOL] if (!setStarted) { [EOL] setStarted = true; [EOL] stack = new Stack(); [EOL] currentNodePointer = parentContext.getCurrentNodePointer(); [EOL] if (currentNodePointer != null) { [EOL] if (!currentNodePointer.isLeaf()) { [EOL] stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL] } [EOL] if (includeSelf) { [EOL] if (currentNodePointer.testNode(nodeTest)) { [EOL] position++; [EOL] return true; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] while (!stack.isEmpty()) { [EOL] NodeIterator it = (NodeIterator) stack.peek(); [EOL] if (it.setPosition(it.getPosition() + 1)) { [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (!isRecursive()) { [EOL] if (!currentNodePointer.isLeaf()) { [EOL] stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL] } [EOL] if (currentNodePointer.testNode(nodeTest)) { [EOL] position++; [EOL] return true; [EOL] } [EOL] } [EOL] } else { [EOL] stack.pop(); [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testIsRecursiveWithEmptyStack() { [EOL] stack.clear(); [EOL] currentNodePointer = new NodePointerMock(null); [EOL] boolean result = isRecursive(); [EOL] assertFalse(result); [EOL] }
public void testIsRecursiveWithNonMatchingNodes() { [EOL] stack.clear(); [EOL] NodePointerMock pointer1 = new NodePointerMock(new Object()); [EOL] NodePointerMock pointer2 = new NodePointerMock(new Object()); [EOL] stack.add(new NodeIteratorMock(pointer1)); [EOL] stack.add(new NodeIteratorMock(pointer2)); [EOL] currentNodePointer = new NodePointerMock(new Object()); [EOL] boolean result = isRecursive(); [EOL] assertFalse(result); [EOL] }
public void testIsRecursiveWithMatchingNodes() { [EOL] Object sharedNode = new Object(); [EOL] stack.clear(); [EOL] NodePointerMock pointer1 = new NodePointerMock(new Object()); [EOL] NodePointerMock pointer2 = new NodePointerMock(sharedNode); [EOL] stack.add(new NodeIteratorMock(pointer1)); [EOL] stack.add(new NodeIteratorMock(pointer2)); [EOL] currentNodePointer = new NodePointerMock(sharedNode); [EOL] boolean result = isRecursive(); [EOL] assertTrue(result); [EOL] }
public void testNamespaceContextWithNullParentContextAndNullNodeTest() { [EOL] NamespaceContext namespaceContext = new NamespaceContext(null, null); [EOL] assertNull(namespaceContext.getParentContext()); [EOL] assertNull(namespaceContext.getNodeTest()); [EOL] }
public void testNamespaceContextWithNonNullParentContextAndNullNodeTest() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NamespaceContext namespaceContext = new NamespaceContext(parentContext, null); [EOL] assertEquals(parentContext, namespaceContext.getParentContext()); [EOL] assertNull(namespaceContext.getNodeTest()); [EOL] }
public void testNamespaceContextWithNullParentContextAndNonNullNodeTest() { [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] NamespaceContext namespaceContext = new NamespaceContext(null, nodeTest); [EOL] assertNull(namespaceContext.getParentContext()); [EOL] assertEquals(nodeTest, namespaceContext.getNodeTest()); [EOL] }
public void testNamespaceContextWithNonNullParentContextAndNonNullNodeTest() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] NamespaceContext namespaceContext = new NamespaceContext(parentContext, nodeTest); [EOL] assertEquals(parentContext, namespaceContext.getParentContext()); [EOL] assertEquals(nodeTest, namespaceContext.getNodeTest()); [EOL] }
public void testNextNode_NotStarted_NodeNameTestWithPrefix() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("prefix", "localName"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(nodeNameTest instanceof NodeNameTest).thenReturn(true); [EOL] boolean result = nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_NotStarted_NodeNameTestWithoutPrefix_Wildcard() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName(null, "localName"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(nodeNameTest.isWildcard()).thenReturn(true); [EOL] when(nodeNameTest instanceof NodeNameTest).thenReturn(true); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.namespaceIterator()).thenReturn(mock(Iterator.class)); [EOL] boolean result = nextNode(); [EOL] assertTrue(result); [EOL] }
public void testNextNode_NotStarted_NodeNameTestWithoutPrefix_NonWildcard() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName(null, "localName"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(nodeNameTest.isWildcard()).thenReturn(false); [EOL] when(nodeNameTest instanceof NodeNameTest).thenReturn(true); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.namespacePointer(testName.getName())).thenReturn(nodePointer); [EOL] boolean result = nextNode(); [EOL] assertTrue(result); [EOL] }
public void testNextNode_Started_IteratorNull() { [EOL] setStarted = true; [EOL] iterator = null; [EOL] boolean result = nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_Started_IteratorNotNull_PositionNotSet() { [EOL] setStarted = true; [EOL] Iterator iterator = mock(Iterator.class); [EOL] when(iterator.setPosition(anyInt())).thenReturn(false); [EOL] this.iterator = iterator; [EOL] boolean result = nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_Started_IteratorNotNull_PositionSet() { [EOL] setStarted = true; [EOL] Iterator iterator = mock(Iterator.class); [EOL] when(iterator.setPosition(anyInt())).thenReturn(true); [EOL] when(iterator.getNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] this.iterator = iterator; [EOL] boolean result = nextNode(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependentWithNullSteps() { [EOL] steps = null; // Set steps to null to test the null condition [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); // Assert that the result should be false when steps is null [EOL] }
public void testComputeContextDependentWithEmptySteps() { [EOL] steps = new Step[0]; // Set steps to an empty array to test the empty array condition [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); // Assert that the result should be false when steps is empty [EOL] }
public void testComputeContextDependentWithAllNonContextDependentSteps() { [EOL] steps = new Step[2]; [EOL] steps[0] = new Step(false); // Assuming Step constructor takes a boolean for context dependent [EOL] steps[1] = new Step(false); [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); // Assert that the result should be false when no steps are context dependent [EOL] }
public void testComputeContextDependentWithOneContextDependentStep() { [EOL] steps = new Step[2]; [EOL] steps[0] = new Step(false); [EOL] steps[1] = new Step(true); // One of the steps is context dependent [EOL] boolean result = computeContextDependent(); [EOL] assertTrue(result); // Assert that the result should be true when at least one step is context dependent [EOL] }
public void testIsSimplePath_basicKnownTrue_basicTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.basicKnown = true; [EOL] instance.basic = true; [EOL] boolean result = instance.isSimplePath(); [EOL] assertTrue(result); [EOL] }
public void testIsSimplePath_basicKnownFalse_basicTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.basicKnown = false; [EOL] Step[] steps = new Step[] { /* steps that are simple */ }; [EOL] instance.setSteps(steps); // Assuming there is a method to set steps [EOL] boolean result = instance.isSimplePath(); [EOL] assertTrue(result); [EOL] }
public void testIsSimplePath_basicKnownFalse_basicFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.basicKnown = false; [EOL] Step[] steps = new Step[] { /* steps where at least one is not simple */ }; [EOL] instance.setSteps(steps); // Assuming there is a method to set steps [EOL] boolean result = instance.isSimplePath(); [EOL] assertFalse(result); [EOL] }
protected boolean isSimpleStep(Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_SELF) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeTypeTest)) { [EOL] return false; [EOL] } [EOL] int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL] if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeNameTest)) { [EOL] return false; [EOL] } [EOL] if (((NodeNameTest) nodeTest).isWildcard()) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } [EOL] return false; [EOL] }
public void testAreBasicPredicatesWithNull() { [EOL] boolean result = areBasicPredicates(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testAreBasicPredicatesWithEmptyArray() { [EOL] Expression[] predicates = new Expression[0]; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertTrue(result); [EOL] } [EOL] public void testAreBasicPredicatesWithNonContextDependentNameAttributeTest() { [EOL] Expression[] predicates = new Expression[1]; [EOL] NameAttributeTest nat = mock(NameAttributeTest.class); [EOL] when(nat.isContextDependent()).thenReturn(false); [EOL] when(nat.getNameTestExpression()).thenReturn(mock(NameTestExpression.class)); [EOL] predicates[0] = nat; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertTrue(result); [EOL] } [EOL] public void testAreBasicPredicatesWithContextDependentNameAttributeTest() { [EOL] Expression[] predicates = new Expression[1]; [EOL] NameAttributeTest nat = mock(NameAttributeTest.class); [EOL] when(nat.isContextDependent()).thenReturn(true); [EOL] when(nat.getNameTestExpression()).thenReturn(mock(NameTestExpression.class)); [EOL] predicates[0] = nat; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertFalse(result); [EOL] } [EOL] public void testAreBasicPredicatesWithContextDependentNonNameAttributeTest() { [EOL] Expression[] predicates = new Expression[1]; [EOL] Expression exp = mock(Expression.class); [EOL] when(exp.isContextDependent()).thenReturn(true); [EOL] predicates[0] = exp; [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertFalse(result); [EOL] } [EOL] public void testAreBasicPredicatesWithMultiplePredicates() { [EOL] Expression[] predicates = new Expression[2]; [EOL] predicates[0] = mock(Expression.class); [EOL] when(predicates[0].isContextDependent()).thenReturn(false); [EOL] predicates[1] = mock(Expression.class); [EOL] when(predicates[1].isContextDependent()).thenReturn(false); [EOL] boolean result = areBasicPredicates(predicates); [EOL] assertFalse(result); [EOL] }

public void testGetSingleNodePointerForStepsWithEmptySteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(mock(Pointer.class)); [EOL] setStepsLength(0); // Assuming there is a method to set the steps length [EOL] Pointer result = getSingleNodePointerForSteps(context); [EOL] assertNotNull(result); [EOL] verify(context).getSingleNodePointer(); [EOL] }
public void testGetSingleNodePointerForStepsWithSimplePath() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(nodePointer); [EOL] setStepsLength(1); // Assuming there is a method to set the steps length [EOL] setIsSimplePath(true); // Assuming there is a method to set the simple path flag [EOL] Pointer result = getSingleNodePointerForSteps(context); [EOL] assertNotNull(result); [EOL] verify(context).getSingleNodePointer(); [EOL] }
public void testGetSingleNodePointerForStepsWithComplexPath() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] setStepsLength(1); // Assuming there is a method to set the steps length [EOL] setIsSimplePath(false); // Assuming there is a method to set the simple path flag [EOL] Pointer result = getSingleNodePointerForSteps(context); [EOL] assertNotNull(result); [EOL] }
public void testSearchForPathWithNonNullPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testSearchForPathWithNullPointerAndSimpleSteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(false); [EOL] steps = new Step[] { /* steps setup with simple steps */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithComplexStep() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(false); [EOL] steps = new Step[] { /* steps setup with at least one complex step */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialPointerAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer partialPointer = mock(Pointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(true).thenReturn(true); // hasNext returns true twice [EOL] when(context.next()).thenReturn(partialPointer); [EOL] steps = new Step[] { /* steps setup with simple steps */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialNodePointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] NodePointer partialNodePointer = mock(NodePointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(true).thenReturn(false); // hasNext returns true once [EOL] when(context.next()).thenReturn(partialNodePointer); [EOL] steps = new Step[] { /* steps setup with simple steps */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] }
private EvalContext buildContextChain(EvalContext context, int stepCount, boolean createInitialContext) { [EOL] if (createInitialContext) { [EOL] context = new InitialContext(context); [EOL] } [EOL] if (steps.length == 0) { [EOL] return context; [EOL] } [EOL] for (int i = 0; i < stepCount; i++) { [EOL] context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest()); [EOL] Expression[] predicates = steps[i].getPredicates(); [EOL] if (predicates != null) { [EOL] for (int j = 0; j < predicates.length; j++) { [EOL] if (j != 0) { [EOL] context = new UnionContext(context, new EvalContext[] { context }); [EOL] } [EOL] context = new PredicateContext(context, predicates[j]); [EOL] } [EOL] } [EOL] } [EOL] return context; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL] if (nodeTest instanceof NodeNameTest) { [EOL] QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL] String prefix = qname.getPrefix(); [EOL] String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL] if (namespaceURI != null) { [EOL] nodeTest = new NodeNameTest(qname, namespaceURI); [EOL] } [EOL] } [EOL] switch(axis) { [EOL] case Compiler.AXIS_ANCESTOR: [EOL] return new AncestorContext(context, false, nodeTest); [EOL] case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL] return new AncestorContext(context, true, nodeTest); [EOL] case Compiler.AXIS_ATTRIBUTE: [EOL] return new AttributeContext(context, nodeTest); [EOL] case Compiler.AXIS_CHILD: [EOL] return new ChildContext(context, nodeTest, false, false); [EOL] case Compiler.AXIS_DESCENDANT: [EOL] return new DescendantContext(context, false, nodeTest); [EOL] case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL] return new DescendantContext(context, true, nodeTest); [EOL] case Compiler.AXIS_FOLLOWING: [EOL] return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL] case Compiler.AXIS_FOLLOWING_SIBLING: [EOL] return new ChildContext(context, nodeTest, true, false); [EOL] case Compiler.AXIS_NAMESPACE: [EOL] return new NamespaceContext(context, nodeTest); [EOL] case Compiler.AXIS_PARENT: [EOL] return new ParentContext(context, nodeTest); [EOL] case Compiler.AXIS_PRECEDING: [EOL] return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL] case Compiler.AXIS_PRECEDING_SIBLING: [EOL] return new ChildContext(context, nodeTest, true, true); [EOL] case Compiler.AXIS_SELF: [EOL] return new SelfContext(context, nodeTest); [EOL] } [EOL] return null; [EOL] }
public void testVariablePointerWithNonNullVariablesAndName() { [EOL] Variables variables = new Variables(); [EOL] QName qName = new QName("namespace", "localPart"); [EOL] VariablePointer variablePointer = new VariablePointer(variables, qName); [EOL] assertNotNull(variablePointer); [EOL] assertEquals(variables, variablePointer.getVariables()); [EOL] assertEquals(qName, variablePointer.getName()); [EOL] assertTrue(variablePointer.isActual()); [EOL] }
public void testGetBaseValueWhenActualIsFalse() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("testVariable", "testValue"); [EOL] JXPathException exception = null; [EOL] try { [EOL] context.getVariables().getBaseValue(); [EOL] } catch (JXPathException e) { [EOL] exception = e; [EOL] } [EOL] assertNotNull("Expected JXPathException to be thrown", exception); [EOL] assertEquals("Undefined variable: testVariable", exception.getMessage()); [EOL] }
public void testGetBaseValueWhenActualIsTrue() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("testVariable", "testValue"); [EOL] context.getVariables().setActual(true); [EOL] Object result = context.getVariables().getBaseValue(); [EOL] assertNotNull("Expected non-null result", result); [EOL] assertEquals("Expected result to be 'testValue'", "testValue", result); [EOL] }
public void testIsLeafWithNullNode() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathNode node = context.getPointer(null); [EOL] boolean result = node.isLeaf(); [EOL] assertTrue("Expected the result to be true when node is null", result); [EOL] }
public void testIsLeafWithAtomicNode() { [EOL] JXPathContext context = JXPathContext.newContext(new AtomicNode()); [EOL] JXPathNode node = context.getPointer("/atomicNode"); [EOL] boolean result = node.isLeaf(); [EOL] assertTrue("Expected the result to be true for an atomic node", result); [EOL] }
public void testIsLeafWithNonAtomicNode() { [EOL] JXPathContext context = JXPathContext.newContext(new NonAtomicNode()); [EOL] JXPathNode node = context.getPointer("/nonAtomicNode"); [EOL] boolean result = node.isLeaf(); [EOL] assertFalse("Expected the result to be false for a non-atomic node", result); [EOL] }
public void testGetImmediateNodeWithIndexNotWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBaseValue(someBaseValue); [EOL] instance.setIndex(someIndexNotEqualToWHOLE_COLLECTION); [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(ValueUtils.getValue(someBaseValue, someIndexNotEqualToWHOLE_COLLECTION), result); [EOL] }
public void testGetImmediateNodeWithIndexWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setBaseValue(someBaseValue); [EOL] instance.setIndex(WHOLE_COLLECTION); [EOL] Object result = instance.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(ValueUtils.getValue(someBaseValue), result); [EOL] }
public void testSetValueWithActualFalse() { [EOL] try { [EOL] VariablePointer variablePointer = new VariablePointer(...); // Provide necessary initialization [EOL] variablePointer.setValue("New Value"); [EOL] fail("Should have thrown JXPathException because actual is false"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot set undefined variable: " + variablePointer.getName(), e.getMessage()); [EOL] } [EOL] }
public void testSetValueWithIndexNotWholeCollection() { [EOL] VariablePointer variablePointer = new VariablePointer(...); // Provide necessary initialization [EOL] variablePointer.setActual(true); [EOL] variablePointer.setIndex(1); // Set index to a value that is not WHOLE_COLLECTION [EOL] variablePointer.setValue("New Value"); [EOL] }
public void testSetValueWithIndexWholeCollection() { [EOL] VariablePointer variablePointer = new VariablePointer(...); // Provide necessary initialization [EOL] variablePointer.setActual(true); [EOL] variablePointer.setIndex(VariablePointer.WHOLE_COLLECTION); [EOL] variablePointer.setValue("New Value"); [EOL] }
public boolean isActual() { [EOL] return actual; [EOL] }
public void testGetImmediateValuePointerWhenValuePointerIsNullAndActualIsTrue() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = null; [EOL] instance.actual = true; [EOL] NodePointer result = instance.getImmediateValuePointer(); [EOL] assertNotNull("Expected non-null NodePointer when actual is true", result); [EOL] }
public void testGetImmediateValuePointerWhenValuePointerIsNullAndActualIsFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = null; [EOL] instance.actual = false; [EOL] NodePointer result = instance.getImmediateValuePointer(); [EOL] assertTrue("Expected result to be an instance of NullPointer", result instanceof NullPointer); [EOL] }
public void testGetImmediateValuePointerWhenValuePointerIsNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = new NodePointerSubclass(); // Replace with an actual instance of a NodePointer subclass [EOL] instance.actual = true; // The value of 'actual' does not matter in this scenario [EOL] NodePointer result = instance.getImmediateValuePointer(); [EOL] assertSame("Expected the same NodePointer that was already set", instance.valuePointer, result); [EOL] }
public void testCreatePathWithActualTrue() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new TestNodePointer(true); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertSame("Expected the same NodePointer instance when actual is true", nodePointer, result); [EOL] assertEquals("Expected the value to be set when actual is true", value, nodePointer.getValue()); [EOL] }
public void testCreatePathWithActualFalse() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new TestNodePointer(false); [EOL] NodePointer expectedPointer = new TestNodePointer(true); [EOL] when(nodePointer.createPath(context)).thenReturn(expectedPointer); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotSame("Expected a different NodePointer instance when actual is false", nodePointer, result); [EOL] assertEquals("Expected the value to be set on the new NodePointer when actual is false", value, expectedPointer.getValue()); [EOL] }
public void testAsPathWithActualTrueAndIndexWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.name = "testName"; [EOL] instance.actual = true; [EOL] instance.index = YourClassUnderTest.WHOLE_COLLECTION; [EOL] instance.setNode(null); // Assuming there is a method to set the node [EOL] String result = instance.asPath(); [EOL] assertEquals("$testName", result); [EOL] }
public void testAsPathWithActualFalseAndIndexNotWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.name = "testName"; [EOL] instance.actual = false; [EOL] instance.index = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] String result = instance.asPath(); [EOL] assertEquals("$testName[2]", result); [EOL] }
public void testAsPathWithActualTrueIndexNotWholeCollectionAndNodeNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.name = "testName"; [EOL] instance.actual = true; [EOL] instance.index = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] instance.setNode(new Node()); // Assuming there is a method to set the node and Node is a valid class [EOL] String result = instance.asPath(); [EOL] assertEquals("$testName", result); [EOL] }
public void testAsPathWithActualTrueIndexNotWholeCollectionAndNodeNullAndIsCollectionFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.name = "testName"; [EOL] instance.actual = true; [EOL] instance.index = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] instance.setNode(null); // Assuming there is a method to set the node [EOL] instance.setIsCollection(false); // Assuming there is a method to set the collection status [EOL] String result = instance.asPath(); [EOL] assertEquals("$testName[2]", result); [EOL] }
public void testAsPathWithActualTrueIndexNotWholeCollectionAndNodeNullAndIsCollectionTrue() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.name = "testName"; [EOL] instance.actual = true; [EOL] instance.index = 1; // Assuming WHOLE_COLLECTION is not 1 [EOL] instance.setNode(null); // Assuming there is a method to set the node [EOL] instance.setIsCollection(true); // Assuming there is a method to set the collection status [EOL] String result = instance.asPath(); [EOL] assertEquals("$testName[2]", result); [EOL] }
public void testNode_NullNodeTest() { [EOL] NodeTest nodeTest = null; [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JXPathCompiledExpression expression = (JXPathCompiledExpression) context.compile("some/xpath/expression"); [EOL] ValuePointer valuePointer = (ValuePointer) expression.getValuePointer(context); [EOL] boolean result = valuePointer.testNode(nodeTest); [EOL] assertFalse("Expected testNode to return false with null NodeTest", result); [EOL] }
public void testNode_ValidNodeTest() { [EOL] NodeTest nodeTest = new NodeNameTest(new QName("someNode")); [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JXPathCompiledExpression expression = (JXPathCompiledExpression) context.compile("some/xpath/expression"); [EOL] ValuePointer valuePointer = (ValuePointer) expression.getValuePointer(context); [EOL] boolean result = valuePointer.testNode(nodeTest); [EOL] assertTrue("Expected testNode to return true with valid NodeTest", result); [EOL] }
public void testGetParent_NullParent() { [EOL] NodePointer testNodePointer = createNodePointerWithParent(null); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertNull(result); [EOL] } [EOL] public void testGetParent_NonContainerParent() { [EOL] NodePointer parent = createNonContainerNodePointer(); [EOL] NodePointer testNodePointer = createNodePointerWithParent(parent); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertSame(parent, result); [EOL] } [EOL] public void testGetParent_ContainerParent() { [EOL] NodePointer containerParent = createContainerNodePointer(); [EOL] NodePointer nonContainerGrandparent = createNonContainerNodePointer(); [EOL] when(containerParent.getImmediateParentPointer()).thenReturn(nonContainerGrandparent); [EOL] NodePointer testNodePointer = createNodePointerWithParent(containerParent); [EOL] NodePointer result = testNodePointer.getParent(); [EOL] assertSame(nonContainerGrandparent, result); [EOL] }

public void testGetImmediateParentPointer() { [EOL] NodePointer testNodePointer = new ConcreteNodePointer(); // Assuming ConcreteNodePointer is a concrete implementation of NodePointer [EOL] NodePointer expectedParent = new ConcreteNodePointer(); // Assuming we have a parent node set up [EOL] testNodePointer.parent = expectedParent; // Directly setting the parent for the purpose of the test [EOL] NodePointer result = testNodePointer.getImmediateParentPointer(); [EOL] assertEquals("The parent pointer should be the expected one", expectedParent, result); [EOL] }
public void testSetAttributeTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAttribute(true); [EOL] assertTrue(instance.attribute); [EOL] }
public void testSetAttributeFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAttribute(false); [EOL] assertFalse(instance.attribute); [EOL] }
public void testGetValueWhenValuePointerIsNotThis() { [EOL] NodePointer mockValuePointer = Mockito.mock(NodePointer.class); [EOL] NodePointer mockThis = Mockito.mock(NodePointer.class, Mockito.CALLS_REAL_METHODS); [EOL] Mockito.when(mockThis.getValuePointer()).thenReturn(mockValuePointer); [EOL] Mockito.when(mockValuePointer.getValue()).thenReturn("MockValue"); [EOL] Mockito.when(mockValuePointer != mockThis).thenReturn(true); [EOL] Object result = mockThis.getValue(); [EOL] assertEquals("MockValue", result); [EOL] }
public void testGetValueWhenValuePointerIsThis() { [EOL] NodePointer mockThis = Mockito.mock(NodePointer.class, Mockito.CALLS_REAL_METHODS); [EOL] Mockito.when(mockThis.getValuePointer()).thenReturn(mockThis); [EOL] Mockito.when(mockThis.getNode()).thenReturn("MockNode"); [EOL] Object result = mockThis.getValue(); [EOL] assertEquals("MockNode", result); [EOL] }
public void testNodeWithNullTest() { [EOL] boolean result = testNode(null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndContainer() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndNullNodeName() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(this.getName()).thenReturn(null); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndDifferentPrefixes() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testPrefix", "testName"); [EOL] QName nodeName = new QName("nodePrefix", "nodeName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.getNamespaceURI("testPrefix")).thenReturn("testNS"); [EOL] when(this.getNamespaceURI("nodePrefix")).thenReturn("nodeNS"); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndSamePrefixesDifferentNamespaces() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("prefix", "testName"); [EOL] QName nodeName = new QName("prefix", "nodeName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.getNamespaceURI("prefix")).thenReturn("testNS", "nodeNS"); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestWildcard() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.isWildcard()).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestSameQName() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName qName = new QName("prefix", "localName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(qName); [EOL] when(this.getName()).thenReturn(qName); [EOL] when(nodeNameTest.isWildcard()).thenReturn(false); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestAndNodeTypeNode() { [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] when(this.isNode()).thenReturn(true); [EOL] boolean result = testNode(nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestAndNotNodeTypeNode() { [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_OTHER); [EOL] boolean result = testNode(nodeTypeTest); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsBothNull() { [EOL] boolean result = equalStrings(null, null); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsFirstNull() { [EOL] boolean result = equalStrings(null, "test"); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsSecondNull() { [EOL] boolean result = equalStrings("test", null); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsBothNonNullEqual() { [EOL] boolean result = equalStrings("test", "test"); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsBothNonNullNotEqual() { [EOL] boolean result = equalStrings("test", "different"); [EOL] assertFalse(result); [EOL] }
public String getNamespaceURI(String prefix) { [EOL] return null; [EOL] }
public void testIsDefaultNamespaceWithNullPrefix() { [EOL] boolean result = instance.isDefaultNamespace(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsDefaultNamespaceWithNonNullPrefixButNullNamespace() { [EOL] boolean result = instance.isDefaultNamespace("nonNullPrefix"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsDefaultNamespaceWithNonNullPrefixAndNonNullNamespaceNotMatchingDefault() { [EOL] boolean result = instance.isDefaultNamespace("nonNullPrefix"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsDefaultNamespaceWithNonNullPrefixAndNonNullNamespaceMatchingDefault() { [EOL] boolean result = instance.isDefaultNamespace("nonNullPrefix"); [EOL] assertTrue(result); [EOL] }

public void testCloneWithNonNullParent() throws Exception { [EOL] NodePointer original = new NodePointer(); [EOL] NodePointer parent = new NodePointer(); [EOL] original.setParent(parent); [EOL] NodePointer cloned = (NodePointer) original.clone(); [EOL] assertNotNull(cloned); [EOL] assertNotNull(cloned.getParent()); [EOL] assertNotSame(parent, cloned.getParent()); [EOL] }
public void testCloneWithNullParent() throws Exception { [EOL] NodePointer original = new NodePointer(); [EOL] original.setParent(null); [EOL] NodePointer cloned = (NodePointer) original.clone(); [EOL] assertNotNull(cloned); [EOL] assertNull(cloned.getParent()); [EOL] }
public void testCompareToWithSameParentAndNonNullParent() { [EOL] NodePointer parent = new NodePointer(); // Mocked NodePointer with necessary methods [EOL] NodePointer pointer1 = new NodePointer(parent); [EOL] NodePointer pointer2 = new NodePointer(parent); [EOL] when(parent.compareChildNodePointers(pointer1, pointer2)).thenReturn(1); [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(1, result); [EOL] }
public void testCompareToWithSameParentAndNullParent() { [EOL] NodePointer pointer1 = new NodePointer(null); [EOL] NodePointer pointer2 = new NodePointer(null); [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareToWithDifferentParents() { [EOL] NodePointer parent1 = new NodePointer(); // Mocked NodePointer with necessary methods [EOL] NodePointer parent2 = new NodePointer(); // Mocked NodePointer with necessary methods [EOL] NodePointer pointer1 = new NodePointer(parent1); [EOL] NodePointer pointer2 = new NodePointer(parent2); [EOL] when(NodePointer.compareNodePointers(pointer1, 2, pointer2, 2)).thenReturn(-1); [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareNodePointersWithEqualDepthAndBothNull() { [EOL] NodePointer p1 = null; [EOL] NodePointer p2 = null; [EOL] int depth1 = 0; [EOL] int depth2 = 0; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareNodePointersWithFirstDepthLessThanSecond() { [EOL] NodePointer p1 = mock(NodePointer.class); [EOL] NodePointer p2 = mock(NodePointer.class); [EOL] when(p2.getParent()).thenReturn(null); [EOL] int depth1 = 0; [EOL] int depth2 = 1; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareNodePointersWithFirstDepthGreaterThanSecond() { [EOL] NodePointer p1 = mock(NodePointer.class); [EOL] NodePointer p2 = mock(NodePointer.class); [EOL] when(p1.getParent()).thenReturn(null); [EOL] int depth1 = 1; [EOL] int depth2 = 0; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(1, result); [EOL] }
public void testCompareNodePointersWithEqualNonNullPointers() { [EOL] NodePointer p1 = mock(NodePointer.class); [EOL] NodePointer p2 = p1; [EOL] int depth1 = 1; [EOL] int depth2 = 1; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareNodePointersWithDifferentNonNullPointersAndDepthOne() { [EOL] NodePointer p1 = mock(NodePointer.class); [EOL] NodePointer p2 = mock(NodePointer.class); [EOL] int depth1 = 1; [EOL] int depth2 = 1; [EOL] try { [EOL] compareNodePointers(p1, depth1, p2, depth2); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testCompareNodePointersWithDifferentNonNullPointersAndGreaterDepth() { [EOL] NodePointer p1 = mock(NodePointer.class); [EOL] NodePointer p2 = mock(NodePointer.class); [EOL] NodePointer parent1 = mock(NodePointer.class); [EOL] NodePointer parent2 = mock(NodePointer.class); [EOL] when(p1.getParent()).thenReturn(parent1); [EOL] when(p2.getParent()).thenReturn(parent2); [EOL] when(parent1.compareChildNodePointers(p1, p2)).thenReturn(1); [EOL] int depth1 = 2; [EOL] int depth2 = 2; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(1, result); [EOL] }
public void testJDOMAttributePointerWithNonNullParentNonNullAttribute() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Attribute attr = mock(Attribute.class); [EOL] JDOMAttributePointer pointer = new JDOMAttributePointer(parent, attr); [EOL] assertNotNull(pointer); [EOL] assertSame(attr, pointer.getAttribute()); [EOL] assertSame(parent, pointer.getParent()); [EOL] }
public void testJDOMAttributePointerWithNullParentNonNullAttribute() { [EOL] Attribute attr = mock(Attribute.class); [EOL] JDOMAttributePointer pointer = new JDOMAttributePointer(null, attr); [EOL] assertNotNull(pointer); [EOL] assertSame(attr, pointer.getAttribute()); [EOL] assertNull(pointer.getParent()); [EOL] }
public void testJDOMAttributePointerWithNonNullParentNullAttribute() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] JDOMAttributePointer pointer = new JDOMAttributePointer(parent, null); [EOL] assertNotNull(pointer); [EOL] assertNull(pointer.getAttribute()); [EOL] assertSame(parent, pointer.getParent()); [EOL] }
public void testJDOMAttributePointerWithNullParentNullAttribute() { [EOL] JDOMAttributePointer pointer = new JDOMAttributePointer(null, null); [EOL] assertNotNull(pointer); [EOL] assertNull(pointer.getAttribute()); [EOL] assertNull(pointer.getParent()); [EOL] }
public void testGetValue() { [EOL] Object expectedValue = ...; // Initialize with the expected value [EOL] Object actualValue = yourObject.getValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public Object getImmediateNodeTest() { [EOL] YourClass instance = new YourClass(); [EOL] Object expected = instance.attr; [EOL] Object result = instance.getImmediateNode(); [EOL] assertEquals(expected, result); [EOL] }
public void testIsCollectionWithNull() { [EOL] boolean result = isCollection(null); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithArray() { [EOL] boolean result = isCollection(new int[]{1, 2, 3}); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithCollection() { [EOL] boolean result = isCollection(new ArrayList<>()); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithNonCollection() { [EOL] boolean result = isCollection(new Object()); [EOL] assertFalse(result); [EOL] }
public void testIterateWithNull() { [EOL] Iterator iterator = YourClass.iterate(null); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIterateWithEmptyArray() { [EOL] Object[] emptyArray = new Object[0]; [EOL] Iterator iterator = YourClass.iterate(emptyArray); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIterateWithNonEmptyArray() { [EOL] Object[] nonEmptyArray = new Object[] { "element1", "element2" }; [EOL] Iterator iterator = YourClass.iterate(nonEmptyArray); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("element1", iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("element2", iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIterateWithCollection() { [EOL] Collection collection = Arrays.asList("element1", "element2"); [EOL] Iterator iterator = YourClass.iterate(collection); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("element1", iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("element2", iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIterateWithSingleObject() { [EOL] String singleObject = "singleElement"; [EOL] Iterator iterator = YourClass.iterate(singleObject); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals("singleElement", iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testGetValueWithNullCollection() { [EOL] Object result = getValue(null, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithEmptyArray() { [EOL] Object[] array = new Object[0]; [EOL] Object result = getValue(array, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidArrayIndex() { [EOL] Object[] array = new Object[] { "value1", "value2" }; [EOL] Object result = getValue(array, 1); [EOL] assertEquals("value2", result); [EOL] } [EOL] public void testGetValueWithInvalidArrayIndex() { [EOL] Object[] array = new Object[] { "value1", "value2" }; [EOL] Object result = getValue(array, -1); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithEmptyList() { [EOL] List<Object> list = new ArrayList<>(); [EOL] Object result = getValue(list, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidListIndex() { [EOL] List<Object> list = new ArrayList<>(); [EOL] list.add("value1"); [EOL] list.add("value2"); [EOL] Object result = getValue(list, 1); [EOL] assertEquals("value2", result); [EOL] } [EOL] public void testGetValueWithInvalidListIndex() { [EOL] List<Object> list = new ArrayList<>(); [EOL] list.add("value1"); [EOL] list.add("value2"); [EOL] Object result = getValue(list, -1); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithEmptyCollection() { [EOL] Collection<Object> collection = new HashSet<>(); [EOL] Object result = getValue(collection, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidCollectionIndex() { [EOL] Collection<Object> collection = new HashSet<>(); [EOL] collection.add("value1"); [EOL] collection.add("value2"); [EOL] Object result = getValue(collection, 1); [EOL] assertNotNull(result); // Assuming the collection iterator order is consistent [EOL] } [EOL] public void testGetValueWithInvalidCollectionIndex() { [EOL] Collection<Object> collection = new HashSet<>(); [EOL] collection.add("value1"); [EOL] collection.add("value2"); [EOL] Object result = getValue(collection, 3); [EOL] assertNull(result); [EOL] }
public void testGetValueWithValidReadMethod() { [EOL] Object bean = new MyBean(); // Assuming MyBean is a valid bean class with a readable property [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("propertyName", MyBean.class); // Assuming propertyName is a valid property with a read method [EOL] Object result = ClassName.getValue(bean, propertyDescriptor); [EOL] assertNotNull(result); // Replace ClassName with the actual class name where getValue is located [EOL] }
public void testGetValueWithNullMethod() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("invalidProperty", MyBean.class); // Assuming invalidProperty has no read method [EOL] try { [EOL] ClassName.getValue(bean, propertyDescriptor); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("No read method", e.getMessage()); [EOL] } [EOL] }
public void testGetValueWithNullBean() { [EOL] Object bean = null; [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("propertyName", MyBean.class); // Assuming propertyName is a valid property [EOL] try { [EOL] ClassName.getValue(bean, propertyDescriptor); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertTrue(e.getMessage().contains("Cannot access property: null.propertyName")); [EOL] } [EOL] }
public void testGetValueWithInaccessibleProperty() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("inaccessibleProperty", MyBean.class); // Assuming inaccessibleProperty exists but is not accessible [EOL] try { [EOL] ClassName.getValue(bean, propertyDescriptor); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertTrue(e.getMessage().contains("Cannot access property: MyBean.inaccessibleProperty")); [EOL] } [EOL] }
public void testSetValueWithNullMethod() { [EOL] Object bean = new Object(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] when(propertyDescriptor.getWriteMethod()).thenReturn(null); [EOL] Object value = new Object(); [EOL] try { [EOL] JXPathUtils.setValue(bean, propertyDescriptor, value); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("No write method", e.getMessage()); [EOL] } [EOL] }
public void testSetValueWithValidMethod() { [EOL] Object bean = new Object(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] Method writeMethod = mock(Method.class); [EOL] when(propertyDescriptor.getWriteMethod()).thenReturn(writeMethod); [EOL] when(propertyDescriptor.getPropertyType()).thenReturn(Object.class); [EOL] Object value = new Object(); [EOL] try { [EOL] JXPathUtils.setValue(bean, propertyDescriptor, value); [EOL] verify(writeMethod).invoke(eq(bean), any(Object[].class)); [EOL] } catch (Exception e) { [EOL] fail("No exception expected"); [EOL] } [EOL] }
public void testSetValueWithException() { [EOL] Object bean = new Object(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] Method writeMethod = mock(Method.class); [EOL] when(propertyDescriptor.getWriteMethod()).thenReturn(writeMethod); [EOL] when(propertyDescriptor.getPropertyType()).thenReturn(Object.class); [EOL] when(writeMethod.invoke(eq(bean), any(Object[].class))).thenThrow(new IllegalAccessException()); [EOL] Object value = new Object(); [EOL] try { [EOL] JXPathUtils.setValue(bean, propertyDescriptor, value); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertTrue(e.getMessage().contains("Cannot modify property:")); [EOL] } [EOL] }
public void testConvertWithValidConversion() { [EOL] Object value = "123"; [EOL] Class type = Integer.class; [EOL] Object result = convert(value, type); [EOL] assertNotNull(result); [EOL] assertEquals(Integer.class, result.getClass()); [EOL] assertEquals(123, result); [EOL] }
public void testConvertWithInvalidConversion() { [EOL] Object value = "abc"; [EOL] Class type = Integer.class; [EOL] try { [EOL] convert(value, type); [EOL] fail("Expected JXPathException was not thrown"); [EOL] } catch (JXPathException ex) { [EOL] assertNotNull(ex.getMessage()); [EOL] assertTrue(ex.getMessage().contains("Cannot convert value of class java.lang.String to type class java.lang.Integer")); [EOL] } [EOL] }
public void testConvertWithNullValue() { [EOL] Object value = null; [EOL] Class type = Integer.class; [EOL] try { [EOL] convert(value, type); [EOL] fail("Expected JXPathException was not thrown"); [EOL] } catch (JXPathException ex) { [EOL] assertNotNull(ex.getMessage()); [EOL] assertTrue(ex.getMessage().contains("Cannot convert value of class null to type class java.lang.Integer")); [EOL] } [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index) { [EOL] if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL] try { [EOL] IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL] Method method = ipd.getIndexedReadMethod(); [EOL] if (method != null) { [EOL] return method.invoke(bean, new Object[] { new Integer(index) }); [EOL] } [EOL] } catch (InvocationTargetException ex) { [EOL] Throwable t = ((InvocationTargetException) ex).getTargetException(); [EOL] if (t instanceof ArrayIndexOutOfBoundsException) { [EOL] return null; [EOL] } [EOL] throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), t); [EOL] } catch (Throwable ex) { [EOL] throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), ex); [EOL] } [EOL] } [EOL] return getValue(getValue(bean, propertyDescriptor), index); [EOL] }
public void testSetValueWithIndexedPropertyDescriptorAndValidMethod() { [EOL] Object bean = new MyBean(); [EOL] IndexedPropertyDescriptor propertyDescriptor = mock(IndexedPropertyDescriptor.class); [EOL] Method writeMethod = MyBean.class.getMethod("setIndexedProperty", int.class, String.class); [EOL] when(propertyDescriptor.getIndexedWriteMethod()).thenReturn(writeMethod); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] assertEquals("testValue", ((MyBean) bean).getIndexedProperty(index)); [EOL] }
public void testSetValueWithIndexedPropertyDescriptorAndNullMethod() { [EOL] Object bean = new MyBean(); [EOL] IndexedPropertyDescriptor propertyDescriptor = mock(IndexedPropertyDescriptor.class); [EOL] when(propertyDescriptor.getIndexedWriteMethod()).thenReturn(null); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] try { [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testSetValueWithNonIndexedPropertyDescriptor() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] int index = 0; [EOL] Object value = "testValue"; [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] assertEquals("testValue", ((MyBean) bean).getSimpleProperty()); [EOL] }
public void testSetValueWithNonIndexedPropertyDescriptorAndNonZeroIndex() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] int index = 1; [EOL] Object value = "testValue"; [EOL] try { [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testSetValueWithCollection() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = mock(PropertyDescriptor.class); [EOL] int index = 0; [EOL] Object value = "testValue"; [EOL] Collection collection = new ArrayList(); [EOL] when(JXPath.getValue(bean, propertyDescriptor)).thenReturn(collection); [EOL] JXPath.setValue(bean, propertyDescriptor, index, value); [EOL] assertTrue(collection.contains(value)); [EOL] }
public void testGetDynamicPropertyHandlerWithExistingHandler() { [EOL] Class clazz = ExistingHandlerClass.class; // Assume ExistingHandlerClass implements DynamicPropertyHandler [EOL] DynamicPropertyHandler expectedHandler = new ExistingHandlerClass(); [EOL] dynamicPropertyHandlerMap.put(clazz, expectedHandler); [EOL] DynamicPropertyHandler resultHandler = YourClass.getDynamicPropertyHandler(clazz); [EOL] assertSame("Handler should be the one from the map", expectedHandler, resultHandler); [EOL] }
public void testGetDynamicPropertyHandlerWithNewHandler() { [EOL] Class clazz = NewHandlerClass.class; // Assume NewHandlerClass implements DynamicPropertyHandler and has a public no-arg constructor [EOL] DynamicPropertyHandler resultHandler = YourClass.getDynamicPropertyHandler(clazz); [EOL] assertNotNull("Handler should not be null", resultHandler); [EOL] assertTrue("Handler should be instance of NewHandlerClass", resultHandler instanceof NewHandlerClass); [EOL] }
public void testGetDynamicPropertyHandlerWithInstantiationException() { [EOL] Class clazz = NoDefaultConstructorHandlerClass.class; // Assume NoDefaultConstructorHandlerClass implements DynamicPropertyHandler but does not have a public no-arg constructor [EOL] try { [EOL] YourClass.getDynamicPropertyHandler(clazz); [EOL] fail("JXPathException expected due to no default constructor"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Exception message should match", "Cannot allocate dynamic property handler of class " + clazz.getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetDynamicPropertyHandlerWithIllegalAccessException() { [EOL] Class clazz = PrivateConstructorHandlerClass.class; // Assume PrivateConstructorHandlerClass implements DynamicPropertyHandler and has a private no-arg constructor [EOL] try { [EOL] YourClass.getDynamicPropertyHandler(clazz); [EOL] fail("JXPathException expected due to private constructor"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Exception message should match", "Cannot allocate dynamic property handler of class " + clazz.getName(), e.getMessage()); [EOL] } [EOL] }
public void testGetAccessibleMethodWithNullMethod() { [EOL] Method result = ClassName.getAccessibleMethod(null); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleMethodWithNonPublicMethod() throws NoSuchMethodException { [EOL] Class<?> clazz = SomeClass.class; [EOL] Method privateMethod = clazz.getDeclaredMethod("somePrivateMethod"); [EOL] Method result = ClassName.getAccessibleMethod(privateMethod); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleMethodWithPublicMethodInPublicClass() throws NoSuchMethodException { [EOL] Class<?> clazz = SomePublicClass.class; [EOL] Method publicMethod = clazz.getMethod("somePublicMethod"); [EOL] Method result = ClassName.getAccessibleMethod(publicMethod); [EOL] assertNotNull(result); [EOL] assertEquals(publicMethod, result); [EOL] }
public void testGetAccessibleMethodWithPublicMethodInNonPublicClass() throws NoSuchMethodException { [EOL] Class<?> clazz = SomeNonPublicClass.class; [EOL] Method publicMethod = clazz.getMethod("somePublicMethod"); [EOL] Method result = ClassName.getAccessibleMethod(publicMethod); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleMethodWithInheritedPublicMethod() throws NoSuchMethodException { [EOL] Class<?> clazz = SomeSubClass.class; [EOL] Method inheritedPublicMethod = clazz.getMethod("inheritedPublicMethod"); [EOL] Method result = ClassName.getAccessibleMethod(inheritedPublicMethod); [EOL] assertNotNull(result); [EOL] assertEquals(inheritedPublicMethod, result); [EOL] }
public void testGetAccessibleMethodWithPublicMethodFromInterface() throws NoSuchMethodException { [EOL] Class<?> clazz = SomeClassImplementingInterface.class; [EOL] Method interfaceMethod = clazz.getMethod("interfaceMethod"); [EOL] Method result = ClassName.getAccessibleMethod(interfaceMethod); [EOL] assertNotNull(result); [EOL] assertEquals(interfaceMethod, result); [EOL] }
public void testCreateNodePointerWithDocument() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate with a string [EOL] Object bean = org.w3c.dom.Document; // Assuming this is a valid Document instance [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] }
public void testCreateNodePointerWithElement() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate with a string [EOL] Object bean = org.w3c.dom.Element; // Assuming this is a valid Element instance [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] }
public void testCreateNodePointerWithNonDocumentOrElement() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate with a string [EOL] Object bean = new Object(); // A generic Object that is neither Document nor Element [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public Object getImmediateNode() { [EOL] Object value = getBaseValue(); [EOL] if (index != WHOLE_COLLECTION) { [EOL] if (index >= 0 && index < getLength()) { [EOL] return ValueUtils.getValue(value, index); [EOL] } else { [EOL] return null; [EOL] } [EOL] } else { [EOL] return ValueUtils.getValue(value); [EOL] } [EOL] }
public String testGetNamespaceURIWithValidPrefix() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String prefix = "validPrefix"; [EOL] String expectedNamespaceURI = "http://example.com/namespace"; [EOL] context.getNamespaceContext().registerNamespace(prefix, expectedNamespaceURI); [EOL] String result = context.getNamespaceURI(prefix); [EOL] assert result.equals(expectedNamespaceURI) : "Expected namespace URI to match the registered one."; [EOL] }
public String testGetNamespaceURIWithInvalidPrefix() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String prefix = "invalidPrefix"; [EOL] String expectedNamespaceURI = null; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assert result == expectedNamespaceURI : "Expected namespace URI to be null for an invalid prefix."; [EOL] }
public String testGetNamespaceURIWithNullPrefix() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String prefix = null; [EOL] try { [EOL] context.getNamespaceURI(prefix); [EOL] assert false : "Expected getNamespaceURI to throw an exception when prefix is null."; [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
```java [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL] switch(pos) { [EOL] case 0: [EOL] if ((active1 & 0xc0000L) != 0L) [EOL] return 10; [EOL] if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 1: [EOL] if ((active0 & 0x8000008000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 1; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 2: [EOL] if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 2; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 3: [EOL] if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL] if (jjmatchedPos != 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 4: [EOL] if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 5: [EOL] if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL] if (jjmatchedPos != 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 6: [EOL] if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 6; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 7: [EOL] if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x802000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 8: [EOL] if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] if (jjmatchedPos != 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 9: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 10: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 10; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 11: [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 11; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 12: [EOL] if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 12; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 13: [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 13; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 14: [EOL] if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x1000f00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 14; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 15: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xf00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 16: [EOL] if ((active0 & 0xe00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 17: [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 18: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 18; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 19: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 19; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [
private final int jjMoveStringLiteralDfa0_0() { [EOL] switch(curChar) { [EOL] case 33: [EOL] return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL] case 36: [EOL] return jjStopAtPos(0, 17); [EOL] case 40: [EOL] return jjStopAtPos(0, 80); [EOL] case 41: [EOL] return jjStopAtPos(0, 81); [EOL] case 42: [EOL] return jjStopAtPos(0, 88); [EOL] case 43: [EOL] return jjStopAtPos(0, 9); [EOL] case 44: [EOL] return jjStopAtPos(0, 87); [EOL] case 45: [EOL] return jjStopAtPos(0, 10); [EOL] case 46: [EOL] jjmatchedKind = 82; [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL] case 47: [EOL] jjmatchedKind = 6; [EOL] return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL] case 58: [EOL] return jjStopAtPos(0, 79); [EOL] case 60: [EOL] jjmatchedKind = 13; [EOL] return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL] case 61: [EOL] return jjStopAtPos(0, 11); [EOL] case 62: [EOL] jjmatchedKind = 15; [EOL] return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL] case 64: [EOL] return jjStopAtPos(0, 86); [EOL] case 91: [EOL] return jjStopAtPos(0, 84); [EOL] case 93: [EOL] return jjStopAtPos(0, 85); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL] case 107: [EOL] return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL] case 124: [EOL] return jjStopAtPos(0, 8); [EOL] default: [EOL] return jjMoveNfa_0(0, 0); [EOL] } [EOL] }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(0, active0, active1); [EOL] return 1; [EOL] } [EOL] switch(curChar) { [EOL] case 46: [EOL] if ((active1 & 0x80000L) != 0L) [EOL] return jjStopAtPos(1, 83); [EOL] break; [EOL] case 47: [EOL] if ((active0 & 0x80L) != 0L) [EOL] return jjStopAtPos(1, 7); [EOL] break; [EOL] case 61: [EOL] if ((active0 & 0x1000L) != 0L) [EOL] return jjStopAtPos(1, 12); [EOL] else if ((active0 & 0x4000L) != 0L) [EOL] return jjStopAtPos(1, 14); [EOL] else if ((active0 & 0x10000L) != 0L) [EOL] return jjStopAtPos(1, 16); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL] case 100: [EOL] if ((active0 & 0x8000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 51, 12); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL] case 104: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL] case 114: [EOL] if ((active0 & 0x8000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 27, 12); [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(0, active0, active1); [EOL] }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(0, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(1, active0, active1); [EOL] return 2; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL] case 100: [EOL] if ((active0 & 0x10000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 28, 12); [EOL] else if ((active0 & 0x20000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 29, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL] case 109: [EOL] if ((active1 & 0x200L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 73, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL] case 116: [EOL] if ((active1 & 0x8L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 67, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL] case 118: [EOL] if ((active0 & 0x40000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 30, 12); [EOL] break; [EOL] case 120: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL] case 121: [EOL] if ((active0 & 0x10000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 52, 12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(1, active0, active1); [EOL] }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(1, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(2, active0, active1); [EOL] return 3; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x80000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 31, 12); [EOL] else if ((active0 & 0x80000000000000L) != 0L) { [EOL] jjmatchedKind = 55; [EOL] jjmatchedPos = 3; [EOL] } else if ((active1 & 0x10L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 68, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x80L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 71, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL] case 108: [EOL] if ((active1 & 0x40L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 70, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL] case 116: [EOL] if ((active0 & 0x100000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 32, 12); [EOL] else if ((active0 & 0x1000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 48, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(2, active0, active1); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(2, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(3, active0, active1); [EOL] return 4; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL] case 100: [EOL] if ((active1 & 0x1000L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 76, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x20L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 69, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x400L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 74, 12); [EOL] break; [EOL] case 115: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL] case 116: [EOL] if ((active0 & 0x4000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 50, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(3, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72
```java [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(3, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(4, active0, active1); [EOL] return 5; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x800000000L) != 0L) [EOL] return jjStopAtPos(5, 35); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active0 & 0x100000000000000L) != 0L) { [EOL] jjmatchedKind = 56; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x100L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 72, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 57, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(4, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\
```java [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(4, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(5, active0, active1); [EOL] return 6; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL] case 58: [EOL] if ((active0 & 0x1000000000L) != 0L) [EOL] return jjStopAtPos(6, 36); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x800L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 75, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL] case 110: [EOL] if ((active1 & 0x4L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 66, 12); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 33, 12); [EOL] break; [EOL] case 117: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(5, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(5, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(6, active0, active1); [EOL] return 7; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x2000000000L) != 0L) [EOL] return jjStopAtPos(7, 37); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 110: [EOL] if ((active0 & 0x2000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 49, 12); [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL] case 115: [EOL] if ((active0 & 0x800000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 59, 12); [EOL] break; [EOL] case 116: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 122: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); long[] jjbitVec0; long[] jjbitVec2; long[] jjbitVec3; long[] jjbitVec4; long[] jjbitVec5; long[] jjbitVec6; long[] jjbitVec7; long[] jjbitVec8; long[] jjbitVec9; long[] jjbitVec10; long[] jjbitVec11; long[] jjbitVec12; long[] jjbitVec13; long[] jjbitVec14; long[] jjbitVec15; long[] jjbitVec16; long[] jjbitVec17; long[] jjbitVec18; long[] jjbitVec19; long[] jjbitVec20; long[] jjbitVec21; long[] jjbitVec22; long[] jjbitVec23; long[] jjbitVec24; long[] jjbitVec25; long[] jjbitVec26; long[] jjbitVec27; long[] jjbitVec28; long[] jjbitVec29; long[] jjbitVec30; long[] jjbitVec31; long[] jjbitVec32; long[] jjbitVec33; long[] jjbitVec34; long[] jjbitVec35; long[] jjbitVec36; long[] jjbitVec37; long[] jjbitVec38; long[] jjbitVec39; long[] jjbitVec40; long[] jjbitVec41; int[] jjnextStates; String[] jjstrLiteralImages; String[] lexStateNames; long[] jjtoToken; long[] jjtoSkip;
```java [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(6, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(7, active0, active1); [EOL] return 8; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x2L) != 0L) [EOL] return jjStartNfaWithStates_0(8, 65, 12); [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL] case 103: [EOL] if ((active0 & 0x4000000000000000L) != 0L) { [EOL] jjmatchedKind = 62; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\
```java [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(7, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(8, active0, active1); [EOL] return 9; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL] case 58: [EOL] if ((active0 & 0x4000000000L) != 0L) [EOL] return jjStopAtPos(9, 38); [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(9, 53, 12); [EOL] break; [EOL] case 103: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\
```java [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(8, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(9, active0, active1); [EOL] return 10; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x8000000000L) != 0L) [EOL] return jjStopAtPos(10, 39); [EOL] else if ((active0 & 0x10000000000L) != 0L) [EOL] return jjStopAtPos(10, 40); [EOL] else if ((active0 & 0x20000000000L) != 0L) [EOL] return jjStopAtPos(10, 41); [EOL] else if ((active0 & 0x40000000000L) != 0L) [EOL] return jjStopAtPos(10, 42); [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(10, 58, 12); [EOL] break; [EOL] case 114: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(9, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163
```java [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(9, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(10, active0, active1); [EOL] return 11; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x80000000000L) != 0L) [EOL] return jjStopAtPos(11, 43); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(10, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\
```java [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(10, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(11, active0, active1); [EOL] return 12; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x8000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 63, 12); [EOL] break; [EOL] case 105: [EOL] if ((active0 & 0x40000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 54, 12); [EOL] break; [EOL] case 110: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x2000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 77, 12); [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(11, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156
private final int jjMoveNfa_0(int startState, int curPos) { [EOL] int[] nextStates; [EOL] int startsAt = 0; [EOL] jjnewStateCnt = 13; [EOL] int i = 1; [EOL] jjstateSet[0] = startState; [EOL] int j, kind = 0x7fffffff; [EOL] for (; ; ) { [EOL] if (++jjround == 0x7fffffff) [EOL] ReInitRounds(); [EOL] if (curChar < 64) { [EOL] long l = 1L << curChar; [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if ((0x3ff000000000000L & l) != 0L) { [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] } else if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] else if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] else if (curChar == 34) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 1: [EOL] if ((0xfffffffbffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 2: [EOL] if (curChar == 34 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 3: [EOL] if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 4: [EOL] if ((0xffffff7fffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 5: [EOL] if (curChar == 39 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 6: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] break; [EOL] case 7: [EOL] if (curChar != 46) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 8: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 9: [EOL] if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 10: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 12: [EOL] if ((0x3ff600000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjstateSet[jjnewStateCnt++] = 12; [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else if (curChar < 128) { [EOL] long l = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] case 12: [EOL] if ((0x7fffffe87fffffeL & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] jjAddStates(2, 3); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else { [EOL] int hiByte = (int) (curChar >> 8); [EOL] int i1 = hiByte >> 6; [EOL] long l1 = 1L << (hiByte & 077); [EOL] int i2 = (curChar & 0xff) >> 6; [EOL] long l2 = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(2, 3); [EOL] break; [EOL] case 12: [EOL] if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } [EOL] if (kind != 0x7fffffff) { [EOL] jjmatchedKind = kind; [EOL] jjmatchedPos = curPos; [EOL] kind = 0x7fffffff; [EOL] } [EOL] ++curPos; [EOL] if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL] return curPos; [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] return curPos; [EOL] } [EOL] } [EOL] }
public void testDOMNodePointerWithNullParentAndNode() { [EOL] NodePointer parent = null; [EOL] Node node = null; [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(parent, node); [EOL] assertNull(domNodePointer.getParent()); [EOL] assertNull(domNodePointer.getNode()); [EOL] }
public void testDOMNodePointerWithNonNullParentAndNullNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Node node = null; [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(parent, node); [EOL] assertNotNull(domNodePointer.getParent()); [EOL] assertNull(domNodePointer.getNode()); [EOL] }
public void testDOMNodePointerWithNullParentAndNonNullNode() { [EOL] NodePointer parent = null; [EOL] Node node = mock(Node.class); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(parent, node); [EOL] assertNull(domNodePointer.getParent()); [EOL] assertNotNull(domNodePointer.getNode()); [EOL] }
public void testDOMNodePointerWithNonNullParentAndNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Node node = mock(Node.class); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(parent, node); [EOL] assertNotNull(domNodePointer.getParent()); [EOL] assertNotNull(domNodePointer.getNode()); [EOL] }
public boolean testNode(NodeTest test) { [EOL] return testNode(node, test); [EOL] }
public void testNodeWithNullTest() { [EOL] Node node = mock(Node.class); [EOL] boolean result = ClassName.testNode(node, null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testNamespace", "testLocalName"); [EOL] when(testNameTest.getNodeName()).thenReturn(testName); [EOL] when(testNameTest.getNamespaceURI()).thenReturn("testNamespace"); [EOL] when(testNameTest.isWildcard()).thenReturn(false); [EOL] boolean result = ClassName.testNode(node, testNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndNonElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] boolean result = ClassName.testNode(node, testNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeTypeTestElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = ClassName.testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestDocumentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = ClassName.testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] boolean result = ClassName.testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] boolean result = ClassName.testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestProcessingInstructionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] boolean result = ClassName.testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithProcessingInstructionTest() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("testTarget"); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] boolean result = ClassName.testNode(node, piTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithMismatchedProcessingInstructionTest() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("testTarget"); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("differentTarget"); [EOL] boolean result = ClassName.testNode(node, piTest); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsBothNull() { [EOL] assertTrue(equalStrings(null, null)); [EOL] }
public void testEqualStringsFirstNullSecondEmpty() { [EOL] assertTrue(equalStrings(null, "")); [EOL] }
public void testEqualStringsFirstNullSecondWhitespace() { [EOL] assertTrue(equalStrings(null, "   ")); [EOL] }
public void testEqualStringsFirstEmptySecondNull() { [EOL] assertTrue(equalStrings("", null)); [EOL] }
public void testEqualStringsBothEmpty() { [EOL] assertTrue(equalStrings("", "")); [EOL] }
public void testEqualStringsFirstWhitespaceSecondNull() { [EOL] assertTrue(equalStrings("   ", null)); [EOL] }
public void testEqualStringsBothWhitespace() { [EOL] assertTrue(equalStrings("   ", "   ")); [EOL] }
public void testEqualStringsSameNonEmpty() { [EOL] assertTrue(equalStrings("test", "test")); [EOL] }
public void testEqualStringsDifferentNonEmpty() { [EOL] assertFalse(equalStrings("test", "fail")); [EOL] }
public void testEqualStringsTrimmedEqual() { [EOL] assertTrue(equalStrings(" test ", "test")); [EOL] }
public void testEqualStringsNonTrimmedNotEqual() { [EOL] assertFalse(equalStrings("test", " test ")); [EOL] }
public void testGetNameForElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(DOMNodePointer.getPrefix(node)).thenReturn("prefix"); [EOL] when(DOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] QName result = new QName("prefix", "localName"); [EOL] assertEquals(result, getName()); [EOL] }
public void testGetNameForProcessingInstructionNode() { [EOL] Node node = mock(Node.class); [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(pi.getTarget()).thenReturn("target"); [EOL] when(node).thenReturn(pi); [EOL] QName result = new QName(null, "target"); [EOL] assertEquals(result, getName()); [EOL] }
public void testGetNameForOtherNodeTypes() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE); // Assuming ATTRIBUTE_NODE is a valid node type constant [EOL] QName result = new QName(null, null); [EOL] assertEquals(result, getName()); [EOL] }
public void testChildIteratorWithNullTestAndFalseReverseAndNullStartWith() { [EOL] NodeTest test = null; [EOL] boolean reverse = false; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodeIterator); [EOL] }
public void testChildIteratorWithNonNullTestAndFalseReverseAndNullStartWith() { [EOL] NodeTest test = new NodeNameTest(new QName("testNode")); [EOL] boolean reverse = false; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodeIterator); [EOL] }
public void testChildIteratorWithNonNullTestAndTrueReverseAndNullStartWith() { [EOL] NodeTest test = new NodeNameTest(new QName("testNode")); [EOL] boolean reverse = true; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodeIterator); [EOL] }
public void testChildIteratorWithNonNullTestAndTrueReverseAndNonNullStartWith() { [EOL] NodeTest test = new NodeNameTest(new QName("testNode")); [EOL] boolean reverse = true; [EOL] NodePointer startWith = new DOMNodePointer(new Document(), new Locale()); [EOL] NodeIterator result = childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodeIterator); [EOL] }
public void testAttributeIteratorWithNonNullName() { [EOL] QName name = new QName("test"); [EOL] NodeIterator iterator = attributeIterator(name); [EOL] assertNotNull(iterator); [EOL] assertTrue(iterator instanceof DOMAttributeIterator); [EOL] }
public void testAttributeIteratorWithNullName() { [EOL] try { [EOL] NodeIterator iterator = attributeIterator(null); [EOL] fail("Should have thrown IllegalArgumentException for null name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNamespacePointerWithEmptyPrefix() { [EOL] NodePointer testNodePointer = new NodePointerImplementation(); [EOL] String prefix = ""; [EOL] NodePointer result = testNodePointer.namespacePointer(prefix); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NamespacePointer); [EOL] assertEquals(prefix, ((NamespacePointer) result).getPrefix()); [EOL] } [EOL] public void testNamespacePointerWithNonNullPrefix() { [EOL] NodePointer testNodePointer = new NodePointerImplementation(); [EOL] String prefix = "testPrefix"; [EOL] NodePointer result = testNodePointer.namespacePointer(prefix); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NamespacePointer); [EOL] assertEquals(prefix, ((NamespacePointer) result).getPrefix()); [EOL] }
public void testGetNamespaceURIWithNullPrefix() { [EOL] String result = getNamespaceURI(null); [EOL] assertEquals(getDefaultNamespaceURI(), result); [EOL] }
public void testGetNamespaceURIWithEmptyPrefix() { [EOL] String result = getNamespaceURI(""); [EOL] assertEquals(getDefaultNamespaceURI(), result); [EOL] }
public void testGetNamespaceURIWithXMLPrefix() { [EOL] String result = getNamespaceURI("xml"); [EOL] assertEquals(XML_NAMESPACE_URI, result); [EOL] }
public void testGetNamespaceURIWithXMLNSPrefix() { [EOL] String result = getNamespaceURI("xmlns"); [EOL] assertEquals(XMLNS_NAMESPACE_URI, result); [EOL] }
public void testGetNamespaceURIWithUnboundPrefix() { [EOL] String result = getNamespaceURI("unbound"); [EOL] assertEquals(NodePointer.UNKNOWN_NAMESPACE, result); [EOL] }
public void testGetNamespaceURIWithBoundPrefix() { [EOL] namespaces.put("prefix", "namespaceURI"); [EOL] String result = getNamespaceURI("prefix"); [EOL] assertEquals("namespaceURI", result); [EOL] }
public void testGetNamespaceURIWithUnknownNamespace() { [EOL] namespaces.put("unknown", NodePointer.UNKNOWN_NAMESPACE); [EOL] String result = getNamespaceURI("unknown"); [EOL] assertNull(result); [EOL] }
public boolean isActual() { [EOL] return true; [EOL] }
public void testIsLeaf_NodeWithNoChildren() { [EOL] Node node = mock(Node.class); [EOL] when(node.hasChildNodes()).thenReturn(false); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testIsLeaf_NodeWithChildren() { [EOL] Node node = mock(Node.class); [EOL] when(node.hasChildNodes()).thenReturn(true); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertFalse(result); [EOL] }
public void testGetPrefixWithNonNullPrefix() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPrefix()).thenReturn("prefix"); [EOL] String result = ClassName.getPrefix(node); [EOL] assertEquals("prefix", result); [EOL] }
public void testGetPrefixWithNullPrefixAndNoColonInName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPrefix()).thenReturn(null); [EOL] when(node.getNodeName()).thenReturn("nodeName"); [EOL] String result = ClassName.getPrefix(node); [EOL] assertNull(result); [EOL] }
public void testGetPrefixWithNullPrefixAndColonInName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPrefix()).thenReturn(null); [EOL] when(node.getNodeName()).thenReturn("ns:nodeName"); [EOL] String result = ClassName.getPrefix(node); [EOL] assertEquals("ns", result); [EOL] }
public void testGetLocalNameWithNonNullLocalName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getLocalName()).thenReturn("localName"); [EOL] String result = ClassName.getLocalName(node); [EOL] assertEquals("localName", result); [EOL] }
public void testGetLocalNameWithNullLocalNameAndNoColonInNodeName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getLocalName()).thenReturn(null); [EOL] when(node.getNodeName()).thenReturn("nodeName"); [EOL] String result = ClassName.getLocalName(node); [EOL] assertEquals("nodeName", result); [EOL] }
public void testGetLocalNameWithNullLocalNameAndColonInNodeName() { [EOL] Node node = mock(Node.class); [EOL] when(node.getLocalName()).thenReturn(null); [EOL] when(node.getNodeName()).thenReturn("prefix:nodeName"); [EOL] String result = ClassName.getLocalName(node); [EOL] assertEquals("nodeName", result); [EOL] }
public void testGetNamespaceURINodeIsDocument() { [EOL] Node node = mock(Document.class); [EOL] Element element = mock(Element.class); [EOL] when(((Document) node).getDocumentElement()).thenReturn(element); [EOL] when(element.getNamespaceURI()).thenReturn("http://example.com"); [EOL] String result = jxPath.getNamespaceURI(node); [EOL] assertEquals("http://example.com", result); [EOL] }
public void testGetNamespaceURINodeIsElementWithNonNullUri() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespaceURI()).thenReturn("http://example.com"); [EOL] String result = jxPath.getNamespaceURI(node); [EOL] assertEquals("http://example.com", result); [EOL] }
public void testGetNamespaceURINodeIsElementWithNullUriAndNoPrefix() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespaceURI()).thenReturn(null); [EOL] when(jxPath.getPrefix(node)).thenReturn(null); [EOL] when(((Element) node).getAttributeNode("xmlns")).thenReturn(null); [EOL] String result = jxPath.getNamespaceURI(node); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceURINodeIsElementWithNullUriAndPrefix() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespaceURI()).thenReturn(null); [EOL] when(jxPath.getPrefix(node)).thenReturn("ex"); [EOL] when(((Element) node).getAttributeNode("xmlns:ex")).thenReturn(null); [EOL] String result = jxPath.getNamespaceURI(node); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceURINodeIsElementWithNullUriAndPrefixAttributeExists() { [EOL] Node node = mock(Element.class); [EOL] Attr attr = mock(Attr.class); [EOL] when(((Element) node).getNamespaceURI()).thenReturn(null); [EOL] when(jxPath.getPrefix(node)).thenReturn("ex"); [EOL] when(((Element) node).getAttributeNode("xmlns:ex")).thenReturn(attr); [EOL] when(attr.getValue()).thenReturn("http://example.com"); [EOL] String result = jxPath.getNamespaceURI(node); [EOL] assertEquals("http://example.com", result); [EOL] }
public void testGetValueWhenNodeIsNull() { [EOL] instance.setNode(null); [EOL] Object result = instance.getValue(); [EOL] assertNull("Expected the result to be null when node is null", result); [EOL] } [EOL] public void testGetValueWhenNodeIsNotNull() { [EOL] Node node = createNodeWithStringValue("testValue"); [EOL] instance.setNode(node); [EOL] Object result = instance.getValue(); [EOL] assertEquals("Expected the result to be the string value of the node", "testValue", result); [EOL] }
public void testStringValueWithCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] when(node.getData()).thenReturn(" This is a comment "); [EOL] String result = stringValue(node); [EOL] assertEquals("This is a comment", result); [EOL] }
public void testStringValueWithTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(node.getNodeValue()).thenReturn(" This is a text node "); [EOL] String result = stringValue(node); [EOL] assertEquals("This is a text node", result); [EOL] }
public void testStringValueWithCDataSectionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE); [EOL] when(node.getNodeValue()).thenReturn(" This is a CDATA section "); [EOL] String result = stringValue(node); [EOL] assertEquals("This is a CDATA section", result); [EOL] }
public void testStringValueWithProcessingInstructionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] when(node.getData()).thenReturn("data"); [EOL] when(pi.getData()).thenReturn(" This is processing instruction data "); [EOL] String result = stringValue(node); [EOL] assertEquals("This is processing instruction data", result); [EOL] }
public void testStringValueWithOtherNodeHavingTextChild() { [EOL] Node node = mock(Node.class); [EOL] Node childNode = mock(Node.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(childNode); [EOL] when(childNode.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(childNode.getNodeValue()).thenReturn(" Child text node "); [EOL] String result = stringValue(node); [EOL] assertEquals("Child text node", result); [EOL] }
public void testStringValueWithOtherNodeHavingNonTextChild() { [EOL] Node node = mock(Node.class); [EOL] Node childNode = mock(Node.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(childNode); [EOL] when(childNode.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(childNode.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(0); [EOL] String result = stringValue(node); [EOL] assertEquals("", result); [EOL] }
public void testComputeContextDependent() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testJDOMNamespacePointerWithNullParentAndNullPrefix() { [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(null, null); [EOL] assertNull(pointer.getParent()); [EOL] assertNull(pointer.getPrefix()); [EOL] }
public void testJDOMNamespacePointerWithNullParentAndNonNullPrefix() { [EOL] String prefix = "testPrefix"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(null, prefix); [EOL] assertNull(pointer.getParent()); [EOL] assertEquals(prefix, pointer.getPrefix()); [EOL] }
public void testJDOMNamespacePointerWithNonNullParentAndNullPrefix() { [EOL] NodePointer parent = new NodePointer() { [EOL] }; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(parent, null); [EOL] assertEquals(parent, pointer.getParent()); [EOL] assertNull(pointer.getPrefix()); [EOL] }
public void testJDOMNamespacePointerWithNonNullParentAndNonNullPrefix() { [EOL] NodePointer parent = new NodePointer() { [EOL] }; [EOL] String prefix = "testPrefix"; [EOL] JDOMNamespacePointer pointer = new JDOMNamespacePointer(parent, prefix); [EOL] assertEquals(parent, pointer.getParent()); [EOL] assertEquals(prefix, pointer.getPrefix()); [EOL] }
public void testDOMNodeIteratorWithNonNullStartWith() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Node node = mock(Node.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] Node startNode = mock(Node.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(startWith.getNode()).thenReturn(startNode); [EOL] DOMNodeIterator iterator = new DOMNodeIterator(parent, nodeTest, false, startWith); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(node, iterator.node); [EOL] assertEquals(startNode, iterator.child); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testDOMNodeIteratorWithNullStartWith() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Node node = mock(Node.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] DOMNodeIterator iterator = new DOMNodeIterator(parent, nodeTest, true, null); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(node, iterator.node); [EOL] assertNull(iterator.child); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertTrue(iterator.reverse); [EOL] }
public void testGetNodePointer_PositionIsZero() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] instance.child = mock(Node.class); [EOL] instance.parent = mock(Node.class); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodePointer); [EOL] assertEquals(instance.child, result.getNode()); [EOL] }
public void testGetNodePointer_PositionIsNotZero_ChildIsNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 1; // Any non-zero value [EOL] instance.child = null; [EOL] instance.parent = mock(Node.class); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionIsNotZero_ChildIsNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 1; // Any non-zero value [EOL] instance.child = mock(Node.class); [EOL] instance.parent = mock(Node.class); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodePointer); [EOL] assertEquals(instance.child, result.getNode()); [EOL] }
public void testSetPosition_IncreasePosition() { [EOL] YourIteratorClass instance = new YourIteratorClass(); [EOL] int newPosition = 5; [EOL] for (int i = 0; i < newPosition; i++) { [EOL] instance.next(); // Increment position to the desired one [EOL] } [EOL] boolean result = instance.setPosition(newPosition); [EOL] assertTrue(result); [EOL] assertEquals(newPosition, instance.getPosition()); [EOL] }
public void testSetPosition_DecreasePosition() { [EOL] YourIteratorClass instance = new YourIteratorClass(); [EOL] int initialPosition = 10; [EOL] for (int i = 0; i < initialPosition; i++) { [EOL] instance.next(); // Increment position to 10 [EOL] } [EOL] int newPosition = 5; [EOL] boolean result = instance.setPosition(newPosition); [EOL] assertTrue(result); [EOL] assertEquals(newPosition, instance.getPosition()); [EOL] }
public void testSetPosition_NextReturnsFalse() { [EOL] YourIteratorClass instance = new YourIteratorClass(); [EOL] int newPosition = 5; [EOL] for (int i = 0; i < newPosition - 1; i++) { [EOL] instance.next(); // Increment position to one less than the desired one [EOL] } [EOL] mockNextToReturnFalse(instance); [EOL] boolean result = instance.setPosition(newPosition); [EOL] assertFalse(result); [EOL] }
public void testSetPosition_PreviousReturnsFalse() { [EOL] YourIteratorClass instance = new YourIteratorClass(); [EOL] int initialPosition = 10; [EOL] for (int i = 0; i < initialPosition; i++) { [EOL] instance.next(); // Increment position to 10 [EOL] } [EOL] int newPosition = 5; [EOL] for (int i = 0; i < 4; i++) { [EOL] instance.previous(); // Decrement position to one more than the desired one [EOL] } [EOL] mockPreviousToReturnFalse(instance); [EOL] boolean result = instance.setPosition(newPosition); [EOL] assertFalse(result); [EOL] }
private boolean next() { [EOL] position++; [EOL] if (!reverse) { [EOL] if (position == 1) { [EOL] if (child == null) { [EOL] child = node.getFirstChild(); [EOL] } else { [EOL] child = child.getNextSibling(); [EOL] } [EOL] } else { [EOL] child = child.getNextSibling(); [EOL] } [EOL] while (child != null && !testChild()) { [EOL] child = child.getNextSibling(); [EOL] } [EOL] } else { [EOL] if (position == 1) { [EOL] if (child == null) { [EOL] child = node.getLastChild(); [EOL] } else { [EOL] child = child.getPreviousSibling(); [EOL] } [EOL] } else { [EOL] child = child.getPreviousSibling(); [EOL] } [EOL] while (child != null && !testChild()) { [EOL] child = child.getPreviousSibling(); [EOL] } [EOL] } [EOL] return child != null; [EOL] }
public void testTestChild_NodeTestReturnsTrue() { [EOL] DOMNodePointer childPointer = Mockito.mock(DOMNodePointer.class); [EOL] NodeTest nodeTest = Mockito.mock(NodeTest.class); [EOL] Mockito.when(DOMNodePointer.testNode(childPointer, nodeTest)).thenReturn(true); [EOL] boolean result = childPointer.testChild(); [EOL] assertTrue(result); [EOL] }
public void testTestChild_NodeTestReturnsFalse() { [EOL] DOMNodePointer childPointer = Mockito.mock(DOMNodePointer.class); [EOL] NodeTest nodeTest = Mockito.mock(NodeTest.class); [EOL] Mockito.when(DOMNodePointer.testNode(childPointer, nodeTest)).thenReturn(false); [EOL] boolean result = childPointer.testChild(); [EOL] assertFalse(result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorIsNull() { [EOL] setPosition(0); [EOL] setIterator(null); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorHasNonNullPointer() { [EOL] setPosition(0); [EOL] setIteratorWithNonNullPointer(); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsNotZero() { [EOL] setPosition(1); // Any non-zero value [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testSetPositionWithNonZeroOldPositionAndNonNullIterator() { [EOL] int position = 5; [EOL] setCurrentPosition(1); [EOL] iterator = mock(Iterator.class); [EOL] when(iterator.setPosition(position)).thenReturn(true); [EOL] boolean result = setPosition(position); [EOL] verify(this, never()).prepare(); [EOL] verify(iterator).setPosition(position); [EOL] assertTrue(result); [EOL] }
public void testSetPositionWithZeroOldPositionAndNonNullIterator() { [EOL] int position = 5; [EOL] setCurrentPosition(0); [EOL] iterator = mock(Iterator.class); [EOL] when(iterator.setPosition(position)).thenReturn(true); [EOL] boolean result = setPosition(position); [EOL] verify(this).prepare(); [EOL] verify(iterator).setPosition(position); [EOL] assertTrue(result); [EOL] }
public void testSetPositionWithNonNullIteratorReturningFalse() { [EOL] int position = 5; [EOL] setCurrentPosition(1); [EOL] iterator = mock(Iterator.class); [EOL] when(iterator.setPosition(position)).thenReturn(false); [EOL] boolean result = setPosition(position); [EOL] verify(this, never()).prepare(); [EOL] verify(iterator).setPosition(position); [EOL] assertFalse(result); [EOL] }
public void testSetPositionWithNullIterator() { [EOL] int position = 5; [EOL] setCurrentPosition(1); [EOL] iterator = null; [EOL] boolean result = setPosition(position); [EOL] verify(this, never()).prepare(); [EOL] assertFalse(result); [EOL] }
public void testConvertWithNullObject() { [EOL] Object result = ClassName.convert(null, String.class); [EOL] assertNull(result); [EOL] } [EOL] public void testConvertWithNonNullObject() { [EOL] Object inputObject = "test"; [EOL] Object result = ClassName.convert(inputObject, String.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof String); [EOL] assertEquals("test", result); [EOL] } [EOL] public void testConvertWithIncompatibleType() { [EOL] Object inputObject = "test"; [EOL] try { [EOL] Object result = ClassName.convert(inputObject, Integer.class); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testAsPathWithParentAndIndexNotWholeCollection() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] when(parent.asPath()).thenReturn("/parentPath"); [EOL] when(parent.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION - 1); [EOL] NodePointer child = new ConcreteNodePointer(parent, 1); [EOL] String result = child.asPath(); [EOL] assertEquals("/parentPath/.[2]", result); [EOL] }
public void testAsPathWithParentAndIndexWholeCollection() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] when(parent.asPath()).thenReturn("/parentPath"); [EOL] when(parent.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] NodePointer child = new ConcreteNodePointer(parent, NodePointer.WHOLE_COLLECTION); [EOL] String result = child.asPath(); [EOL] assertEquals("/parentPath", result); [EOL] }
public void testAsPathWithoutParentAndIndexNotWholeCollection() { [EOL] NodePointer child = new ConcreteNodePointer(null, 1); [EOL] String result = child.asPath(); [EOL] assertEquals("/.[2]", result); [EOL] }
public void testAsPathWithoutParentAndIndexWholeCollection() { [EOL] NodePointer child = new ConcreteNodePointer(null, NodePointer.WHOLE_COLLECTION); [EOL] String result = child.asPath(); [EOL] assertEquals("/", result); [EOL] }
public void testUnionContextWithNullParentContextAndNullContexts() { [EOL] UnionContext unionContext = new UnionContext(null, null); [EOL] assertNull(unionContext.getContexts()); [EOL] }
public void testUnionContextWithNonNullParentContextAndNullContexts() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] UnionContext unionContext = new UnionContext(parentContext, null); [EOL] assertNull(unionContext.getContexts()); [EOL] }
public void testUnionContextWithNullParentContextAndEmptyContexts() { [EOL] UnionContext unionContext = new UnionContext(null, new EvalContext[0]); [EOL] assertEquals(0, unionContext.getContexts().length); [EOL] }
public void testUnionContextWithNonNullParentContextAndEmptyContexts() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] UnionContext unionContext = new UnionContext(parentContext, new EvalContext[0]); [EOL] assertEquals(0, unionContext.getContexts().length); [EOL] }
public void testUnionContextWithNonNullParentContextAndNonNullContexts() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] EvalContext[] contexts = new EvalContext[] {mock(EvalContext.class), mock(EvalContext.class)}; [EOL] UnionContext unionContext = new UnionContext(parentContext, contexts); [EOL] assertEquals(2, unionContext.getContexts().length); [EOL] }
public void testGetDocumentOrder_MultipleContexts() { [EOL] this.contexts = new Context[2]; // or any other relevant type [EOL] int order = getDocumentOrder(); [EOL] assertEquals(1, order); [EOL] }
public void testGetDocumentOrder_SingleContext() { [EOL] this.contexts = new Context[1]; // or any other relevant type [EOL] int order = getDocumentOrder(); [EOL] int expectedOrder = super.getDocumentOrder(); [EOL] assertEquals(expectedOrder, order); [EOL] }
public void testSetPositionNotPrepared() { [EOL] YourClass instance = new YourClass(); [EOL] int position = 1; [EOL] boolean result = instance.setPosition(position); [EOL] boolean expectedResult = true; // Assuming super.setPosition returns true [EOL] assertEquals(expectedResult, result); [EOL] assertTrue(instance.prepared); [EOL] }
public void testSetPositionAlreadyPrepared() { [EOL] YourClass instance = new YourClass(); [EOL] instance.prepared = true; [EOL] int position = 1; [EOL] boolean result = instance.setPosition(position); [EOL] boolean expectedResult = true; // Assuming super.setPosition returns true [EOL] assertEquals(expectedResult, result); [EOL] }
public void testPropertyPointerWithNonNullParent() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] PropertyPointer propertyPointer = new PropertyPointer(parent); [EOL] assertNotNull(propertyPointer.getParent()); [EOL] }
public void testPropertyPointerWithNullParent() { [EOL] PropertyPointer propertyPointer = new PropertyPointer(null); [EOL] assertNull(propertyPointer.getParent()); [EOL] }
public void testGetPropertyIndex() { [EOL] MyClass instance = new MyClass(); [EOL] int expected = 0; // Assuming default value or set it to the value you expect [EOL] instance.propertyIndex = expected; [EOL] int result = instance.getPropertyIndex(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetBeanWhenBeanIsNull() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] Object expectedNode = new Object(); [EOL] when(parentPointer.getNode()).thenReturn(expectedNode); [EOL] MyClass instance = new MyClass(); [EOL] instance.setImmediateParentPointer(parentPointer); // Assuming there's a method to set the parent pointer [EOL] Object result = instance.getBean(); [EOL] assertEquals(expectedNode, result); [EOL] }
public void testGetBeanWhenBeanIsNotNull() { [EOL] Object initialBean = new Object(); [EOL] MyClass instance = new MyClass(); [EOL] instance.setBean(initialBean); // Assuming there's a method to set the bean [EOL] Object result = instance.getBean(); [EOL] assertEquals(initialBean, result); [EOL] }
public QName getName() { [EOL] return new QName(null, getPropertyName()); [EOL] }
public void testIsActualWhenPropertyIsNotActual() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest() { [EOL] @Override [EOL] public boolean isActualProperty() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean isActual() { [EOL] return super.isActual(); [EOL] } [EOL] }; [EOL] boolean result = obj.isActual(); [EOL] assertFalse(result); [EOL] }
public void testIsActualWhenPropertyIsActual() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest() { [EOL] @Override [EOL] public boolean isActualProperty() { [EOL] return true; [EOL] } [EOL] @Override [EOL] public boolean isActual() { [EOL] return true; // Assuming the super implementation returns true [EOL] } [EOL] }; [EOL] boolean result = obj.isActual(); [EOL] assertTrue(result); [EOL] }
public void testGetImmediateValuePointer() { [EOL] NodePointer result = nodePointer.getImmediateValuePointer(); [EOL] assertNotNull(result); [EOL] assertEquals(nodePointer.getName(), result.getName()); [EOL] assertEquals(nodePointer.getImmediateNode(), result.getImmediateNode()); [EOL] }
public void testCreatePathWithIndexLessThanLength() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] int index = 0; [EOL] int length = 1; [EOL] NodePointer nodePointer = new ConcreteNodePointer(index, length); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, nodePointer.getValue()); [EOL] }
public void testCreatePathWithIndexEqualToWholeCollection() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] int index = NodePointer.WHOLE_COLLECTION; [EOL] int length = 0; [EOL] NodePointer nodePointer = new ConcreteNodePointer(index, length); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, nodePointer.getValue()); [EOL] }
public void testCreatePathWithIndexGreaterThanOrEqualToLength() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object value = new Object(); [EOL] int index = 1; [EOL] int length = 1; [EOL] NodePointer nodePointer = new ConcreteNodePointer(index, length); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, nodePointer.getValue()); [EOL] }
public void testCreateChildWithNonNullName() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("testName"); [EOL] int index = 1; [EOL] PropertyPointer propPointer = mock(PropertyPointer.class); [EOL] PropertyPointer clonedPropPointer = mock(PropertyPointer.class); [EOL] NodePointer resultNodePointer = mock(NodePointer.class); [EOL] when(propPointer.clone()).thenReturn(clonedPropPointer); [EOL] when(clonedPropPointer.createPath(context)).thenReturn(resultNodePointer); [EOL] NodePointer result = propPointer.createChild(context, name, index); [EOL] verify(clonedPropPointer).setPropertyName("testName"); [EOL] verify(clonedPropPointer).setIndex(index); [EOL] assertSame("Expected result node pointer is not returned", resultNodePointer, result); [EOL] }
public void testCreateChildWithNullName() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = null; [EOL] int index = 1; [EOL] PropertyPointer propPointer = mock(PropertyPointer.class); [EOL] PropertyPointer clonedPropPointer = mock(PropertyPointer.class); [EOL] NodePointer resultNodePointer = mock(NodePointer.class); [EOL] when(propPointer.clone()).thenReturn(clonedPropPointer); [EOL] when(clonedPropPointer.createPath(context)).thenReturn(resultNodePointer); [EOL] NodePointer result = propPointer.createChild(context, name, index); [EOL] verify(clonedPropPointer, never()).setPropertyName(anyString()); [EOL] verify(clonedPropPointer).setIndex(index); [EOL] assertSame("Expected result node pointer is not returned", resultNodePointer, result); [EOL] }
public void testEquals_SameObject() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] assertTrue(pp.equals(pp)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] Object other = new Object(); [EOL] assertFalse(pp.equals(other)); [EOL] } [EOL] public void testEquals_NullParent() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.parent = null; [EOL] other.parent = new PropertyPointer(); [EOL] assertFalse(pp.equals(other)); [EOL] } [EOL] public void testEquals_DifferentParent() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.parent = new PropertyPointer(); [EOL] other.parent = new PropertyPointer(); [EOL] when(pp.parent.equals(other.parent)).thenReturn(false); [EOL] assertFalse(pp.equals(other)); [EOL] } [EOL] public void testEquals_SameParent() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.parent = new PropertyPointer(); [EOL] other.parent = pp.parent; [EOL] when(pp.getPropertyIndex()).thenReturn(1); [EOL] when(other.getPropertyIndex()).thenReturn(1); [EOL] when(pp.getPropertyName()).thenReturn("name"); [EOL] when(other.getPropertyName()).thenReturn("name"); [EOL] assertTrue(pp.equals(other)); [EOL] } [EOL] public void testEquals_DifferentPropertyIndex() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.parent = new PropertyPointer(); [EOL] other.parent = pp.parent; [EOL] when(pp.getPropertyIndex()).thenReturn(1); [EOL] when(other.getPropertyIndex()).thenReturn(2); [EOL] assertFalse(pp.equals(other)); [EOL] } [EOL] public void testEquals_DifferentPropertyName() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.parent = new PropertyPointer(); [EOL] other.parent = pp.parent; [EOL] when(pp.getPropertyIndex()).thenReturn(1); [EOL] when(other.getPropertyIndex()).thenReturn(1); [EOL] when(pp.getPropertyName()).thenReturn("name"); [EOL] when(other.getPropertyName()).thenReturn("differentName"); [EOL] assertFalse(pp.equals(other)); [EOL] } [EOL] public void testEquals_DifferentIndexWholeCollection() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.index = PropertyPointer.WHOLE_COLLECTION; [EOL] other.index = 1; [EOL] assertFalse(pp.equals(other)); [EOL] } [EOL] public void testEquals_SameIndexWholeCollection() { [EOL] PropertyPointer pp = new PropertyPointer(); [EOL] PropertyPointer other = new PropertyPointer(); [EOL] pp.index = PropertyPointer.WHOLE_COLLECTION; [EOL] other.index = PropertyPointer.WHOLE_COLLECTION; [EOL] assertTrue(pp.equals(other)); [EOL] }

public void testCreateNodePointerWithContainer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Container container = mock(Container.class); [EOL] NodePointer result = createNodePointer(parent, name, container); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ContainerPointer); [EOL] }
public void testCreateNodePointerWithNonContainer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object nonContainerBean = new Object(); [EOL] NodePointer result = createNodePointer(parent, name, nonContainerBean); [EOL] assertNull(result); [EOL] }
public void testCreateNodePointerWithDynaBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] DynaBean dynaBean = mock(DynaBean.class); [EOL] NodePointer result = createNodePointer(parent, name, dynaBean); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DynaBeanPointer); [EOL] }
public void testCreateNodePointerWithNonDynaBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object nonDynaBean = new Object(); [EOL] NodePointer result = createNodePointer(parent, name, nonDynaBean); [EOL] assertNull(result); [EOL] }
public void testComputeValueWithValidArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(2.0); [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertEquals("The division result should be correct", 5.0, (Double) result, 0.001); [EOL] }
public void testComputeValueWithZeroDenominator() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(0.0); [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertTrue("The result should be Infinity when denominator is zero", Double.isInfinite((Double) result)); [EOL] }
public void testGetValueWithNullResultAndNonLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(null); [EOL] try { [EOL] Object result = context.getValue("nonexistent", expr); [EOL] fail("Expected JXPathNotFoundException to be thrown"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNullResultAndLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(null); [EOL] Object result = context.getValue("nonexistent", expr); [EOL] assertNull(result); [EOL] }
public void testGetValueWithEvalContextResultAndSingleNodePointer() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] when(nodePointer.getValue()).thenReturn("expectedValue"); [EOL] Object result = context.getValue("existent", expr); [EOL] assertEquals("expectedValue", result); [EOL] }
public void testGetValueWithEvalContextResultAndNullSingleNodePointerNonLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(null); [EOL] try { [EOL] Object result = context.getValue("nonexistent", expr); [EOL] fail("Expected JXPathNotFoundException to be thrown"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNodePointerResultAndNonActualValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] NodePointer parentNodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.getValuePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] when(nodePointer.getImmediateParentPointer()).thenReturn(parentNodePointer); [EOL] when(parentNodePointer.isContainer()).thenReturn(true); [EOL] when(parentNodePointer.isActual()).thenReturn(false); [EOL] try { [EOL] Object result = context.getValue("nonexistent", expr); [EOL] fail("Expected JXPathNotFoundException to be thrown"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNodePointerResultAndActualValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.getValuePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] when(nodePointer.getValue()).thenReturn("expectedValue"); [EOL] Object result = context.getValue("existent", expr); [EOL] assertEquals("expectedValue", result); [EOL] }
public Object getValueTestWithValidArguments() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object result = context.getValue("/valid/xpath", String.class); [EOL] assertNotNull(result); [EOL] }
public Object getValueTestWithInvalidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] try { [EOL] context.getValue("invalid:xpath", String.class); [EOL] fail("Should have thrown an exception for invalid XPath"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public Object getValueTestWithNullRequiredType() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] try { [EOL] context.getValue("/valid/xpath", null); [EOL] fail("Should have thrown an exception for null requiredType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetValueWithNonNullValueAndRequiredType() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Class<?> requiredType = String.class; [EOL] Object result = context.getValue(xpath, expr, requiredType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof String); [EOL] }
public void testGetValueWithNonNullValueAndInconvertibleType() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Class<?> requiredType = Integer.class; [EOL] try { [EOL] context.getValue(xpath, expr, requiredType); [EOL] fail("Expected JXPathTypeConversionException was not thrown."); [EOL] } catch (JXPathTypeConversionException e) { [EOL] assertNotNull(e.getMessage()); [EOL] assertTrue(e.getMessage().contains("It cannot be converted to " + requiredType.getName())); [EOL] } [EOL] }
public void testGetValueWithNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/invalid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Class<?> requiredType = String.class; [EOL] Object result = context.getValue(xpath, expr, requiredType); [EOL] assertNull(result); [EOL] }
public void testGetValueWithNullRequiredType() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Object result = context.getValue(xpath, expr, null); [EOL] assertNotNull(result); [EOL] }
public void testGetPointerWithEvalContextResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertSame(nodePointer, result); [EOL] }
public void testGetPointerWithNodePointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertSame(nodePointer, result); [EOL] }
public void testGetPointerWithNonActualNodePointerAndLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertSame(nodePointer, result); [EOL] }
public void testGetPointerWithNonActualNodePointerAndNotLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] try { [EOL] context.getPointer("some/xpath", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetPointerWithNonPointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] Object nonPointerResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nonPointerResult); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
public void testSetValueWithValidArguments() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] } catch (JXPathException e) { [EOL] fail("Should not have thrown an exception with valid arguments"); [EOL] } [EOL] }
public void testSetValueWithInvalidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/invalid/xpath"; [EOL] Expression expr = context.compile(xpath); [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] fail("Should have thrown a JXPathException with invalid XPath"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testSetValueWithNullXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = null; [EOL] Expression expr = context.compile("/valid/xpath"); [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] fail("Should have thrown a NullPointerException with null XPath"); [EOL] } catch (NullPointerException e) { [EOL] } catch (JXPathException e) { [EOL] fail("Should have thrown a NullPointerException, not a JXPathException"); [EOL] } [EOL] }
public void testSetValueWithNullExpression() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = null; [EOL] Object value = "new value"; [EOL] try { [EOL] context.setValue(xpath, expr, value); [EOL] fail("Should have thrown a NullPointerException with null Expression"); [EOL] } catch (NullPointerException e) { [EOL] } catch (JXPathException e) { [EOL] fail("Should have thrown a NullPointerException, not a JXPathException"); [EOL] } [EOL] }
public Pointer createPath(String xpath) { [EOL] return createPath(xpath, compileExpression(xpath)); [EOL] }
public void testCreatePathWithPointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(expectedPointer); [EOL] Pointer result = context.createPath("dummyXPath", expr); [EOL] assertNotNull("The result should not be null", result); [EOL] assertTrue("The result should be a NodePointer", result instanceof NodePointer); [EOL] }
public void testCreatePathWithEvalContextResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer expectedPointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = context.createPath("dummyXPath", expr); [EOL] assertNotNull("The result should not be null", result); [EOL] assertTrue("The result should be a NodePointer", result instanceof NodePointer); [EOL] }
public void testCreatePathWithInvalidResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(new Object()); [EOL] try { [EOL] context.createPath("invalidXPath", expr); [EOL] fail("JXPathException expected for non-Pointer, non-EvalContext result"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot create path:invalidXPath", e.getMessage()); [EOL] } [EOL] }
public void testCreatePathWithException() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenThrow(new RuntimeException("Test Exception")); [EOL] try { [EOL] context.createPath("exceptionXPath", expr); [EOL] fail("JXPathException expected when an exception is thrown"); [EOL] } catch (JXPathException e) { [EOL] assertTrue(e.getMessage().contains("Exception trying to create xpath exceptionXPath")); [EOL] assertNotNull("The cause should be set", e.getCause()); [EOL] } [EOL] }
public void testSetValueWithPointerResultAndCreateTrue() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = true; [EOL] Pointer mockPointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(mockPointer); [EOL] doNothing().when((NodePointer) mockPointer).createPath(any(JXPathContext.class), any()); [EOL] Pointer result = setValue(xpath, expr, value, create); [EOL] assertNotNull(result); [EOL] verify((NodePointer) mockPointer).createPath(any(JXPathContext.class), eq(value)); [EOL] }
public void testSetValueWithPointerResultAndCreateFalse() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = false; [EOL] Pointer mockPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(mockPointer); [EOL] doNothing().when(mockPointer).setValue(any()); [EOL] Pointer result = setValue(xpath, expr, value, create); [EOL] assertNotNull(result); [EOL] verify(mockPointer).setValue(eq(value)); [EOL] }
public void testSetValueWithEvalContextResult() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = false; [EOL] EvalContext mockEvalContext = mock(EvalContext.class); [EOL] Pointer mockPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(mockEvalContext); [EOL] when(mockEvalContext.getSingleNodePointer()).thenReturn(mockPointer); [EOL] doNothing().when(mockPointer).setValue(any()); [EOL] Pointer result = setValue(xpath, expr, value, create); [EOL] assertNotNull(result); [EOL] verify(mockEvalContext).getSingleNodePointer(); [EOL] verify(mockPointer).setValue(eq(value)); [EOL] }
public void testSetValueWithNonPointerNonEvalContextResultAndCreateTrue() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = true; [EOL] Object nonPointerResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nonPointerResult); [EOL] try { [EOL] setValue(xpath, expr, value, create); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot set value for xpath: " + xpath, e.getMessage()); [EOL] } [EOL] }
public void testSetValueWithNonPointerNonEvalContextResultAndCreateFalse() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Object value = new Object(); [EOL] boolean create = false; [EOL] Object nonPointerResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nonPointerResult); [EOL] try { [EOL] setValue(xpath, expr, value, create); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot set value for xpath: " + xpath, e.getMessage()); [EOL] } [EOL] }
public void testCheckSimplePathWithNonLocationPathExpression() { [EOL] Expression expr = new Expression() { [EOL] }; [EOL] try { [EOL] checkSimplePath(expr); [EOL] fail("JXPathInvalidSyntaxException expected"); [EOL] } catch (JXPathInvalidSyntaxException e) { [EOL] assertEquals("JXPath can only create a path if it uses exclusively the child:: and attribute:: axes and has no context-dependent predicates", e.getMessage()); [EOL] } [EOL] }
public void testCheckSimplePathWithComplexLocationPath() { [EOL] LocationPath locationPath = new LocationPath() { [EOL] public boolean isSimplePath() { [EOL] return false; [EOL] } [EOL] }; [EOL] try { [EOL] checkSimplePath(locationPath); [EOL] fail("JXPathInvalidSyntaxException expected"); [EOL] } catch (JXPathInvalidSyntaxException e) { [EOL] assertEquals("JXPath can only create a path if it uses exclusively the child:: and attribute:: axes and has no context-dependent predicates", e.getMessage()); [EOL] } [EOL] }
public void testCheckSimplePathWithSimpleLocationPath() { [EOL] LocationPath locationPath = new LocationPath() { [EOL] public boolean isSimplePath() { [EOL] return true; [EOL] } [EOL] }; [EOL] try { [EOL] checkSimplePath(locationPath); [EOL] } catch (JXPathInvalidSyntaxException e) { [EOL] fail("JXPathInvalidSyntaxException not expected"); [EOL] } [EOL] }
public void testRemovePathWithValidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String validXPath = "/valid/xpath"; [EOL] context.removePath(validXPath); [EOL] }
public void testRemovePathWithInvalidXPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String invalidXPath = "/invalid/xpath"; [EOL] try { [EOL] context.removePath(invalidXPath); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testRemovePathWithValidPointer() { [EOL] String xpath = "/valid/xpath"; [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] when(getPointer(xpath, expr)).thenReturn(mockPointer); [EOL] removePath(xpath, expr); [EOL] verify(mockPointer).remove(); [EOL] }
public void testRemovePathWithNullPointer() { [EOL] String xpath = "/invalid/xpath"; [EOL] Expression expr = mock(Expression.class); [EOL] when(getPointer(xpath, expr)).thenReturn(null); [EOL] removePath(xpath, expr); [EOL] verify(getPointer(xpath, expr), never()).remove(); [EOL] }
public void testRemovePathWithException() { [EOL] String xpath = "/exception/xpath"; [EOL] Expression expr = mock(Expression.class); [EOL] Throwable throwable = new RuntimeException("Test Exception"); [EOL] when(getPointer(xpath, expr)).thenThrow(throwable); [EOL] try { [EOL] removePath(xpath, expr); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException ex) { [EOL] assertEquals("Exception trying to remove xpath " + xpath, ex.getMessage()); [EOL] assertSame(throwable, ex.getCause()); [EOL] } [EOL] }
public void testRegisterNamespaceWithUnsealedResolver() { [EOL] NamespaceResolver mockResolver = Mockito.mock(NamespaceResolver.class); [EOL] Mockito.when(mockResolver.isSealed()).thenReturn(false); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setNamespaceResolver(mockResolver); [EOL] context.registerNamespace("prefix", "namespaceURI"); [EOL] Mockito.verify(mockResolver).registerNamespace("prefix", "namespaceURI"); [EOL] }
public void testRegisterNamespaceWithSealedResolver() { [EOL] NamespaceResolver mockResolver = Mockito.mock(NamespaceResolver.class); [EOL] Mockito.when(mockResolver.isSealed()).thenReturn(true); [EOL] Mockito.when(mockResolver.clone()).thenReturn(mockResolver); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setNamespaceResolver(mockResolver); [EOL] context.registerNamespace("prefix", "namespaceURI"); [EOL] Mockito.verify(mockResolver).registerNamespace("prefix", "namespaceURI"); [EOL] Mockito.verify(mockResolver).clone(); [EOL] }
public void testComputeValue_PositiveNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] when(expression.computeValue(context)).thenReturn(10.0); [EOL] UnaryMinusFunction function = new UnaryMinusFunction(new Expression[]{expression}); [EOL] Object result = function.computeValue(context); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(-10.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testComputeValue_NegativeNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] when(expression.computeValue(context)).thenReturn(-10.0); [EOL] UnaryMinusFunction function = new UnaryMinusFunction(new Expression[]{expression}); [EOL] Object result = function.computeValue(context); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(10.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testComputeValue_Zero() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression expression = mock(Expression.class); [EOL] when(expression.computeValue(context)).thenReturn(0.0); [EOL] UnaryMinusFunction function = new UnaryMinusFunction(new Expression[]{expression}); [EOL] Object result = function.computeValue(context); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(0.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testGetNodeSet() { [EOL] YourClass instance = new YourClass(); [EOL] NodeSet expected = new NodeSet(); [EOL] instance.nodeSet = expected; [EOL] NodeSet result = instance.getNodeSet(); [EOL] assertSame(expected, result); [EOL] }
public void testComputeContextDependentWithNullArgs() { [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependentWithEmptyArgs() { [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependentWithAllNonContextDependentArgs() { [EOL] boolean result = computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependentWithAtLeastOneContextDependentArg() { [EOL] boolean result = computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeValueWithNonEvalContextArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] ConstantContext constantContext = mock(ConstantContext.class); [EOL] when(rootContext.getConstantContext(any())).thenReturn(constantContext); [EOL] Function[] args = new Function[] { mock(Function.class), mock(Function.class) }; [EOL] when(args[0].compute(context)).thenReturn(new Object()); [EOL] when(args[1].compute(context)).thenReturn(new Object()); [EOL] Object result = computeValue(context); [EOL] assertTrue(result instanceof UnionContext); [EOL] UnionContext unionContext = (UnionContext) result; [EOL] assertEquals(rootContext, unionContext.getRootContext()); [EOL] assertArrayEquals(new EvalContext[] { constantContext, constantContext }, unionContext.getArgContexts()); [EOL] }
public void testComputeValueWithEvalContextArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] Function[] args = new Function[] { mock(Function.class), mock(Function.class) }; [EOL] EvalContext argEvalContext = mock(EvalContext.class); [EOL] when(args[0].compute(context)).thenReturn(argEvalContext); [EOL] when(args[1].compute(context)).thenReturn(new Object()); [EOL] when(rootContext.getConstantContext(any())).thenReturn(mock(ConstantContext.class)); [EOL] Object result = computeValue(context); [EOL] assertTrue(result instanceof UnionContext); [EOL] UnionContext unionContext = (UnionContext) result; [EOL] assertEquals(rootContext, unionContext.getRootContext()); [EOL] assertArrayEquals(new EvalContext[] { argEvalContext, mock(ConstantContext.class) }, unionContext.getArgContexts()); [EOL] }
public void testComputeValueWithEmptyArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] Function[] args = new Function[] {}; [EOL] Object result = computeValue(context); [EOL] assertTrue(result instanceof UnionContext); [EOL] UnionContext unionContext = (UnionContext) result; [EOL] assertEquals(rootContext, unionContext.getRootContext()); [EOL] assertArrayEquals(new EvalContext[] {}, unionContext.getArgContexts()); [EOL] }
public void testJDOMNodeIteratorWithDocumentNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Document document = mock(Document.class); [EOL] when(parent.getNode()).thenReturn(document); [EOL] List content = mock(List.class); [EOL] when(document.getContent()).thenReturn(content); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, null); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(content, iterator.children); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorWithElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Element element = mock(Element.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] List content = mock(List.class); [EOL] when(element.getContent()).thenReturn(content); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, null); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(content, iterator.children); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorWithNonDocumentOrElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Object nonDocumentOrElementNode = new Object(); [EOL] when(parent.getNode()).thenReturn(nonDocumentOrElementNode); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, null); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(Collections.EMPTY_LIST, iterator.children); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorWithStartWithNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] Node startWithNode = mock(Node.class); [EOL] when(startWith.getNode()).thenReturn(startWithNode); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, startWith); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(startWithNode, iterator.child); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorReverseTrue() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, true, null); [EOL] assertEquals(parent, iterator.parent); [EOL] assertEquals(nodeTest, iterator.nodeTest); [EOL] assertTrue(iterator.reverse); [EOL] }
public void testGetNodePointer_WhenChildIsNullAndSetPositionReturnsFalse() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.child = null; [EOL] NodePointer result = testInstance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_WhenChildIsNullAndSetPositionReturnsTrue() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.child = null; [EOL] NodePointer result = testInstance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] }
public void testGetNodePointer_WhenChildIsNotNull() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.child = new Object(); // Replace with an appropriate child object [EOL] NodePointer result = testInstance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] }
public void testNextWithReverseFalseAndPositionOneAndChildNotNull() { [EOL] position = 0; [EOL] reverse = false; [EOL] child = mockChild(); [EOL] children.add(child); [EOL] when(children.indexOf(child)).thenReturn(0); [EOL] boolean result = next(); [EOL] assertEquals(1, index); [EOL] assertTrue(result); [EOL] }
public void testNextWithReverseFalseAndPositionGreaterThanOne() { [EOL] position = 1; [EOL] reverse = false; [EOL] children.add(mockChild()); [EOL] children.add(mockChild()); [EOL] boolean result = next(); [EOL] assertEquals(2, index); [EOL] assertTrue(result); [EOL] }
public void testNextWithReverseFalseAndNoChildrenPassingTest() { [EOL] position = 1; [EOL] reverse = false; [EOL] children.add(mockChild()); [EOL] when(testChild()).thenReturn(false); [EOL] boolean result = next(); [EOL] assertFalse(result); [EOL] }
public void testNextWithReverseTrueAndPositionOneAndChildNotNull() { [EOL] position = 0; [EOL] reverse = true; [EOL] child = mockChild(); [EOL] children.add(child); [EOL] children.add(mockChild()); [EOL] when(children.indexOf(child)).thenReturn(0); [EOL] boolean result = next(); [EOL] assertEquals(children.size() - 2, index); [EOL] assertTrue(result); [EOL] }
public void testNextWithReverseTrueAndPositionGreaterThanOne() { [EOL] position = 1; [EOL] reverse = true; [EOL] children.add(mockChild()); [EOL] children.add(mockChild()); [EOL] boolean result = next(); [EOL] assertEquals(children.size() - 3, index); [EOL] assertTrue(result); [EOL] }
public void testNextWithReverseTrueAndNoChildrenPassingTest() { [EOL] position = 1; [EOL] reverse = true; [EOL] children.add(mockChild()); [EOL] when(testChild()).thenReturn(false); [EOL] boolean result = next(); [EOL] assertFalse(result); [EOL] }
private boolean testChild() { [EOL] return JDOMNodePointer.testNode(parent, child, nodeTest); [EOL] }
public void testJXPathExceptionWithMessage() { [EOL] String expectedMessage = "Test message"; [EOL] JXPathException exception = new JXPathException(expectedMessage); [EOL] assertNull(exception.getCause()); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] }
public void testJXPathExceptionWithMessageAndThrowable() { [EOL] String expectedMessage = "Test message"; [EOL] Throwable expectedThrowable = new Throwable("Test throwable"); [EOL] JXPathException exception = new JXPathException(expectedMessage, expectedThrowable); [EOL] assertEquals("Exception message should match the expected message", expectedMessage, exception.getMessage()); [EOL] assertEquals("Exception cause should match the expected throwable", expectedThrowable, exception.getCause()); [EOL] }
