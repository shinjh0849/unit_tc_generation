public void testGetTypeInfoForArrayType() { [EOL] Type arrayType = new TypeToken<String[]>(){}.getType(); [EOL] TypeInfoArray result = TypeInfoArray.getTypeInfoForArray(arrayType); [EOL] assertNotNull(result); [EOL] assertEquals(arrayType, result.getType()); [EOL] }
public void testGetTypeInfoForArrayWithNonArrayType() { [EOL] try { [EOL] Type nonArrayType = String.class; [EOL] TypeInfoArray.getTypeInfoForArray(nonArrayType); [EOL] fail("Expected IllegalArgumentException for non-array type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetActualTypeWithClass() { [EOL] Type result = getActualType(String.class, null, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithParameterizedType() { [EOL] Type typeToEvaluate = new ParameterizedTypeImpl(List.class, new Type[]{String.class}, null); [EOL] Type result = getActualType(typeToEvaluate, null, List.class); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedResult = (ParameterizedType) result; [EOL] assertEquals(List.class, parameterizedResult.getRawType()); [EOL] assertArrayEquals(new Type[]{String.class}, parameterizedResult.getActualTypeArguments()); [EOL] }
public void testGetActualTypeWithGenericArrayType() { [EOL] Type componentType = new GenericArrayTypeImpl(String.class); [EOL] Type typeToEvaluate = new GenericArrayTypeImpl(componentType); [EOL] Type result = getActualType(typeToEvaluate, null, null); [EOL] assertTrue(result instanceof GenericArrayType); [EOL] GenericArrayType arrayResult = (GenericArrayType) result; [EOL] assertEquals(componentType, arrayResult.getGenericComponentType()); [EOL] }
public void testGetActualTypeWithTypeVariable() { [EOL] TypeVariable<Class<TypeVariableDummy>> typeVariable = TypeVariableDummy.class.getTypeParameters()[0]; [EOL] Type parentType = new ParameterizedTypeImpl(TypeVariableDummy.class, new Type[]{String.class}, null); [EOL] Type result = getActualType(typeVariable, parentType, TypeVariableDummy.class); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithWildcardType() { [EOL] WildcardType wildcardType = new WildcardTypeImpl(new Type[]{String.class}, new Type[]{}); [EOL] Type result = getActualType(wildcardType, null, null); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeWithUnsupportedType() { [EOL] Type unsupportedType = new UnsupportedTypeImpl(); [EOL] try { [EOL] getActualType(unsupportedType, null, null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] class ParameterizedTypeImpl implements ParameterizedType { [EOL] } [EOL] class GenericArrayTypeImpl implements GenericArrayType { [EOL] } [EOL] class WildcardTypeImpl implements WildcardType { [EOL] } [EOL] class UnsupportedTypeImpl implements Type { [EOL] } [EOL] class TypeVariableDummy<T> { [EOL] }
public void start_withNullNode_doesNotThrow() { [EOL] ObjectTypePair node = null; [EOL] start(node); [EOL] }
public void start_withNonCircularReference_doesNotThrow() { [EOL] ObjectTypePair node = new ObjectTypePair(); [EOL] start(node); [EOL] }
public void start_withCircularReference_throwsException() { [EOL] ObjectTypePair node = new ObjectTypePair(); [EOL] ancestors.push(node); [EOL] try { [EOL] start(node); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndSerializeNulls() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = true; [EOL] when(f.get(parent)).thenReturn(null); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndNotNullField() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] Object fieldValue = new Object(); [EOL] when(f.get(parent)).thenReturn(fieldValue); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandlerWithJsonObjectRootAndCustomSerializer() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] Object fieldValue = new Object(); [EOL] JsonElement customSerializedElement = new JsonPrimitive("custom"); [EOL] when(f.get(parent)).thenReturn(fieldValue); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] when(findAndInvokeCustomSerializer(any(ObjectTypePair.class))).thenReturn(customSerializedElement); [EOL] boolean result = visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandlerThrowsIllegalAccessException() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] when(f.get(parent)).thenThrow(new IllegalAccessException()); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandlerThrowsCircularReferenceException() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement root = new JsonObject(); [EOL] boolean serializeNulls = false; [EOL] CircularReferenceException circularReferenceException = new CircularReferenceException(); [EOL] when(f.get(parent)).thenThrow(circularReferenceException); [EOL] when(root.isJsonObject()).thenReturn(true); [EOL] try { [EOL] visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
public void testNameWithNullNameThrowsException() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.name(null); [EOL] fail("JsonWriter.name(null) should throw NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testNameWithNonNullName() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] assertEquals("{\"name\":", writer.getBuffer().toString()); [EOL] writer.endObject(); [EOL] }
public void testStringWithSpecialCharacters() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(out); [EOL] writer.string("a\"b\\c\td\be\nf\rg\fh"); [EOL] assertEquals("\"a\\\"b\\\\c\\td\\be\\nf\\rg\\fh\"", out.toString()); [EOL] }
public void testStringWithHtmlSafeTrue() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(out); [EOL] writer.setHtmlSafe(true); [EOL] writer.string("<>&='"); [EOL] assertEquals("\"\\u003c\\u003e\\u0026\\u003d\\u0027\"", out.toString()); [EOL] }
public void testStringWithHtmlSafeFalse() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(out); [EOL] writer.setHtmlSafe(false); [EOL] writer.string("<>&='"); [EOL] assertEquals("\"<>&='\"", out.toString()); [EOL] }
public void testStringWithControlCharacters() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(out); [EOL] writer.string("a\nb\rc\fd"); [EOL] assertEquals("\"a\\nb\\rc\\fd\"", out.toString()); [EOL] }
public void testStringWithNonControlCharacters() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] JsonWriter writer = new JsonWriter(out); [EOL] writer.string("normalString"); [EOL] assertEquals("\"normalString\"", out.toString()); [EOL] }
public void testBeforeNameWithNonEmptyObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] writer.setIndent("  "); [EOL] writer.beforeName(); [EOL] assertEquals(',', writer.getBuffer().charAt(writer.getBuffer().length() - 1)); [EOL] }
public void testBeforeNameWithEmptyObject() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.setIndent("  "); [EOL] writer.beforeName(); [EOL] assertFalse(writer.getBuffer().toString().contains(",")); [EOL] }
public void testBeforeNameWithIllegalState() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setIndent("  "); [EOL] try { [EOL] writer.beforeName(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains("Nesting problem")); [EOL] } [EOL] }
public void testBeforeValueWithEmptyDocumentAndLenient() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndRoot() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndNotRoot() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must start with an array or an object.", e.getMessage()); [EOL] } [EOL] }
public void testBeforeValueWithEmptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.beforeValue(false); [EOL] }
public void testBeforeValueWithNonemptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.value(true); [EOL] writer.beforeValue(false); [EOL] }
public void testBeforeValueWithDanglingName() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] writer.beforeValue(false); [EOL] }
public void testBeforeValueWithNonemptyDocument() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must have only one top-level value.", e.getMessage()); [EOL] } [EOL] }
public void testBeforeValueWithInvalidState() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains("Nesting problem:")); [EOL] } [EOL] }
public void testTranslateNameWithEmptyAnnotations() { [EOL] FieldNamingStrategy strategy = new SomeFieldNamingStrategySubclass(); [EOL] String result = strategy.translateName("fieldName", String.class, Collections.emptyList()); [EOL] assertEquals("fieldName", result); [EOL] }
public void testTranslateNameWithNonNullAnnotations() { [EOL] FieldNamingStrategy strategy = new SomeFieldNamingStrategySubclass(); [EOL] Collection<Annotation> annotations = Arrays.asList(String.class.getAnnotations()); [EOL] String result = strategy.translateName("anotherFieldName", String.class, annotations); [EOL] assertEquals("anotherFieldName", result); [EOL] }
public void testTypeInfoArrayWithNonArrayType() { [EOL] Type type = String.class; // String is not an array type [EOL] TypeInfoArray typeInfoArray = new TypeInfoArray(type); [EOL] assertEquals(String.class, typeInfoArray.componentRawType); [EOL] assertNull(typeInfoArray.secondLevel); [EOL] }
public void testTypeInfoArrayWithArrayType() { [EOL] Type type = String[].class; // String[] is an array type [EOL] TypeInfoArray typeInfoArray = new TypeInfoArray(type); [EOL] assertEquals(String.class, typeInfoArray.componentRawType); [EOL] assertNull(typeInfoArray.secondLevel); [EOL] }
public void testTypeInfoArrayWithMultidimensionalArrayType() { [EOL] Type type = String[][].class; // String[][] is a multidimensional array type [EOL] TypeInfoArray typeInfoArray = new TypeInfoArray(type); [EOL] assertEquals(String.class, typeInfoArray.componentRawType); [EOL] assertNotNull(typeInfoArray.secondLevel); [EOL] }
public void testExtractSecondLevelTypeWithGenericArrayType() { [EOL] Type actualType = new GenericArrayType() { [EOL] @Override [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] Class<?> rawClass = Object[].class; [EOL] Type result = extractSecondLevelType(actualType, rawClass); [EOL] assertEquals(String.class, result); [EOL] } [EOL] public void testExtractSecondLevelTypeWithNonGenericArrayType() { [EOL] Type actualType = String.class; [EOL] Class<?> rawClass = Object[].class; [EOL] Type result = extractSecondLevelType(actualType, rawClass); [EOL] assertEquals(Object.class, result.getComponentType()); [EOL] }

public Type getSecondLevelType() { [EOL] return secondLevel; [EOL] }
public void testEscapeJsonStringWithPlainText() throws IOException { [EOL] String input = "This is a plain text without special chars"; [EOL] String expected = "This is a plain text without special chars"; [EOL] String result = new Escaper(false).escapeJsonString(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeJsonStringWithSpecialChars() throws IOException { [EOL] String input = "\"Quoted text with \\n new line and a tab \\t\""; [EOL] String expected = "\\\"Quoted text with \\\\n new line and a tab \\\\t\\\""; [EOL] String result = new Escaper(false).escapeJsonString(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeJsonStringWithControlChars() throws IOException { [EOL] String input = String.valueOf((char) 0x1f); // ASCII unit separator [EOL] String expected = "\\u001f"; [EOL] String result = new Escaper(false).escapeJsonString(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeJsonStringWithHtmlChars() throws IOException { [EOL] String input = "<html>\"Special & chars\"</html>"; [EOL] String expected = "\\u003chtml\\u003e\\\"Special \\u0026 chars\\\"\\u003c/html\\u003e"; [EOL] String result = new Escaper(true).escapeJsonString(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeJsonStringWithHighUnicode() throws IOException { [EOL] String input = "𐐷"; // Unicode supplementary character [EOL] String expected = "\\ud801\\udc37"; [EOL] String result = new Escaper(false).escapeJsonString(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeJsonStringWithIOException() { [EOL] CharSequence input = new CharSequence() { [EOL] @Override [EOL] public int length() { [EOL] return 2; [EOL] } [EOL] @Override [EOL] public char charAt(int index) { [EOL] return 'a'; [EOL] } [EOL] @Override [EOL] public CharSequence subSequence(int start, int end) { [EOL] return this; [EOL] } [EOL] @Override [EOL] public String toString() { [EOL] throw new RuntimeException("Forced IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] new Escaper(false).escapeJsonString(input); [EOL] fail("Expected RuntimeException due to IOException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testEscapeJsonString_noSpecialCharacters() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("normalString", out); [EOL] assertEquals("normalString", out.toString()); [EOL] }
public void testEscapeJsonString_withNewLine() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\nNewLine", out); [EOL] assertEquals("stringWith\\nNewLine", out.toString()); [EOL] }
public void testEscapeJsonString_withTab() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\tTab", out); [EOL] assertEquals("stringWith\\tTab", out.toString()); [EOL] }
public void testEscapeJsonString_withBackspace() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\bBackspace", out); [EOL] assertEquals("stringWith\\bBackspace", out.toString()); [EOL] }
public void testEscapeJsonString_withFormFeed() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\fFormFeed", out); [EOL] assertEquals("stringWith\\fFormFeed", out.toString()); [EOL] }
public void testEscapeJsonString_withCarriageReturn() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\rCarriageReturn", out); [EOL] assertEquals("stringWith\\rCarriageReturn", out.toString()); [EOL] }
public void testEscapeJsonString_withBackslash() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\\Backslash", out); [EOL] assertEquals("stringWith\\\\Backslash", out.toString()); [EOL] }
public void testEscapeJsonString_withForwardSlash() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith/ForwardSlash", out); [EOL] assertEquals("stringWith\\/ForwardSlash", out.toString()); [EOL] }
public void testEscapeJsonString_withDoubleQuote() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\"DoubleQuote", out); [EOL] assertEquals("stringWith\\\"DoubleQuote", out.toString()); [EOL] }
public void testEscapeJsonString_withControlCharacter() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\u0001ControlChar", out); [EOL] assertEquals("stringWith\\u0001ControlChar", out.toString()); [EOL] }
public void testEscapeJsonString_withNonControlNonSpecialCharacter() throws IOException { [EOL] StringBuffer out = new StringBuffer(); [EOL] escapeJsonString("stringWith\u007fDelete", out); [EOL] assertEquals("stringWith\\u007fDelete", out.toString()); [EOL] }
public void testMustEscapeCharInJsString_nonSupplementary() { [EOL] Escaper escaper = new Escaper(false); [EOL] assertFalse(escaper.mustEscapeCharInJsString('a')); [EOL] assertTrue(escaper.mustEscapeCharInJsString('<')); [EOL] }
public void testMustEscapeCharInJsString_nonSupplementaryWithHtmlEscape() { [EOL] Escaper escaper = new Escaper(true); [EOL] assertFalse(escaper.mustEscapeCharInJsString('a')); [EOL] assertTrue(escaper.mustEscapeCharInJsString('<')); [EOL] assertTrue(escaper.mustEscapeCharInJsString('&')); [EOL] }
public void testMustEscapeCharInJsString_supplementary() { [EOL] Escaper escaper = new Escaper(false); [EOL] assertFalse(escaper.mustEscapeCharInJsString(Character.toCodePoint('\uD800', '\uDF48'))); [EOL] }
public void testIsControlCharacter_ControlCharacters() throws IOException { [EOL] assertTrue(isControlCharacter(0x1F)); // Last control character before 0x20 [EOL] assertTrue(isControlCharacter(0x2028)); // LINE SEPARATOR [EOL] assertTrue(isControlCharacter(0x2029)); // PARAGRAPH SEPARATOR [EOL] assertTrue(isControlCharacter(0x7F)); // First control character after 0x7E [EOL] assertTrue(isControlCharacter(0x9F)); // Last control character in the range 0x7F-0x9F [EOL] }
public void testIsControlCharacter_NonControlCharacters() throws IOException { [EOL] assertFalse(isControlCharacter(0x20)); // First non-control character after 0x1F [EOL] assertFalse(isControlCharacter(0x21)); // Some character outside the control character range [EOL] assertFalse(isControlCharacter(0x7E)); // Last non-control character before 0x7F [EOL] assertFalse(isControlCharacter(0xA0)); // First non-control character after 0x9F [EOL] }
public void testQuickPeekEmptyDocumentLenient() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.peek(); // This will trigger quickPeek [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertTrue(token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT); [EOL] }
public void testQuickPeekEmptyDocumentStrict() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(false); [EOL] try { [EOL] jsonReader.peek(); // This will trigger quickPeek [EOL] fail("Should have thrown a syntax error"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testQuickPeekEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[]")); [EOL] jsonReader.beginArray(); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertEquals(JsonToken.END_ARRAY, token); [EOL] }
public void testQuickPeekNonEmptyArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[true]")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextBoolean(); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertEquals(JsonToken.END_ARRAY, token); [EOL] }
public void testQuickPeekEmptyObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.beginObject(); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertEquals(JsonToken.END_OBJECT, token); [EOL] }
public void testQuickPeekDanglingName() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"name\":")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertEquals(JsonToken.STRING, token); // Assuming objectValue() returns STRING for a dangling name [EOL] }
public void testQuickPeekNonEmptyObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"name\":true}")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] jsonReader.nextBoolean(); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertEquals(JsonToken.END_OBJECT, token); [EOL] }
public void testQuickPeekNonEmptyDocumentLenient() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.setLenient(true); [EOL] JsonToken token = jsonReader.quickPeek(); [EOL] assertEquals(JsonToken.BOOLEAN, token); [EOL] }
public void testQuickPeekNonEmptyDocumentStrict() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.setLenient(false); [EOL] try { [EOL] jsonReader.peek(); // This will trigger quickPeek [EOL] fail("Should have thrown an exception for expecting EOF"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testQuickPeekClosed() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.close(); [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testQuickPeekDefaultCase() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")) { [EOL] @Override [EOL] public JsonScope peekStack() { [EOL] return null; // Force default case [EOL] } [EOL] }; [EOL] try { [EOL] jsonReader.quickPeek(); [EOL] fail("Should have thrown AssertionError"); [EOL] } catch (AssertionError e) { [EOL] } [EOL] }
public void testNextStringWithValidStringToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"testString\"")); [EOL] jsonReader.beginArray(); [EOL] String result = jsonReader.nextString(); [EOL] assertEquals("testString", result); [EOL] }
public void testNextStringWithValidNumberToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("12345")); [EOL] jsonReader.beginArray(); [EOL] String result = jsonReader.nextString(); [EOL] assertEquals("12345", result); [EOL] }
public void testNextStringWithInvalidToken() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[true]")); [EOL] jsonReader.beginArray(); [EOL] try { [EOL] jsonReader.nextString(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected a string but was BOOLEAN", e.getMessage()); [EOL] } [EOL] }
public void testNextStringAtEndOfArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[\"testString\"]")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.nextString(); [EOL] try { [EOL] jsonReader.nextString(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected a string but was END_ARRAY", e.getMessage()); [EOL] } [EOL] }
public void testNextStringAtEndOfObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{\"key\":\"value\"}")); [EOL] jsonReader.beginObject(); [EOL] jsonReader.nextName(); [EOL] jsonReader.nextString(); [EOL] try { [EOL] jsonReader.nextString(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Expected a string but was END_OBJECT", e.getMessage()); [EOL] } [EOL] }
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL] if (firstElement) { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] default: [EOL] pos--; [EOL] } [EOL] } else { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] case ';': [EOL] case ',': [EOL] break; [EOL] default: [EOL] throw syntaxError("Unterminated object"); [EOL] } [EOL] } [EOL] int quote = nextNonWhitespace(); [EOL] switch(quote) { [EOL] case '\'': [EOL] checkLenient(); [EOL] case '"': [EOL] name = nextString((char) quote); [EOL] break; [EOL] default: [EOL] checkLenient(); [EOL] pos--; [EOL] name = nextLiteral(); [EOL] if (name.length() == 0) { [EOL] throw syntaxError("Expected name"); [EOL] } [EOL] } [EOL] replaceTop(JsonScope.DANGLING_NAME); [EOL] hasToken = true; [EOL] return token = JsonToken.NAME; [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
private JsonToken objectValue() throws IOException { [EOL] switch(nextNonWhitespace()) { [EOL] case ':': [EOL] break; [EOL] case '=': [EOL] checkLenient(); [EOL] if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL] pos++; [EOL] } [EOL] break; [EOL] default: [EOL] throw syntaxError("Expected ':'"); [EOL] } [EOL] replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL] return nextValue(); [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
public void testNextValueBeginObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.BEGIN_OBJECT, token); [EOL] }
public void testNextValueBeginArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.BEGIN_ARRAY, token); [EOL] }
public void testNextValueStringWithSingleQuote() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("'string'")); [EOL] jsonReader.setLenient(true); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.STRING, token); [EOL] }
public void testNextValueStringWithDoubleQuote() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"string\"")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.STRING, token); [EOL] }
public void testNextValueLiteral() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.BOOLEAN, token); // Assuming readLiteral() correctly identifies the boolean literal [EOL] }
private void checkLenient() throws IOException { [EOL] if (!lenient) { [EOL] throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON"); [EOL] } [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
private String nextString(char quote) throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] if (c == quote) { [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start - 1); [EOL] } else { [EOL] builder.append(buffer, start, pos - start - 1); [EOL] return builder.toString(); [EOL] } [EOL] } else if (c == '\\') { [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start - 1); [EOL] builder.append(readEscapeCharacter()); [EOL] start = pos; [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] throw syntaxError("Unterminated string"); [EOL] }
private String nextLiteral() throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] switch(c) { [EOL] case '/': [EOL] case '\\': [EOL] case ';': [EOL] case '#': [EOL] case '=': [EOL] checkLenient(); [EOL] case '{': [EOL] case '}': [EOL] case '[': [EOL] case ']': [EOL] case ':': [EOL] case ',': [EOL] case ' ': [EOL] case '\t': [EOL] case '\f': [EOL] case '\r': [EOL] case '\n': [EOL] pos--; [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start); [EOL] } else { [EOL] builder.append(buffer, start, pos - start); [EOL] return builder.toString(); [EOL] } [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] return builder.toString(); [EOL] }
public void testDecodeLiteralWithNullValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("null")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.NULL, jsonReader.peek()); [EOL] }
public void testDecodeLiteralWithBooleanTrueValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.peek()); [EOL] }
public void testDecodeLiteralWithBooleanFalseValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("false")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.peek()); [EOL] }
public void testDecodeLiteralWithNumberValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("123.45")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.NUMBER, jsonReader.peek()); [EOL] }
public void testDecodeLiteralWithStringValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("notANumber")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.STRING, jsonReader.peek()); [EOL] }
public void testSyntaxError() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] try { [EOL] jsonReader.syntaxError("Invalid syntax"); [EOL] fail("Expected IOException"); [EOL] } catch (MalformedJsonException e) { [EOL] assertEquals("Invalid syntax near ", e.getMessage()); [EOL] } [EOL] }
public void testGetSnippetAtStart() { [EOL] JsonReader reader = new JsonReader(new StringReader("...")); // Replace "..." with actual JSON content [EOL] reader.setLenient(true); [EOL] CharSequence snippet = reader.getSnippet(); [EOL] } [EOL] public void testGetSnippetAtMiddle() { [EOL] JsonReader reader = new JsonReader(new StringReader("...")); // Replace "..." with actual JSON content [EOL] reader.setLenient(true); [EOL] CharSequence snippet = reader.getSnippet(); [EOL] } [EOL] public void testGetSnippetAtEnd() { [EOL] JsonReader reader = new JsonReader(new StringReader("...")); // Replace "..." with actual JSON content [EOL] reader.setLenient(true); [EOL] CharSequence snippet = reader.getSnippet(); [EOL] }
public void testVisitFieldUsingCustomHandler_JsonParseException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement json = new JsonPrimitive("not a JsonObject"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(json, null, null); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_NullChild() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", JsonNull.INSTANCE); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), null, null); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_NoMatchingHandler() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("fieldName", "value"); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), null, null); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandler_SuccessfulSet() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("fieldName", "value"); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] Map<Type, JsonDeserializer<?>> deserializers = new HashMap<>(); [EOL] deserializers.put(declaredTypeOfField, (JsonDeserializer<Object>) (json, typeOfT, context) -> "deserializedValue"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), deserializers, null); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_IllegalAccessException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("fieldName", "value"); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] doThrow(new IllegalAccessException()).when(f).set(any(), any()); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(new JsonParser().parse(jsonObject.toString()), null, null); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown RuntimeException"); [EOL] } catch (RuntimeException expected) { [EOL] } [EOL] }
public void testDefaultDateTypeAdapterWithAllStyles() { [EOL] DefaultDateTypeAdapter adapterFull = new DefaultDateTypeAdapter(DateFormat.FULL); [EOL] assertNotNull(adapterFull);
DefaultDateTypeAdapter adapterLong = new DefaultDateTypeAdapter(DateFormat.LONG); [EOL] assertNotNull(adapterLong);
DefaultDateTypeAdapter adapterMedium = new DefaultDateTypeAdapter(DateFormat.MEDIUM); [EOL] assertNotNull(adapterMedium);
DefaultDateTypeAdapter adapterShort = new DefaultDateTypeAdapter(DateFormat.SHORT); [EOL] assertNotNull(adapterShort); [EOL] }
public void testSerializeWithValidDate() { [EOL] java.sql.Date src = new java.sql.Date(System.currentTimeMillis()); [EOL] Type typeOfSrc = java.sql.Date.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); [EOL] Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create(); [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] String expectedDate = format.format(src); [EOL] assertEquals(expectedDate, result.getAsString()); [EOL] }
public void testSerializeWithNullDate() { [EOL] java.sql.Date src = null; [EOL] Type typeOfSrc = java.sql.Date.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] assertNull(result); [EOL] }
public void testSerializeWithValidURL() { [EOL] Gson gson = new Gson(); [EOL] URL url = new URL("http://www.google.com"); [EOL] Type typeOfSrc = new TypeToken<URL>() {}.getType(); [EOL] JsonSerializationContext context = gson.getAdapter(URL.class); [EOL] JsonElement result = gson.serialize(url, typeOfSrc, context); [EOL] assertEquals("\"http://www.google.com\"", result.toString()); [EOL] }
public void testCreateInstanceWithValidType() { [EOL] Type type = Properties.class.getGenericSuperclass(); [EOL] Properties result = createInstance(type); [EOL] assertNotNull(result); [EOL] }
public void testCreateInstanceWithInvalidType() { [EOL] Type type = String.class; // Assuming String is an invalid type for this context [EOL] try { [EOL] Properties result = createInstance(type); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithEmptyJsonObject() { [EOL] JsonElement json = new JsonParser().parse("{}"); [EOL] Type typeOfT = new TypeToken<Map<String, String>>(){}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Map result = deserialize(json, typeOfT, context); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDeserializeWithNonEmptyJsonObject() { [EOL] JsonElement json = new JsonParser().parse("{\"key1\":\"value1\", \"key2\":\"value2\"}"); [EOL] Type typeOfT = new TypeToken<Map<String, String>>(){}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Map result = deserialize(json, typeOfT, context); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("value1", result.get("key1")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testDeserializeWithComplexJsonObject() { [EOL] JsonElement json = new JsonParser().parse("{\"key1\":{\"innerKey1\":\"innerValue1\"}, \"key2\":{\"innerKey2\":\"innerValue2\"}}"); [EOL] Type typeOfT = new TypeToken<Map<String, Map<String, String>>>(){}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Map result = deserialize(json, typeOfT, context); [EOL] assertEquals(2, result.size()); [EOL] assertNotNull(result.get("key1")); [EOL] assertEquals("innerValue1", ((Map)result.get("key1")).get("innerKey1")); [EOL] assertNotNull(result.get("key2")); [EOL] assertEquals("innerValue2", ((Map)result.get("key2")).get("innerKey2")); [EOL] }
public void testConstructMapTypeWithValidMapType() { [EOL] Type mapType = new TypeToken<Map<String, Integer>>(){}.getType(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] Map result = constructMapType(mapType, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Map); [EOL] }
public void testConstructMapTypeWithInvalidType() { [EOL] Type notMapType = String.class; [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] try { [EOL] constructMapType(notMapType, context); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testSerializeWithNullBigDecimal() { [EOL] BigDecimal src = null; [EOL] Type typeOfSrc = BigDecimal.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertNull(result); [EOL] }
public void testSerializeWithNonNullBigDecimal() { [EOL] BigDecimal src = new BigDecimal("123.45"); [EOL] Type typeOfSrc = BigDecimal.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123.45", result.getAsString()); [EOL] }
public void testToString() { [EOL] BigIntegerTypeAdapter bigIntegerTypeAdapter = new BigIntegerTypeAdapter(); [EOL] String result = bigIntegerTypeAdapter.toString(); [EOL] assertEquals("BigIntegerTypeAdapter", result); [EOL] }
public void testDeserializeWithNumber() { [EOL] JsonElement json = new JsonPrimitive(123); [EOL] Number result = deserialize(json, Number.class, null); [EOL] assertEquals(123, result.intValue()); [EOL] }
public void testDeserializeWithNull() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] try { [EOL] Number result = deserialize(json, Number.class, null); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithStringRepresentingNumber() { [EOL] JsonElement json = new JsonPrimitive("123"); [EOL] Number result = deserialize(json, Number.class, null); [EOL] assertEquals(123, result.intValue()); [EOL] }
public void testSerializeWithNullLong() { [EOL] LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT; [EOL] Gson gson = new GsonBuilder().setLongSerializationPolicy(longSerializationPolicy).create(); [EOL] JsonElement result = gson.serialize(null, Long.class, gson.getAdapter(Long.class)); [EOL] assertNull(result); [EOL] }
public void testSerializeWithNonNullLong() { [EOL] LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT; [EOL] Gson gson = new GsonBuilder().setLongSerializationPolicy(longSerializationPolicy).create(); [EOL] JsonElement result = gson.serialize(123L, Long.class, gson.getAdapter(Long.class)); [EOL] assertNotNull(result); [EOL] assertEquals("123", result.getAsString()); [EOL] }
public void testDeserializeWithLongValue() { [EOL] JsonElement json = new JsonPrimitive(10L); [EOL] Type typeOfT = Long.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Long result = deserialize(json, typeOfT, context); [EOL] assertEquals(Long.valueOf(10L), result); [EOL] }
public void testDeserializeWithNonLongValue() { [EOL] JsonElement json = new JsonPrimitive("not a long"); [EOL] Type typeOfT = Long.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] Type typeOfT = Long.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSerializeWithFiniteFloat() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float finiteFloat = 123.45f; [EOL] JsonElement result = gson.serialize(finiteFloat, Float.class, null); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123.45", result.getAsString()); [EOL] }
public void testSerializeWithNaN() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float nanValue = Float.NaN; [EOL] try { [EOL] gson.serialize(nanValue, Float.class, null); [EOL] fail("Expected IllegalArgumentException for NaN value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals("NaN is not a valid float value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithPositiveInfinity() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float positiveInfinity = Float.POSITIVE_INFINITY; [EOL] try { [EOL] gson.serialize(positiveInfinity, Float.class, null); [EOL] fail("Expected IllegalArgumentException for positive infinity value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals("Infinity is not a valid float value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithNegativeInfinity() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] Float negativeInfinity = Float.NEGATIVE_INFINITY; [EOL] try { [EOL] gson.serialize(negativeInfinity, Float.class, null); [EOL] fail("Expected IllegalArgumentException for negative infinity value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] assertEquals("-Infinity is not a valid float value as per JSON specification. To override this behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.", expected.getMessage()); [EOL] } [EOL] }
public void testSerializeWithSpecialFloatingPointValuesAllowed() { [EOL] Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create(); [EOL] Float nanValue = Float.NaN; [EOL] JsonElement resultNaN = gson.serialize(nanValue, Float.class, null); [EOL] assertTrue(resultNaN.isJsonPrimitive()); [EOL] assertEquals("NaN", resultNaN.getAsString()); [EOL] Float positiveInfinity = Float.POSITIVE_INFINITY; [EOL] JsonElement resultPositiveInfinity = gson.serialize(positiveInfinity, Float.class, null); [EOL] assertTrue(resultPositiveInfinity.isJsonPrimitive()); [EOL] assertEquals("Infinity", resultPositiveInfinity.getAsString()); [EOL] Float negativeInfinity = Float.NEGATIVE_INFINITY; [EOL] JsonElement resultNegativeInfinity = gson.serialize(negativeInfinity, Float.class, null); [EOL] assertTrue(resultNegativeInfinity.isJsonPrimitive()); [EOL] assertEquals("-Infinity", resultNegativeInfinity.getAsString()); [EOL] }
public void testSerializeWithValidCharacter() { [EOL] Gson gson = new Gson(); [EOL] JsonSerializationContext context = new JsonSerializationContext() { [EOL] @Override [EOL] public JsonElement serialize(Object src) { [EOL] return gson.toJsonTree(src); [EOL] } [EOL] @Override [EOL] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return gson.toJsonTree(src, typeOfSrc); [EOL] } [EOL] }; [EOL] Character src = 'a'; [EOL] Type typeOfSrc = Character.class; [EOL] JsonElement result = gson.serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("a", result.getAsString()); [EOL] }
public void testDeserializeWithJsonPrimitiveString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("testString"); [EOL] String result = deserialize(jsonPrimitive, String.class, null); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeWithJsonNull() { [EOL] JsonNull jsonNull = JsonNull.INSTANCE; [EOL] try { [EOL] deserialize(jsonNull, String.class, null); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithNonStringJsonElement() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key", "value"); [EOL] try { [EOL] deserialize(jsonObject, String.class, null); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSerializeTrue() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.serialize(true, Boolean.class, null); [EOL] assertEquals("true", result.getAsString()); [EOL] }
public void testSerializeFalse() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.serialize(false, Boolean.class, null); [EOL] assertEquals("false", result.getAsString()); [EOL] }
public void testDeserializeTrue() { [EOL] JsonPrimitive jsonPrimitiveTrue = new JsonPrimitive(true); [EOL] Boolean result = deserialize(jsonPrimitiveTrue, Boolean.class, null); [EOL] assertTrue(result); [EOL] }
public void testDeserializeFalse() { [EOL] JsonPrimitive jsonPrimitiveFalse = new JsonPrimitive(false); [EOL] Boolean result = deserialize(jsonPrimitiveFalse, Boolean.class, null); [EOL] assertFalse(result); [EOL] }
public void testDeserializeThrowsException() { [EOL] JsonPrimitive jsonPrimitiveString = new JsonPrimitive("not a boolean"); [EOL] try { [EOL] deserialize(jsonPrimitiveString, Boolean.class, null); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testTypeInfoMapWithPropertiesClass() { [EOL] Type mapType = Properties.class; [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(String.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithParameterizedType() { [EOL] Type mapType = new TypeToken<Map<String, Integer>>(){}.getType(); [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(Integer.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithInvalidType() { [EOL] Type mapType = String.class; [EOL] try { [EOL] new TypeInfoMap(mapType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testJsonArrayDeserializationVisitorConstruction() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] Type arrayType = new TypeToken<List<String>>(){}.getType(); [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(); [EOL] ObjectConstructor objectConstructor = new ObjectConstructor(); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(deserializers); [EOL] JsonArrayDeserializationVisitor visitor = new JsonArrayDeserializationVisitor( [EOL] jsonArray, arrayType, factory, objectConstructor, deserializers, context [EOL] ); [EOL] assertNotNull(visitor); [EOL] }
public void testVisitArrayWithJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(1)); [EOL] jsonArray.add(new JsonPrimitive(2)); [EOL] jsonArray.add(JsonNull.INSTANCE); [EOL] Object array = Array.newInstance(Integer.class, jsonArray.size()); [EOL] Type arrayType = Integer[].class; [EOL] JsonElement json = jsonArray; [EOL] visitArray(array, arrayType); [EOL] assertEquals(Array.get(array, 0), 1); [EOL] assertEquals(Array.get(array, 1), 2); [EOL] assertNull(Array.get(array, 2)); [EOL] }
public void testVisitArrayWithNonJsonArrayThrowsException() { [EOL] JsonElement json = new JsonPrimitive(1); [EOL] Object array = new Object(); [EOL] Type arrayType = Object.class; [EOL] try { [EOL] visitArray(array, arrayType); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testVisitArrayWithJsonObject() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key", "value"); [EOL] jsonArray.add(jsonObject); [EOL] Object array = Array.newInstance(Map.class, jsonArray.size()); [EOL] Type arrayType = Map[].class; [EOL] JsonElement json = jsonArray; [EOL] visitArray(array, arrayType); [EOL] assertTrue(Array.get(array, 0) instanceof Map); [EOL] }
public void testVisitArrayWithNestedJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonArray nestedJsonArray = new JsonArray(); [EOL] nestedJsonArray.add(new JsonPrimitive(3)); [EOL] jsonArray.add(nestedJsonArray); [EOL] Object array = Array.newInstance(Integer[].class, jsonArray.size()); [EOL] Type arrayType = Integer[][].class; [EOL] JsonElement json = jsonArray; [EOL] visitArray(array, arrayType); [EOL] assertTrue(Array.get(array, 0) instanceof Integer[]); [EOL] }
public void testVisitArrayWithJsonPrimitive() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("test")); [EOL] Object array = Array.newInstance(String.class, jsonArray.size()); [EOL] Type arrayType = String[].class; [EOL] JsonElement json = jsonArray; [EOL] visitArray(array, arrayType); [EOL] assertEquals(Array.get(array, 0), "test"); [EOL] }
public void testVisitArrayWithIllegalState() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonElement() {}); // Anonymous subclass to trigger IllegalStateException [EOL] Object array = Array.newInstance(Object.class, jsonArray.size()); [EOL] Type arrayType = Object[].class; [EOL] JsonElement json = jsonArray; [EOL] try { [EOL] visitArray(array, arrayType); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testParseString() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\"testString\"")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("testString", result.getAsString()); [EOL] }
public void testParseNumber() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("12345")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(12345, result.getAsInt()); [EOL] }
public void testParseBoolean() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertTrue(result.getAsBoolean()); [EOL] }
public void testParseNull() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("null")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testParseArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[\"item1\", 2, true, null]")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonArray()); [EOL] JsonArray array = result.getAsJsonArray(); [EOL] assertEquals(4, array.size()); [EOL] assertEquals("item1", array.get(0).getAsString()); [EOL] assertEquals(2, array.get(1).getAsInt()); [EOL] assertTrue(array.get(2).getAsBoolean()); [EOL] assertTrue(array.get(3).isJsonNull()); [EOL] }
public void testParseObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key1\":\"value1\",\"key2\":123,\"key3\":false}")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonObject()); [EOL] JsonObject object = result.getAsJsonObject(); [EOL] assertEquals("value1", object.get("key1").getAsString()); [EOL] assertEquals(123, object.get("key2").getAsInt()); [EOL] assertFalse(object.get("key3").getAsBoolean()); [EOL] }
public void testParseMalformedJson() { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key1\":\"value1\",")); [EOL] try { [EOL] parse(reader); [EOL] fail("Should have thrown JsonSyntaxException"); [EOL] } catch (JsonSyntaxException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonSyntaxException, but got IOException"); [EOL] } [EOL] }
public void testParseUnexpectedToken() { [EOL] JsonReader reader = new JsonReader(new StringReader("]")); [EOL] try { [EOL] parse(reader); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected IllegalArgumentException, but got IOException"); [EOL] } [EOL] }
public void testParseEOFException() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] reader.close(); [EOL] try { [EOL] parse(reader); [EOL] fail("Should have thrown JsonIOException"); [EOL] } catch (JsonIOException e) { [EOL] } [EOL] }
public void testWriteNullElementWithSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, true, writer); [EOL] verify(writer).nullValue(); [EOL] }
public void testWriteNullElementWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, false, writer); [EOL] verify(writer, never()).nullValue(); [EOL] }
public void testWriteJsonPrimitiveNumber() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(10); [EOL] write(element, true, writer); [EOL] verify(writer).value(10); [EOL] }
public void testWriteJsonPrimitiveBoolean() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(true); [EOL] write(element, true, writer); [EOL] verify(writer).value(true); [EOL] }
public void testWriteJsonPrimitiveString() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] write(element, true, writer); [EOL] verify(writer).value("test"); [EOL] }
public void testWriteJsonArray() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(1); [EOL] jsonArray.add("string"); [EOL] JsonElement element = jsonArray; [EOL] write(element, true, writer); [EOL] verify(writer).beginArray(); [EOL] verify(writer).value(1); [EOL] verify(writer).value("string"); [EOL] verify(writer).endArray(); [EOL] }
public void testWriteJsonObject() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key1", 1); [EOL] jsonObject.addProperty("key2", "value2"); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).value(1); [EOL] verify(writer).name("key2"); [EOL] verify(writer).value("value2"); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueAndSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, false, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer, never()).name("key1"); [EOL] verify(writer, never()).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteIllegalArgument() { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = mock(JsonElement.class); [EOL] when(element.isJsonNull()).thenReturn(false); [EOL] when(element.isJsonPrimitive()).thenReturn(false); [EOL] when(element.isJsonArray()).thenReturn(false); [EOL] when(element.isJsonObject()).thenReturn(false); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] write(element, true, writer); [EOL] }); [EOL] assertEquals("Couldn't write " + element.getClass(), exception.getMessage()); [EOL] }
public void testCheckArgumentTrueCondition() { [EOL] Gson.checkArgument(true); [EOL] }
public void testCheckArgumentFalseCondition() { [EOL] try { [EOL] Gson.checkArgument(false); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("condition failed: false", e.getMessage()); [EOL] } [EOL] }
public void testSize_Empty() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] int size = jsonArray.size(); [EOL] assertEquals(0, size); [EOL] }
public void testSize_NonEmpty() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(1)); [EOL] jsonArray.add(new JsonPrimitive(2)); [EOL] int size = jsonArray.size(); [EOL] assertEquals(2, size); [EOL] }
public void testGet_ValidIndex() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(1)); [EOL] jsonArray.add(new JsonPrimitive(2)); [EOL] jsonArray.add(new JsonPrimitive(3)); [EOL] JsonElement element = jsonArray.get(1); [EOL] assertNotNull(element); [EOL] assertEquals(2, element.getAsInt()); [EOL] }
public void testGet_InvalidIndex() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(1)); [EOL] jsonArray.add(new JsonPrimitive(2)); [EOL] jsonArray.add(new JsonPrimitive(3)); [EOL] try { [EOL] jsonArray.get(3); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetAsString_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("singleElement")); [EOL] String result = jsonArray.getAsString(); [EOL] assertEquals("singleElement", result); [EOL] }
public void testGetAsString_MultipleElementsThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("element1")); [EOL] jsonArray.add(new JsonPrimitive("element2")); [EOL] try { [EOL] jsonArray.getAsString(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsString_EmptyArrayThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] try { [EOL] jsonArray.getAsString(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetAsBoolean_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(true)); [EOL] boolean result = jsonArray.getAsBoolean(); [EOL] assertTrue(result); [EOL] }
public void testGetAsBoolean_MultipleElements_ThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(true)); [EOL] jsonArray.add(new JsonPrimitive(false)); [EOL] try { [EOL] jsonArray.getAsBoolean(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testNext_ThrowsNoSuchElementException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNext_ReturnsValidJsonElement() throws JsonParseException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")); [EOL] jsonReader.setLenient(true); [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] JsonElement element = parser.next(); [EOL] assertNotNull(element); [EOL] assertTrue(element.isJsonArray()); [EOL] }
public void testNext_ThrowsJsonParseExceptionOnStackOverflowError() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")) { [EOL] @Override [EOL] public void beginArray() throws IOException { [EOL] throw new StackOverflowError(); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNext_ThrowsJsonParseExceptionOnOutOfMemoryError() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")) { [EOL] @Override [EOL] public JsonElement peek() throws IOException { [EOL] throw new OutOfMemoryError(); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNext_ThrowsJsonParseExceptionWithCause() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")) { [EOL] @Override [EOL] public JsonElement peek() throws IOException { [EOL] throw new JsonParseException("Invalid JSON"); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected JsonParseException to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNext_ThrowsNoSuchElementExceptionOnEOFException() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[1,2,3]")) { [EOL] @Override [EOL] public JsonElement peek() throws IOException { [EOL] throw new EOFException(); [EOL] } [EOL] }; [EOL] JsonStreamParser parser = new JsonStreamParser(jsonReader); [EOL] try { [EOL] parser.next(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testCopyOfEmptyMap() { [EOL] ParameterizedTypeHandlerMap<Object> original = new ParameterizedTypeHandlerMap<>(); [EOL] ParameterizedTypeHandlerMap<Object> copy = original.copyOf(); [EOL] assertTrue(copy != original); [EOL] assertTrue(copy.map.isEmpty()); [EOL] assertTrue(copy.typeHierarchyList.isEmpty()); [EOL] }
public void testCopyOfMapWithEntries() { [EOL] ParameterizedTypeHandlerMap<Object> original = new ParameterizedTypeHandlerMap<>(); [EOL] original.register(String.class, new Object()); [EOL] original.register(Integer.class, new Object()); [EOL] ParameterizedTypeHandlerMap<Object> copy = original.copyOf(); [EOL] assertTrue(copy != original); [EOL] assertEquals(original.map.size(), copy.map.size()); [EOL] assertTrue(copy.map.containsKey(String.class)); [EOL] assertTrue(copy.map.containsKey(Integer.class)); [EOL] }
public void testCopyOfMapWithTypeHierarchy() { [EOL] ParameterizedTypeHandlerMap<Object> original = new ParameterizedTypeHandlerMap<>(); [EOL] Pair<Class<?>, Object> stringHierarchy = new Pair<>(String.class, new Object()); [EOL] original.registerForTypeHierarchy(stringHierarchy); [EOL] ParameterizedTypeHandlerMap<Object> copy = original.copyOf(); [EOL] assertTrue(copy != original); [EOL] assertEquals(original.typeHierarchyList.size(), copy.typeHierarchyList.size()); [EOL] assertTrue(copy.typeHierarchyList.contains(stringHierarchy)); [EOL] }
public void testIsArrayWithClassType() { [EOL] assertTrue(isArray(String[].class)); [EOL] }
public void testIsArrayWithGenericArrayType() { [EOL] Type genericArrayType = new GenericArrayType() { [EOL] @Override [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] assertTrue(isArray(genericArrayType)); [EOL] }
public void testIsArrayWithNonArrayType() { [EOL] assertFalse(isArray(String.class)); [EOL] }
public void testTranslateNameWithNullFieldAttributes() { [EOL] try { [EOL] translateName(null); [EOL] fail("translateName should throw NullPointerException if FieldAttributes is null"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testTranslateNameWithNoSerializedNameAnnotation() { [EOL] FieldAttributes mockFieldAttributes = mock(FieldAttributes.class); [EOL] when(mockFieldAttributes.getAnnotation(SerializedName.class)).thenReturn(null); [EOL] NameStrategy delegate = mock(NameStrategy.class); [EOL] when(delegate.translateName(any(FieldAttributes.class))).thenReturn("translatedName"); [EOL] FieldNameValidator fieldNameValidator = mock(FieldNameValidator.class); [EOL] String result = translateName(mockFieldAttributes); [EOL] verify(delegate).translateName(mockFieldAttributes); [EOL] assertEquals("translatedName", result); [EOL] }
public void testTranslateNameWithSerializedNameAnnotation() { [EOL] FieldAttributes mockFieldAttributes = mock(FieldAttributes.class); [EOL] SerializedName mockSerializedName = mock(SerializedName.class); [EOL] when(mockFieldAttributes.getAnnotation(SerializedName.class)).thenReturn(mockSerializedName); [EOL] when(mockSerializedName.value()).thenReturn("serializedNameValue"); [EOL] FieldNameValidator fieldNameValidator = mock(FieldNameValidator.class); [EOL] when(fieldNameValidator.validate(anyString())).thenReturn("validatedName"); [EOL] String result = translateName(mockFieldAttributes); [EOL] verify(fieldNameValidator).validate("serializedNameValue"); [EOL] assertEquals("validatedName", result); [EOL] }
public void testFromJsonWithNullInput() { [EOL] Gson gson = new Gson(); [EOL] String json = null; [EOL] Type typeOfT = String.class; [EOL] Object result = gson.fromJson(json, typeOfT); [EOL] assertNull(result); [EOL] }
public void testFromJsonWithEmptyString() { [EOL] Gson gson = new Gson(); [EOL] String json = ""; [EOL] Type typeOfT = String.class; [EOL] try { [EOL] gson.fromJson(json, typeOfT); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonWithValidString() { [EOL] Gson gson = new Gson(); [EOL] String json = "\"test\""; [EOL] Type typeOfT = String.class; [EOL] String result = gson.fromJson(json, typeOfT); [EOL] assertEquals("test", result); [EOL] }
public void testCheckNotNullWithNonNullClass() { [EOL] Class<?> result = checkNotNull(String.class); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testCheckNotNullWithNullClass() { [EOL] try { [EOL] checkNotNull(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testWrapWithNonNullPrimitiveType() { [EOL] Class<?> primitiveType = int.class; [EOL] Class<?> wrappedType = wrap(primitiveType); [EOL] assertEquals("wrap should return the wrapper type for a primitive type", Integer.class, wrappedType); [EOL] }
public void testWrapWithNonNullWrapperType() { [EOL] Class<?> wrapperType = Integer.class; [EOL] Class<?> wrappedType = wrap(wrapperType); [EOL] assertEquals("wrap should return the same wrapper type if a wrapper type is passed", Integer.class, wrappedType); [EOL] }
public void testWrapWithNonPrimitiveNonWrapperType() { [EOL] Class<?> nonPrimitiveType = String.class; [EOL] Class<?> wrappedType = wrap(nonPrimitiveType); [EOL] assertEquals("wrap should return the same type if a non-primitive, non-wrapper type is passed", String.class, wrappedType); [EOL] }
public void testWrapWithNullType() { [EOL] try { [EOL] wrap(null); [EOL] fail("wrap should throw NullPointerException if the type is null"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testUnwrapWithPrimitiveType() { [EOL] Class<?> primitiveClass = Integer.TYPE; [EOL] Class<?> unwrapped = GsonUtils.unwrap(primitiveClass); [EOL] assertEquals(primitiveClass, unwrapped); [EOL] }
public void testUnwrapWithWrapperType() { [EOL] Class<?> wrapperClass = Integer.class; [EOL] Class<?> unwrapped = GsonUtils.unwrap(wrapperClass); [EOL] assertEquals(Integer.TYPE, unwrapped); [EOL] }
public void testUnwrapWithNonPrimitiveType() { [EOL] Class<?> nonPrimitiveClass = String.class; [EOL] Class<?> unwrapped = GsonUtils.unwrap(nonPrimitiveClass); [EOL] assertEquals(nonPrimitiveClass, unwrapped); [EOL] }
public void testUnwrapWithNull() { [EOL] try { [EOL] GsonUtils.unwrap(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testJsonDeserializerExceptionWrapperWithNonNullDelegate() { [EOL] JsonDeserializer<?> mockDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializerExceptionWrapper<?> wrapper = new JsonDeserializerExceptionWrapper<>(mockDeserializer); [EOL] assertNotNull(wrapper); [EOL] }
public void testJsonDeserializerExceptionWrapperWithNullDelegate() { [EOL] try { [EOL] new JsonDeserializerExceptionWrapper<>(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testDeserializeWithValidInput() { [EOL] JsonElement json = new JsonPrimitive("test"); [EOL] Type typeOfT = String.class; [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] when(delegate.deserialize(json, typeOfT, context)).thenReturn("test"); [EOL] T result = deserialize(json, typeOfT, context); [EOL] assertNotNull(result); [EOL] assertEquals("test", result); [EOL] }
public void testDeserializeWithJsonParseException() { [EOL] JsonElement json = new JsonPrimitive("invalid"); [EOL] Type typeOfT = String.class; [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] when(delegate.deserialize(json, typeOfT, context)).thenThrow(new JsonParseException("Invalid json")); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithGenericException() { [EOL] JsonElement json = new JsonPrimitive("invalid"); [EOL] Type typeOfT = String.class; [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] when(delegate.deserialize(json, typeOfT, context)).thenThrow(new RuntimeException("Unexpected error")); [EOL] try { [EOL] deserialize(json, typeOfT, context); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] assertTrue(e.getMessage().contains("failed to deserialized json object")); [EOL] assertTrue(e.getCause() instanceof RuntimeException); [EOL] } [EOL] }
public void testJsonParseExceptionWithMessage() { [EOL] String expectedMessage = "Test message"; [EOL] JsonParseException exception = new JsonParseException(expectedMessage); [EOL] assertEquals(expectedMessage, exception.getMessage()); [EOL] }
public void testTranslateNameWithEmptyPolicies() { [EOL] CompositeFieldNamingPolicy compositePolicy = new CompositeFieldNamingPolicy(); [EOL] String targetName = "testFieldName"; [EOL] Type fieldType = String.class; [EOL] Collection<Annotation> annotations = Collections.emptyList(); [EOL] String translatedName = compositePolicy.translateName(targetName, fieldType, annotations); [EOL] assertEquals("testFieldName", translatedName); [EOL] }
public void testTranslateNameWithSinglePolicy() { [EOL] RecursiveFieldNamingPolicy mockPolicy = new RecursiveFieldNamingPolicy() { [EOL] @Override [EOL] public String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL] return "mock_" + target; [EOL] } [EOL] }; [EOL] CompositeFieldNamingPolicy compositePolicy = new CompositeFieldNamingPolicy(mockPolicy); [EOL] String targetName = "testFieldName"; [EOL] Type fieldType = String.class; [EOL] Collection<Annotation> annotations = Collections.emptyList(); [EOL] String translatedName = compositePolicy.translateName(targetName, fieldType, annotations); [EOL] assertEquals("mock_testFieldName", translatedName); [EOL] }
public void testTranslateNameWithMultiplePolicies() { [EOL] RecursiveFieldNamingPolicy mockPolicy1 = new RecursiveFieldNamingPolicy() { [EOL] @Override [EOL] public String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL] return "mock1_" + target; [EOL] } [EOL] }; [EOL] RecursiveFieldNamingPolicy mockPolicy2 = new RecursiveFieldNamingPolicy() { [EOL] @Override [EOL] public String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL] return "mock2_" + target; [EOL] } [EOL] }; [EOL] CompositeFieldNamingPolicy compositePolicy = new CompositeFieldNamingPolicy(mockPolicy1, mockPolicy2); [EOL] String targetName = "testFieldName"; [EOL] Type fieldType = String.class; [EOL] Collection<Annotation> annotations = Collections.emptyList(); [EOL] String translatedName = compositePolicy.translateName(targetName, fieldType, annotations); [EOL] assertEquals("mock2_mock1_testFieldName", translatedName); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL] return false; [EOL] }
public void testHashCode_nullGenericComponentType() { [EOL] TypeToken<?> typeToken = new TypeToken<Object>() {}; [EOL] typeToken.genericComponentType = null; [EOL] int hashCode = typeToken.hashCode(); [EOL] assertEquals(0, hashCode); [EOL] }
public void testHashCode_nonNullGenericComponentType() { [EOL] TypeToken<?> typeToken = new TypeToken<List<String>>() {}; [EOL] int expectedHashCode = typeToken.genericComponentType.hashCode(); [EOL] int actualHashCode = typeToken.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testVisitChildAsArrayWithValidArray() { [EOL] Type childType = new TypeToken<List<Integer>>() {}.getType(); [EOL] JsonArray jsonChild = new JsonArray(); [EOL] jsonChild.add(1); [EOL] jsonChild.add(2); [EOL] jsonChild.add(3); [EOL] Gson gson = new Gson(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new GsonDeserializationContext(gson)); [EOL] ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers = new ParameterizedTypeHandlerMap<>(); [EOL] ConstructorConstructor objectConstructor = new ConstructorConstructor(Collections.emptyMap()); [EOL] JsonDeserializationVisitorFactory factory = new JsonDeserializationVisitorFactory(); [EOL] Object result = visitChildAsArray(childType, jsonChild); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof List); [EOL] List<Integer> resultList = (List<Integer>) result; [EOL] assertEquals(3, resultList.size()); [EOL] assertEquals(Integer.valueOf(1), resultList.get(0)); [EOL] assertEquals(Integer.valueOf(2), resultList.get(1)); [EOL] assertEquals(Integer.valueOf(3), resultList.get(2)); [EOL] }
public void testVisitChildWithNonNullTypeAndVisitor() { [EOL] Type type = String.class; [EOL] JsonDeserializationVisitor<?> childVisitor = mock(JsonDeserializationVisitor.class); [EOL] ObjectNavigatorFactory factory = mock(ObjectNavigatorFactory.class); [EOL] ObjectNavigator on = mock(ObjectNavigator.class); [EOL] when(factory.create(any(ObjectTypePair.class))).thenReturn(on); [EOL] Object result = visitChild(type, childVisitor); [EOL] verify(factory).create(any(ObjectTypePair.class)); [EOL] verify(on).accept(childVisitor); [EOL] verify(childVisitor).getTarget(); [EOL] assertNotNull(result); [EOL] }
public void testTranslateNameWithNonLetterAtStart() { [EOL] String target = "123name"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = new ArrayList<>(); // Assuming annotations are not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("123name", result); [EOL] }
public void testTranslateNameWithUpperCaseFirstLetter() { [EOL] String target = "Name"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = new ArrayList<>(); // Assuming annotations are not used in the method [EOL] letterModifier = LetterModifier.UPPER; // Assuming letterModifier is a field that can be set [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("Name", result); [EOL] }
public void testTranslateNameWithLowerCaseFirstLetterAndUpperCaseModifier() { [EOL] String target = "name"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = new ArrayList<>(); // Assuming annotations are not used in the method [EOL] letterModifier = LetterModifier.UPPER; // Assuming letterModifier is a field that can be set [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("Name", result); [EOL] }
public void testTranslateNameWithUpperCaseFirstLetterAndLowerCaseModifier() { [EOL] String target = "Name"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = new ArrayList<>(); // Assuming annotations are not used in the method [EOL] letterModifier = LetterModifier.LOWER; // Assuming letterModifier is a field that can be set [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("name", result); [EOL] }
public void testTranslateNameAllNonLetters() { [EOL] String target = "123456"; [EOL] Type fieldType = null; // Assuming fieldType is not used in the method [EOL] Collection<Annotation> annotations = new ArrayList<>(); // Assuming annotations are not used in the method [EOL] String result = translateName(target, fieldType, annotations); [EOL] assertEquals("123456", result); [EOL] }
public void testConstructArrayWithValidTypeAndPositiveLength() { [EOL] Type type = Integer.class; [EOL] int length = 10; [EOL] Object array = constructArray(type, length); [EOL] assertNotNull(array); [EOL] assertTrue(array.getClass().isArray()); [EOL] assertEquals(length, Array.getLength(array)); [EOL] }
public void testConstructArrayWithValidTypeAndZeroLength() { [EOL] Type type = String.class; [EOL] int length = 0; [EOL] Object array = constructArray(type, length); [EOL] assertNotNull(array); [EOL] assertTrue(array.getClass().isArray()); [EOL] assertEquals(length, Array.getLength(array)); [EOL] }
public void testConstructArrayWithValidTypeAndNegativeLength() { [EOL] Type type = Double.class; [EOL] int length = -1; [EOL] try { [EOL] constructArray(type, length); [EOL] fail("Should have thrown NegativeArraySizeException"); [EOL] } catch (NegativeArraySizeException expected) { [EOL] } [EOL] }
public void testNavigateClassFieldsWithSkippedFields() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] FieldAttributes fieldAttributes = mock(FieldAttributes.class); [EOL] when(exclusionStrategy.shouldSkipField(fieldAttributes)).thenReturn(true); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, never()).visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithSkippedClass() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] FieldAttributes fieldAttributes = mock(FieldAttributes.class); [EOL] when(exclusionStrategy.shouldSkipField(fieldAttributes)).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(true); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, never()).visitFieldUsingCustomHandler(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithCustomHandler() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] FieldAttributes fieldAttributes = mock(FieldAttributes.class); [EOL] when(exclusionStrategy.shouldSkipField(fieldAttributes)).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitFieldUsingCustomHandler(fieldAttributes, any(Type.class), obj)).thenReturn(true); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor).visitFieldUsingCustomHandler(fieldAttributes, any(Type.class), obj); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithArrayField() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] FieldAttributes fieldAttributes = mock(FieldAttributes.class); [EOL] TypeInfo fieldTypeInfo = mock(TypeInfo.class); [EOL] when(exclusionStrategy.shouldSkipField(fieldAttributes)).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitFieldUsingCustomHandler(fieldAttributes, any(Type.class), obj)).thenReturn(false); [EOL] when(fieldTypeInfo.isArray()).thenReturn(true); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, never()).visitFieldUsingCustomHandler(fieldAttributes, any(Type.class), obj); [EOL] verify(visitor).visitArrayField(fieldAttributes, any(Type.class), obj); [EOL] verify(visitor, never()).visitObjectField(any(FieldAttributes.class), any(Type.class), any()); [EOL] }
public void testNavigateClassFieldsWithObjectField() { [EOL] Object obj = new Object(); [EOL] Class<?> clazz = obj.getClass(); [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] FieldAttributes fieldAttributes = mock(FieldAttributes.class); [EOL] TypeInfo fieldTypeInfo = mock(TypeInfo.class); [EOL] when(exclusionStrategy.shouldSkipField(fieldAttributes)).thenReturn(false); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitFieldUsingCustomHandler(fieldAttributes, any(Type.class), obj)).thenReturn(false); [EOL] when(fieldTypeInfo.isArray()).thenReturn(false); [EOL] navigateClassFields(obj, clazz, visitor); [EOL] verify(visitor, never()).visitFieldUsingCustomHandler(fieldAttributes, any(Type.class), obj); [EOL] verify(visitor, never()).visitArrayField(any(FieldAttributes.class), any(Type.class), any()); [EOL] verify(visitor).visitObjectField(fieldAttributes, any(Type.class), obj); [EOL] }
public void testSetVersion_Positive() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] double version = 1.0; [EOL] GsonBuilder result = gsonBuilder.setVersion(version); [EOL] assertEquals(version, gsonBuilder.ignoreVersionsAfter, 0); [EOL] assertSame(gsonBuilder, result); [EOL] } [EOL] public void testSetVersion_Negative() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] double version = -1.0; [EOL] GsonBuilder result = gsonBuilder.setVersion(version); [EOL] assertEquals(version, gsonBuilder.ignoreVersionsAfter, 0); [EOL] assertSame(gsonBuilder, result); [EOL] } [EOL] public void testSetVersion_Zero() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] double version = 0.0; [EOL] GsonBuilder result = gsonBuilder.setVersion(version); [EOL] assertEquals(version, gsonBuilder.ignoreVersionsAfter, 0); [EOL] assertSame(gsonBuilder, result); [EOL] } [EOL] public void testSetVersion_MaxDouble() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] double version = Double.MAX_VALUE; [EOL] GsonBuilder result = gsonBuilder.setVersion(version); [EOL] assertEquals(version, gsonBuilder.ignoreVersionsAfter, 0); [EOL] assertSame(gsonBuilder, result); [EOL] } [EOL] public void testSetVersion_MinDouble() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] double version = Double.MIN_VALUE; [EOL] GsonBuilder result = gsonBuilder.setVersion(version); [EOL] assertEquals(version, gsonBuilder.ignoreVersionsAfter, 0); [EOL] assertSame(gsonBuilder, result); [EOL] }
public void testRegisterTypeAdapterWithInstanceCreator() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Type type = new TypeToken<List<String>>() {}.getType(); [EOL] InstanceCreator<List<String>> instanceCreator = type1 -> new ArrayList<>(); [EOL] builder.registerTypeAdapter(type, instanceCreator); [EOL] }
public void testRegisterTypeAdapterWithJsonSerializer() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Type type = new TypeToken<List<String>>() {}.getType(); [EOL] JsonSerializer<List<String>> jsonSerializer = (src, typeOfSrc, context) -> new JsonPrimitive("serializer"); [EOL] builder.registerTypeAdapter(type, jsonSerializer); [EOL] }
public void testRegisterTypeAdapterWithJsonDeserializer() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Type type = new TypeToken<List<String>>() {}.getType(); [EOL] JsonDeserializer<List<String>> jsonDeserializer = (json, typeOfT, context) -> new ArrayList<>(); [EOL] builder.registerTypeAdapter(type, jsonDeserializer); [EOL] }
public void testRegisterTypeAdapterWithInvalidType() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Type type = new TypeToken<List<String>>() {}.getType(); [EOL] Object invalidTypeAdapter = new Object(); [EOL] try { [EOL] builder.registerTypeAdapter(type, invalidTypeAdapter); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
private <T> GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator) { [EOL] instanceCreators.register(typeOfT, instanceCreator); [EOL] return this; [EOL] }
public void testRegisterSerializerWithNonNullTypeAndSerializer() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] JsonSerializer<String> serializer = (src, typeOfSrc, context) -> new JsonPrimitive(src); [EOL] builder = builder.registerSerializer(String.class, serializer); [EOL] assertNotNull(builder); [EOL] }
public void testRegisterSerializerWithNullType() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] JsonSerializer<String> serializer = (src, typeOfSrc, context) -> new JsonPrimitive(src); [EOL] try { [EOL] builder.registerSerializer(null, serializer); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testRegisterSerializerWithNullSerializer() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] try { [EOL] builder.registerSerializer(String.class, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testRegisterDeserializerWithNonNullTypeAndDeserializer() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Type typeOfT = String.class; [EOL] JsonDeserializer<String> deserializer = (json, typeOfSrc, context) -> "deserialized"; [EOL] GsonBuilder returnedBuilder = builder.registerDeserializer(typeOfT, deserializer); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testRegisterDeserializerWithNullType() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] JsonDeserializer<String> deserializer = (json, typeOfSrc, context) -> "deserialized"; [EOL] try { [EOL] builder.registerDeserializer(null, deserializer); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testRegisterDeserializerWithNullDeserializer() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] Type typeOfT = String.class; [EOL] try { [EOL] builder.registerDeserializer(typeOfT, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testCreateWithSerializeInnerClasses() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeInnerClasses(false); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testCreateWithIgnoreVersionsAfter() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setVersion(1.0); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testCreateWithExcludeFieldsWithoutExposeAnnotation() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.excludeFieldsWithoutExposeAnnotation(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testCreateWithAllConfigurations() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.serializeInnerClasses(false); [EOL] builder.setVersion(1.0); [EOL] builder.excludeFieldsWithoutExposeAnnotation(); [EOL] Gson gson = builder.create(); [EOL] assertNotNull(gson); [EOL] }
public void testTranslateNameWithEmptyString() { [EOL] String result = translateName("", null, null); [EOL] assertEquals("", result); [EOL] }
public void testTranslateNameWithSingleWord() { [EOL] String result = translateName("word", null, null); [EOL] assertEquals("word", result); [EOL] }
public void testTranslateNameWithCamelCase() { [EOL] String result = translateName("camelCaseWord", null, null); [EOL] assertEquals("camel-Case-Word", result); [EOL] }
public void testTranslateNameWithUpperCase() { [EOL] String result = translateName("UPPERCASE", null, null); [EOL] assertEquals("UPPERCASE", result); [EOL] }
public void testTranslateNameWithLeadingUppercase() { [EOL] String result = translateName("LeadingUppercase", null, null); [EOL] assertEquals("Leading-Uppercase", result); [EOL] }
public void testPushWithNonNullObject() { [EOL] ObjectTypePair obj = new ObjectTypePair(/* parameters to construct the object */); [EOL] JsonReaderInternalAccess.INSTANCE.push(obj); [EOL] }
public void testPushWithNullObject() { [EOL] try { [EOL] JsonReaderInternalAccess.INSTANCE.push(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPop_WhenStackNotEmpty_ShouldReturnTopElement() { [EOL] JsonReaderInternalAccess.INSTANCE.promoteNameToValue(reader); [EOL] ObjectTypePair result = instance.pop(); [EOL] assertNotNull(result); [EOL] }
public void testPop_WhenStackEmpty_ShouldThrowEmptyStackException() { [EOL] try { [EOL] ObjectTypePair result = instance.pop(); [EOL] fail("Expected EmptyStackException to be thrown"); [EOL] } catch (EmptyStackException e) { [EOL] } [EOL] }
public void testPeekWhenStackIsEmpty() { [EOL] JsonReader reader = new JsonReader(new StringReader("{}")); [EOL] try { [EOL] reader.beginObject(); [EOL] reader.peek(); [EOL] fail("Expected NoSuchElementException"); [EOL] } catch (NoSuchElementException expected) { [EOL] } [EOL] }
public void testPeekWhenStackIsNotEmpty() { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key\":\"value\"}")); [EOL] reader.beginObject(); [EOL] ObjectTypePair result = reader.peek(); [EOL] assertNotNull(result); [EOL] assertEquals(JsonToken.NAME, result.type); [EOL] }
public void testGetDeclaringClass() { [EOL] MyObject obj = new MyObject(); [EOL] Class<?> clazz = obj.getDeclaringClass(); [EOL] assertNotNull(clazz); [EOL] assertEquals(MyObject.class, clazz); [EOL] }
public void testGetDeclaredType_WithNullGenericType() { [EOL] FieldInfo fieldInfo = new FieldInfo(null, null, null); // Assuming a constructor that sets genericType to null [EOL] Type result = fieldInfo.getDeclaredType(); [EOL] assertNotNull(result); [EOL] }
public void testGetDeclaredType_WithNonNullGenericType() { [EOL] Type expectedType = String.class; // Assuming String.class as a placeholder for any Type [EOL] FieldInfo fieldInfo = new FieldInfo(null, expectedType, null); // Assuming a constructor that sets genericType to a non-null value [EOL] Type result = fieldInfo.getDeclaredType(); [EOL] assertSame(expectedType, result); [EOL] }
public void testGetDeclaredClass() { [EOL] Class<?> expected = String.class; [EOL] Class<?> actual = instance.getDeclaredClass(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAnnotations_CacheMiss() { [EOL] Field field = mock(Field.class); [EOL] Class<?> declaringClazz = mock(Class.class); [EOL] String name = "testField"; [EOL] AnnotationCache ANNOTATION_CACHE = mock(AnnotationCache.class); [EOL] when(field.getAnnotations()).thenReturn(new Annotation[0]); [EOL] when(ANNOTATION_CACHE.getElement(any(Pair.class))).thenReturn(null); [EOL] FieldInfo fieldInfo = new FieldInfo(field, declaringClazz, name, ANNOTATION_CACHE); [EOL] Collection<Annotation> result = fieldInfo.getAnnotations(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] verify(ANNOTATION_CACHE).addElement(any(Pair.class), eq(result)); [EOL] }
public void testGetAnnotations_CacheHit() { [EOL] Field field = mock(Field.class); [EOL] Class<?> declaringClazz = mock(Class.class); [EOL] String name = "testField"; [EOL] AnnotationCache ANNOTATION_CACHE = mock(AnnotationCache.class); [EOL] Collection<Annotation> cachedAnnotations = Collections.singletonList(mock(Annotation.class)); [EOL] when(ANNOTATION_CACHE.getElement(any(Pair.class))).thenReturn(cachedAnnotations); [EOL] FieldInfo fieldInfo = new FieldInfo(field, declaringClazz, name, ANNOTATION_CACHE); [EOL] Collection<Annotation> result = fieldInfo.getAnnotations(); [EOL] assertSame(cachedAnnotations, result); [EOL] verify(ANNOTATION_CACHE, never()).addElement(any(Pair.class), any(Collection.class)); [EOL] }
public void testGetAnnotationFromArrayWithMatchingAnnotation() { [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] annotations.add(new Override() { [EOL] public Class<? extends Annotation> annotationType() { [EOL] return Override.class; [EOL] } [EOL] }); [EOL] Override result = getAnnotationFromArray(annotations, Override.class); [EOL] assertNotNull(result); [EOL] }
public void testGetAnnotationFromArrayWithNoMatchingAnnotation() { [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] annotations.add(new Deprecated() { [EOL] public Class<? extends Annotation> annotationType() { [EOL] return Deprecated.class; [EOL] } [EOL] }); [EOL] Override result = getAnnotationFromArray(annotations, Override.class); [EOL] assertNull(result); [EOL] }
public void testGetAnnotationFromArrayWithEmptyCollection() { [EOL] Collection<Annotation> annotations = new ArrayList<>(); [EOL] Override result = getAnnotationFromArray(annotations, Override.class); [EOL] assertNull(result); [EOL] }
public void testJsonPrimitiveWithBoolean() { [EOL] JsonPrimitive jsonPrimitiveTrue = new JsonPrimitive(true); [EOL] assertTrue(jsonPrimitiveTrue.isBoolean()); [EOL] assertTrue(jsonPrimitiveTrue.getAsBoolean()); [EOL] assertEquals(Boolean.TRUE, jsonPrimitiveTrue.getAsBooleanWrapper()); [EOL] JsonPrimitive jsonPrimitiveFalse = new JsonPrimitive(false); [EOL] assertTrue(jsonPrimitiveFalse.isBoolean()); [EOL] assertFalse(jsonPrimitiveFalse.getAsBoolean()); [EOL] assertEquals(Boolean.FALSE, jsonPrimitiveFalse.getAsBooleanWrapper()); [EOL] }
public void testJsonPrimitiveWithNumber() { [EOL] Number numberValue = 42; [EOL] JsonPrimitive jsonPrimitiveNumber = new JsonPrimitive(numberValue); [EOL] assertTrue(jsonPrimitiveNumber.isNumber()); [EOL] assertEquals(numberValue, jsonPrimitiveNumber.getAsNumber()); [EOL] assertEquals(numberValue.intValue(), jsonPrimitiveNumber.getAsInt()); [EOL] }
public void testJsonPrimitiveWithString() { [EOL] String stringValue = "test"; [EOL] JsonPrimitive jsonPrimitiveString = new JsonPrimitive(stringValue); [EOL] assertTrue(jsonPrimitiveString.isString()); [EOL] assertEquals(stringValue, jsonPrimitiveString.getAsString()); [EOL] }
public void testJsonPrimitiveWithCharacter() { [EOL] Character charValue = 'a'; [EOL] JsonPrimitive jsonPrimitiveChar = new JsonPrimitive(charValue); [EOL] assertTrue(jsonPrimitiveChar.isString()); [EOL] assertEquals(charValue.toString(), jsonPrimitiveChar.getAsString()); [EOL] assertEquals(charValue.charValue(), jsonPrimitiveChar.getAsCharacter()); [EOL] }
public void testJsonPrimitiveHashCodeAndEquals() { [EOL] JsonPrimitive jsonPrimitiveA = new JsonPrimitive(42); [EOL] JsonPrimitive jsonPrimitiveB = new JsonPrimitive(42); [EOL] JsonPrimitive jsonPrimitiveC = new JsonPrimitive(43); [EOL] assertEquals(jsonPrimitiveA.hashCode(), jsonPrimitiveB.hashCode()); [EOL] assertNotEquals(jsonPrimitiveA.hashCode(), jsonPrimitiveC.hashCode()); [EOL] assertTrue(jsonPrimitiveA.equals(jsonPrimitiveB)); [EOL] assertFalse(jsonPrimitiveA.equals(jsonPrimitiveC)); [EOL] assertFalse(jsonPrimitiveA.equals(null)); [EOL] assertFalse(jsonPrimitiveA.equals(new Object())); [EOL] }
public void testJsonPrimitiveWithNull() { [EOL] JsonPrimitive jsonPrimitiveNull = new JsonPrimitive((String) null); [EOL] assertTrue(jsonPrimitiveNull.isString()); [EOL] assertNull(jsonPrimitiveNull.getAsString()); [EOL] }
public void testJsonPrimitiveWithDifferentTypes() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(42); [EOL] JsonPrimitive jsonPrimitiveDouble = new JsonPrimitive(42.0); [EOL] JsonPrimitive jsonPrimitiveString = new JsonPrimitive("42"); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitiveInt)); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitiveDouble)); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitiveString)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitiveInt)); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitiveDouble)); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitiveString)); [EOL] }
public void testSetValueWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] jsonPrimitive.setValue('b'); [EOL] assertEquals("b", jsonPrimitive.getAsString()); [EOL] }
public void testSetValueWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] jsonPrimitive.setValue(20); [EOL] assertEquals(20, jsonPrimitive.getAsNumber()); [EOL] }
public void testSetValueWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] jsonPrimitive.setValue("newTest"); [EOL] assertEquals("newTest", jsonPrimitive.getAsString()); [EOL] }
public void testSetValueWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] jsonPrimitive.setValue(false); [EOL] assertEquals(false, jsonPrimitive.getAsBoolean()); [EOL] }
public void testSetValueWithNull() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Object) null); [EOL] try { [EOL] jsonPrimitive.setValue(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testSetValueWithUnsupportedType() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] try { [EOL] jsonPrimitive.setValue(new Object()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testIsBooleanWithBooleanValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] }
public void testIsBooleanWithNumberValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] }
public void testIsBooleanWithStringValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] }
public void testIsBooleanWithCharacterValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(jsonPrimitive.isBoolean()); [EOL] }
public void testGetAsBooleanWrapperWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(Boolean.TRUE); [EOL] Boolean result = jsonPrimitive.getAsBooleanWrapper(); [EOL] assertTrue(result); [EOL] }
public void testGetAsBooleanWrapperWithNull() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((Boolean) null); [EOL] Boolean result = jsonPrimitive.getAsBooleanWrapper(); [EOL] assertNull(result); [EOL] }
public void testJsonPrimitiveWithNumber() { [EOL] Number numberValue = 123; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(numberValue); [EOL] assertEquals(numberValue, jsonPrimitive.getAsNumber()); [EOL] }
public void testJsonPrimitiveWithString() { [EOL] String stringValue = "test"; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(stringValue); [EOL] assertEquals(stringValue, jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithCharacter() { [EOL] Character charValue = 'a'; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(charValue); [EOL] assertEquals((Object) charValue, jsonPrimitive.getAsCharacter()); [EOL] }
public void testSetValue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(""); [EOL] jsonPrimitive.setValue(true); [EOL] assertTrue(jsonPrimitive.isBoolean()); [EOL] assertTrue(jsonPrimitive.getAsBoolean()); [EOL] }
public void testIsNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] }
public void testStringToNumber() { [EOL] Number number = JsonPrimitive.stringToNumber("10"); [EOL] assertEquals(10, number.intValue()); [EOL] }
public void testIsString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] }
public void testGetAsDouble() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10.5); [EOL] assertEquals(10.5, jsonPrimitive.getAsDouble(), 0.0); [EOL] }
public void testGetAsBigDecimal() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(new BigDecimal("10.5")); [EOL] assertEquals(new BigDecimal("10.5"), jsonPrimitive.getAsBigDecimal()); [EOL] }
public void testGetAsBigInteger() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(new BigInteger("10")); [EOL] assertEquals(new BigInteger("10"), jsonPrimitive.getAsBigInteger()); [EOL] }
public void testGetAsFloat() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10.5f); [EOL] assertEquals(10.5f, jsonPrimitive.getAsFloat(), 0.0f); [EOL] }
public void testGetAsLong() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10L); [EOL] assertEquals(10L, jsonPrimitive.getAsLong()); [EOL] }
public void testGetAsShort() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((short) 10); [EOL] assertEquals((short) 10, jsonPrimitive.getAsShort()); [EOL] }
public void testGetAsInt() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertEquals(10, jsonPrimitive.getAsInt()); [EOL] }
public void testGetAsByte() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive((byte) 10); [EOL] assertEquals((byte) 10, jsonPrimitive.getAsByte()); [EOL] }
public void testGetAsCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertEquals('a', jsonPrimitive.getAsCharacter()); [EOL] }
public void testGetAsObject() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertEquals(10, jsonPrimitive.getAsObject()); [EOL] }
public void testHashCode() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] int hashCode = jsonPrimitive.hashCode(); [EOL] assertNotNull(hashCode); [EOL] }
public void testEquals() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive(10); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] }
public void testIsIntegral() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitive)); [EOL] }
public void testIsFloatingPoint() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10.5); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitive)); [EOL] }
public void testGetAsBooleanWithBooleanTrue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertTrue(jsonPrimitive.getAsBoolean()); [EOL] }
public void testGetAsBooleanWithBooleanFalse() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(false); [EOL] assertFalse(jsonPrimitive.getAsBoolean()); [EOL] }
public void testGetAsBooleanWithStringTrue() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("true"); [EOL] assertTrue(jsonPrimitive.getAsBoolean()); [EOL] }
public void testGetAsBooleanWithStringFalse() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("false"); [EOL] assertFalse(jsonPrimitive.getAsBoolean()); [EOL] }
public void testGetAsBooleanWithNumberOne() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(1); [EOL] assertThrows(IllegalStateException.class, jsonPrimitive::getAsBoolean); [EOL] }
public void testGetAsBooleanWithNumberZero() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(0); [EOL] assertThrows(IllegalStateException.class, jsonPrimitive::getAsBoolean); [EOL] }
public void testGetAsBooleanWithCharacterT() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('T'); [EOL] assertThrows(IllegalStateException.class, jsonPrimitive::getAsBoolean); [EOL] }
public void testGetAsBooleanWithCharacterF() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('F'); [EOL] assertThrows(IllegalStateException.class, jsonPrimitive::getAsBoolean); [EOL] }
private static boolean isPrimitiveOrString(Object target) { [EOL] if (target instanceof String) { [EOL] return true; [EOL] } [EOL] Class<?> classOfPrimitive = target.getClass(); [EOL] for (Class<?> standardPrimitive : PRIMITIVE_TYPES) { [EOL] if (standardPrimitive.isAssignableFrom(classOfPrimitive)) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testShouldSkipField_NoAnnotation() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(null); [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipField_AnnotationPresentDeserializeTrue() { [EOL] Expose mockExpose = mock(Expose.class); [EOL] when(mockExpose.deserialize()).thenReturn(true); [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(mockExpose); [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipField(f); [EOL] assertFalse(result); [EOL] }
public void testShouldSkipField_AnnotationPresentDeserializeFalse() { [EOL] Expose mockExpose = mock(Expose.class); [EOL] when(mockExpose.deserialize()).thenReturn(false); [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] when(f.getAnnotation(Expose.class)).thenReturn(mockExpose); [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipField(f); [EOL] assertTrue(result); [EOL] }
public void testGetAsJsonObject_WhenIsJsonObject() { [EOL] JsonElement element = new JsonObject(); [EOL] JsonObject jsonObject = element.getAsJsonObject(); [EOL] assertNotNull(jsonObject); [EOL] assertTrue(element.isJsonObject()); [EOL] }
public void testGetAsJsonObject_WhenNotJsonObject() { [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] try { [EOL] element.getAsJsonObject(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("This is not a JSON Object.", e.getMessage()); [EOL] } [EOL] }
public void testToMoreSpecificTypeWithPreserveType() { [EOL] ObjectTypePair original = new ObjectTypePair(null, Object.class, true); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertSame("Expected the same ObjectTypePair due to preserveType being true", original, result); [EOL] } [EOL] public void testToMoreSpecificTypeWithNullObject() { [EOL] ObjectTypePair original = new ObjectTypePair(null, Object.class, false); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertSame("Expected the same ObjectTypePair due to obj being null", original, result); [EOL] }
public void testToMoreSpecificTypeWithActualTypeSameAsType() { [EOL] Object obj = new Object(); [EOL] ObjectTypePair original = new ObjectTypePair(obj, Object.class, false); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertSame("Expected the same ObjectTypePair due to actualType being the same as type", original, result); [EOL] }
public void testToMoreSpecificTypeWithMoreSpecificActualType() { [EOL] String obj = "test"; [EOL] ObjectTypePair original = new ObjectTypePair(obj, Object.class, false); [EOL] ObjectTypePair result = original.toMoreSpecificType(); [EOL] assertNotSame("Expected a different ObjectTypePair due to more specific actualType", original, result); [EOL] assertEquals("Expected actualType to be String.class", String.class, result.getType()); [EOL] }
public void testEquals_Reflexive() { [EOL] ObjectTypePair x = new ObjectTypePair(new Object(), Object.class, true); [EOL] assertTrue(x.equals(x)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ObjectTypePair x = new ObjectTypePair(new Object(), Object.class, true); [EOL] assertFalse(x.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] ObjectTypePair x = new ObjectTypePair(new Object(), Object.class, true); [EOL] assertFalse(x.equals(new String("Not an ObjectTypePair"))); [EOL] } [EOL] public void testEquals_DifferentObjectTypePair_NullObj() { [EOL] ObjectTypePair x = new ObjectTypePair(null, Object.class, true); [EOL] ObjectTypePair y = new ObjectTypePair(new Object(), Object.class, true); [EOL] assertFalse(x.equals(y)); [EOL] } [EOL] public void testEquals_DifferentObjectTypePair_DifferentObj() { [EOL] Object obj1 = new Object(); [EOL] Object obj2 = new Object(); [EOL] ObjectTypePair x = new ObjectTypePair(obj1, Object.class, true); [EOL] ObjectTypePair y = new ObjectTypePair(obj2, Object.class, true); [EOL] assertFalse(x.equals(y)); [EOL] } [EOL] public void testEquals_DifferentObjectTypePair_NullType() { [EOL] ObjectTypePair x = new ObjectTypePair(new Object(), null, true); [EOL] ObjectTypePair y = new ObjectTypePair(new Object(), Object.class, true); [EOL] assertFalse(x.equals(y)); [EOL] } [EOL] public void testEquals_DifferentObjectTypePair_DifferentType() { [EOL] ObjectTypePair x = new ObjectTypePair(new Object(), String.class, true); [EOL] ObjectTypePair y = new ObjectTypePair(new Object(), Object.class, true); [EOL] assertFalse(x.equals(y)); [EOL] } [EOL] public void testEquals_DifferentPreserveType() { [EOL] ObjectTypePair x = new ObjectTypePair(new Object(), Object.class, true); [EOL] ObjectTypePair y = new ObjectTypePair(new Object(), Object.class, false); [EOL] assertFalse(x.equals(y)); [EOL] } [EOL] public void testEquals_EqualObjectTypePair() { [EOL] Object obj = new Object(); [EOL] ObjectTypePair x = new ObjectTypePair(obj, Object.class, true); [EOL] ObjectTypePair y = new ObjectTypePair(obj, Object.class, true); [EOL] assertTrue(x.equals(y)); [EOL] }
public void testShouldSkipClass_WithInnerClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(InnerClass.class); [EOL] assertTrue(result); [EOL] }
public void testShouldSkipClass_WithNonInnerClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.shouldSkipClass(String.class); [EOL] assertFalse(result); [EOL] }
