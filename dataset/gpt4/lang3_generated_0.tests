public void testToBooleanObjectTrue() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = trueValue; [EOL] Boolean result = Lang3.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testToBooleanObjectFalse() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = falseValue; [EOL] Boolean result = Lang3.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testToBooleanObjectNull() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = nullValue; [EOL] Boolean result = Lang3.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] assertNull(result); [EOL] }
public void testToBooleanObjectIllegalArgumentException() { [EOL] int trueValue = 1; [EOL] int falseValue = 0; [EOL] int nullValue = -1; [EOL] int testValue = 2; [EOL] try { [EOL] Lang3.toBooleanObject(testValue, trueValue, falseValue, nullValue); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToIntegerObject_WithTrueBooleanAndNonNullValues() { [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 0; [EOL] Integer result = toIntegerObject(true, trueValue, falseValue); [EOL] assertEquals(trueValue, result); [EOL] } [EOL] public void testToIntegerObject_WithFalseBooleanAndNonNullValues() { [EOL] Integer trueValue = 1; [EOL] Integer falseValue = 0; [EOL] Integer result = toIntegerObject(false, trueValue, falseValue); [EOL] assertEquals(falseValue, result); [EOL] } [EOL] public void testToIntegerObject_WithTrueBooleanAndNullTrueValue() { [EOL] Integer trueValue = null; [EOL] Integer falseValue = 0; [EOL] Integer result = toIntegerObject(true, trueValue, falseValue); [EOL] assertNull(result); [EOL] } [EOL] public void testToIntegerObject_WithFalseBooleanAndNullFalseValue() { [EOL] Integer trueValue = 1; [EOL] Integer falseValue = null; [EOL] Integer result = toIntegerObject(false, trueValue, falseValue); [EOL] assertNull(result); [EOL] } [EOL] public void testToIntegerObject_WithBothNullValues() { [EOL] Integer trueValue = null; [EOL] Integer falseValue = null; [EOL] Integer result = toIntegerObject(true, trueValue, falseValue); [EOL] assertNull(result); [EOL] } [EOL] public void testToIntegerObject_WithBothNullValuesAndFalseBoolean() { [EOL] Integer trueValue = null; [EOL] Integer falseValue = null; [EOL] Integer result = toIntegerObject(false, trueValue, falseValue); [EOL] assertNull(result); [EOL] }
public void testToBoolean_StrEqualsTrueString() { [EOL] assertTrue(StringUtils.toBoolean("true", "true", "false")); [EOL] }
public void testToBoolean_StrEqualsFalseString() { [EOL] assertFalse(StringUtils.toBoolean("false", "true", "false")); [EOL] }
public void testToBoolean_StrNonMatchingNotNull() { [EOL] try { [EOL] StringUtils.toBoolean("maybe", "true", "false"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testToBoolean_StrNull() { [EOL] try { [EOL] StringUtils.toBoolean(null, "true", "false"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testToBoolean_TrueStringNull() { [EOL] try { [EOL] StringUtils.toBoolean("true", null, "false"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testToBoolean_FalseStringNull() { [EOL] try { [EOL] StringUtils.toBoolean("false", "true", null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testToStringOnOff_WhenBoolIsNull() { [EOL] String result = StringUtils.toStringOnOff(null); [EOL] assertNull(result); [EOL] }
public void testToStringOnOff_WhenBoolIsTrue() { [EOL] String result = StringUtils.toStringOnOff(true); [EOL] assertEquals("on", result); [EOL] }
public void testToStringOnOff_WhenBoolIsFalse() { [EOL] String result = StringUtils.toStringOnOff(false); [EOL] assertEquals("off", result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = MyClass.and((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = MyClass.and(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = MyClass.and(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_ValidArray_AllTrue() { [EOL] Boolean result = MyClass.and(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testAnd_ValidArray_OneFalse() { [EOL] Boolean result = MyClass.and(new Boolean[]{true, false, true}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = ArrayUtils.or(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = ArrayUtils.or(new boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_AllFalse_ReturnsFalse() { [EOL] boolean result = ArrayUtils.or(false, false, false); [EOL] assertFalse(result); [EOL] }
public void testOr_OneTrue_ReturnsTrue() { [EOL] boolean result = ArrayUtils.or(false, true, false); [EOL] assertTrue(result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ValidArrayWithTrue_ReturnsTrue() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testOr_ValidArrayWithAllFalse_ReturnsFalse() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testXor_NullArray_ThrowsException() { [EOL] try { [EOL] ArrayUtils.xor(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testXor_EmptyArray_ThrowsException() { [EOL] try { [EOL] ArrayUtils.xor(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testXor_SingleTrue_ReturnsTrue() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{true}); [EOL] assertTrue(result); [EOL] }
public void testXor_SingleFalse_ReturnsFalse() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{false}); [EOL] assertFalse(result); [EOL] }
public void testXor_MultipleTrue_ReturnsFalse() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{true, true}); [EOL] assertFalse(result); [EOL] }
public void testXor_OneTrueOneFalse_ReturnsTrue() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{true, false}); [EOL] assertTrue(result); [EOL] }
public void testXor_MultipleFalse_ReturnsFalse() { [EOL] boolean result = ArrayUtils.xor(new boolean[]{false, false}); [EOL] assertFalse(result); [EOL] }
public void testXor_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testXor_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testXor_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testXor_ValidArrayWithSingleTrue_ReturnsTrue() { [EOL] Boolean result = Lang3.xor(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] } [EOL] public void testXor_ValidArrayWithMultipleTrue_ReturnsFalse() { [EOL] Boolean result = Lang3.xor(new Boolean[]{true, true, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] public void testXor_ValidArrayWithNoTrue_ReturnsFalse() { [EOL] Boolean result = Lang3.xor(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testNumericEntityUnescaperWithNoOptions() { [EOL] NumericEntityUnescaper unescaper = new NumericEntityUnescaper(); [EOL] assertTrue("Default option should be semiColonRequired", unescaper.options.contains(NumericEntityUnescaper.OPTION.semiColonRequired)); [EOL] }
public void testNumericEntityUnescaperWithOptions() { [EOL] NumericEntityUnescaper unescaper = new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonRequired, NumericEntityUnescaper.OPTION.errorIfNoSemiColon); [EOL] assertTrue("Should contain semiColonRequired option", unescaper.options.contains(NumericEntityUnescaper.OPTION.semiColonRequired)); [EOL] assertTrue("Should contain errorIfNoSemiColon option", unescaper.options.contains(NumericEntityUnescaper.OPTION.errorIfNoSemiColon)); [EOL] }
public void testIsSetWithNullOptions() { [EOL] MyClass myClass = new MyClass(null); [EOL] assertFalse(myClass.isSet(OPTION.SOME_OPTION)); [EOL] }
public void testIsSetWithEmptyOptions() { [EOL] MyClass myClass = new MyClass(Collections.emptySet()); [EOL] assertFalse(myClass.isSet(OPTION.SOME_OPTION)); [EOL] }
public void testIsSetWithOptionPresent() { [EOL] Set<OPTION> options = new HashSet<>(); [EOL] options.add(OPTION.SOME_OPTION); [EOL] MyClass myClass = new MyClass(options); [EOL] assertTrue(myClass.isSet(OPTION.SOME_OPTION)); [EOL] }
public void testIsSetWithOptionNotPresent() { [EOL] Set<OPTION> options = new HashSet<>(); [EOL] options.add(OPTION.ANOTHER_OPTION); [EOL] MyClass myClass = new MyClass(options); [EOL] assertFalse(myClass.isSet(OPTION.SOME_OPTION)); [EOL] }
public void testTranslateWithAmpersandAndHashAtTheEnd() throws IOException { [EOL] CharSequence input = "&#"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with incomplete entity should return 0", 0, result); [EOL] } [EOL] public void testTranslateWithAmpersandHashAndSemicolon() throws IOException { [EOL] CharSequence input = "&#;"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with empty entity should return 0", 0, result); [EOL] } [EOL] public void testTranslateWithValidHexEntity() throws IOException { [EOL] CharSequence input = "&#x41;"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with valid hex entity should return correct length", 5, result); [EOL] assertEquals("Translation with valid hex entity should write correct char", 'A', out.toString().charAt(0)); [EOL] } [EOL] public void testTranslateWithValidDecimalEntity() throws IOException { [EOL] CharSequence input = "&#65;"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with valid decimal entity should return correct length", 4, result); [EOL] assertEquals("Translation with valid decimal entity should write correct char", 'A', out.toString().charAt(0)); [EOL] } [EOL] public void testTranslateWithInvalidEntityMissingSemicolon() throws IOException { [EOL] CharSequence input = "&#65"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] try { [EOL] translate(input, index, out); [EOL] fail("Translation with missing semicolon should throw IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] } [EOL] public void testTranslateWithInvalidEntityNotNumeric() throws IOException { [EOL] CharSequence input = "&#xG;"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with invalid hex entity should return 0", 0, result); [EOL] } [EOL] public void testTranslateWithEntityValueTooLarge() throws IOException { [EOL] CharSequence input = "&#x110000;"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with entity value too large should return correct length", 9, result); [EOL] assertEquals("Translation with entity value too large should write surrogate pair", 2, out.toString().length()); [EOL] }
public void testTranslateWithEntityValueInValidRange() throws IOException { [EOL] CharSequence input = "&#xFFFF;"; [EOL] Writer out = new StringWriter(); [EOL] int index = 0; [EOL] int result = translate(input, index, out); [EOL] assertEquals("Translation with entity value in valid range should return correct length", 7, result); [EOL] assertEquals("Translation with entity value in valid range should write single char", 1, out.toString().length()); [EOL] }
public void testInvokeMethodWithNullParameterTypesAndArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object result = invokeMethod(object, methodName, null, null); [EOL] assertNotNull(result); [EOL] assertEquals(object.toString(), result); [EOL] }
public void testInvokeMethodWithEmptyParameterTypesAndArgs() throws Exception { [EOL] final String methodName = "toString"; [EOL] final Object object = new Object(); [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class<?>[0]; [EOL] Object result = invokeMethod(object, methodName, args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals(object.toString(), result); [EOL] }
public void testInvokeMethodWithNoMatchingMethod() { [EOL] final String methodName = "nonExistentMethod"; [EOL] final Object object = new Object(); [EOL] try { [EOL] invokeMethod(object, methodName, null, null); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testInvokeExactStaticMethodWithNullArgsAndTypes() throws Exception { [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] try { [EOL] Object result = invokeExactStaticMethod(TestClass.class, "staticMethod", args, parameterTypes); [EOL] assertNotNull(result); [EOL] } catch (NoSuchMethodException e) { [EOL] fail("Method should exist"); [EOL] } [EOL] }
public void testInvokeExactStaticMethodWithEmptyArgsAndTypes() throws Exception { [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class[0]; [EOL] try { [EOL] Object result = invokeExactStaticMethod(TestClass.class, "staticMethod", args, parameterTypes); [EOL] assertNotNull(result); [EOL] } catch (NoSuchMethodException e) { [EOL] fail("Method should exist"); [EOL] } [EOL] }
public void testInvokeExactStaticMethodWithInvalidMethodName() { [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class[0]; [EOL] try { [EOL] invokeExactStaticMethod(TestClass.class, "nonExistentMethod", args, parameterTypes); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testInvokeExactStaticMethodWithInvalidClass() { [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class[0]; [EOL] try { [EOL] invokeExactStaticMethod(String.class, "staticMethod", args, parameterTypes); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } catch (Exception e) { [EOL] fail("Expected NoSuchMethodException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testInvokeExactStaticMethodWithNullArgs() throws Exception { [EOL] Class<?> cls = MyClass.class; [EOL] String methodName = "myStaticMethod"; [EOL] Object result = MethodUtils.invokeExactStaticMethod(cls, methodName, (Object[]) null); [EOL] assertNotNull(result); [EOL] assertEquals("Expected result from static method", "StaticMethodResult", result); [EOL] }
public void testInvokeExactStaticMethodWithEmptyArgs() throws Exception { [EOL] Class<?> cls = MyClass.class; [EOL] String methodName = "myStaticMethod"; [EOL] Object[] args = {}; [EOL] Object result = MethodUtils.invokeExactStaticMethod(cls, methodName, args); [EOL] assertNotNull(result); [EOL] assertEquals("Expected result from static method", "StaticMethodResult", result); [EOL] }
public void testInvokeExactStaticMethodWithArgs() throws Exception { [EOL] Class<?> cls = MyClass.class; [EOL] String methodName = "myStaticMethodWithArgs"; [EOL] Object[] args = {"arg1", 123, true}; [EOL] Object result = MethodUtils.invokeExactStaticMethod(cls, methodName, args); [EOL] assertNotNull(result); [EOL] assertEquals("Expected result from static method with args", "ExpectedResult", result); [EOL] }
public void testGetAccessibleMethod_ValidMethod() { [EOL] Method method = StringUtils.getAccessibleMethod(String.class, "isEmpty"); [EOL] assertNotNull(method); [EOL] assertEquals("isEmpty", method.getName()); [EOL] }
public void testGetAccessibleMethod_InValidMethod() { [EOL] Method method = StringUtils.getAccessibleMethod(String.class, "nonExistentMethod"); [EOL] assertNull(method); [EOL] }
public void testGetAccessibleMethod_ValidMethodWithParameters() { [EOL] Method method = StringUtils.getAccessibleMethod(String.class, "substring", int.class, int.class); [EOL] assertNotNull(method); [EOL] assertEquals("substring", method.getName()); [EOL] assertEquals(2, method.getParameterTypes().length); [EOL] }
public void testGetAccessibleMethod_InValidMethodWithParameters() { [EOL] Method method = StringUtils.getAccessibleMethod(String.class, "substring", int.class); [EOL] assertNull(method); [EOL] }
public void testGetAccessibleMethod_NullInput() { [EOL] Method result = ClassUtils.getAccessibleMethod(null); [EOL] assertNull(result); [EOL] } [EOL] public void testGetAccessibleMethod_InaccessibleMethod() throws NoSuchMethodException { [EOL] Method method = PrivateClass.class.getDeclaredMethod("privateMethod"); [EOL] Method result = ClassUtils.getAccessibleMethod(method); [EOL] assertNull(result); [EOL] } [EOL] public void testGetAccessibleMethod_PublicMethod() throws NoSuchMethodException { [EOL] Method method = PublicClass.class.getMethod("publicMethod"); [EOL] Method result = ClassUtils.getAccessibleMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals("publicMethod", result.getName()); [EOL] } [EOL] public void testGetAccessibleMethod_FromInterface() throws NoSuchMethodException { [EOL] Method method = SomeInterface.class.getMethod("interfaceMethod"); [EOL] Method result = ClassUtils.getAccessibleMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals("interfaceMethod", result.getName()); [EOL] } [EOL] public void testGetAccessibleMethod_FromSuperclass() throws NoSuchMethodException { [EOL] Method method = SubClass.class.getMethod("inheritedMethod"); [EOL] Method result = ClassUtils.getAccessibleMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals("inheritedMethod", result.getName()); [EOL] }
public void testGetAccessibleMethodFromSuperclass_PublicMethod() { [EOL] class SuperClass { [EOL] public void publicMethod() { [EOL] } [EOL] } [EOL] class SubClass extends SuperClass { [EOL] } [EOL] Method method = getAccessibleMethodFromSuperclass(SubClass.class, "publicMethod"); [EOL] assertNotNull(method); [EOL] assertEquals("publicMethod", method.getName()); [EOL] }
public void testGetAccessibleMethodFromSuperclass_NoSuchMethod() { [EOL] class SuperClass { [EOL] } [EOL] class SubClass extends SuperClass { [EOL] } [EOL] Method method = getAccessibleMethodFromSuperclass(SubClass.class, "nonExistentMethod"); [EOL] assertNull(method); [EOL] }
public void testGetAccessibleMethodFromSuperclass_NonPublicMethod() { [EOL] class SuperClass { [EOL] void packagePrivateMethod() { [EOL] } [EOL] } [EOL] class SubClass extends SuperClass { [EOL] } [EOL] Method method = getAccessibleMethodFromSuperclass(SubClass.class, "packagePrivateMethod"); [EOL] assertNull(method); [EOL] }
public void testGetAccessibleMethodFromSuperclass_PublicMethodInObject() { [EOL] class SuperClass { [EOL] } [EOL] class SubClass extends SuperClass { [EOL] } [EOL] Method method = getAccessibleMethodFromSuperclass(SubClass.class, "toString"); [EOL] assertNotNull(method); [EOL] assertEquals("toString", method.getName()); [EOL] }
private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls, final String methodName, Class<?>... parameterTypes) { [EOL] Method method = null; [EOL] for (; cls != null; cls = cls.getSuperclass()) { [EOL] final Class<?>[] interfaces = cls.getInterfaces(); [EOL] for (int i = 0; i < interfaces.length; i++) { [EOL] if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL] continue; [EOL] } [EOL] try { [EOL] method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL] } catch (final NoSuchMethodException e) { [EOL] } [EOL] if (method != null) { [EOL] break; [EOL] } [EOL] method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL] if (method != null) { [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] return method; [EOL] }
public void testToDouble_NullString() { [EOL] double result = StringUtils.toDouble(null); [EOL] assertEquals(0.0d, result, 0.0d); [EOL] }
public void testToDouble_EmptyString() { [EOL] double result = StringUtils.toDouble(""); [EOL] assertEquals(0.0d, result, 0.0d); [EOL] }
public void testToDouble_ValidString() { [EOL] double result = StringUtils.toDouble("1.23"); [EOL] assertEquals(1.23d, result, 0.0d); [EOL] }
public void testToDouble_InvalidString() { [EOL] double result = StringUtils.toDouble("abc"); [EOL] assertEquals(0.0d, result, 0.0d); [EOL] }
public void testToDoubleWithNullString() { [EOL] double defaultValue = 1.0; [EOL] double result = StringUtils.toDouble(null, defaultValue); [EOL] assertEquals(defaultValue, result, 0.0); [EOL] }
public void testToDoubleWithValidString() { [EOL] String validString = "5.0"; [EOL] double expected = 5.0; [EOL] double result = StringUtils.toDouble(validString, 0.0); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testToDoubleWithInvalidString() { [EOL] String invalidString = "invalid"; [EOL] double defaultValue = 1.0; [EOL] double result = StringUtils.toDouble(invalidString, defaultValue); [EOL] assertEquals(defaultValue, result, 0.0); [EOL] }
public void testToByte_NullString() { [EOL] final byte defaultValue = 1; [EOL] byte result = StringUtils.toByte(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] } [EOL] public void testToByte_ValidNumberString() { [EOL] final byte defaultValue = 1; [EOL] byte result = StringUtils.toByte("2", defaultValue); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testToByte_InvalidNumberString() { [EOL] final byte defaultValue = 1; [EOL] byte result = StringUtils.toByte("invalid", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testCreateNumberWithNull() { [EOL] Number result = NumberUtils.createNumber(null); [EOL] assertNull(result); [EOL] } [EOL] public void testCreateNumberWithBlankString() { [EOL] try { [EOL] NumberUtils.createNumber(" "); [EOL] fail("Should throw NumberFormatException for blank string"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateNumberWithHexPrefix() { [EOL] Number result = NumberUtils.createNumber("0xFF"); [EOL] assertNotNull(result); [EOL] assertEquals("Hex number not created correctly", 255, result.intValue()); [EOL] } [EOL] public void testCreateNumberWithInvalidHex() { [EOL] try { [EOL] NumberUtils.createNumber("0xG"); [EOL] fail("Should throw NumberFormatException for invalid hex"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateNumberWithLongHex() { [EOL] Number result = NumberUtils.createNumber("0x8000000000000000"); [EOL] assertNotNull(result); [EOL] assertTrue("Long hex number not created correctly", result instanceof BigInteger); [EOL] } [EOL] public void testCreateNumberWithTooLongHex() { [EOL] Number result = NumberUtils.createNumber("0x80000000000000000"); [EOL] assertNotNull(result); [EOL] assertTrue("Too long hex number not created correctly", result instanceof BigInteger); [EOL] } [EOL] public void testCreateNumberWithOctal() { [EOL] Number result = NumberUtils.createNumber("07654321"); [EOL] assertNotNull(result); [EOL] assertEquals("Octal number not created correctly", 07654321, result.intValue()); [EOL] } [EOL] public void testCreateNumberWithInvalidOctal() { [EOL] try { [EOL] NumberUtils.createNumber("085"); [EOL] fail("Should throw NumberFormatException for invalid octal"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateNumberWithDecimal() { [EOL] Number result = NumberUtils.createNumber("1234.56"); [EOL] assertNotNull(result); [EOL] assertTrue("Decimal number not created correctly", result instanceof BigDecimal); [EOL] } [EOL] public void testCreateNumberWithExponent() { [EOL] Number result = NumberUtils.createNumber("1234e5"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with exponent not created correctly", result instanceof BigDecimal); [EOL] } [EOL] public void testCreateNumberWithInvalidExponent() { [EOL] try { [EOL] NumberUtils.createNumber("1234e"); [EOL] fail("Should throw NumberFormatException for invalid exponent"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateNumberWithLNotation() { [EOL] Number result = NumberUtils.createNumber("1234L"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with L notation not created correctly", result instanceof Long); [EOL] } [EOL] public void testCreateNumberWithFNotation() { [EOL] Number result = NumberUtils.createNumber("1234F"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with F notation not created correctly", result instanceof Float); [EOL] } [EOL] public void testCreateNumberWithDNotation() { [EOL] Number result = NumberUtils.createNumber("1234D"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with D notation not created correctly", result instanceof Double); [EOL] } [EOL] public void testCreateNumberWithInvalidNotation() { [EOL] try { [EOL] NumberUtils.createNumber("1234Z"); [EOL] fail("Should throw NumberFormatException for invalid notation"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testCreateNumberWithInvalidNumber() { [EOL] try { [EOL] NumberUtils.createNumber("abcd"); [EOL] fail("Should throw NumberFormatException for invalid number"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testIsAllZerosWithNull() { [EOL] assertTrue(isAllZeros(null)); [EOL] }
public void testIsAllZerosWithEmptyString() { [EOL] assertFalse(isAllZeros("")); [EOL] }
public void testIsAllZerosWithOnlyZeros() { [EOL] assertTrue(isAllZeros("0000")); [EOL] }
public void testIsAllZerosWithNonZeroCharacter() { [EOL] assertFalse(isAllZeros("000010")); [EOL] }
public void testCreateFloatWithNull() { [EOL] Float result = StringUtils.createFloat(null); [EOL] assertNull(result); [EOL] } [EOL] public void testCreateFloatWithValidString() { [EOL] Float expected = 1.23f; [EOL] Float result = StringUtils.createFloat("1.23"); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testCreateFloatWithInvalidString() { [EOL] try { [EOL] StringUtils.createFloat("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateDoubleWithNull() { [EOL] Double result = StringUtils.createDouble(null); [EOL] assertNull(result); [EOL] } [EOL] public void testCreateDoubleWithValidString() { [EOL] Double result = StringUtils.createDouble("123.45"); [EOL] assertNotNull(result); [EOL] assertEquals(123.45, result, 0.0); [EOL] } [EOL] public void testCreateDoubleWithInvalidString() { [EOL] try { [EOL] StringUtils.createDouble("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateBigDecimalWithNullInput() { [EOL] BigDecimal result = Lang3.createBigDecimal(null); [EOL] assertNull(result); [EOL] }
public void testCreateBigDecimalWithBlankString() { [EOL] try { [EOL] Lang3.createBigDecimal(" "); [EOL] fail("Should have thrown NumberFormatException for blank string"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("A blank string is not a valid number", e.getMessage()); [EOL] } [EOL] }
public void testCreateBigDecimalWithDoubleMinus() { [EOL] try { [EOL] Lang3.createBigDecimal("--123"); [EOL] fail("Should have thrown NumberFormatException for string starting with --"); [EOL] } catch (NumberFormatException e) { [EOL] assertEquals("--123 is not a valid number.", e.getMessage()); [EOL] } [EOL] }
public void testCreateBigDecimalWithValidString() { [EOL] BigDecimal expected = new BigDecimal("123"); [EOL] BigDecimal result = Lang3.createBigDecimal("123"); [EOL] assertEquals(expected, result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] byte[] array = {42}; [EOL] byte result = min(array); [EOL] assertEquals(42, result); [EOL] }
public void testMinWithMultipleElementArray() { [EOL] byte[] array = {42, 35, 89, 7, 28}; [EOL] byte result = min(array); [EOL] assertEquals(7, result); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] byte[] array = {42, 42, 42, 42, 42}; [EOL] byte result = min(array); [EOL] assertEquals(42, result); [EOL] }
public void testMinWithNegativeElementsArray() { [EOL] byte[] array = {-42, -35, -89, -7, -28}; [EOL] byte result = min(array); [EOL] assertEquals(-89, result); [EOL] }
public void testMinWithValidArray() { [EOL] double[] array = {1.0, 2.0, 0.5, 3.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals(0.5, result, 0.0); [EOL] } [EOL] public void testMinWithNaN() { [EOL] double[] array = {1.0, Double.NaN, 0.5, 3.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertTrue(Double.isNaN(result)); [EOL] } [EOL] public void testMinWithSingleElement() { [EOL] double[] array = {1.0}; [EOL] double result = ArrayUtils.min(array); [EOL] assertEquals(1.0, result, 0.0); [EOL] } [EOL] public void testMinWithEmptyArray() { [EOL] double[] array = {}; [EOL] try { [EOL] ArrayUtils.min(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMaxWithSingleElementArray() { [EOL] long[] array = new long[]{5}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(5, result); [EOL] }
public void testMaxWithMultipleElementsArray() { [EOL] long[] array = new long[]{1, 3, 7, 2}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(7, result); [EOL] }
public void testMaxWithAllNegativeElementsArray() { [EOL] long[] array = new long[]{-10, -3, -7, -2}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(-2, result); [EOL] }
public void testMaxWithMixedElementsArray() { [EOL] long[] array = new long[]{-1, 0, 1}; [EOL] long result = ArrayUtils.max(array); [EOL] assertEquals(1, result); [EOL] }
public void testMaxWithNonEmptyArray() { [EOL] byte[] array = {1, 3, 7, 5}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(7, result); [EOL] }
public void testMaxWithSingleElementArray() { [EOL] byte[] array = {42}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(42, result); [EOL] }
public void testMaxWithAllElementsEqualArray() { [EOL] byte[] array = {2, 2, 2, 2}; [EOL] byte result = ArrayUtils.max(array); [EOL] assertEquals(2, result); [EOL] }
public void testMaxWithValidArray() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertEquals(3.0f, result, 0.01f); [EOL] }
public void testMaxWithFirstElementMax() { [EOL] float[] array = {3.0f, 2.0f, 1.0f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertEquals(3.0f, result, 0.01f); [EOL] }
public void testMaxWithNegativeNumbers() { [EOL] float[] array = {-1.0f, -2.0f, -3.0f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertEquals(-1.0f, result, 0.01f); [EOL] }
public void testMaxWithAllEqualElements() { [EOL] float[] array = {2.0f, 2.0f, 2.0f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertEquals(2.0f, result, 0.01f); [EOL] }
public void testMaxWithNaN() { [EOL] float[] array = {1.0f, Float.NaN, 3.0f}; [EOL] float result = ArrayUtils.max(array); [EOL] assertTrue(Float.isNaN(result)); [EOL] }
public void testMax_AllEqual() { [EOL] long a = 5; [EOL] long b = 5; [EOL] long c = 5; [EOL] long result = YourClass.max(a, b, c); [EOL] assertEquals(5, result); [EOL] }
public void testMax_AIsMax() { [EOL] long a = 10; [EOL] long b = 5; [EOL] long c = 2; [EOL] long result = YourClass.max(a, b, c); [EOL] assertEquals(10, result); [EOL] }
public void testMax_BIsMax() { [EOL] long a = 3; [EOL] long b = 7; [EOL] long c = 6; [EOL] long result = YourClass.max(a, b, c); [EOL] assertEquals(7, result); [EOL] }
public void testMax_CIsMax() { [EOL] long a = 3; [EOL] long b = 4; [EOL] long c = 8; [EOL] long result = YourClass.max(a, b, c); [EOL] assertEquals(8, result); [EOL] }
public void testMaxWithAllPositiveValues() { [EOL] float a = 1.0f; [EOL] float b = 2.0f; [EOL] float c = 3.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(3.0f, result); [EOL] }
public void testMaxWithAllNegativeValues() { [EOL] float a = -1.0f; [EOL] float b = -2.0f; [EOL] float c = -3.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(-1.0f, result); [EOL] }
public void testMaxWithMixedValues() { [EOL] float a = -1.0f; [EOL] float b = 2.0f; [EOL] float c = 0.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(2.0f, result); [EOL] }
public void testMaxWithAllEqualValues() { [EOL] float a = 2.0f; [EOL] float b = 2.0f; [EOL] float c = 2.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(2.0f, result); [EOL] }
public void testMaxWithFirstTwoEqualAndGreater() { [EOL] float a = 2.0f; [EOL] float b = 2.0f; [EOL] float c = 1.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(2.0f, result); [EOL] }
public void testMaxWithLastTwoEqualAndGreater() { [EOL] float a = 1.0f; [EOL] float b = 2.0f; [EOL] float c = 2.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(2.0f, result); [EOL] }
public void testMaxWithFirstAndLastEqualAndGreater() { [EOL] float a = 2.0f; [EOL] float b = 1.0f; [EOL] float c = 2.0f; [EOL] float result = max(a, b, c); [EOL] assertEquals(2.0f, result); [EOL] }
public void testClearShort_Zero() { [EOL] short holder = 0; [EOL] short result = clearShort(holder); [EOL] assertEquals("Clearing a zero short should return zero", 0, result); [EOL] }
public void testClearShort_Positive() { [EOL] short holder = 12345; [EOL] short result = clearShort(holder); [EOL] assertEquals("Clearing a positive short should return zero", 0, result); [EOL] }
public void testClearShort_Negative() { [EOL] short holder = -12345; [EOL] short result = clearShort(holder); [EOL] assertEquals("Clearing a negative short should return zero", 0, result); [EOL] }
public void testClearShort_MaxValue() { [EOL] short holder = Short.MAX_VALUE; [EOL] short result = clearShort(holder); [EOL] assertEquals("Clearing the max short value should return zero", 0, result); [EOL] }
public void testClearShort_MinValue() { [EOL] short holder = Short.MIN_VALUE; [EOL] short result = clearShort(holder); [EOL] assertEquals("Clearing the min short value should return zero", 0, result); [EOL] }
public short setShort(final short holder) { [EOL] return (short) set(holder); [EOL] }
public short setShort(final short holder) { [EOL] return (short) (holder | 0x0100); [EOL] } [EOL] public short clearShort(final short holder) { [EOL] return (short) (holder & 0xFEFF); [EOL] } [EOL] public short setShortBoolean(final short holder, final boolean flag) { [EOL] return flag ? setShort(holder) : clearShort(holder); [EOL] }
public void testBasicThreadFactoryWithDefaultWrappedFactory() { [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder(); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertNotNull(factory); [EOL] assertNotNull(factory.wrappedFactory); [EOL] assertNull(factory.namingPattern); [EOL] assertEquals(0, factory.priority); [EOL] assertFalse(factory.daemonFlag); [EOL] assertNull(factory.uncaughtExceptionHandler); [EOL] assertNotNull(factory.threadCounter); [EOL] }
public void testBasicThreadFactoryWithCustomWrappedFactory() { [EOL] ThreadFactory customWrappedFactory = mock(ThreadFactory.class); [EOL] BasicThreadFactory.Builder builder = new BasicThreadFactory.Builder() [EOL] .wrappedFactory(customWrappedFactory); [EOL] BasicThreadFactory factory = new BasicThreadFactory(builder); [EOL] assertNotNull(factory); [EOL] assertSame(customWrappedFactory, factory.wrappedFactory); [EOL] assertNull(factory.namingPattern); [EOL] assertEquals(0, factory.priority); [EOL] assertFalse(factory.daemonFlag); [EOL] assertNull(factory.uncaughtExceptionHandler); [EOL] assertNotNull(factory.threadCounter); [EOL] }
public final ThreadFactory getWrappedFactory() { [EOL] return wrappedFactory; [EOL] }
public void testGetNamingPattern() { [EOL] YourClass instance = new YourClass("examplePattern"); [EOL] String expected = "examplePattern"; [EOL] String actual = instance.getNamingPattern(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDaemonFlagWhenDaemonFlagIsNull() { [EOL] SomeClass instance = new SomeClass(); [EOL] instance.setDaemonFlag(null); [EOL] Boolean result = instance.getDaemonFlag(); [EOL] assertNull(result); [EOL] }
public void testGetDaemonFlagWhenDaemonFlagIsTrue() { [EOL] SomeClass instance = new SomeClass(); [EOL] instance.setDaemonFlag(true); [EOL] Boolean result = instance.getDaemonFlag(); [EOL] assertTrue(result); [EOL] }
public void testGetDaemonFlagWhenDaemonFlagIsFalse() { [EOL] SomeClass instance = new SomeClass(); [EOL] instance.setDaemonFlag(false); [EOL] Boolean result = instance.getDaemonFlag(); [EOL] assertFalse(result); [EOL] }
public void testGetPriorityWhenPriorityIsNull() { [EOL] MyClass instance = new MyClass(null); [EOL] Integer result = instance.getPriority(); [EOL] assertNull(result); [EOL] }
public void testGetPriorityWhenPriorityIsNotNull() { [EOL] Integer expected = 5; [EOL] MyClass instance = new MyClass(expected); [EOL] Integer result = instance.getPriority(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetUncaughtExceptionHandler() { [EOL] MyClass instance = new MyClass(); [EOL] Thread.UncaughtExceptionHandler expectedHandler = new Thread.UncaughtExceptionHandler() { [EOL] @Override [EOL] public void uncaughtException(Thread t, Throwable e) { [EOL] } [EOL] }; [EOL] instance.setUncaughtExceptionHandler(expectedHandler); [EOL] Thread.UncaughtExceptionHandler actualHandler = instance.getUncaughtExceptionHandler(); [EOL] assertEquals(expectedHandler, actualHandler); [EOL] }
public void testNewThreadWithNonNullRunnable() { [EOL] Runnable r = () -> { /* Your Runnable implementation here */ }; [EOL] CustomThreadFactory factory = new CustomThreadFactory(); [EOL] Thread t = factory.newThread(r); [EOL] assertNotNull(t); [EOL] } [EOL] public void testNewThreadWithNullRunnable() { [EOL] Runnable r = null; [EOL] CustomThreadFactory factory = new CustomThreadFactory(); [EOL] try { [EOL] factory.newThread(r); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testNewThreadInitialization() { [EOL] Runnable r = () -> { /* Your Runnable implementation here */ }; [EOL] CustomThreadFactory factory = new CustomThreadFactory() { [EOL] @Override [EOL] protected void initializeThread(Thread t) { [EOL] super.initializeThread(t); [EOL] assertEquals("Expected thread name", t.getName()); [EOL] } [EOL] }; [EOL] Thread t = factory.newThread(r); [EOL] assertNotNull(t); [EOL] }
public void testInitializeThreadWithNamingPattern() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .namingPattern("test-thread-%d") [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.getName().matches("test-thread-\\d+")); [EOL] }
public void testInitializeThreadWithUncaughtExceptionHandler() { [EOL] Thread.UncaughtExceptionHandler handler = (thread, throwable) -> { /* No-op */ }; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .uncaughtExceptionHandler(handler) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(handler, t.getUncaughtExceptionHandler()); [EOL] }
public void testInitializeThreadWithPriority() { [EOL] int priority = Thread.NORM_PRIORITY + 1; [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .priority(priority) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertEquals(priority, t.getPriority()); [EOL] }
public void testInitializeThreadWithDaemonFlag() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder() [EOL] .daemon(true) [EOL] .build(); [EOL] Thread t = new Thread(); [EOL] factory.initializeThread(t); [EOL] assertTrue(t.isDaemon()); [EOL] }
public void testInitializeThreadWithNullValues() { [EOL] BasicThreadFactory factory = new BasicThreadFactory.Builder().build(); [EOL] Thread t = new Thread(); [EOL] String defaultName = t.getName(); [EOL] Thread.UncaughtExceptionHandler defaultHandler = t.getUncaughtExceptionHandler(); [EOL] int defaultPriority = t.getPriority(); [EOL] boolean defaultDaemonFlag = t.isDaemon(); [EOL] factory.initializeThread(t); [EOL] assertEquals(defaultName, t.getName()); [EOL] assertEquals(defaultHandler, t.getUncaughtExceptionHandler()); [EOL] assertEquals(defaultPriority, t.getPriority()); [EOL] assertEquals(defaultDaemonFlag, t.isDaemon()); [EOL] }
public void testWrappedFactoryWithNull() { [EOL] try { [EOL] new Builder().wrappedFactory(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Wrapped ThreadFactory must not be null!", e.getMessage()); [EOL] } [EOL] }
public void testWrappedFactoryWithNonNull() { [EOL] ThreadFactory factory = Runnable::run; [EOL] Builder builder = new Builder(); [EOL] Builder returnedBuilder = builder.wrappedFactory(factory); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testDaemonTrue() { [EOL] Builder builder = new Builder(); [EOL] Builder result = builder.daemon(true); [EOL] assertEquals(Boolean.TRUE, builder.daemonFlag); [EOL] assertSame(builder, result); [EOL] } [EOL] public void testDaemonFalse() { [EOL] Builder builder = new Builder(); [EOL] Builder result = builder.daemon(false); [EOL] assertEquals(Boolean.FALSE, builder.daemonFlag); [EOL] assertSame(builder, result); [EOL] }
public void testReset() { [EOL] CustomThreadFactory factory = new CustomThreadFactory(); [EOL] factory.setWrappedFactory(ThreadFactory); [EOL] factory.setExceptionHandler(UncaughtExceptionHandler); [EOL] factory.setNamingPattern("pattern"); [EOL] factory.setPriority(Thread.NORM_PRIORITY); [EOL] factory.setDaemon(true); [EOL] factory.reset(); [EOL] assertNull(factory.getWrappedFactory()); [EOL] assertNull(factory.getExceptionHandler()); [EOL] assertNull(factory.getNamingPattern()); [EOL] assertNull(factory.getPriority()); [EOL] assertNull(factory.isDaemon()); [EOL] }
public void testBuild() { [EOL] BasicThreadFactoryBuilder builder = new BasicThreadFactoryBuilder(); [EOL] BasicThreadFactory factory = builder.build(); [EOL] assertNotNull(factory); [EOL] assertTrue(builder.isReset()); [EOL] }
public void testAcquireWhenShutdown() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.shutdown(); [EOL] try { [EOL] semaphore.acquire(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("TimedSemaphore is shut down!", e.getMessage()); [EOL] } [EOL] }
public void testAcquireStartsTimerTask() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.acquire(); [EOL] assertNotNull(semaphore.getTask()); [EOL] }
public void testAcquireWhenNoLimit() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(TimedSemaphore.NO_LIMIT); [EOL] semaphore.acquire(); [EOL] assertEquals(1, semaphore.getAcquireCount()); [EOL] }
public void testAcquireWhenUnderLimit() throws InterruptedException { [EOL] TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(10); [EOL] for (int i = 0; i < 5; i++) { [EOL] semaphore.acquire(); [EOL] } [EOL] assertEquals(5, semaphore.getAcquireCount()); [EOL] }
public void testAcquireBlocksWhenAtLimit() throws InterruptedException { [EOL] final TimedSemaphore semaphore = new TimedSemaphore(); [EOL] semaphore.setLimit(1); [EOL] semaphore.acquire(); // should acquire without blocking [EOL] Thread testThread = new Thread(new Runnable() { [EOL] public void run() { [EOL] try { [EOL] semaphore.acquire(); // should block [EOL] } catch (InterruptedException e) { [EOL] Thread.currentThread().interrupt(); [EOL] } [EOL] } [EOL] }); [EOL] testThread.start(); [EOL] Thread.sleep(100); // give the test thread time to run [EOL] testThread.interrupt(); // interrupt the blocking call [EOL] testThread.join(); [EOL] assertTrue(testThread.isInterrupted()); [EOL] assertEquals(1, semaphore.getAcquireCount()); [EOL] }
public void testContextedRuntimeExceptionWithNullContext() { [EOL] String message = "Error message"; [EOL] Throwable cause = new Exception("Cause"); [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(message, cause, null); [EOL] assertNotNull(exception); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertNotNull(exception.getContext()); [EOL] }
public void testContextedRuntimeExceptionWithNonNullContext() { [EOL] String message = "Error message"; [EOL] Throwable cause = new Exception("Cause"); [EOL] ExceptionContext context = new DefaultExceptionContext(); [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(message, cause, context); [EOL] assertNotNull(exception); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertEquals(context, exception.getContext()); [EOL] }
public void testAddContextValueWithNullLabel() { [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(); [EOL] exception.addContextValue(null, "value"); [EOL] assertNull(exception.getFirstContextValueForKey(null)); [EOL] }
public void testAddContextValueWithNonNullLabel() { [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(); [EOL] exception.addContextValue("label", "value"); [EOL] assertEquals("value", exception.getFirstContextValueForKey("label")); [EOL] }
public void testWriteObjectWithSerializableListeners() throws IOException { [EOL] ObjectOutputStream mockObjectOutputStream = mock(ObjectOutputStream.class); [EOL] MyListenerClass instance = new MyListenerClass(); [EOL] instance.addListener(new SerializableListener()); [EOL] instance.writeObject(mockObjectOutputStream); [EOL] verify(mockObjectOutputStream).writeObject(any()); [EOL] } [EOL] public void testWriteObjectWithNonSerializableListeners() throws IOException { [EOL] ObjectOutputStream mockObjectOutputStream = mock(ObjectOutputStream.class); [EOL] MyListenerClass instance = new MyListenerClass(); [EOL] instance.addListener(new NonSerializableListener()); [EOL] instance.writeObject(mockObjectOutputStream); [EOL] verify(mockObjectOutputStream, never()).writeObject(any()); [EOL] } [EOL] public void testWriteObjectWithMixedListeners() throws IOException { [EOL] ObjectOutputStream mockObjectOutputStream = mock(ObjectOutputStream.class); [EOL] MyListenerClass instance = new MyListenerClass(); [EOL] instance.addListener(new SerializableListener()); [EOL] instance.addListener(new NonSerializableListener()); [EOL] instance.writeObject(mockObjectOutputStream); [EOL] verify(mockObjectOutputStream).writeObject(any()); [EOL] }

public void testReadObjectWithValidInput() throws IOException, ClassNotFoundException { [EOL] ObjectInputStream ois = mock(ObjectInputStream.class); [EOL] EventListener[] mockListeners = new EventListener[] { mock(EventListener.class) }; [EOL] when(ois.readObject()).thenReturn(mockListeners); [EOL] MyEventSource<EventListener> source = new MyEventSource<>(); [EOL] Method readObjectMethod = MyEventSource.class.getDeclaredMethod("readObject", ObjectInputStream.class); [EOL] readObjectMethod.setAccessible(true); [EOL] readObjectMethod.invoke(source, ois); [EOL] assertNotNull(source.listeners); [EOL] assertEquals(1, source.listeners.size()); [EOL] assertSame(mockListeners[0], source.listeners.get(0)); [EOL] }
public void testReadObjectWithInvalidInput() throws IOException, ClassNotFoundException { [EOL] ObjectInputStream ois = mock(ObjectInputStream.class); [EOL] when(ois.readObject()).thenThrow(new ClassNotFoundException()); [EOL] MyEventSource<EventListener> source = new MyEventSource<>(); [EOL] Method readObjectMethod = MyEventSource.class.getDeclaredMethod("readObject", ObjectInputStream.class); [EOL] readObjectMethod.setAccessible(true); [EOL] assertThrows(ClassNotFoundException.class, () -> readObjectMethod.invoke(source, ois)); [EOL] }
public void testTranslateWithBackslashAndU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u0041", 0, out); [EOL] assertEquals("Should return 6 because it processes '\\u' and four hex digits", 6, result); [EOL] assertEquals("Should write 'A' to the writer", "A", out.toString()); [EOL] } [EOL] public void testTranslateWithMultipleUs() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\uuuu0041", 0, out); [EOL] assertEquals("Should return 8 because it processes multiple 'u's and four hex digits", 8, result); [EOL] assertEquals("Should write 'A' to the writer", "A", out.toString()); [EOL] } [EOL] public void testTranslateWithPlusSign() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u+0041", 0, out); [EOL] assertEquals("Should return 7 because it processes '\\u', a plus sign, and four hex digits", 7, result); [EOL] assertEquals("Should write 'A' to the writer", "A", out.toString()); [EOL] } [EOL] public void testTranslateWithLessThanFourHexDigits() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u004", 0, out); [EOL] fail("Should have thrown IllegalArgumentException because of less than four hex digits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testTranslateWithInvalidHexDigits() { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] translate("\\u00AG", 0, out); [EOL] fail("Should have thrown IllegalArgumentException because of invalid hex digits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testTranslateWithNoBackslashU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("A", 0, out); [EOL] assertEquals("Should return 0 because there is no '\\u' sequence", 0, result); [EOL] assertEquals("Should not write anything to the writer", "", out.toString()); [EOL] } [EOL] public void testTranslateAtEndOfString() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\u0041", 6, out); [EOL] assertEquals("Should return 0 because index is at the end of the string", 0, result); [EOL] assertEquals("Should not write anything to the writer", "", out.toString()); [EOL] } [EOL] public void testTranslateWithBackslashButNoU() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int result = translate("\\x0041", 0, out); [EOL] assertEquals("Should return 0 because there is a backslash but no 'u' after it", 0, result); [EOL] assertEquals("Should not write anything to the writer", "", out.toString()); [EOL] }

public void testMutableFloatWithNull() { [EOL] Throwable e = null; [EOL] try { [EOL] new MutableFloat(null); [EOL] } catch (NullPointerException ex) { [EOL] e = ex; [EOL] } [EOL] assertNotNull(e); [EOL] }
public void testMutableFloatWithInteger() { [EOL] final int intValue = 5; [EOL] MutableFloat mutFloat = new MutableFloat(intValue); [EOL] assertEquals(intValue, mutFloat.floatValue(), 0.01f); [EOL] }
public void testMutableFloatWithFloat() { [EOL] final float floatValue = 5.5f; [EOL] MutableFloat mutFloat = new MutableFloat(floatValue); [EOL] assertEquals(floatValue, mutFloat.floatValue(), 0.01f); [EOL] }
public void testMutableFloatWithDouble() { [EOL] final double doubleValue = 5.5d; [EOL] MutableFloat mutFloat = new MutableFloat(doubleValue); [EOL] assertEquals((float)doubleValue, mutFloat.floatValue(), 0.01f); [EOL] }
public void testMutableFloatWithLong() { [EOL] final long longValue = 5L; [EOL] MutableFloat mutFloat = new MutableFloat(longValue); [EOL] assertEquals(longValue, mutFloat.floatValue(), 0.01f); [EOL] }
public void testMutableFloatWithShort() { [EOL] final short shortValue = 5; [EOL] MutableFloat mutFloat = new MutableFloat(shortValue); [EOL] assertEquals(shortValue, mutFloat.floatValue(), 0.01f); [EOL] }
public void testMutableFloatWithByte() { [EOL] final byte byteValue = 5; [EOL] MutableFloat mutFloat = new MutableFloat(byteValue); [EOL] assertEquals(byteValue, mutFloat.floatValue(), 0.01f); [EOL] }
public void testAdd_PositiveOperand() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] adder.add(5.0f); [EOL] assertEquals(5.0f, adder.value, 0.001); [EOL] }
public void testAdd_NegativeOperand() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] adder.add(-5.0f); [EOL] assertEquals(-5.0f, adder.value, 0.001); [EOL] }
public void testAdd_ZeroOperand() { [EOL] FloatAdder adder = new FloatAdder(); [EOL] adder.add(0.0f); [EOL] assertEquals(0.0f, adder.value, 0.001); [EOL] }
public void testToFloat() { [EOL] MutableFloat mutableFloat = new MutableFloat(5.5f); [EOL] Float result = mutableFloat.toFloat(); [EOL] assertEquals(Float.valueOf(5.5f), result); [EOL] }
public void testGetSimpleNameWithNullClass() { [EOL] String result = ClassNameUtils.getSimpleName(null); [EOL] assertEquals("", result); [EOL] }
public void testGetSimpleNameWithRegularClass() { [EOL] String result = ClassNameUtils.getSimpleName(String.class); [EOL] assertEquals("String", result); [EOL] }
public void testGetSimpleNameWithNullObject() { [EOL] String result = StringUtils.getSimpleName(null, "DefaultValue"); [EOL] assertEquals("DefaultValue", result); [EOL] }
public void testGetSimpleNameWithNonNullObject() { [EOL] String result = StringUtils.getSimpleName(new Object(), null); [EOL] assertEquals("Object", result); [EOL] }
public void testGetPackageNameWithNullObject() { [EOL] String expected = "defaultPackage"; [EOL] String actual = StringUtils.getPackageName(null, expected); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetPackageNameWithNonNullObject() { [EOL] Object object = new String("Test"); [EOL] String expected = "java.lang"; [EOL] String actual = StringUtils.getPackageName(object, null); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsAssignableWithNullToClass() { [EOL] boolean result = isAssignable(String.class, null, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithNullCls() { [EOL] boolean result = isAssignable(null, String.class, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingAndPrimitiveToWrapper() { [EOL] boolean result = isAssignable(int.class, Integer.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithAutoboxingAndWrapperToPrimitive() { [EOL] boolean result = isAssignable(Integer.class, int.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithClsEqualsToClass() { [EOL] boolean result = isAssignable(String.class, String.class, true); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithPrimitiveToNonPrimitive() { [EOL] boolean result = isAssignable(int.class, String.class, true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithIntegerToLongFloatDouble() { [EOL] boolean result = isAssignable(Integer.TYPE, Long.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Integer.TYPE, Float.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Integer.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithLongToFloatDouble() { [EOL] boolean result = isAssignable(Long.TYPE, Float.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Long.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithBooleanToOtherPrimitives() { [EOL] boolean result = isAssignable(Boolean.TYPE, Integer.TYPE, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithDoubleToOtherPrimitives() { [EOL] boolean result = isAssignable(Double.TYPE, Float.TYPE, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithFloatToDouble() { [EOL] boolean result = isAssignable(Float.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithCharacterToNumericPrimitives() { [EOL] boolean result = isAssignable(Character.TYPE, Integer.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Character.TYPE, Long.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Character.TYPE, Float.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Character.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithShortToNumericPrimitives() { [EOL] boolean result = isAssignable(Short.TYPE, Integer.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Short.TYPE, Long.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Short.TYPE, Float.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Short.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithByteToNumericPrimitives() { [EOL] boolean result = isAssignable(Byte.TYPE, Short.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Byte.TYPE, Integer.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Byte.TYPE, Long.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Byte.TYPE, Float.TYPE, false); [EOL] assertTrue(result); [EOL] result = isAssignable(Byte.TYPE, Double.TYPE, false); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithNonPrimitiveToPrimitive() { [EOL] boolean result = isAssignable(String.class, int.class, false); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithNonPrimitiveToNonPrimitive() { [EOL] boolean result = isAssignable(Object.class, String.class, false); [EOL] assertTrue(result); [EOL] }
public void testWrappersToPrimitivesWithNullInput() { [EOL] Class<?>[] result = wrappersToPrimitives(null); [EOL] assertNull(result); [EOL] }
public void testWrappersToPrimitivesWithEmptyArray() { [EOL] Class<?>[] classes = new Class<?>[0]; [EOL] Class<?>[] result = wrappersToPrimitives(classes); [EOL] assertArrayEquals(classes, result); [EOL] }
public void testWrappersToPrimitivesWithNonNullInput() { [EOL] Class<?>[] classes = new Class<?>[] {Integer.class, Double.class}; [EOL] Class<?>[] result = wrappersToPrimitives(classes); [EOL] Class<?>[] expected = new Class<?>[] {int.class, double.class}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testGetClassWithAbbreviation() throws ClassNotFoundException { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String className = "int"; [EOL] boolean initialize = true; [EOL] Class<?> result = ClassUtils.getClass(classLoader, className, initialize); [EOL] assertEquals(int.class, result); [EOL] }
public void testGetClassWithoutAbbreviation() throws ClassNotFoundException { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String className = "java.lang.String"; [EOL] boolean initialize = true; [EOL] Class<?> result = ClassUtils.getClass(classLoader, className, initialize); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetClassClassNotFoundException() { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String className = "non.existing.ClassName"; [EOL] boolean initialize = true; [EOL] try { [EOL] ClassUtils.getClass(classLoader, className, initialize); [EOL] fail("Should have thrown ClassNotFoundException"); [EOL] } catch (ClassNotFoundException expected) { [EOL] } [EOL] }
public void testGetClassInnerClass() throws ClassNotFoundException { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String className = "java.util.Map$Entry"; [EOL] boolean initialize = true; [EOL] Class<?> result = ClassUtils.getClass(classLoader, className, initialize); [EOL] assertEquals(Map.Entry.class, result); [EOL] }
public void testGetClassInnerClassNotFound() { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] String className = "java.util.Map$NonExistingInnerClass"; [EOL] boolean initialize = true; [EOL] try { [EOL] ClassUtils.getClass(classLoader, className, initialize); [EOL] fail("Should have thrown ClassNotFoundException for inner class"); [EOL] } catch (ClassNotFoundException expected) { [EOL] } [EOL] }
public void testGetPublicMethod_PublicMethodExists() throws Exception { [EOL] Method method = MyClass.class.getMethod("publicMethod", String.class); [EOL] Method result = MyUtils.getPublicMethod(MyClass.class, "publicMethod", String.class); [EOL] assertNotNull(result); [EOL] assertEquals(method, result); [EOL] } [EOL] public void testGetPublicMethod_MethodNotPublic() { [EOL] try { [EOL] MyUtils.getPublicMethod(MyClass.class, "privateMethod", String.class); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException expected) { [EOL] } [EOL] } [EOL] public void testGetPublicMethod_MethodInSuperclass() throws Exception { [EOL] Method method = MySuperClass.class.getMethod("publicMethod", String.class); [EOL] Method result = MyUtils.getPublicMethod(MySubClass.class, "publicMethod", String.class); [EOL] assertNotNull(result); [EOL] assertEquals(method, result); [EOL] } [EOL] public void testGetPublicMethod_MethodInInterface() throws Exception { [EOL] Method method = MyInterface.class.getMethod("publicMethod", String.class); [EOL] Method result = MyUtils.getPublicMethod(MyImplementingClass.class, "publicMethod", String.class); [EOL] assertNotNull(result); [EOL] assertEquals(method, result); [EOL] } [EOL] public void testGetPublicMethod_NoSuchMethod() { [EOL] try { [EOL] MyUtils.getPublicMethod(MyClass.class, "nonExistentMethod"); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException expected) { [EOL] } [EOL] }

public void testToCanonicalNameWithNullInput() { [EOL] try { [EOL] toCanonicalName(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("className must not be null.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testToCanonicalNameWithEmptyString() { [EOL] String result = toCanonicalName(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testToCanonicalNameWithoutArrayBrackets() { [EOL] String result = toCanonicalName("String"); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testToCanonicalNameWithArrayBrackets() { [EOL] String result = toCanonicalName("String[]"); [EOL] assertEquals("[Ljava.lang.String;", result); [EOL] } [EOL] public void testToCanonicalNameWithMultipleArrayBrackets() { [EOL] String result = toCanonicalName("String[][]"); [EOL] assertEquals("[[Ljava.lang.String;", result); [EOL] } [EOL] public void testToCanonicalNameWithWhitespace() { [EOL] String result = toCanonicalName(" String "); [EOL] assertEquals("String", result); [EOL] } [EOL] public void testToCanonicalNameWithAbbreviation() { [EOL] String result = toCanonicalName("int[]"); [EOL] assertEquals("[I", result); [EOL] }
public void testGetPackageCanonicalName_NullClass() { [EOL] String result = ClassUtils.getPackageCanonicalName(null); [EOL] assertEquals("", result); [EOL] }
public void testGetPackageCanonicalName_RegularClass() { [EOL] String result = ClassUtils.getPackageCanonicalName(java.lang.String.class); [EOL] assertEquals("java.lang", result); [EOL] }
public void testStartWhenNotStartedWithExternalExecutor() { [EOL] MyClass testClass = new MyClass() { [EOL] @Override [EOL] public boolean isStarted() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public ExecutorService getExternalExecutor() { [EOL] return Executors.newSingleThreadExecutor(); [EOL] } [EOL] }; [EOL] boolean result = testClass.start(); [EOL] assertTrue(result); [EOL] assertNotNull(testClass.future); [EOL] }
public void testStartWhenNotStartedWithoutExternalExecutor() { [EOL] MyClass testClass = new MyClass() { [EOL] @Override [EOL] public boolean isStarted() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public ExecutorService getExternalExecutor() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public ExecutorService createExecutor() { [EOL] return Executors.newSingleThreadExecutor(); [EOL] } [EOL] }; [EOL] boolean result = testClass.start(); [EOL] assertTrue(result); [EOL] assertNotNull(testClass.future); [EOL] }
public void testStartWhenAlreadyStarted() { [EOL] MyClass testClass = new MyClass() { [EOL] @Override [EOL] public boolean isStarted() { [EOL] return true; [EOL] } [EOL] }; [EOL] boolean result = testClass.start(); [EOL] assertFalse(result); [EOL] }
public void testGetWhenFutureCompletesSuccessfully() throws Exception { [EOL] Future<String> future = mock(Future.class); [EOL] when(future.get()).thenReturn("Success"); [EOL] AbstractConcurrentFunction<String> function = new AbstractConcurrentFunction<String>() { [EOL] @Override [EOL] public Future<String> getFuture() { [EOL] return future; [EOL] } [EOL] }; [EOL] String result = function.get(); [EOL] assertEquals("Success", result); [EOL] }
public void testGetWhenExecutionExceptionOccurs() throws Exception { [EOL] Future<String> future = mock(Future.class); [EOL] when(future.get()).thenThrow(new ExecutionException(new Exception())); [EOL] AbstractConcurrentFunction<String> function = new AbstractConcurrentFunction<String>() { [EOL] @Override [EOL] public Future<String> getFuture() { [EOL] return future; [EOL] } [EOL] }; [EOL] String result = function.get(); [EOL] assertNull(result); [EOL] }
public void testGetWhenInterruptedExceptionOccurs() throws Exception { [EOL] Future<String> future = mock(Future.class); [EOL] when(future.get()).thenThrow(new InterruptedException()); [EOL] AbstractConcurrentFunction<String> function = new AbstractConcurrentFunction<String>() { [EOL] @Override [EOL] public Future<String> getFuture() { [EOL] return future; [EOL] } [EOL] }; [EOL] try { [EOL] function.get(); [EOL] fail("Should have thrown ConcurrentException"); [EOL] } catch (ConcurrentException expected) { [EOL] assertNotNull(expected.getCause()); [EOL] assertTrue(expected.getCause() instanceof InterruptedException); [EOL] assertTrue(Thread.currentThread().isInterrupted()); [EOL] } [EOL] }
public void testNumericEntityEscaperConstructor() { [EOL] NumericEntityEscaper escaper = new NumericEntityEscaper(10, 20, true); [EOL] assertEquals(10, escaper.below); [EOL] assertEquals(20, escaper.above); [EOL] assertTrue(escaper.between); [EOL] }
public void testNumericEntityEscaperConstructorWithNegativeValues() { [EOL] NumericEntityEscaper escaper = new NumericEntityEscaper(-10, -20, false); [EOL] assertEquals(-10, escaper.below); [EOL] assertEquals(-20, escaper.above); [EOL] assertFalse(escaper.between); [EOL] }
public void testBelow_withNegativeCodepoint() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.below(-1); [EOL] assertFalse(escaper.isEscaped(0)); [EOL] assertFalse(escaper.isEscaped(Integer.MAX_VALUE)); [EOL] }
public void testBelow_withZeroCodepoint() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.below(0); [EOL] assertFalse(escaper.isEscaped(0)); [EOL] assertTrue(escaper.isEscaped(1)); [EOL] }
public void testBelow_withPositiveCodepoint() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.below(100); [EOL] assertFalse(escaper.isEscaped(99)); [EOL] assertTrue(escaper.isEscaped(100)); [EOL] }
public void testAbove_withNegativeCodepoint() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.above(-1); [EOL] assertFalse(escaper.isEscaped(0)); [EOL] assertTrue(escaper.isEscaped(1)); [EOL] }
public void testAbove_withZeroCodepoint() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.above(0); [EOL] assertFalse(escaper.isEscaped(0)); [EOL] assertTrue(escaper.isEscaped(1)); [EOL] }
public void testAbove_withPositiveCodepoint() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.above(1); [EOL] assertFalse(escaper.isEscaped(1)); [EOL] assertTrue(escaper.isEscaped(2)); [EOL] }
public void testOutsideOf_ValidRange() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.outsideOf(50, 70); [EOL] assertNotNull(escaper); [EOL] assertFalse(escaper.isEscaping(55)); [EOL] assertTrue(escaper.isEscaping(49)); [EOL] assertTrue(escaper.isEscaping(71)); [EOL] }
public void testOutsideOf_InvertedRange() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.outsideOf(70, 50); [EOL] assertNotNull(escaper); [EOL] assertFalse(escaper.isEscaping(60)); [EOL] assertTrue(escaper.isEscaping(49)); [EOL] assertTrue(escaper.isEscaping(71)); [EOL] }
public void testOutsideOf_SameBoundaries() { [EOL] NumericEntityEscaper escaper = NumericEntityEscaper.outsideOf(50, 50); [EOL] assertNotNull(escaper); [EOL] assertFalse(escaper.isEscaping(50)); [EOL] assertTrue(escaper.isEscaping(49)); [EOL] assertTrue(escaper.isEscaping(51)); [EOL] }
public void testTranslate_CodepointOutsideRangeBelowAndBetweenTrue() throws IOException { [EOL] final int codepoint = 50; // Below the 'below' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = true; [EOL] final StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(below, above, between); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertFalse("Translation should fail for codepoint below range when between is true", result); [EOL] assertEquals("Output should be empty as translation did not occur", "", out.toString()); [EOL] }
public void testTranslate_CodepointOutsideRangeAboveAndBetweenTrue() throws IOException { [EOL] final int codepoint = 80; // Above the 'above' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = true; [EOL] final StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(below, above, between); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertFalse("Translation should fail for codepoint above range when between is true", result); [EOL] assertEquals("Output should be empty as translation did not occur", "", out.toString()); [EOL] }
public void testTranslate_CodepointWithinRangeAndBetweenTrue() throws IOException { [EOL] final int codepoint = 65; // Within the 'below' and 'above' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = true; [EOL] final StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(below, above, between); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertTrue("Translation should succeed for codepoint within range when between is true", result); [EOL] assertEquals("Output should contain the translated codepoint", "&#65;", out.toString()); [EOL] }
public void testTranslate_CodepointWithinRangeAndBetweenFalse() throws IOException { [EOL] final int codepoint = 65; // Within the 'below' and 'above' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = false; [EOL] final StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(below, above, between); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertFalse("Translation should fail for codepoint within range when between is false", result); [EOL] assertEquals("Output should be empty as translation did not occur", "", out.toString()); [EOL] }
public void testTranslate_CodepointOutsideRangeBelowAndBetweenFalse() throws IOException { [EOL] final int codepoint = 50; // Below the 'below' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = false; [EOL] final StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(below, above, between); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertTrue("Translation should succeed for codepoint below range when between is false", result); [EOL] assertEquals("Output should contain the translated codepoint", "&#50;", out.toString()); [EOL] }
public void testTranslate_CodepointOutsideRangeAboveAndBetweenFalse() throws IOException { [EOL] final int codepoint = 80; // Above the 'above' threshold [EOL] final int below = 60; [EOL] final int above = 70; [EOL] final boolean between = false; [EOL] final StringWriter out = new StringWriter(); [EOL] NumericEntityTranslator translator = new NumericEntityTranslator(below, above, between); [EOL] boolean result = translator.translate(codepoint, out); [EOL] assertTrue("Translation should succeed for codepoint above range when between is false", result); [EOL] assertEquals("Output should contain the translated codepoint", "&#80;", out.toString()); [EOL] }
public void testPutIfAbsentWithNullMap() { [EOL] ConcurrentMap<Object, Object> map = null; [EOL] Object key = new Object(); [EOL] Object value = new Object(); [EOL] Object result = Lang3.putIfAbsent(map, key, value); [EOL] assertNull(result); [EOL] }
public void testPutIfAbsentWithExistingKey() { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] Object result = Lang3.putIfAbsent(map, key, new Object()); [EOL] assertSame(value, result); [EOL] }
public void testPutIfAbsentWithAbsentKey() { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] Object value = new Object(); [EOL] Object result = Lang3.putIfAbsent(map, key, value); [EOL] assertSame(value, result); [EOL] }
public void testCreateIfAbsentWithNullMap() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = null; [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, new Object(), init); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentWithNullInitializer() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] ConcurrentInitializer<Object> init = null; [EOL] Object result = Lang3.createIfAbsent(map, new Object(), init); [EOL] assertNull(result); [EOL] }
public void testCreateIfAbsentWithNewKey() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertNotNull(result); [EOL] assertTrue(map.containsKey(key)); [EOL] assertEquals(result, map.get(key)); [EOL] }
public void testCreateIfAbsentWithExistingKey() throws ConcurrentException { [EOL] ConcurrentMap<Object, Object> map = new ConcurrentHashMap<>(); [EOL] Object key = new Object(); [EOL] Object value = new Object(); [EOL] map.put(key, value); [EOL] ConcurrentInitializer<Object> init = () -> new Object(); [EOL] Object result = Lang3.createIfAbsent(map, key, init); [EOL] assertSame(value, result); [EOL] }
public void testCreateIfAbsentUncheckedWithExistingKey() { [EOL] ConcurrentMap<String, String> map = new ConcurrentHashMap<>(); [EOL] String key = "testKey"; [EOL] String value = "testValue"; [EOL] map.put(key, value); [EOL] ConcurrentInitializer<String> init = () -> "newValue"; [EOL] String result = ConcurrentUtils.createIfAbsentUnchecked(map, key, init); [EOL] assertEquals("Value should be the one already in the map", value, result); [EOL] } [EOL] public void testCreateIfAbsentUncheckedWithAbsentKey() { [EOL] ConcurrentMap<String, String> map = new ConcurrentHashMap<>(); [EOL] String key = "testKey"; [EOL] ConcurrentInitializer<String> init = () -> "newValue"; [EOL] String result = ConcurrentUtils.createIfAbsentUnchecked(map, key, init); [EOL] assertEquals("Value should be the one created by the initializer", "newValue", result); [EOL] } [EOL] public void testCreateIfAbsentUncheckedWithException() { [EOL] ConcurrentMap<String, String> map = new ConcurrentHashMap<>(); [EOL] String key = "testKey"; [EOL] ConcurrentInitializer<String> init = () -> { throw new ConcurrentException("Test Exception"); }; [EOL] try { [EOL] ConcurrentUtils.createIfAbsentUnchecked(map, key, init); [EOL] fail("Expected ConcurrentRuntimeException"); [EOL] } catch (ConcurrentRuntimeException ex) { [EOL] assertNotNull("Cause should not be null", ex.getCause()); [EOL] assertEquals("Cause should be a ConcurrentException", ConcurrentException.class, ex.getCause().getClass()); [EOL] } [EOL] }
public void testConstantFutureWithNonNull() { [EOL] String constantValue = "Constant Value"; [EOL] Future<String> future = constantFuture(constantValue); [EOL] assertTrue(future.isDone()); [EOL] try { [EOL] assertEquals(constantValue, future.get()); [EOL] } catch (Exception e) { [EOL] fail("Exception should not be thrown"); [EOL] } [EOL] }
public void testConstantFutureWithNull() { [EOL] Future<Object> future = constantFuture(null); [EOL] assertTrue(future.isDone()); [EOL] try { [EOL] assertNull(future.get()); [EOL] } catch (Exception e) { [EOL] fail("Exception should not be thrown"); [EOL] } [EOL] }
public void testConstantFutureWithValue() { [EOL] String testValue = "Test"; [EOL] ConstantFuture<String> constantFuture = new ConstantFuture<>(testValue); [EOL] assertEquals(testValue, constantFuture.value); [EOL] }
public void testConstantFutureWithNull() { [EOL] ConstantFuture<Object> constantFuture = new ConstantFuture<>(null); [EOL] assertNull(constantFuture.value); [EOL] }
public void testIsDoneReturnsTrue() { [EOL] SomeClass instance = new SomeClass(); [EOL] boolean result = instance.isDone(); [EOL] assertTrue(result); [EOL] }
public T get() { [EOL] return value; [EOL] }
public void testGetWithTimeout() throws Exception { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = expectedValue; [EOL] Object result = instance.get(1000, TimeUnit.MILLISECONDS); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testIsCancelled() { [EOL] SomeClass instance = new SomeClass(); [EOL] boolean result = instance.isCancelled(); [EOL] assertFalse(result); [EOL] }
public void testCancel() { [EOL] SomeClass instance = new SomeClass(); [EOL] boolean result = instance.cancel(true); [EOL] assertFalse("Expected cancel to return false", result); [EOL] result = instance.cancel(false); [EOL] assertFalse("Expected cancel to return false", result); [EOL] }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL] return parse(source, pos); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; };
public void testGetCache_NewField() { [EOL] ConcurrentMap<Locale, Strategy> cache = FastDateParser.getCache(Calendar.YEAR); [EOL] assertNotNull("Cache should not be null", cache); [EOL] }
public void testGetCache_ExistingField() { [EOL] FastDateParser.getCache(Calendar.YEAR); [EOL] ConcurrentMap<Locale, Strategy> cache = FastDateParser.getCache(Calendar.YEAR); [EOL] assertNotNull("Cache should not be null", cache); [EOL] }
public void testNumberStrategyConstructor() { [EOL] int field = Calendar.YEAR; [EOL] NumberStrategy strategy = new NumberStrategy(field); [EOL] assertEquals(field, strategy.getField()); [EOL] }
public void testNumberStrategySetCalendar() { [EOL] FastDateParser parser = new FastDateParser("yyyy", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "2023"; [EOL] NumberStrategy strategy = new NumberStrategy(Calendar.YEAR); [EOL] strategy.setCalendar(parser, cal, value); [EOL] assertEquals(2023, cal.get(Calendar.YEAR)); [EOL] }
public void testNumberStrategyModify() { [EOL] NumberStrategy strategy = new NumberStrategy(Calendar.MONTH); [EOL] int result = strategy.modify(5); [EOL] assertEquals(4, result); // Since MONTH strategy subtracts 1 [EOL] }
public void testNumberStrategyAddRegex() { [EOL] FastDateParser parser = new FastDateParser("MM", TimeZone.getDefault(), Locale.getDefault()); [EOL] StringBuilder regex = new StringBuilder(); [EOL] NumberStrategy strategy = new NumberStrategy(Calendar.MONTH); [EOL] strategy.addRegex(parser, regex); [EOL] assertTrue(regex.length() > 0); // Check if regex pattern is added [EOL] }
public void testNumberStrategyIsNumber() { [EOL] NumberStrategy strategy = new NumberStrategy(Calendar.MONTH); [EOL] assertTrue(strategy.isNumber()); [EOL] }
public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape) { [EOL] this(StrLookup.mapLookup(valueMap), prefix, suffix, escape); [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testReplaceWithNullSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String result = sub.replace(null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceWithValidSourceNoSubstitution() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "No substitution here"; [EOL] String result = sub.replace(source, 0, source.length()); [EOL] assertEquals("No substitution here", result); [EOL] }
public void testReplaceWithValidSourceAndSubstitution() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor sub = new StrSubstitutor(valueMap); [EOL] String source = "${key}"; [EOL] String result = sub.replace(source, 0, source.length()); [EOL] assertEquals("value", result); [EOL] }
public void testReplaceWithOffsetAndLength() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "No substitution here"; [EOL] String result = sub.replace(source, 3, 10); [EOL] assertEquals("substitution", result); [EOL] }
public void testReplaceWithInvalidOffset() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "No substitution here"; [EOL] try { [EOL] sub.replace(source, -1, source.length()); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceWithInvalidLength() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String source = "No substitution here"; [EOL] try { [EOL] sub.replace(source, 0, source.length() + 1); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_NullSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = null; [EOL] String result = sub.replace(source, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_EmptySource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = new char[0]; [EOL] String result = sub.replace(source, 0, 0); [EOL] assertEquals("", result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_ValidSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char[] source = "Hello World".toCharArray(); [EOL] String result = sub.replace(source, 6, 5); [EOL] assertEquals("World", result); [EOL] }
public void testReplaceCharArrayWithOffsetAndLength_Substitution() { [EOL] StrSubstitutor sub = new StrSubstitutor(Collections.singletonMap("name", "World")); [EOL] sub.setVariablePrefixMatcher(StrMatcher.stringMatcher("{")); [EOL] sub.setVariableSuffixMatcher(StrMatcher.stringMatcher("}")); [EOL] char[] source = "{name}".toCharArray(); [EOL] String result = sub.replace(source, 0, source.length); [EOL] assertEquals("World", result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_NullSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] String result = sub.replace((StringBuffer) null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_EmptySource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer(""); [EOL] String result = sub.replace(source, 0, 10); [EOL] assertEquals("", result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_ValidSource() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("hello world"); [EOL] String result = sub.replace(source, 0, 5); [EOL] assertEquals("hello", result); [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_OffsetOutOfBounds() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("hello world"); [EOL] try { [EOL] sub.replace(source, 20, 5); [EOL] fail("Expected StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceStringBufferWithOffsetAndLength_LengthOutOfBounds() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] StringBuffer source = new StringBuffer("hello world"); [EOL] try { [EOL] sub.replace(source, 0, 50); [EOL] fail("Expected StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_StrBuilderNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] String result = substitutor.replace((StrBuilder) null, 0, 10); [EOL] assertNull(result); [EOL] }
public void testReplace_StrBuilderValid() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] String result = substitutor.replace(source, 0, 6); [EOL] assertNotNull(result); [EOL] assertEquals("abcdef", result); [EOL] }
public void testReplace_StrBuilderPartial() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] String result = substitutor.replace(source, 2, 3); [EOL] assertNotNull(result); [EOL] assertEquals("cde", result); [EOL] }
public void testReplace_StrBuilderOffsetOutOfBounds() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] try { [EOL] substitutor.replace(source, 10, 3); [EOL] fail("Expected StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplace_StrBuilderLengthOutOfBounds() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("abcdef"); [EOL] try { [EOL] substitutor.replace(source, 0, 10); [EOL] fail("Expected StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceInStrBuilderWithNullSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = null; [EOL] boolean result = substitutor.replaceIn(source, 0, 10); [EOL] assertFalse("replaceIn should return false when source is null", result); [EOL] }
public void testReplaceInStrBuilderWithValidSource() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrBuilder source = new StrBuilder("test"); [EOL] boolean result = substitutor.replaceIn(source, 0, source.length()); [EOL] assertTrue("replaceIn should return true when source is valid", result); [EOL] }
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL] final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL] final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL] final char escape = getEscapeChar(); [EOL] final boolean top = priorVariables == null; [EOL] boolean altered = false; [EOL] int lengthChange = 0; [EOL] char[] chars = buf.buffer; [EOL] int bufEnd = offset + length; [EOL] int pos = offset; [EOL] while (pos < bufEnd) { [EOL] final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL] if (startMatchLen == 0) { [EOL] pos++; [EOL] } else { [EOL] if (pos > offset && chars[pos - 1] == escape) { [EOL] buf.deleteCharAt(pos - 1); [EOL] chars = buf.buffer; [EOL] lengthChange--; [EOL] altered = true; [EOL] bufEnd--; [EOL] } else { [EOL] final int startPos = pos; [EOL] pos += startMatchLen; [EOL] int endMatchLen = 0; [EOL] int nestedVarCount = 0; [EOL] while (pos < bufEnd) { [EOL] if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL] nestedVarCount++; [EOL] pos += endMatchLen; [EOL] continue; [EOL] } [EOL] endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL] if (endMatchLen == 0) { [EOL] pos++; [EOL] } else { [EOL] if (nestedVarCount == 0) { [EOL] String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL] if (isEnableSubstitutionInVariables()) { [EOL] final StrBuilder bufName = new StrBuilder(varName); [EOL] substitute(bufName, 0, bufName.length()); [EOL] varName = bufName.toString(); [EOL] } [EOL] pos += endMatchLen; [EOL] final int endPos = pos; [EOL] if (priorVariables == null) { [EOL] priorVariables = new ArrayList<String>(); [EOL] priorVariables.add(new String(chars, offset, length)); [EOL] } [EOL] checkCyclicSubstitution(varName, priorVariables); [EOL] priorVariables.add(varName); [EOL] final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL] if (varValue != null) { [EOL] final int varLen = varValue.length(); [EOL] buf.replace(startPos, endPos, varValue); [EOL] altered = true; [EOL] int change = substitute(buf, startPos, varLen, priorVariables); [EOL] change = change + varLen - (endPos - startPos); [EOL] pos += change; [EOL] bufEnd += change; [EOL] lengthChange += change; [EOL] chars = buf.buffer; [EOL] } [EOL] priorVariables.remove(priorVariables.size() - 1); [EOL] break; [EOL] } else { [EOL] nestedVarCount--; [EOL] pos += endMatchLen; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (top) { [EOL] return altered ? 1 : 0; [EOL] } [EOL] return lengthChange; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testCheckCyclicSubstitution_NoCycle() { [EOL] List<String> priorVariables = new ArrayList<>(); [EOL] priorVariables.add("var1"); [EOL] priorVariables.add("var2"); [EOL] checkCyclicSubstitution("var3", priorVariables); [EOL] }
public void testCheckCyclicSubstitution_WithCycle() { [EOL] List<String> priorVariables = new ArrayList<>(); [EOL] priorVariables.add("var1"); [EOL] priorVariables.add("var2"); [EOL] priorVariables.add("var1"); // Add a variable that introduces a cycle [EOL] try { [EOL] checkCyclicSubstitution("var1", priorVariables); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Infinite loop in property interpolation of var1: var2->var1", e.getMessage()); [EOL] } [EOL] }
public void testSetEnableSubstitutionInVariables_True() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] substitutor.setEnableSubstitutionInVariables(true); [EOL] assertTrue(substitutor.isEnableSubstitutionInVariables()); [EOL] }
public void testSetEnableSubstitutionInVariables_False() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] substitutor.setEnableSubstitutionInVariables(false); [EOL] assertFalse(substitutor.isEnableSubstitutionInVariables()); [EOL] }
public void testGetFraction_ValidInput_PositiveWhole() { [EOL] Fraction result = Fraction.getFraction(1, 1, 2); [EOL] assertEquals(3, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_ValidInput_NegativeWhole() { [EOL] Fraction result = Fraction.getFraction(-1, 1, 2); [EOL] assertEquals(-3, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] } [EOL] public void testGetFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 1, 0); [EOL] fail("Expected ArithmeticException due to zero denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NegativeDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 1, -1); [EOL] fail("Expected ArithmeticException due to negative denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be negative", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NegativeNumerator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, -1, 2); [EOL] fail("Expected ArithmeticException due to negative numerator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The numerator must not be negative", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NumeratorTooLarge_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MAX_VALUE, 1, 1); [EOL] fail("Expected ArithmeticException due to large numerator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("Numerator too large to represent as an Integer.", ae.getMessage()); [EOL] } [EOL] } [EOL] public void testGetFraction_NumeratorTooSmall_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MIN_VALUE, 1, 1); [EOL] fail("Expected ArithmeticException due to small numerator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("Numerator too large to represent as an Integer.", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_NullString() { [EOL] try { [EOL] Fraction.getFraction(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetFraction_DecimalString() { [EOL] Fraction fraction = Fraction.getFraction("0.5"); [EOL] assertEquals(Fraction.getFraction(1, 2), fraction); [EOL] }
public void testGetFraction_WholeWithFractionString() { [EOL] Fraction fraction = Fraction.getFraction("1 2/3"); [EOL] assertEquals(Fraction.getFraction(5, 3), fraction); [EOL] }
public void testGetFraction_InvalidWholeWithFractionString() { [EOL] try { [EOL] Fraction.getFraction("1 2"); [EOL] fail("Expected NumberFormatException"); [EOL] } catch (NumberFormatException ex) { [EOL] } [EOL] }
public void testGetFraction_SimpleFractionString() { [EOL] Fraction fraction = Fraction.getFraction("3/4"); [EOL] assertEquals(Fraction.getFraction(3, 4), fraction); [EOL] }
public void testGetFraction_WholeNumberString() { [EOL] Fraction fraction = Fraction.getFraction("5"); [EOL] assertEquals(Fraction.getFraction(5, 1), fraction); [EOL] }
public void testGetFraction_InvalidString() { [EOL] try { [EOL] Fraction.getFraction("invalid"); [EOL] fail("Expected NumberFormatException"); [EOL] } catch (NumberFormatException ex) { [EOL] } [EOL] }
public void testGetProperNumerator_PositiveNumeratorAndDenominator() { [EOL] Fraction fraction = new Fraction(6, 3); [EOL] int result = fraction.getProperNumerator(); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testGetProperNumerator_NegativeNumeratorAndPositiveDenominator() { [EOL] Fraction fraction = new Fraction(-6, 3); [EOL] int result = fraction.getProperNumerator(); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testGetProperNumerator_PositiveNumeratorAndNegativeDenominator() { [EOL] Fraction fraction = new Fraction(6, -3); [EOL] int result = fraction.getProperNumerator(); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testGetProperNumerator_NegativeNumeratorAndDenominator() { [EOL] Fraction fraction = new Fraction(-6, -3); [EOL] int result = fraction.getProperNumerator(); [EOL] assertEquals(0, result); [EOL] }
public void testGetProperNumerator_NonZeroRemainder() { [EOL] Fraction fraction = new Fraction(7, 3); [EOL] int result = fraction.getProperNumerator(); [EOL] assertEquals(1, result); [EOL] }
public void testGetProperWholeWithPositiveNumeratorAndDenominator() { [EOL] Fraction fraction = new Fraction(3, 2); [EOL] int result = fraction.getProperWhole(); [EOL] assertEquals(1, result); [EOL] }
public void testGetProperWholeWithNegativeNumeratorAndPositiveDenominator() { [EOL] Fraction fraction = new Fraction(-3, 2); [EOL] int result = fraction.getProperWhole(); [EOL] assertEquals(-1, result); [EOL] }
public void testGetProperWholeWithZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 2); [EOL] int result = fraction.getProperWhole(); [EOL] assertEquals(0, result); [EOL] }
public void testGetProperWholeWithOneNumerator() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] int result = fraction.getProperWhole(); [EOL] assertEquals(0, result); [EOL] }
public void testIntValueWithPositiveNumeratorAndDenominator() { [EOL] int numerator = 10; [EOL] int denominator = 2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(5, result); [EOL] } [EOL] public void testIntValueWithNegativeNumeratorAndPositiveDenominator() { [EOL] int numerator = -10; [EOL] int denominator = 2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(-5, result); [EOL] } [EOL] public void testIntValueWithPositiveNumeratorAndNegativeDenominator() { [EOL] int numerator = 10; [EOL] int denominator = -2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(-5, result); [EOL] } [EOL] public void testIntValueWithNegativeNumeratorAndDenominator() { [EOL] int numerator = -10; [EOL] int denominator = -2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(5, result); [EOL] } [EOL] public void testIntValueWithZeroNumerator() { [EOL] int numerator = 0; [EOL] int denominator = 2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIntValueWithOneNumerator() { [EOL] int numerator = 1; [EOL] int denominator = 2; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testIntValueWithDenominatorOne() { [EOL] int numerator = 10; [EOL] int denominator = 1; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(10, result); [EOL] }
public void testIntValueWithMaxNumerator() { [EOL] int numerator = Integer.MAX_VALUE; [EOL] int denominator = 1; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] } [EOL] public void testIntValueWithMinNumerator() { [EOL] int numerator = Integer.MIN_VALUE; [EOL] int denominator = 1; [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] int result = fraction.intValue(); [EOL] assertEquals(Integer.MIN_VALUE, result); [EOL] }
public void testIntValueWithZeroDenominator() { [EOL] int numerator = 10; [EOL] int denominator = 0; [EOL] try { [EOL] Fraction fraction = new Fraction(numerator, denominator); [EOL] fraction.intValue(); [EOL] fail("Should have thrown ArithmeticException due to division by zero"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testLongValue_PositiveNumeratorPositiveDenominator() { [EOL] Fraction fraction = Fraction.getFraction(5, 2); [EOL] long result = fraction.longValue(); [EOL] assertEquals(2L, result); [EOL] }
public void testLongValue_PositiveNumeratorNegativeDenominator() { [EOL] Fraction fraction = Fraction.getFraction(5, -2); [EOL] long result = fraction.longValue(); [EOL] assertEquals(-2L, result); [EOL] }
public void testLongValue_NegativeNumeratorPositiveDenominator() { [EOL] Fraction fraction = Fraction.getFraction(-5, 2); [EOL] long result = fraction.longValue(); [EOL] assertEquals(-2L, result); [EOL] }
public void testLongValue_NegativeNumeratorNegativeDenominator() { [EOL] Fraction fraction = Fraction.getFraction(-5, -2); [EOL] long result = fraction.longValue(); [EOL] assertEquals(2L, result); [EOL] }
public void testLongValue_ZeroNumerator() { [EOL] Fraction fraction = Fraction.getFraction(0, 2); [EOL] long result = fraction.longValue(); [EOL] assertEquals(0L, result); [EOL] }
public void testFloatValue_PositiveNumeratorPositiveDenominator() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] float result = fraction.floatValue(); [EOL] assertEquals(0.5f, result, 0.0f); [EOL] }
public void testFloatValue_PositiveNumeratorNegativeDenominator() { [EOL] Fraction fraction = new Fraction(1, -2); [EOL] float result = fraction.floatValue(); [EOL] assertEquals(-0.5f, result, 0.0f); [EOL] }
public void testFloatValue_NegativeNumeratorPositiveDenominator() { [EOL] Fraction fraction = new Fraction(-1, 2); [EOL] float result = fraction.floatValue(); [EOL] assertEquals(-0.5f, result, 0.0f); [EOL] }
public void testFloatValue_NegativeNumeratorNegativeDenominator() { [EOL] Fraction fraction = new Fraction(-1, -2); [EOL] float result = fraction.floatValue(); [EOL] assertEquals(0.5f, result, 0.0f); [EOL] }
public void testFloatValue_ZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 2); [EOL] float result = fraction.floatValue(); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testFloatValue_DenominatorOne() { [EOL] Fraction fraction = new Fraction(1, 1); [EOL] float result = fraction.floatValue(); [EOL] assertEquals(1.0f, result, 0.0f); [EOL] }
public void testDoubleValue_PositiveFraction() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] double result = fraction.doubleValue(); [EOL] assertEquals(0.5, result, 0.0); [EOL] }
public void testDoubleValue_NegativeFraction() { [EOL] Fraction fraction = new Fraction(-1, 2); [EOL] double result = fraction.doubleValue(); [EOL] assertEquals(-0.5, result, 0.0); [EOL] }
public void testDoubleValue_ZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 2); [EOL] double result = fraction.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testDoubleValue_OneNumerator() { [EOL] Fraction fraction = new Fraction(1, 1); [EOL] double result = fraction.doubleValue(); [EOL] assertEquals(1.0, result, 0.0); [EOL] }
public void testEquals_sameObject() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] assertTrue(fraction.equals(fraction)); [EOL] }
public void testEquals_differentClass() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Object other = new Object(); [EOL] assertFalse(fraction.equals(other)); [EOL] }
public void testEquals_nullObject() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Object other = null; [EOL] assertFalse(fraction.equals(other)); [EOL] }
public void testEquals_equalFractions() { [EOL] Fraction fraction1 = new Fraction(1, 2); [EOL] Fraction fraction2 = new Fraction(1, 2); [EOL] assertTrue(fraction1.equals(fraction2)); [EOL] }
public void testEquals_unequalNumerators() { [EOL] Fraction fraction1 = new Fraction(1, 2); [EOL] Fraction fraction2 = new Fraction(3, 2); [EOL] assertFalse(fraction1.equals(fraction2)); [EOL] }
public void testEquals_unequalDenominators() { [EOL] Fraction fraction1 = new Fraction(1, 2); [EOL] Fraction fraction2 = new Fraction(1, 3); [EOL] assertFalse(fraction1.equals(fraction2)); [EOL] }
public void testToProperString_ZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 3); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("0", result); [EOL] }
public void testToProperString_NumeratorEqualsDenominator() { [EOL] Fraction fraction = new Fraction(2, 2); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("1", result); [EOL] }
public void testToProperString_NumeratorEqualsNegativeDenominator() { [EOL] Fraction fraction = new Fraction(-3, 3); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("-1", result); [EOL] }
public void testToProperString_ProperFractionPositive() { [EOL] Fraction fraction = new Fraction(1, 3); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("1/3", result); [EOL] }
public void testToProperString_ProperFractionNegative() { [EOL] Fraction fraction = new Fraction(-1, 3); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("-1/3", result); [EOL] }
public void testToProperString_ImproperFractionPositive() { [EOL] Fraction fraction = new Fraction(5, 3); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("1 2/3", result); [EOL] }
public void testToProperString_ImproperFractionNegative() { [EOL] Fraction fraction = new Fraction(-5, 3); [EOL] String result = fraction.toProperString(); [EOL] assertEquals("-1 2/3", result); [EOL] }
public void testLastIndexOf_StringInstance() { [EOL] CharSequence cs = "test string"; [EOL] int searchChar = 't'; [EOL] int start = 10; [EOL] int result = StringUtils.lastIndexOf(cs, searchChar, start); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_StartNegative() { [EOL] CharSequence cs = "test string"; [EOL] int searchChar = 't'; [EOL] int start = -1; [EOL] int result = StringUtils.lastIndexOf(cs, searchChar, start); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_StartGreaterThanLength() { [EOL] CharSequence cs = "test string"; [EOL] int searchChar = 't'; [EOL] int start = 20; [EOL] int result = StringUtils.lastIndexOf(cs, searchChar, start); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_CharNotFound() { [EOL] CharSequence cs = "test string"; [EOL] int searchChar = 'x'; [EOL] int start = 10; [EOL] int result = StringUtils.lastIndexOf(cs, searchChar, start); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_EmptyString() { [EOL] CharSequence cs = ""; [EOL] int searchChar = 't'; [EOL] int start = 0; [EOL] int result = StringUtils.lastIndexOf(cs, searchChar, start); [EOL] assertEquals(-1, result); [EOL] }
public void testRegionMatches_StringMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 1, "bcde", 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_StringNoMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", false, 1, "bBde", 0, 4); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_IgnoreCaseMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", true, 1, "bBde", 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_IgnoreCaseNoMatch() { [EOL] boolean result = StringUtils.regionMatches("abcdef", true, 1, "bBde", 0, 3); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_NonStringInputMatch() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] CharSequence substring = new StringBuilder("bcde"); [EOL] boolean result = StringUtils.regionMatches(cs, false, 1, substring, 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_NonStringInputNoMatch() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] CharSequence substring = new StringBuilder("bBde"); [EOL] boolean result = StringUtils.regionMatches(cs, false, 1, substring, 0, 4); [EOL] assertFalse(result); [EOL] } [EOL] public void testRegionMatches_NonStringIgnoreCaseMatch() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] CharSequence substring = new StringBuilder("bBde"); [EOL] boolean result = StringUtils.regionMatches(cs, true, 1, substring, 0, 4); [EOL] assertTrue(result); [EOL] } [EOL] public void testRegionMatches_NonStringIgnoreCaseNoMatch() { [EOL] CharSequence cs = new StringBuilder("abcdef"); [EOL] CharSequence substring = new StringBuilder("bBde"); [EOL] boolean result = StringUtils.regionMatches(cs, true, 1, substring, 0, 3); [EOL] assertFalse(result); [EOL] }
public void testGetCSVClone() throws CloneNotSupportedException { [EOL] StrTokenizer tokenizer1 = StringUtils.getCSVClone(); [EOL] StrTokenizer tokenizer2 = StringUtils.getCSVClone(); [EOL] assertNotNull(tokenizer1); [EOL] assertNotNull(tokenizer2); [EOL] assertNotSame(tokenizer1, tokenizer2); [EOL] assertEquals(tokenizer1.next(), tokenizer2.next()); [EOL] }
public void testGetCSVInstance_CoversGetCSVClone() { [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance(); [EOL] assertNotNull(tokenizer); [EOL] assertEquals(',', tokenizer.getDelimiterChar()); [EOL] assertTrue(tokenizer.isIgnoreEmptyTokens()); [EOL] assertEquals(StrMatcher.noneMatcher(), tokenizer.getIgnoredMatcher()); [EOL] assertEquals(StrMatcher.noneMatcher(), tokenizer.getTrimmerMatcher()); [EOL] assertEquals(StrMatcher.stringMatcher("\""), tokenizer.getQuoteMatcher()); [EOL] }
public void testGetCSVInstanceWithNullInput() { [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance(null); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetCSVInstanceWithEmptyString() { [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance(""); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetCSVInstanceWithNonEmptyString() { [EOL] StrTokenizer tokenizer = StrTokenizer.getCSVInstance("a,b,c"); [EOL] assertNotNull(tokenizer); [EOL] assertTrue(tokenizer.hasNext()); [EOL] assertEquals("a", tokenizer.next()); [EOL] }
public void testGetTSVClone() throws CloneNotSupportedException { [EOL] StrTokenizer tokenizer1 = StringUtils.getTSVClone(); [EOL] StrTokenizer tokenizer2 = StringUtils.getTSVClone(); [EOL] assertNotNull(tokenizer1); [EOL] assertNotNull(tokenizer2); [EOL] assertNotSame(tokenizer1, tokenizer2); [EOL] assertEquals(tokenizer1.next(), tokenizer2.next()); [EOL] }
public static StrTokenizer getTSVInstance() { [EOL] return getTSVClone(); [EOL] }
public void testStrTokenizerWithNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer(null); [EOL] assertNull("Tokenizer chars should be null", tokenizer.toCharArray()); [EOL] }
public void testStrTokenizerWithEmptyInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer(new char[] {}); [EOL] assertArrayEquals("Tokenizer chars should be empty", new char[] {}, tokenizer.toCharArray()); [EOL] }
public void testStrTokenizerWithNonEmptyInput() { [EOL] char[] input = new char[] {'a', 'b', 'c'}; [EOL] StrTokenizer tokenizer = new StrTokenizer(input); [EOL] assertArrayEquals("Tokenizer chars should match input", input, tokenizer.toCharArray()); [EOL] }
public void testStrTokenizerWithCharDelimiter() { [EOL] char[] input = {'a', 'b', 'c'}; [EOL] char delim = ','; [EOL] StrTokenizer tokenizer = new StrTokenizer(input, delim); [EOL] assertEquals("a,b,c", tokenizer.getContent()); [EOL] assertEquals(delim, tokenizer.getDelimiterChar()); [EOL] }
public void testStrTokenizerWithNullInput() { [EOL] char[] input = null; [EOL] char delim = ','; [EOL] StrTokenizer tokenizer = new StrTokenizer(input, delim); [EOL] assertNull(tokenizer.next()); [EOL] assertEquals(delim, tokenizer.getDelimiterChar()); [EOL] }
public void testStrTokenizerWithDelimAndQuote() { [EOL] char[] input = {'a', 'b', 'c'}; [EOL] char delim = ','; [EOL] char quote = '"'; [EOL] StrTokenizer tokenizer = new StrTokenizer(input, delim, quote); [EOL] assertEquals(quote, tokenizer.getQuoteChar()); [EOL] assertEquals(delim, tokenizer.getDelimiterChar()); [EOL] assertTrue(Arrays.equals(input, tokenizer.toCharArray())); [EOL] }
public void testStrTokenizerWithNullInput() { [EOL] char delim = ','; [EOL] char quote = '"'; [EOL] StrTokenizer tokenizer = new StrTokenizer(null, delim, quote); [EOL] assertEquals(quote, tokenizer.getQuoteChar()); [EOL] assertEquals(delim, tokenizer.getDelimiterChar()); [EOL] assertNull(tokenizer.toCharArray()); [EOL] }
public void testSize_WhenTokenized_ShouldReturnCorrectSize() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] int size = tokenizer.size(); [EOL] assertEquals(3, size); [EOL] }
public void testSize_WhenEmpty_ShouldReturnZero() { [EOL] StrTokenizer tokenizer = new StrTokenizer(""); [EOL] int size = tokenizer.size(); [EOL] assertEquals(0, size); [EOL] }
public void testSize_WhenNotTokenizedYet_ShouldTokenizeAndReturnSize() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.setTokenized(false); [EOL] int size = tokenizer.size(); [EOL] assertEquals(3, size); [EOL] }
public void testNextToken_HasNextToken() { [EOL] StringTokenizer tokenizer = new StringTokenizer("token1 token2 token3"); [EOL] String token = tokenizer.nextToken(); [EOL] assertEquals("token1", token); [EOL] token = tokenizer.nextToken(); [EOL] assertEquals("token2", token); [EOL] }
public void testNextToken_NoNextToken() { [EOL] StringTokenizer tokenizer = new StringTokenizer(""); [EOL] String token = tokenizer.nextToken(); [EOL] assertNull(token); [EOL] }
public void testGetTokenArray_NotTokenized() { [EOL] Tokenizer tokenizer = new Tokenizer(); // Assuming a constructor exists [EOL] try { [EOL] tokenizer.getTokenArray(); [EOL] fail("Expected IllegalStateException due to not tokenized"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetTokenArray_EmptyTokens() { [EOL] Tokenizer tokenizer = new Tokenizer(); // Assuming a method tokenize exists [EOL] tokenizer.tokenize(""); // Assuming this method tokenizes and sets an empty array [EOL] String[] tokens = tokenizer.getTokenArray(); [EOL] assertNotNull(tokens); [EOL] assertEquals(0, tokens.length); [EOL] }
public void testGetTokenArray_NonEmptyTokens() { [EOL] Tokenizer tokenizer = new Tokenizer(); // Assuming a method tokenize exists [EOL] tokenizer.tokenize("a b c"); // Assuming this method tokenizes the string into ["a", "b", "c"] [EOL] String[] tokens = tokenizer.getTokenArray(); [EOL] assertNotNull(tokens); [EOL] assertEquals(3, tokens.length); [EOL] assertEquals("a", tokens[0]); [EOL] assertEquals("b", tokens[1]); [EOL] assertEquals("c", tokens[2]); [EOL] }
public void testReset() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.nextToken(); [EOL] StrTokenizer result = tokenizer.reset(); [EOL] assertEquals("Reset should return the same tokenizer", tokenizer, result); [EOL] assertNull("Tokens should be null after reset", tokenizer.nextToken()); [EOL] }
public void testResetWithNonNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer("initial"); [EOL] StrTokenizer result = tokenizer.reset("reset"); [EOL] assertNotNull(result); [EOL] assertEquals("reset", result.nextToken()); [EOL] }
public void testResetWithNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer("initial"); [EOL] StrTokenizer result = tokenizer.reset(null); [EOL] assertNotNull(result); [EOL] assertFalse(result.hasNext()); [EOL] }
public void testResetWithNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer("test"); [EOL] StrTokenizer result = tokenizer.reset(null); [EOL] assertNotNull(result); [EOL] assertSame(tokenizer, result); [EOL] assertNull(result.toCharArray()); [EOL] }
public void testResetWithNonNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer("test"); [EOL] char[] input = new char[] {'a', 'b', 'c'}; [EOL] StrTokenizer result = tokenizer.reset(input); [EOL] assertNotNull(result); [EOL] assertSame(tokenizer, result); [EOL] assertArrayEquals(input, result.toCharArray()); [EOL] }
public void testNext_WhenHasNextIsTrue_ShouldReturnNextToken() { [EOL] String[] tokens = {"token1", "token2", "token3"}; [EOL] Tokenizer tokenizer = new Tokenizer(tokens); // Assuming Tokenizer is the class name and it has a constructor that accepts an array of tokens [EOL] String result = tokenizer.next(); [EOL] assertEquals("token1", result); [EOL] assertEquals(1, tokenizer.getTokenPos()); // Assuming getTokenPos() is a method to get the current token position [EOL] } [EOL] public void testNext_WhenHasNextIsFalse_ShouldThrowException() { [EOL] String[] tokens = {}; [EOL] Tokenizer tokenizer = new Tokenizer(tokens); [EOL] try { [EOL] tokenizer.next(); [EOL] fail("Expected an NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testHasPrevious_WhenTokenPosIsZero_ShouldReturnFalse() { [EOL] Tokenizer tokenizer = new Tokenizer(""); // Assuming Tokenizer is the class where hasPrevious() is defined [EOL] tokenizer.checkTokenized(); // Assuming this method initializes tokenPos to 0 [EOL] boolean result = tokenizer.hasPrevious(); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasPrevious_WhenTokenPosIsGreaterThanZero_ShouldReturnTrue() { [EOL] Tokenizer tokenizer = new Tokenizer("some text"); // Assuming Tokenizer is the class where hasPrevious() is defined [EOL] tokenizer.checkTokenized(); // Assuming this method sets tokenPos > 0 based on the input text [EOL] boolean result = tokenizer.hasPrevious(); [EOL] assertTrue(result); [EOL] }
public void testAddTokenWithEmptyTokenAndIgnoreEmpty() { [EOL] List<String> list = new ArrayList<>(); [EOL] addToken(list, ""); [EOL] assertTrue(list.isEmpty()); [EOL] } [EOL] public void testAddTokenWithEmptyTokenAndNotIgnoreEmpty() { [EOL] List<String> list = new ArrayList<>(); [EOL] setIsIgnoreEmptyTokens(false); [EOL] addToken(list, ""); [EOL] assertEquals(1, list.size()); [EOL] assertNull(list.get(0)); [EOL] } [EOL] public void testAddTokenWithEmptyTokenAndEmptyTokenAsNull() { [EOL] List<String> list = new ArrayList<>(); [EOL] setIsIgnoreEmptyTokens(false); [EOL] setIsEmptyTokenAsNull(true); [EOL] addToken(list, ""); [EOL] assertEquals(1, list.size()); [EOL] assertNull(list.get(0)); [EOL] } [EOL] public void testAddTokenWithNonEmptyToken() { [EOL] List<String> list = new ArrayList<>(); [EOL] addToken(list, "token"); [EOL] assertEquals(1, list.size()); [EOL] assertEquals("token", list.get(0)); [EOL] }

public void testReadNextTokenAtEndOfString() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(-1, result); [EOL] assertTrue(tokens.contains("")); [EOL] }
public void testReadNextTokenWithIgnoredAndTrimmerMatchers() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "   a".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(3, result); [EOL] assertTrue(tokens.contains("")); [EOL] }
public void testReadNextTokenWithDelimiterMatcher() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = ",a".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(1, result); [EOL] assertTrue(tokens.contains("")); [EOL] }
public void testReadNextTokenWithQuoteMatcher() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "\"a\"".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertTrue(result > 0); [EOL] assertTrue(tokens.isEmpty()); [EOL] }
public void testReadNextTokenWithoutMatchers() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = "a".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertTrue(result > 0); [EOL] assertTrue(tokens.isEmpty()); [EOL] }
public void testReadWithQuotes_NoQuotes() { [EOL] char[] chars = "test".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals("test", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithQuotes() { [EOL] char[] chars = "a \"quoted\" word".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 2; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(10, result); [EOL] assertEquals("a ", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithEscapedQuotes() { [EOL] char[] chars = "a \"quo\\\"ted\" word".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 2; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(13, result); [EOL] assertEquals("a ", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithMultipleQuotes() { [EOL] char[] chars = "a \"quoted\" \"word\"".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 2; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(10, result); [EOL] assertEquals("a ", tokens.get(0)); [EOL] result = readWithQuotes(chars, result, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(16, result); [EOL] assertEquals("word", tokens.get(1)); [EOL] }
public void testReadWithQuotes_WithDelimiter() { [EOL] char[] chars = "a,b,c".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(1, result); [EOL] assertEquals("a", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithIgnored() { [EOL] char[] chars = "a  b c".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(3, result); [EOL] assertEquals("a", tokens.get(0)); [EOL] }
public void testReadWithQuotes_WithTrimmer() { [EOL] char[] chars = "a   b c".toCharArray(); [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(5, result); [EOL] assertEquals("a   b", tokens.get(0)); [EOL] }
public void testCloneResetWithNonNullChars() throws CloneNotSupportedException { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.cloneReset(); [EOL] assertNotNull(clonedTokenizer); [EOL] assertNotSame(tokenizer, clonedTokenizer); [EOL] assertTrue(Arrays.equals(tokenizer.getTokenArray(), clonedTokenizer.getTokenArray())); [EOL] } [EOL] public void testCloneResetWithNullChars() throws CloneNotSupportedException { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] tokenizer.setChars(null); [EOL] StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.cloneReset(); [EOL] assertNotNull(clonedTokenizer); [EOL] assertNotSame(tokenizer, clonedTokenizer); [EOL] assertNull(clonedTokenizer.next()); [EOL] }
@Override [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL] Class<? extends Annotation> annotationType = null; [EOL] for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL] if (Annotation.class.isAssignableFrom(iface)) { [EOL] final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL] annotationType = found; [EOL] break; [EOL] } [EOL] } [EOL] return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=new ToStringStyle() {;     private static final long serialVersionUID = 1L; [EOL] { [EOL] setDefaultFullDetail(true); [EOL] setArrayContentDetail(true); [EOL] setUseClassName(true); [EOL] setUseShortClassName(true); [EOL] setUseIdentityHashCode(false); [EOL] setContentStart("("); [EOL] setContentEnd(")"); [EOL] setFieldSeparator(", "); [EOL] setArrayStart("["); [EOL] setArrayEnd("]"); [EOL] } [EOL] @Override [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL] Class<? extends Annotation> annotationType = null; [EOL] for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL] if (Annotation.class.isAssignableFrom(iface)) { [EOL] final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL] annotationType = found; [EOL] break; [EOL] } [EOL] } [EOL] return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } [EOL] @Override [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL] if (value instanceof Annotation) { [EOL] value = AnnotationUtils.toString((Annotation) value); [EOL] } [EOL] super.appendDetail(buffer, fieldName, value); [EOL] } [EOL] };
protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL] if (value instanceof Annotation) { [EOL] value = AnnotationUtils.toString((Annotation) value); [EOL] } [EOL] super.appendDetail(buffer, fieldName, value); [EOL] } [EOL] public AnnotationUtils() {} [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL] Class<? extends Annotation> annotationType = null; [EOL] for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL] if (Annotation.class.isAssignableFrom(iface)) { [EOL] final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL] annotationType = found; [EOL] break; [EOL] } [EOL] } [EOL] return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL] if (value instanceof Annotation) { [EOL] value = AnnotationUtils.toString((Annotation) value); [EOL] } [EOL] super.appendDetail(buffer, fieldName, value); [EOL] } [EOL] ToStringStyle TO_STRING_STYLE = new ToStringStyle() { [EOL] private static final long serialVersionUID = 1L; [EOL] { [EOL] setDefaultFullDetail(true); [EOL] setArrayContentDetail(true); [EOL] setUseClassName(true); [EOL] setUseShortClassName(true); [EOL] setUseIdentityHashCode(false); [EOL] setContentStart("("); [EOL] setContentEnd(")"); [EOL] setFieldSeparator(", "); [EOL] setArrayStart("["); [EOL] setArrayEnd("]"); [EOL] } [EOL] protected String getShortClassName(final java.lang.Class<?> cls) { [EOL] Class<? extends Annotation> annotationType = null; [EOL] for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) { [EOL] if (Annotation.class.isAssignableFrom(iface)) { [EOL] final Class<? extends Annotation> found = (Class<? extends Annotation>) iface; [EOL] annotationType = found; [EOL] break; [EOL] } [EOL] } [EOL] return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString(); [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) { [EOL] if (value instanceof Annotation) { [EOL] value = AnnotationUtils.toString((Annotation) value); [EOL] } [EOL] super.appendDetail(buffer, fieldName, value); [EOL] } [EOL] };
public void testEquals_SameAnnotations_ShouldReturnTrue() { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = a1; [EOL] assertTrue(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testEquals_OneNullAnnotation_ShouldReturnFalse() { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = null; [EOL] assertFalse(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testEquals_DifferentTypes_ShouldReturnFalse() { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Deprecated.class); [EOL] assertFalse(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testEquals_SameTypeDifferentValues_ShouldReturnFalse() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenReturn(Override.class); [EOL] when(method.invoke(a2)).thenReturn(Deprecated.class); [EOL] assertFalse(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testEquals_SameTypeSameValues_ShouldReturnTrue() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenReturn(Override.class); [EOL] when(method.invoke(a2)).thenReturn(Override.class); [EOL] assertTrue(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testEquals_InvocationTargetException_ShouldReturnFalse() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenThrow(new InvocationTargetException(new Exception())); [EOL] assertFalse(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testEquals_IllegalAccessException_ShouldReturnFalse() throws Exception { [EOL] Annotation a1 = mock(Annotation.class); [EOL] Annotation a2 = mock(Annotation.class); [EOL] Method method = Override.class.getDeclaredMethod("annotationType"); [EOL] when(a1.annotationType()).thenReturn((Class) Override.class); [EOL] when(a2.annotationType()).thenReturn((Class) Override.class); [EOL] when(a1.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(a2.getClass().getDeclaredMethods()).thenReturn(new Method[]{method}); [EOL] when(method.invoke(a1)).thenThrow(new IllegalAccessException()); [EOL] assertFalse(AnnotationUtils.equals(a1, a2)); [EOL] }
public void testHashCodeWithNonNullAnnotation() throws Exception { [EOL] final Annotation a = new Annotation() { [EOL] @Override [EOL] public Class<? extends Annotation> annotationType() { [EOL] return this.getClass(); [EOL] } [EOL] }; [EOL] int result = AnnotationUtils.hashCode(a); [EOL] assertNotEquals(0, result); [EOL] }
public void testHashCodeWithNullValueInAnnotation() throws Exception { [EOL] final Annotation a = new Annotation() { [EOL] @Override [EOL] public Class<? extends Annotation> annotationType() { [EOL] return this.getClass(); [EOL] } [EOL] @Override [EOL] public boolean equals(Object obj) { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int hashCode() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public String toString() { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] AnnotationUtils.hashCode(a); [EOL] fail("Expected IllegalStateException due to null toString value"); [EOL] } catch (IllegalStateException ex) { [EOL] } [EOL] }
public void testHashCodeWithExceptionInAnnotationMethod() throws Exception { [EOL] final Annotation a = new Annotation() { [EOL] @Override [EOL] public Class<? extends Annotation> annotationType() { [EOL] return this.getClass(); [EOL] } [EOL] @Override [EOL] public boolean equals(Object obj) { [EOL] throw new RuntimeException("Forced exception for test"); [EOL] } [EOL] }; [EOL] try { [EOL] AnnotationUtils.hashCode(a); [EOL] fail("Expected RuntimeException due to forced exception in equals method"); [EOL] } catch (RuntimeException ex) { [EOL] } [EOL] }
public void testToStringWithNoMethods() { [EOL] @Retention(RetentionPolicy.RUNTIME) [EOL] @interface EmptyAnnotation {} [EOL] EmptyAnnotation emptyAnnotation = EmptyAnnotation.class.getAnnotation(EmptyAnnotation.class); [EOL] String result = AnnotationUtils.toString(emptyAnnotation); [EOL] assertEquals("@" + EmptyAnnotation.class.getName() + "()", result); [EOL] } [EOL] public void testToStringWithOneMethod() throws Exception { [EOL] @Retention(RetentionPolicy.RUNTIME) [EOL] @interface SingleMethodAnnotation { [EOL] String value() default "default"; [EOL] } [EOL] SingleMethodAnnotation singleMethodAnnotation = SingleMethodAnnotation.class.getAnnotation(SingleMethodAnnotation.class); [EOL] String result = AnnotationUtils.toString(singleMethodAnnotation); [EOL] assertEquals("@" + SingleMethodAnnotation.class.getName() + "(value=default)", result); [EOL] } [EOL] public void testToStringWithMultipleMethods() throws Exception { [EOL] @Retention(RetentionPolicy.RUNTIME) [EOL] @interface MultipleMethodsAnnotation { [EOL] String name(); [EOL] int count(); [EOL] } [EOL] MultipleMethodsAnnotation multipleMethodsAnnotation = MultipleMethodsAnnotation.class.getAnnotation(MultipleMethodsAnnotation.class); [EOL] String result = AnnotationUtils.toString(multipleMethodsAnnotation); [EOL] assertTrue(result.startsWith("@" + MultipleMethodsAnnotation.class.getName() + "(")); [EOL] assertTrue(result.contains("name=")); [EOL] assertTrue(result.contains("count=")); [EOL] } [EOL] public void testToStringWithInheritedMethods() throws Exception { [EOL] @Retention(RetentionPolicy.RUNTIME) [EOL] @interface ParentAnnotation { [EOL] String parentValue() default "parent"; [EOL] } [EOL] @Retention(RetentionPolicy.RUNTIME) [EOL] @ParentAnnotation [EOL] @interface ChildAnnotation { [EOL] String childValue() default "child"; [EOL] } [EOL] ChildAnnotation childAnnotation = ChildAnnotation.class.getAnnotation(ChildAnnotation.class); [EOL] String result = AnnotationUtils.toString(childAnnotation); [EOL] assertTrue(result.startsWith("@" + ChildAnnotation.class.getName() + "(")); [EOL] assertTrue(result.contains("childValue=child")); [EOL] assertTrue(result.contains("parentValue=parent")); [EOL] } [EOL] public void testToStringWithExceptionInMethod() { [EOL] @Retention(RetentionPolicy.RUNTIME) [EOL] @interface ExceptionAnnotation { [EOL] String throwException() default "throw"; [EOL] } [EOL] ExceptionAnnotation exceptionAnnotation = ExceptionAnnotation.class.getAnnotation(ExceptionAnnotation.class); [EOL] try { [EOL] AnnotationUtils.toString(exceptionAnnotation); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException ex) { [EOL] } [EOL] }
public void testHashMemberWithArrayValue() { [EOL] String name = "testArray"; [EOL] int[] value = new int[]{1, 2, 3}; [EOL] int result = AnnotationUtils.hashMember(name, value); [EOL] }
public void testHashMemberWithAnnotationValue() { [EOL] String name = "testAnnotation"; [EOL] Annotation value = new DummyAnnotation(); [EOL] int result = AnnotationUtils.hashMember(name, value); [EOL] }
public void testHashMemberWithNonArrayNonAnnotationValue() { [EOL] String name = "testString"; [EOL] String value = "test"; [EOL] int result = AnnotationUtils.hashMember(name, value); [EOL] }
private static int arrayMemberHash(final Class<?> componentType, final Object o) { [EOL] if (componentType.equals(Byte.TYPE)) { [EOL] return Arrays.hashCode((byte[]) o); [EOL] } [EOL] if (componentType.equals(Short.TYPE)) { [EOL] return Arrays.hashCode((short[]) o); [EOL] } [EOL] if (componentType.equals(Integer.TYPE)) { [EOL] return Arrays.hashCode((int[]) o); [EOL] } [EOL] if (componentType.equals(Character.TYPE)) { [EOL] return Arrays.hashCode((char[]) o); [EOL] } [EOL] if (componentType.equals(Long.TYPE)) { [EOL] return Arrays.hashCode((long[]) o); [EOL] } [EOL] if (componentType.equals(Float.TYPE)) { [EOL] return Arrays.hashCode((float[]) o); [EOL] } [EOL] if (componentType.equals(Double.TYPE)) { [EOL] return Arrays.hashCode((double[]) o); [EOL] } [EOL] if (componentType.equals(Boolean.TYPE)) { [EOL] return Arrays.hashCode((boolean[]) o); [EOL] } [EOL] return Arrays.hashCode((Object[]) o); [EOL] }
public void testFormatUTCWithValidPattern() { [EOL] long millis = System.currentTimeMillis(); [EOL] String pattern = "yyyy-MM-dd HH:mm:ss"; [EOL] String formattedDate = StringUtils.formatUTC(millis, pattern); [EOL] assertNotNull(formattedDate); [EOL] }
public void testFormatUTCWithNullPattern() { [EOL] long millis = System.currentTimeMillis(); [EOL] String formattedDate = StringUtils.formatUTC(millis, null); [EOL] assertNotNull(formattedDate); [EOL] }
public void testFormatUTCWithNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] String result = StringUtils.formatUTC(null, pattern); [EOL] assertNull(result); [EOL] }
public void testFormatUTCWithNonNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Date date = new Date(); [EOL] String result = StringUtils.formatUTC(date, pattern); [EOL] assertNotNull(result); [EOL] assertTrue(result.endsWith("Z")); // Assuming the pattern includes a Z for UTC timezone [EOL] }
public void testFormatUTCWithEmptyPattern() { [EOL] Date date = new Date(); [EOL] String result = StringUtils.formatUTC(date, ""); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFormatUTCWithNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String result = StringUtils.formatUTC(null, pattern, locale); [EOL] assertNull(result); [EOL] }
public void testFormatUTCWithNullPattern() { [EOL] Date date = new Date(); [EOL] Locale locale = Locale.US; [EOL] try { [EOL] StringUtils.formatUTC(date, null, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testFormatUTCWithNullLocale() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String result = StringUtils.formatUTC(date, pattern, null); [EOL] assertNotNull(result); [EOL] }
public void testFormatUTCWithValidDatePatternLocale() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String result = StringUtils.formatUTC(date, pattern, locale); [EOL] assertNotNull(result); [EOL] }
public void testFormat_withValidDateAndPattern() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(date, pattern); [EOL] assertNotNull(formattedDate); [EOL] assertTrue(formattedDate.matches("\\d{4}-\\d{2}-\\d{2}")); [EOL] }
public void testFormat_withNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(null, pattern); [EOL] assertNull(formattedDate); [EOL] }
public void testFormat_withNullPattern() { [EOL] Date date = new Date(); [EOL] String formattedDate = StringUtils.format(date, null); [EOL] assertNull(formattedDate); [EOL] }
public void testFormat_withNullDateAndPattern() { [EOL] String formattedDate = StringUtils.format(null, null); [EOL] assertNull(formattedDate); [EOL] }
public void testFormatWithNullCalendar() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formatted = StringUtils.format(null, pattern); [EOL] assertNull(formatted); [EOL] }
public void testFormatWithNonNullCalendarAndPattern() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formatted = StringUtils.format(calendar, pattern); [EOL] assertNotNull(formatted); [EOL] }
public void testFormat_withValidDatePatternLocale() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(date, pattern, locale); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern, locale); [EOL] assertEquals(sdf.format(date), formattedDate); [EOL] }
public void testFormat_withNullDate() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String formattedDate = StringUtils.format(null, pattern, locale); [EOL] assertNull(formattedDate); [EOL] }
public void testFormat_withNullPattern() { [EOL] Date date = new Date(); [EOL] Locale locale = Locale.US; [EOL] try { [EOL] StringUtils.format(date, null, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormat_withNullLocale() { [EOL] Date date = new Date(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String formattedDate = StringUtils.format(date, pattern, null); [EOL] assertNotNull(formattedDate); [EOL] SimpleDateFormat sdf = new SimpleDateFormat(pattern); [EOL] assertEquals(sdf.format(date), formattedDate); [EOL] }
public void testFormatWithCalendarPatternLocale_nullCalendar() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String result = StringUtils.format(null, pattern, locale); [EOL] assertNull(result); [EOL] }
public void testFormatWithCalendarPatternLocale_validCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String result = StringUtils.format(calendar, pattern, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("\\d{4}-\\d{2}-\\d{2}")); [EOL] }
public void testFormatWithCalendarPatternLocale_nullPattern() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] Locale locale = Locale.US; [EOL] String result = StringUtils.format(calendar, null, locale); [EOL] assertNull(result); [EOL] }
public void testFormatWithCalendarPatternLocale_nullLocale() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String result = StringUtils.format(calendar, pattern, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("\\d{4}-\\d{2}-\\d{2}")); [EOL] }
public void testFormatWithNullCalendar() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] String result = StringUtils.format(null, pattern, timeZone, locale); [EOL] assertNull(result); [EOL] }
public void testFormatWithNullPattern() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] try { [EOL] StringUtils.format(calendar, null, timeZone, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormatWithNullTimeZone() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.getDefault(); [EOL] String result = StringUtils.format(calendar, pattern, null, locale); [EOL] assertNotNull(result); [EOL] }
public void testFormatWithNullLocale() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] String result = StringUtils.format(calendar, pattern, timeZone, null); [EOL] assertNotNull(result); [EOL] }
public void testFormatWithAllNonNull() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] String result = StringUtils.format(calendar, pattern, timeZone, locale); [EOL] assertNotNull(result); [EOL] }
public void testFormatWithDate() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Date date = new Date(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] StringBuffer result = fdf.format(date, buffer, pos); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testFormatWithCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] StringBuffer result = fdf.format(calendar, buffer, pos); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testFormatWithLong() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Long timestamp = System.currentTimeMillis(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] StringBuffer result = fdf.format(timestamp, buffer, pos); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testFormatWithUnknownObject() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Object unknownObject = new Object(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] try { [EOL] fdf.format(unknownObject, buffer, pos); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Unknown class: " + unknownObject.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testFormatWithNull() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] try { [EOL] fdf.format(null, buffer, pos); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Unknown class: <null>", e.getMessage()); [EOL] } [EOL] }
public void testFormatWithNullDate() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] try { [EOL] fdf.format((Date) null, buf); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFormatWithNonNullDate() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] Date date = new Date(); [EOL] StringBuffer result = fdf.format(date, buf); [EOL] assertNotNull("Buffer should not be null", result); [EOL] assertTrue("Buffer should contain formatted date", result.length() > 0); [EOL] }
public void testGetPattern() { [EOL] PatternFormatter formatter = new PatternFormatter("TestPattern"); [EOL] String pattern = formatter.getPattern(); [EOL] assertEquals("TestPattern", pattern); [EOL] }
public void testToString() { [EOL] FastDatePrinter printer = new FastDatePrinter("yyyy-MM-dd", TimeZone.getDefault(), Locale.getDefault()); [EOL] String expected = "FastDatePrinter[yyyy-MM-dd," + Locale.getDefault() + "," + TimeZone.getDefault().getID() + "]"; [EOL] String actual = printer.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testTwoDigitMonthField() { [EOL] new TwoDigitMonthField(); [EOL] }
public void testTimeZoneNumberRule_ColonTrue() { [EOL] TimeZoneNumberRule rule = new TimeZoneNumberRule(true); [EOL] assertTrue("Colon should be true when passed true", rule.mColon); [EOL] }
public void testTimeZoneNumberRule_ColonFalse() { [EOL] TimeZoneNumberRule rule = new TimeZoneNumberRule(false); [EOL] assertFalse("Colon should be false when passed false", rule.mColon); [EOL] }
public void testAppend_BothObjectsNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(null, null); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_SameObject() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object obj = new Object(); [EOL] builder.append(obj, obj); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentNonArrayObjects() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_OneObjectNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] builder.append(lhs, null); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_NonArrayDifferentClasses() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object lhs = new Object(); [EOL] Object rhs = new String("Test"); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_LongArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] long[] lhs = {1L, 2L, 3L}; [EOL] long[] rhs = {1L, 2L, 3L}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_IntArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = {1, 2, 3}; [EOL] int[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ShortArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] short[] lhs = {1, 2, 3}; [EOL] short[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_CharArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = {'a', 'b', 'c'}; [EOL] char[] rhs = {'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ByteArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] byte[] lhs = {1, 2, 3}; [EOL] byte[] rhs = {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DoubleArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] double[] lhs = {1.0, 2.0, 3.0}; [EOL] double[] rhs = {1.0, 2.0, 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_FloatArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_BooleanArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_ObjectArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = {1, "two", 3.0}; [EOL] Object[] rhs = {1, "two", 3.0}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_DifferentArrayTypes() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] int[] lhs = {1, 2, 3}; [EOL] long[] rhs = {1L, 2L, 3L}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_Arrays_BothNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_Arrays_SameArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] array = new Object[] {1, 2, 3}; [EOL] builder.append(array, array); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_Arrays_DifferentLength() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_Arrays_DifferentElements() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 4}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_Arrays_SameElements() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_Arrays_OneNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_Arrays_AlreadyNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithEqualArrays() { [EOL] long[] array1 = new long[] {1L, 2L, 3L}; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithDifferentArrays() { [EOL] long[] array1 = new long[] {1L, 2L, 3L}; [EOL] long[] array2 = new long[] {4L, 5L, 6L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithDifferentLengths() { [EOL] long[] array1 = new long[] {1L, 2L}; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithNullAndNonNull() { [EOL] long[] array1 = null; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithBothNull() { [EOL] long[] array1 = null; [EOL] long[] array2 = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array1, array2); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendLongArraysWhenEqualsIsAlreadyFalse() { [EOL] long[] array1 = new long[] {1L, 2L, 3L}; [EOL] long[] array2 = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(array1, array2); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendLongArraysWithSameReference() { [EOL] long[] array = new long[] {1L, 2L, 3L}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(array, array); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendFloatArraysWithEqualArrays() { [EOL] float[] lhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendFloatArraysFirstNullSecondNotNull() { [EOL] float[] lhs = null; [EOL] float[] rhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysFirstNotNullSecondNull() { [EOL] float[] lhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysDifferentLengths() { [EOL] float[] lhs = new float[] {1.0f, 2.0f}; [EOL] float[] rhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendFloatArraysSameArray() { [EOL] float[] lhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, lhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppendFloatArraysIsEqualsFalse() { [EOL] float[] lhs = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = new float[] {4.0f, 5.0f, 6.0f}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppendBooleanArraysWithEqualArrays() { [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysWithDifferentArrays() { [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {false, true, false}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysWithDifferentLengths() { [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {true, false, true}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysWithNullLhs() { [EOL] boolean[] lhs = null; [EOL] boolean[] rhs = {true, false, true}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysWithNullRhs() { [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysWithBothNulls() { [EOL] boolean[] lhs = null; [EOL] boolean[] rhs = null; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysWithIsEqualsFalse() { [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppendBooleanArraysSameArray() { [EOL] boolean[] lhs = {true, false, true}; [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(lhs, lhs); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testSplitMatcher() { [EOL] StrMatcher matcher = StrMatcher.splitMatcher(); [EOL] assertNotNull("splitMatcher() should not return null", matcher); [EOL] assertSame("splitMatcher() should always return the same StrMatcher", StrMatcher.splitMatcher(), matcher); [EOL] }
public void testTrimMatcher() { [EOL] StrMatcher matcher = StrMatcher.trimMatcher(); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher instanceof StrMatcher.TrimMatcher); [EOL] }
public void testDoubleQuoteMatcher() { [EOL] StrMatcher matcher = StrMatcher.doubleQuoteMatcher(); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher instanceof StrMatcher.CharMatcher); [EOL] assertEquals('"', ((StrMatcher.CharMatcher) matcher).getChar()); [EOL] }
public void testQuoteMatcher() { [EOL] StrMatcher matcher = StrMatcher.quoteMatcher(); [EOL] assertNotNull("The quoteMatcher() should not return null", matcher); [EOL] assertTrue("The quoteMatcher() should return the same instance on multiple calls", [EOL] matcher == StrMatcher.quoteMatcher()); [EOL] }
public void testNoneMatcher() { [EOL] StrMatcher matcher = StrMatcher.noneMatcher(); [EOL] assertNotNull("The matcher should not be null", matcher); [EOL] assertTrue("The matcher should be a none matcher instance", matcher instanceof StrMatcher.NoneMatcher); [EOL] }
public void testCharMatcher() { [EOL] char testChar = 'a'; [EOL] StrMatcher matcher = StrMatcher.charMatcher(testChar); [EOL] assertTrue(matcher.isMatch(new char[] {testChar}, 0, 0, 1)); [EOL] assertFalse(matcher.isMatch(new char[] {'b'}, 0, 0, 1)); [EOL] }
public void testCharSetMatcher_NullOrEmpty() { [EOL] StrMatcher matcher = StrMatcher.charSetMatcher(null); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] matcher = StrMatcher.charSetMatcher(new char[0]); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] }
public void testCharSetMatcher_SingleChar() { [EOL] char[] singleChar = new char[]{'a'}; [EOL] StrMatcher matcher = StrMatcher.charSetMatcher(singleChar); [EOL] assertTrue(matcher instanceof StrMatcher.CharMatcher); [EOL] }
public void testCharSetMatcher_MultipleChars() { [EOL] char[] multipleChars = new char[]{'a', 'b', 'c'}; [EOL] StrMatcher matcher = StrMatcher.charSetMatcher(multipleChars); [EOL] assertTrue(matcher instanceof StrMatcher.CharSetMatcher); [EOL] }
public void testCharSetMatcher_withEmptyString() { [EOL] StrMatcher matcher = StrMatcher.charSetMatcher(""); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] } [EOL] public void testCharSetMatcher_withNullString() { [EOL] StrMatcher matcher = StrMatcher.charSetMatcher(null); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] } [EOL] public void testCharSetMatcher_withSingleCharacterString() { [EOL] StrMatcher matcher = StrMatcher.charSetMatcher("a"); [EOL] assertTrue(matcher instanceof StrMatcher.CharMatcher); [EOL] } [EOL] public void testCharSetMatcher_withMultipleCharacterString() { [EOL] StrMatcher matcher = StrMatcher.charSetMatcher("abc"); [EOL] assertTrue(matcher instanceof StrMatcher.CharSetMatcher); [EOL] }
public void testStringMatcherWithEmptyString() { [EOL] StrMatcher matcher = StrMatcher.stringMatcher(""); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] } [EOL] public void testStringMatcherWithNullString() { [EOL] StrMatcher matcher = StrMatcher.stringMatcher(null); [EOL] assertSame(StrMatcher.NONE_MATCHER, matcher); [EOL] } [EOL] public void testStringMatcherWithNonEmptyString() { [EOL] String testStr = "test"; [EOL] StrMatcher matcher = StrMatcher.stringMatcher(testStr); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher instanceof StrMatcher.StringMatcher); [EOL] }
public class StrMatcherSubclass extends StrMatcher { [EOL] public StrMatcherSubclass() { [EOL] super(); [EOL] } [EOL] } [EOL] public void testStrMatcherConstructor() { [EOL] StrMatcherSubclass matcher = new StrMatcherSubclass(); [EOL] assertNotNull(matcher); [EOL] }
public int isMatch(final char[] buffer, final int pos) { [EOL] return isMatch(buffer, pos, 0, buffer.length); [EOL] }
public void testCharSetMatcher_withEmptyCharArray() { [EOL] char[] chars = new char[0]; [EOL] CharSetMatcher matcher = new CharSetMatcher(chars); [EOL] assertNotNull("Matcher must not be null", matcher); [EOL] assertEquals("Character array should be empty", 0, matcher.chars.length); [EOL] }
public void testCharSetMatcher_withSingleChar() { [EOL] char[] chars = new char[]{'a'}; [EOL] CharSetMatcher matcher = new CharSetMatcher(chars); [EOL] assertNotNull("Matcher must not be null", matcher); [EOL] assertEquals("Character array should have one element", 1, matcher.chars.length); [EOL] assertEquals("Character should be 'a'", 'a', matcher.chars[0]); [EOL] }
public void testCharSetMatcher_withMultipleChars() { [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] CharSetMatcher matcher = new CharSetMatcher(chars); [EOL] assertNotNull("Matcher must not be null", matcher); [EOL] assertEquals("Character array should have three elements", 3, matcher.chars.length); [EOL] assertArrayEquals("Character array should be sorted", new char[]{'a', 'b', 'c'}, matcher.chars); [EOL] }
public void testCharSetMatcher_withUnsortedChars() { [EOL] char[] chars = new char[]{'b', 'a', 'c'}; [EOL] CharSetMatcher matcher = new CharSetMatcher(chars); [EOL] assertNotNull("Matcher must not be null", matcher); [EOL] assertEquals("Character array should have three elements", 3, matcher.chars.length); [EOL] assertArrayEquals("Character array should be sorted", new char[]{'a', 'b', 'c'}, matcher.chars); [EOL] }
public void testCharSetMatcher_withDuplicateChars() { [EOL] char[] chars = new char[]{'a', 'b', 'a'}; [EOL] CharSetMatcher matcher = new CharSetMatcher(chars); [EOL] assertNotNull("Matcher must not be null", matcher); [EOL] assertEquals("Character array should have three elements", 3, matcher.chars.length); [EOL] assertArrayEquals("Character array should be sorted with duplicates", new char[]{'a', 'a', 'b'}, matcher.chars); [EOL] }
public void testIsMatch_CharFound() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd'}; [EOL] char[] chars = new char[] {'b', 'c'}; [EOL] int pos = 1; // 'b' is at buffer[1] [EOL] int bufferStart = 0; [EOL] int bufferEnd = buffer.length; [EOL] int expected = 1; // 'b' is in chars, so should return 1 [EOL] int actual = isMatch(chars, buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsMatch_CharNotFound() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd'}; [EOL] char[] chars = new char[] {'x', 'y'}; [EOL] int pos = 1; // 'b' is at buffer[1] [EOL] int bufferStart = 0; [EOL] int bufferEnd = buffer.length; [EOL] int expected = 0; // 'b' is not in chars, so should return 0 [EOL] int actual = isMatch(chars, buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsMatch_AtBufferEnd() { [EOL] char[] buffer = new char[] {'a', 'b', 'c', 'd'}; [EOL] char[] chars = new char[] {'d'}; [EOL] int pos = 3; // 'd' is at buffer[3], which is the end [EOL] int bufferStart = 0; [EOL] int bufferEnd = buffer.length; [EOL] int expected = 1; // 'd' is in chars, so should return 1 [EOL] int actual = isMatch(chars, buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(expected, actual); [EOL] }
public void testCharMatcherWithValidChar() { [EOL] char testChar = 'a'; [EOL] CharMatcher matcher = new CharMatcher(testChar); [EOL] assertEquals(testChar, matcher.ch); [EOL] }
public void testCharMatcherWithBoundaryChar() { [EOL] char testChar = Character.MIN_VALUE; [EOL] CharMatcher matcher = new CharMatcher(testChar); [EOL] assertEquals(testChar, matcher.ch); [EOL] }
public void testCharMatcherWithAnotherBoundaryChar() { [EOL] char testChar = Character.MAX_VALUE; [EOL] CharMatcher matcher = new CharMatcher(testChar); [EOL] assertEquals(testChar, matcher.ch); [EOL] }
public void testStringMatcherWithNull() { [EOL] StringMatcher matcher = new StringMatcher(null); [EOL] assertNull("Expected chars to be null", matcher.chars); [EOL] }
public void testStringMatcherWithEmptyString() { [EOL] StringMatcher matcher = new StringMatcher(""); [EOL] assertArrayEquals("Expected empty char array", new char[0], matcher.chars); [EOL] }
public void testStringMatcherWithNonEmptyString() { [EOL] String str = "test"; [EOL] StringMatcher matcher = new StringMatcher(str); [EOL] assertArrayEquals("Expected char array to match input string", str.toCharArray(), matcher.chars); [EOL] }
public void testIsMatch_BufferTooShort_ReturnsZero() { [EOL] char[] buffer = {'a', 'b', 'c'}; [EOL] char[] chars = {'x', 'y', 'z'}; [EOL] int pos = 1; [EOL] int bufferStart = 0; [EOL] int bufferEnd = 2; [EOL] int result = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(0, result); [EOL] }
public void testIsMatch_MatchAtPosition_ReturnsLength() { [EOL] char[] buffer = {'a', 'b', 'c'}; [EOL] char[] chars = {'b', 'c'}; [EOL] int pos = 1; [EOL] int bufferStart = 0; [EOL] int bufferEnd = 3; [EOL] int result = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(chars.length, result); [EOL] }
public void testIsMatch_NoMatchAtPosition_ReturnsZero() { [EOL] char[] buffer = {'a', 'b', 'c'}; [EOL] char[] chars = {'x', 'y'}; [EOL] int pos = 1; [EOL] int bufferStart = 0; [EOL] int bufferEnd = 3; [EOL] int result = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(0, result); [EOL] }
public void testIsMatch_MatchAtStart_ReturnsLength() { [EOL] char[] buffer = {'a', 'b', 'c'}; [EOL] char[] chars = {'a', 'b'}; [EOL] int pos = 0; [EOL] int bufferStart = 0; [EOL] int bufferEnd = 3; [EOL] int result = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(chars.length, result); [EOL] }
public void testIsMatch_MatchAtEnd_ReturnsZero() { [EOL] char[] buffer = {'a', 'b', 'c'}; [EOL] char[] chars = {'b', 'c', 'd'}; [EOL] int pos = 1; [EOL] int bufferStart = 0; [EOL] int bufferEnd = 3; [EOL] int result = isMatch(buffer, pos, bufferStart, bufferEnd); [EOL] assertEquals(0, result); [EOL] }
public void testIsMatch_AllZeros() { [EOL] CharMatcher matcher = new CharMatcher(); [EOL] char[] buffer = new char[] {'a', 'b', 'c'}; [EOL] int result = matcher.isMatch(buffer, 0, 0, buffer.length); [EOL] assertEquals(0, result); [EOL] }
public void testIsMatch_SpaceCharacter() { [EOL] char[] buffer = new char[] {' ', 'a', 'b', 'c'}; [EOL] int pos = 0; [EOL] int result = isMatch(buffer, pos, 0, buffer.length); [EOL] assertEquals(1, result); [EOL] }
public void testIsMatch_NonSpaceCharacter() { [EOL] char[] buffer = new char[] {'a', ' ', 'b', 'c'}; [EOL] int pos = 0; [EOL] int result = isMatch(buffer, pos, 0, buffer.length); [EOL] assertEquals(0, result); [EOL] }
public void testRandomStringUtilsConstructor() { [EOL] new RandomStringUtils(); [EOL] }
public void testRandomWithZeroCount() { [EOL] String result = StringUtils.random(0); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testRandomWithPositiveCount() { [EOL] String result = StringUtils.random(5); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] }
public void testRandomWithLettersOnly() { [EOL] String result = RandomStringUtils.random(5, true, false); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("^[a-zA-Z]+$")); [EOL] }
public void testRandomWithNumbersOnly() { [EOL] String result = RandomStringUtils.random(5, false, true); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("^[0-9]+$")); [EOL] }
public void testRandomWithLettersAndNumbers() { [EOL] String result = RandomStringUtils.random(5, true, true); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("^[a-zA-Z0-9]+$")); [EOL] }
public void testRandomWithNoLettersNoNumbers() { [EOL] String result = RandomStringUtils.random(5, false, false); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("^\\s*$")); [EOL] }
public void testRandomWithLettersOnly() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, false); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[a-zA-Z]+")); [EOL] }
public void testRandomWithNumbersOnly() { [EOL] String result = RandomStringUtils.random(5, 0, 0, false, true); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[0-9]+")); [EOL] }
public void testRandomWithLettersAndNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, true); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[a-zA-Z0-9]+")); [EOL] }
public void testRandomWithNoLettersOrNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, false, false); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[\\x00-\\x7F]+")); [EOL] }
public void testRandomWithSpecificRange() { [EOL] int start = 'a'; [EOL] int end = 'z' + 1; // end is exclusive [EOL] String result = RandomStringUtils.random(5, start, end, true, false); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[a-z]+")); [EOL] }
public void testRandomWithZeroCount() { [EOL] String result = RandomStringUtils.random(0, 0, 0, true, true); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length()); [EOL] }
public void testRandomStringLengthZero() { [EOL] String result = RandomStringUtils.random(0, 0, 0, false, false, null, new Random()); [EOL] assertEquals("", result); [EOL] }
public void testRandomStringLengthNegative() { [EOL] try { [EOL] RandomStringUtils.random(-1, 0, 0, false, false, null, new Random()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringCharsArrayEmpty() { [EOL] try { [EOL] RandomStringUtils.random(5, 0, 0, false, false, new char[]{}, new Random()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringInvalidRange() { [EOL] try { [EOL] RandomStringUtils.random(5, 10, 5, false, false, null, new Random()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringLettersAndNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() == 5); [EOL] assertTrue(result.matches("[a-zA-Z0-9]+")); [EOL] }
public void testRandomStringLettersOnly() { [EOL] String result = RandomStringUtils.random(5, 'a', 'z', true, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() == 5); [EOL] assertTrue(result.matches("[a-zA-Z]+")); [EOL] }
public void testRandomStringNumbersOnly() { [EOL] String result = RandomStringUtils.random(5, '0', '9', false, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() == 5); [EOL] assertTrue(result.matches("[0-9]+")); [EOL] }
public void testRandomStringCustomCharsArray() { [EOL] char[] chars = new char[]{'a', 'b', 'c', '1', '2', '3'}; [EOL] String result = RandomStringUtils.random(5, 0, chars.length, false, false, chars, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() == 5); [EOL] assertTrue(result.matches("[abc123]+")); [EOL] }
public void testRandomStringCustomCharsArrayWithLettersAndNumbers() { [EOL] char[] chars = new char[]{'a', 'b', 'c', '1', '2', '3'}; [EOL] String result = RandomStringUtils.random(5, 0, chars.length, true, true, chars, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() == 5); [EOL] assertTrue(result.matches("[abc123]+")); [EOL] }
public void testMutableByteConstructor() { [EOL] final byte testValue = 0x01; [EOL] MutableByte mutByte = new MutableByte(testValue); [EOL] assertEquals("Constructor failed to set value", testValue, mutByte.byteValue()); [EOL] }
public void testHashCode() { [EOL] MyClass instance = new MyClass(123); [EOL] int expected = 123; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToString_whenValueIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setValue("TestValue"); [EOL] String result = instance.toString(); [EOL] assertEquals("TestValue", result); [EOL] } [EOL] public void testToString_whenValueIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setValue(null); [EOL] String result = instance.toString(); [EOL] assertEquals("null", result); [EOL] }
public void testGetEnumMapWithValidEnumClass() { [EOL] Map<String, Day> enumMap = EnumUtils.getEnumMap(Day.class); [EOL] assertNotNull(enumMap); [EOL] assertEquals(7, enumMap.size()); [EOL] assertTrue(enumMap.containsKey("MONDAY")); [EOL] assertTrue(enumMap.containsValue(Day.MONDAY)); [EOL] } [EOL] public void testGetEnumMapWithNullEnumClass() { [EOL] try { [EOL] Map<String, Day> enumMap = EnumUtils.getEnumMap(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testIsValidEnumWithNullName() { [EOL] boolean result = EnumUtils.isValidEnum(SomeEnum.class, null); [EOL] assertFalse(result); [EOL] }
public void testIsValidEnumWithValidName() { [EOL] boolean result = EnumUtils.isValidEnum(SomeEnum.class, "ENUM_VALUE"); [EOL] assertTrue(result); [EOL] }
public void testIsValidEnumWithInvalidName() { [EOL] boolean result = EnumUtils.isValidEnum(SomeEnum.class, "INVALID_ENUM_VALUE"); [EOL] assertFalse(result); [EOL] }
public void testGetInstanceWithNullPattern() { [EOL] try { [EOL] getInstance(null, TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("pattern must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetInstanceWithNullTimeZone() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] F result = getInstance(pattern, null, Locale.getDefault()); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithNullLocale() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] F result = getInstance(pattern, TimeZone.getDefault(), null); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithAllNonNull() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] final TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] final Locale locale = Locale.CANADA; [EOL] F result = getInstance(pattern, timeZone, locale); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithCachedInstance() { [EOL] final String pattern = "yyyy-MM-dd"; [EOL] final TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] final Locale locale = Locale.CANADA; [EOL] F firstCallResult = getInstance(pattern, timeZone, locale); [EOL] F secondCallResult = getInstance(pattern, timeZone, locale); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
public void testOf_withNonNullValues() { [EOL] String left = "left"; [EOL] String middle = "middle"; [EOL] String right = "right"; [EOL] Triple<String, String, String> result = Triple.of(left, middle, right); [EOL] assertNotNull(result); [EOL] assertEquals(left, result.getLeft()); [EOL] assertEquals(middle, result.getMiddle()); [EOL] assertEquals(right, result.getRight()); [EOL] }
public void testOf_withNullValues() { [EOL] Triple<Object, Object, Object> result = Triple.of(null, null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getLeft()); [EOL] assertNull(result.getMiddle()); [EOL] assertNull(result.getRight()); [EOL] }
public void testCompareTo_EqualTriples() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test", true); [EOL] int result = triple1.compareTo(triple2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LeftGreater() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(2, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test", true); [EOL] int result = triple1.compareTo(triple2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_LeftLess() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(2, "test", true); [EOL] int result = triple1.compareTo(triple2); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_MiddleGreater() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test2", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test1", true); [EOL] int result = triple1.compareTo(triple2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_MiddleLess() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test1", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test2", true); [EOL] int result = triple1.compareTo(triple2); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_RightGreater() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", false); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test", true); [EOL] int result = triple1.compareTo(triple2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_RightLess() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test", false); [EOL] int result = triple1.compareTo(triple2); [EOL] assertTrue(result < 0); [EOL] }
public void testEquals_SameObject() { [EOL] Triple<Integer, String, Boolean> triple = Triple.of(1, "test", true); [EOL] assertTrue(triple.equals(triple)); [EOL] }
public void testEquals_DifferentClass() { [EOL] Triple<Integer, String, Boolean> triple = Triple.of(1, "test", true); [EOL] assertFalse(triple.equals(new Object())); [EOL] }
public void testEquals_EqualTriple() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test", true); [EOL] assertTrue(triple1.equals(triple2)); [EOL] }
public void testEquals_NotEqualTriple_Left() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(2, "test", true); [EOL] assertFalse(triple1.equals(triple2)); [EOL] }
public void testEquals_NotEqualTriple_Middle() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "fail", true); [EOL] assertFalse(triple1.equals(triple2)); [EOL] }
public void testEquals_NotEqualTriple_Right() { [EOL] Triple<Integer, String, Boolean> triple1 = Triple.of(1, "test", true); [EOL] Triple<Integer, String, Boolean> triple2 = Triple.of(1, "test", false); [EOL] assertFalse(triple1.equals(triple2)); [EOL] }
public void testToStringWithValidFormat() { [EOL] Triple<String, String, String> triple = new ImmutableTriple<>("left", "middle", "right"); [EOL] String result = triple.toString("%s %s %s"); [EOL] assertEquals("left middle right", result); [EOL] }
public void testToStringWithNullFormat() { [EOL] Triple<String, String, String> triple = new ImmutableTriple<>("left", "middle", "right"); [EOL] try { [EOL] triple.toString(null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testToStringWithInvalidFormat() { [EOL] Triple<String, String, String> triple = new ImmutableTriple<>("left", "middle", "right"); [EOL] try { [EOL] triple.toString("%s %s"); [EOL] fail("Expected IllegalFormatException to be thrown"); [EOL] } catch (IllegalFormatException e) { [EOL] } [EOL] }
public void testReflectionToStringWithNullObject() { [EOL] String result = StringUtils.reflectionToString(null); [EOL] assertNull(result); [EOL] }
public void testReflectionToStringWithNonNullObject() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.reflectionToString(obj); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(obj.getClass().getName() + "@")); [EOL] }
public void testAppendChar() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] char testChar = 'a'; [EOL] tsb.append(testChar); [EOL] assertEquals("a", tsb.toString()); [EOL] }
public void testAppendCharNullText() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] char testChar = '\0'; [EOL] tsb.append(testChar); [EOL] assertEquals("\0", tsb.toString()); [EOL] }
public void testAppendCharArray_Null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] char[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "{}"); [EOL] }
public void testAppendCharArray_Empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] char[] array = new char[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "{}"); [EOL] }
public void testAppendCharArray_NonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "{abc}"); [EOL] }
public void testAppendFloat() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] float testValue = 123.456f; [EOL] tsb.append(testValue); [EOL] assertEquals(tsb.toString(), this.toString() + testValue); [EOL] }
public void testAppendChar() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] char testChar = 'a'; [EOL] tsb.append("Field", testChar); [EOL] assertEquals("Field=<a>", tsb.toString()); [EOL] }
public void testAppendCharNullFieldName() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] char testChar = 'a'; [EOL] tsb.append(null, testChar); [EOL] assertEquals("<a>", tsb.toString()); [EOL] }
public void testAppendStringFloat() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append("Field", 10.0f); [EOL] assertNotNull(tsb.toString()); [EOL] }
public void testAppendStringFloatWithNullFieldName() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] tsb.append(null, 10.0f); [EOL] assertNotNull(tsb.toString()); [EOL] }
public void testAppendSuperWithNonNullSuperToString() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] String superToString = "SuperToString"; [EOL] tsb.appendSuper(superToString); [EOL] assertEquals(tsb.toString(), superToString); [EOL] }
public void testAppendSuperWithNullSuperToString() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this, ToStringStyle.DEFAULT_STYLE); [EOL] tsb.appendSuper(null); [EOL] assertEquals(tsb.toString(), ""); [EOL] }
public void testGetStyle() { [EOL] ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE); [EOL] ToStringStyle style = ToStringBuilder.getDefaultStyle(); [EOL] assertNotNull(style); [EOL] }
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL] if (str == null || parsePatterns == null) { [EOL] throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL] } [EOL] SimpleDateFormat parser; [EOL] if (locale == null) { [EOL] parser = new SimpleDateFormat(); [EOL] } else { [EOL] parser = new SimpleDateFormat("", locale); [EOL] } [EOL] parser.setLenient(lenient); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] for (final String parsePattern : parsePatterns) { [EOL] String pattern = parsePattern; [EOL] if (parsePattern.endsWith("ZZ")) { [EOL] pattern = pattern.substring(0, pattern.length() - 1); [EOL] } [EOL] parser.applyPattern(pattern); [EOL] pos.setIndex(0); [EOL] String str2 = str; [EOL] if (parsePattern.endsWith("ZZ")) { [EOL] str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL] } [EOL] final Date date = parser.parse(str2, pos); [EOL] if (date != null && pos.getIndex() == str2.length()) { [EOL] return date; [EOL] } [EOL] } [EOL] throw new ParseException("Unable to parse the date: " + str, -1); [EOL] }
public static Date addMonths(final Date date, final int amount) { [EOL] return add(date, Calendar.MONTH, amount); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addDays(final Date date, final int amount) { [EOL] return add(date, Calendar.DAY_OF_MONTH, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=1000; long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; int SEMI_MONTH=1001; int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }}
public void testSetMonths_NullDate() { [EOL] try { [EOL] Date result = DateUtils.setMonths(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testSetMonths() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, 5); // June (month is 0-based) [EOL] Date date = calendar.getTime(); [EOL] Date modifiedDate = DateUtils.setMonths(date, 1); // Set to February [EOL] calendar.setTime(modifiedDate); [EOL] assertEquals("Set month to February", 1, calendar.get(Calendar.MONTH)); [EOL] }

public static Date setDays(final Date date, final int amount) { [EOL] return set(date, Calendar.DAY_OF_MONTH, amount); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };
public static Date setSeconds(final Date date, final int amount) { [EOL] return set(date, Calendar.SECOND, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=1000; long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; int SEMI_MONTH=1001; int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }}
private static Date set(final Date date, final int calendarField, final int amount) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar c = Calendar.getInstance(); [EOL] c.setLenient(false); [EOL] c.setTime(date); [EOL] c.set(calendarField, amount); [EOL] return c.getTime(); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public void testTruncateDateWithNullDate() { [EOL] try { [EOL] DateUtils.truncate(null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testTruncateDateWithValidDate() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.JANUARY, 15, 10, 20, 30); [EOL] cal.set(Calendar.MILLISECOND, 123); [EOL] Date date = cal.getTime(); [EOL] Date truncatedDate = DateUtils.truncate(date, Calendar.DAY_OF_MONTH); [EOL] cal.set(Calendar.HOUR_OF_DAY, 0); [EOL] cal.set(Calendar.MINUTE, 0); [EOL] cal.set(Calendar.SECOND, 0); [EOL] cal.set(Calendar.MILLISECOND, 0); [EOL] assertEquals(cal.getTime(), truncatedDate); [EOL] } [EOL] public void testTruncateDateWithDifferentFields() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.JANUARY, 15, 10, 20, 30); [EOL] cal.set(Calendar.MILLISECOND, 123); [EOL] Date date = cal.getTime(); [EOL] Date truncatedHour = DateUtils.truncate(date, Calendar.HOUR); [EOL] cal.set(Calendar.MINUTE, 0); [EOL] cal.set(Calendar.SECOND, 0); [EOL] cal.set(Calendar.MILLISECOND, 0); [EOL] assertEquals(cal.getTime(), truncatedHour); [EOL] Date truncatedMinute = DateUtils.truncate(date, Calendar.MINUTE); [EOL] cal.set(Calendar.HOUR_OF_DAY, 10); [EOL] cal.set(Calendar.SECOND, 0); [EOL] cal.set(Calendar.MILLISECOND, 0); [EOL] assertEquals(cal.getTime(), truncatedMinute); [EOL] Date truncatedSecond = DateUtils.truncate(date, Calendar.SECOND); [EOL] cal.set(Calendar.MINUTE, 20); [EOL] cal.set(Calendar.MILLISECOND, 0); [EOL] assertEquals(cal.getTime(), truncatedSecond); [EOL] }

public static Calendar truncate(final Calendar date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar truncated = (Calendar) date.clone(); [EOL] modify(truncated, field, MODIFY_TRUNCATE); [EOL] return truncated; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public void testTruncateWithNullDate() { [EOL] try { [EOL] DateUtils.truncate(null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testTruncateWithDateInstance() { [EOL] Date date = new Date(); [EOL] Date truncatedDate = DateUtils.truncate(date, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Truncated date should not be null", truncatedDate); [EOL] } [EOL] public void testTruncateWithCalendarInstance() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] Date truncatedDate = DateUtils.truncate(calendar, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Truncated date should not be null", truncatedDate); [EOL] } [EOL] public void testTruncateWithUnsupportedType() { [EOL] try { [EOL] Object unsupportedType = new Object(); [EOL] DateUtils.truncate(unsupportedType, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException cce) { [EOL] } [EOL] }
private static void modify(final Calendar val, final int field, final int modType) { [EOL] if (val.get(Calendar.YEAR) > 280000000) { [EOL] throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL] } [EOL] if (field == Calendar.MILLISECOND) { [EOL] return; [EOL] } [EOL] final Date date = val.getTime(); [EOL] long time = date.getTime(); [EOL] boolean done = false; [EOL] final int millisecs = val.get(Calendar.MILLISECOND); [EOL] if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL] time = time - millisecs; [EOL] } [EOL] if (field == Calendar.SECOND) { [EOL] done = true; [EOL] } [EOL] final int seconds = val.get(Calendar.SECOND); [EOL] if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL] time = time - (seconds * 1000L); [EOL] } [EOL] if (field == Calendar.MINUTE) { [EOL] done = true; [EOL] } [EOL] final int minutes = val.get(Calendar.MINUTE); [EOL] if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL] time = time - (minutes * 60000L); [EOL] } [EOL] if (date.getTime() != time) { [EOL] date.setTime(time); [EOL] val.setTime(date); [EOL] } [EOL] boolean roundUp = false; [EOL] for (final int[] aField : fields) { [EOL] for (final int element : aField) { [EOL] if (element == field) { [EOL] if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL] if (field == DateUtils.SEMI_MONTH) { [EOL] if (val.get(Calendar.DATE) == 1) { [EOL] val.add(Calendar.DATE, 15); [EOL] } else { [EOL] val.add(Calendar.DATE, -15); [EOL] val.add(Calendar.MONTH, 1); [EOL] } [EOL] } else if (field == Calendar.AM_PM) { [EOL] if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL] val.add(Calendar.HOUR_OF_DAY, 12); [EOL] } else { [EOL] val.add(Calendar.HOUR_OF_DAY, -12); [EOL] val.add(Calendar.DATE, 1); [EOL] } [EOL] } else { [EOL] val.add(aField[0], 1); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] int offset = 0; [EOL] boolean offsetSet = false; [EOL] switch(field) { [EOL] case DateUtils.SEMI_MONTH: [EOL] if (aField[0] == Calendar.DATE) { [EOL] offset = val.get(Calendar.DATE) - 1; [EOL] if (offset >= 15) { [EOL] offset -= 15; [EOL] } [EOL] roundUp = offset > 7; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] case Calendar.AM_PM: [EOL] if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL] offset = val.get(Calendar.HOUR_OF_DAY); [EOL] if (offset >= 12) { [EOL] offset -= 12; [EOL] } [EOL] roundUp = offset >= 6; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] } [EOL] if (!offsetSet) { [EOL] final int min = val.getActualMinimum(aField[0]); [EOL] final int max = val.getActualMaximum(aField[0]); [EOL] offset = val.get(aField[0]) - min; [EOL] roundUp = offset > ((max - min) / 2); [EOL] } [EOL] if (offset != 0) { [EOL] val.set(aField[0], val.get(aField[0]) - offset); [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public void testIteratorWithNullDate() { [EOL] try { [EOL] DateUtils.iterator(null, DateUtils.RANGE_WEEK_MONDAY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIteratorWithValidDate() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.MARCH, 15); // A sample date [EOL] Iterator<Calendar> it = DateUtils.iterator(cal.getTime(), DateUtils.RANGE_MONTH_SUNDAY); [EOL] assertNotNull("Iterator should not be null", it); [EOL] assertTrue("Iterator should have a next element", it.hasNext()); [EOL] Calendar firstDay = it.next(); [EOL] assertEquals("First day of range should be correct", Calendar.SUNDAY, firstDay.get(Calendar.DAY_OF_WEEK)); [EOL] }
public void testIteratorWithDifferentRangeStyles() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.MARCH, 15); // A sample date [EOL] int[] rangeStyles = new int[] { [EOL] DateUtils.RANGE_MONTH_SUNDAY, [EOL] DateUtils.RANGE_MONTH_MONDAY, [EOL] DateUtils.RANGE_WEEK_SUNDAY, [EOL] DateUtils.RANGE_WEEK_MONDAY, [EOL] DateUtils.RANGE_WEEK_RELATIVE, [EOL] DateUtils.RANGE_WEEK_CENTER [EOL] }; [EOL] for (int rangeStyle : rangeStyles) { [EOL] Iterator<Calendar> it = DateUtils.iterator(cal.getTime(), rangeStyle); [EOL] assertNotNull("Iterator should not be null for range style " + rangeStyle, it); [EOL] assertTrue("Iterator should have a next element for range style " + rangeStyle, it.hasNext()); [EOL] } [EOL] }
public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL] if (focus == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] Calendar start = null; [EOL] Calendar end = null; [EOL] int startCutoff = Calendar.SUNDAY; [EOL] int endCutoff = Calendar.SATURDAY; [EOL] switch(rangeStyle) { [EOL] case RANGE_MONTH_SUNDAY: [EOL] case RANGE_MONTH_MONDAY: [EOL] start = truncate(focus, Calendar.MONTH); [EOL] end = (Calendar) start.clone(); [EOL] end.add(Calendar.MONTH, 1); [EOL] end.add(Calendar.DATE, -1); [EOL] if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL] startCutoff = Calendar.MONDAY; [EOL] endCutoff = Calendar.SUNDAY; [EOL] } [EOL] break; [EOL] case RANGE_WEEK_SUNDAY: [EOL] case RANGE_WEEK_MONDAY: [EOL] case RANGE_WEEK_RELATIVE: [EOL] case RANGE_WEEK_CENTER: [EOL] start = truncate(focus, Calendar.DATE); [EOL] end = truncate(focus, Calendar.DATE); [EOL] switch(rangeStyle) { [EOL] case RANGE_WEEK_SUNDAY: [EOL] break; [EOL] case RANGE_WEEK_MONDAY: [EOL] startCutoff = Calendar.MONDAY; [EOL] endCutoff = Calendar.SUNDAY; [EOL] break; [EOL] case RANGE_WEEK_RELATIVE: [EOL] startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL] endCutoff = startCutoff - 1; [EOL] break; [EOL] case RANGE_WEEK_CENTER: [EOL] startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL] endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL] break; [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL] } [EOL] if (startCutoff < Calendar.SUNDAY) { [EOL] startCutoff += 7; [EOL] } [EOL] if (startCutoff > Calendar.SATURDAY) { [EOL] startCutoff -= 7; [EOL] } [EOL] if (endCutoff < Calendar.SUNDAY) { [EOL] endCutoff += 7; [EOL] } [EOL] if (endCutoff > Calendar.SATURDAY) { [EOL] endCutoff -= 7; [EOL] } [EOL] while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL] start.add(Calendar.DATE, -1); [EOL] } [EOL] while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL] end.add(Calendar.DATE, 1); [EOL] } [EOL] return new DateIterator(start, end); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=1000; long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; int SEMI_MONTH=1001; int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }}
public static long getFragmentInMilliseconds(final Date date, final int fragment) { [EOL] return getFragment(date, fragment, Calendar.MILLISECOND); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }
public static long getFragmentInMinutes(final Date date, final int fragment) { [EOL] return getFragment(date, fragment, Calendar.MINUTE); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public void testGetFragmentInHoursWithDate() { [EOL] Date date = new Date(); [EOL] long result = DateUtils.getFragmentInHours(date, Calendar.DAY_OF_YEAR); [EOL] }
public void testGetFragmentInHoursWithInvalidFragment() { [EOL] Date date = new Date(); [EOL] try { [EOL] DateUtils.getFragmentInHours(date, Calendar.ERA); [EOL] fail("Should have thrown IllegalArgumentException for invalid fragment"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public static long getFragmentInDays(final Date date, final int fragment) { [EOL] return getFragment(date, fragment, Calendar.DAY_OF_YEAR); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL] if (calendar == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final long millisPerUnit = getMillisPerUnit(unit); [EOL] long result = 0; [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] case Calendar.MONTH: [EOL] result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] } [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] case Calendar.MONTH: [EOL] case Calendar.DAY_OF_YEAR: [EOL] case Calendar.DATE: [EOL] result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL] case Calendar.HOUR_OF_DAY: [EOL] result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL] case Calendar.MINUTE: [EOL] result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL] case Calendar.SECOND: [EOL] result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL] break; [EOL] case Calendar.MILLISECOND: [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL] } [EOL] return result; [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }};
public void testGetMillisPerUnitWithDayOfYear() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.DAY_OF_YEAR); [EOL] assertEquals(DateUtils.MILLIS_PER_DAY, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithDate() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.DATE); [EOL] assertEquals(DateUtils.MILLIS_PER_DAY, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithHourOfDay() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.HOUR_OF_DAY); [EOL] assertEquals(DateUtils.MILLIS_PER_HOUR, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithMinute() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.MINUTE); [EOL] assertEquals(DateUtils.MILLIS_PER_MINUTE, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithSecond() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.SECOND); [EOL] assertEquals(DateUtils.MILLIS_PER_SECOND, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithMillisecond() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.MILLISECOND); [EOL] assertEquals(1, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithInvalidUnit() { [EOL] try { [EOL] DateUtils.getMillisPerUnit(Calendar.YEAR); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testDateIteratorWithValidRange() { [EOL] Calendar start = Calendar.getInstance(); [EOL] Calendar end = Calendar.getInstance(); [EOL] end.add(Calendar.DATE, 1); [EOL] DateIterator iterator = new DateIterator(start, end); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(start, iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testDateIteratorWithSameStartAndEnd() { [EOL] Calendar start = Calendar.getInstance(); [EOL] Calendar end = (Calendar) start.clone(); [EOL] DateIterator iterator = new DateIterator(start, end); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(start, iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testDateIteratorWithEndBeforeStart() { [EOL] Calendar start = Calendar.getInstance(); [EOL] Calendar end = Calendar.getInstance(); [EOL] end.add(Calendar.DATE, -1); [EOL] try { [EOL] DateIterator iterator = new DateIterator(start, end); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public boolean hasNext() { [EOL] return spot.before(endFinal); [EOL] } [EOL] public DateUtils() {} [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) {} [EOL] public static boolean isSameDay(final Date date1, final Date date2) {} [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {} [EOL] public static boolean isSameInstant(final Date date1, final Date date2) {} [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) {} [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) {} [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException {} [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {} [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException {} [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {} [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException {} [EOL] public static Date addYears(final Date date, final int amount) {} [EOL] public static Date addMonths(final Date date, final int amount) {} [EOL] public static Date addWeeks(final Date date, final int amount) {} [EOL] public static Date addDays(final Date date, final int amount) {} [EOL] public static Date addHours(final Date date, final int amount) {} [EOL] public static Date addMinutes(final Date date, final int amount) {} [EOL] public static Date addSeconds(final Date date, final int amount) {} [EOL] public static Date addMilliseconds(final Date date, final int amount) {} [EOL] private static Date add(final Date date, final int calendarField, final int amount) {} [EOL] public static Date setYears(final Date date, final int amount) {} [EOL] public static Date setMonths(final Date date, final int amount) {} [EOL] public static Date setDays(final Date date, final int amount) {} [EOL] public static Date setHours(final Date date, final int amount) {} [EOL] public static Date setMinutes(final Date date, final int amount) {} [EOL] public static Date setSeconds(final Date date, final int amount) {} [EOL] public static Date setMilliseconds(final Date date, final int amount) {} [EOL] private static Date set(final Date date, final int calendarField, final int amount) {} [EOL] public static Calendar toCalendar(final Date date) {} [EOL] public static Date round(final Date date, final int field) {} [EOL] public static Calendar round(final Calendar date, final int field) {} [EOL] public static Date round(final Object date, final int field) {} [EOL] public static Date truncate(final Date date, final int field) {} [EOL] public static Calendar truncate(final Calendar date, final int field) {} [EOL] public static Date truncate(final Object date, final int field) {} [EOL] public static Date ceiling(final Date date, final int field) {} [EOL] public static Calendar ceiling(final Calendar date, final int field) {} [EOL] public static Date ceiling(final Object date, final int field) {} [EOL] private static void modify(final Calendar val, final int field, final int modType) {} [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) {} [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) {} [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) {} [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) {} [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) {} [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) {} [EOL] public static long getFragmentInHours(final Date date, final int fragment) {} [EOL] public static long getFragmentInDays(final Date date, final int fragment) {} [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {} [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) {} [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {} [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) {} [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) {} [EOL] private static long getFragment(final Date date, final int fragment, final int unit) {} [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) {} [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) {} [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {} [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) {} [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {} [EOL] private static long getMillisPerUnit(final int unit) {} [EOL] public boolean hasNext() {} [EOL] public Calendar next() {} [EOL] public void remove() {} [EOL] long MILLIS_PER_SECOND = 1000; [EOL] long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH = 1001; [EOL] int[][] fields = { { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };
@Override [EOL] public Calendar next() { [EOL] if (spot.equals(endFinal)) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] spot.add(Calendar.DATE, 1); [EOL] return (Calendar) spot.clone(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public final int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL] final int codepoint = Character.codePointAt(input, index); [EOL] final boolean consumed = translate(codepoint, out); [EOL] if (consumed) { [EOL] return 1; [EOL] } else { [EOL] return 0; [EOL] } [EOL] }
public void testCapitalize_NullString() { [EOL] String capitalized = StringUtils.capitalize(null); [EOL] assertNull(capitalized); [EOL] } [EOL] public void testCapitalize_EmptyString() { [EOL] String capitalized = StringUtils.capitalize(""); [EOL] assertEquals("", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithNoDelimiters() { [EOL] String capitalized = StringUtils.capitalize("test"); [EOL] assertEquals("Test", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimiters() { [EOL] String capitalized = StringUtils.capitalize("test string", ' '); [EOL] assertEquals("Test String", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithMultipleDelimiters() { [EOL] String capitalized = StringUtils.capitalize("test-string", ' ', '-'); [EOL] assertEquals("Test-String", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimiterAtStart() { [EOL] String capitalized = StringUtils.capitalize(" test", ' '); [EOL] assertEquals(" Test", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimiterAtEnd() { [EOL] String capitalized = StringUtils.capitalize("test ", ' '); [EOL] assertEquals("Test ", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimitersOnly() { [EOL] String capitalized = StringUtils.capitalize(" ", ' '); [EOL] assertEquals(" ", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDifferentCase() { [EOL] String capitalized = StringUtils.capitalize("tEsT", ' '); [EOL] assertEquals("TEsT", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithNoNeedToCapitalize() { [EOL] String capitalized = StringUtils.capitalize("Test", ' '); [EOL] assertEquals("Test", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithNullDelimiters() { [EOL] String capitalized = StringUtils.capitalize("test", (char[]) null); [EOL] assertEquals("Test", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithEmptyDelimiters() { [EOL] String capitalized = StringUtils.capitalize("test", new char[]{}); [EOL] assertEquals("Test", capitalized); [EOL] }
public void testCapitalizeFullyWithNullString() { [EOL] String result = StringUtils.capitalizeFully(null); [EOL] assertNull(result); [EOL] }
public void testCapitalizeFullyWithEmptyString() { [EOL] String result = StringUtils.capitalizeFully(""); [EOL] assertEquals("", result); [EOL] }
public void testCapitalizeFullyWithWhitespaceString() { [EOL] String result = StringUtils.capitalizeFully("   "); [EOL] assertEquals("   ", result); [EOL] }
public void testCapitalizeFullyWithWord() { [EOL] String result = StringUtils.capitalizeFully("cat"); [EOL] assertEquals("Cat", result); [EOL] }
public void testCapitalizeFullyWithSentence() { [EOL] String result = StringUtils.capitalizeFully("the quick brown fox"); [EOL] assertEquals("The Quick Brown Fox", result); [EOL] }
public void testCapitalizeFully_NullString() { [EOL] String input = null; [EOL] String result = StringUtils.capitalizeFully(input); [EOL] assertNull(result); [EOL] }
public void testCapitalizeFully_EmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.capitalizeFully(input); [EOL] assertEquals("", result); [EOL] }
public void testCapitalizeFully_StringWithNoDelimiters() { [EOL] String input = "test"; [EOL] String result = StringUtils.capitalizeFully(input); [EOL] assertEquals("Test", result); [EOL] }
public void testCapitalizeFully_StringWithDelimiters() { [EOL] String input = "test string"; [EOL] char[] delimiters = new char[]{' '}; [EOL] String result = StringUtils.capitalizeFully(input, delimiters); [EOL] assertEquals("Test String", result); [EOL] }
public void testCapitalizeFully_StringWithDelimitersAsNull() { [EOL] String input = "test string"; [EOL] String result = StringUtils.capitalizeFully(input, (char[]) null); [EOL] assertEquals("Test String", result); [EOL] }
public void testCapitalizeFully_StringWithEmptyDelimiters() { [EOL] String input = "test string"; [EOL] char[] delimiters = new char[]{}; [EOL] String result = StringUtils.capitalizeFully(input, delimiters); [EOL] assertEquals("Test string", result); [EOL] }
public void testSwapCaseEmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSwapCaseNullString() { [EOL] String input = null; [EOL] String result = StringUtils.swapCase(input); [EOL] assertNull(result); [EOL] } [EOL] public void testSwapCaseOnlyLowerCase() { [EOL] String input = "abc"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("ABC", result); [EOL] } [EOL] public void testSwapCaseOnlyUpperCase() { [EOL] String input = "ABC"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testSwapCaseMixedCase() { [EOL] String input = "aBc"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("AbC", result); [EOL] } [EOL] public void testSwapCaseWithWhitespace() { [EOL] String input = "a B c"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("A b C", result); [EOL] } [EOL] public void testSwapCaseWithNumbers() { [EOL] String input = "a1B2c"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("A1b2C", result); [EOL] } [EOL] public void testSwapCaseWithSpecialCharacters() { [EOL] String input = "a!B@c"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("A!b@C", result); [EOL] } [EOL] public void testSwapCaseWithUnicodeTitleCase() { [EOL] String input = "\u01C8"; // Titlecase letter Lj [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("\u01C9", result); // Lowercase letter Lj [EOL] } [EOL] public void testSwapCaseWithUnicodeLowerCase() { [EOL] String input = "\u01C9"; // Lowercase letter Lj [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("\u01C8", result); // Titlecase letter Lj [EOL] }
public void testMultiBackgroundInitializerConstructor() { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] assertNotNull(multiBackgroundInitializer); [EOL] }
public void testInitializeWithNoChildInitializers() throws Exception { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] MultiBackgroundInitializerResults results = multiBackgroundInitializer.initialize(); [EOL] assertNotNull(results); [EOL] assertTrue(results.getResults().isEmpty()); [EOL] assertTrue(results.getExceptionMap().isEmpty()); [EOL] }
public void testInitializeWithChildInitializersNoExceptions() throws Exception { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<String> childInitializer = new MockBackgroundInitializer(); [EOL] multiBackgroundInitializer.addInitializer("child1", childInitializer); [EOL] MultiBackgroundInitializerResults results = multiBackgroundInitializer.initialize(); [EOL] assertNotNull(results); [EOL] assertEquals(1, results.getResults().size()); [EOL] assertTrue(results.getExceptionMap().isEmpty()); [EOL] }
public void testInitializeWithChildInitializersWithExceptions() throws Exception { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<String> childInitializer = new MockBackgroundInitializer(true); [EOL] multiBackgroundInitializer.addInitializer("child1", childInitializer); [EOL] MultiBackgroundInitializerResults results = multiBackgroundInitializer.initialize(); [EOL] assertNotNull(results); [EOL] assertTrue(results.getResults().isEmpty()); [EOL] assertEquals(1, results.getExceptionMap().size()); [EOL] }
public void testIsSuccessfulWhenEmpty() { [EOL] List<Exception> exceptions = new ArrayList<>(); [EOL] MyClass myClass = new MyClass(exceptions); [EOL] assertTrue(myClass.isSuccessful()); [EOL] }
public void testIsSuccessfulWhenNotEmpty() { [EOL] List<Exception> exceptions = new ArrayList<>(); [EOL] exceptions.add(new Exception("Test Exception")); [EOL] MyClass myClass = new MyClass(exceptions); [EOL] assertFalse(myClass.isSuccessful()); [EOL] }
public void testToLocaleWithNullInput() { [EOL] Locale result = toLocale(null); [EOL] assertNull(result); [EOL] }
public void testToLocaleWithInvalidFormatContainingHash() { [EOL] try { [EOL] toLocale("en#US"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en#US", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithInvalidFormatTooShort() { [EOL] try { [EOL] toLocale("e"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: e", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreAndInvalidCountry() { [EOL] try { [EOL] toLocale("_eU"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: _eU", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreAndValidCountry() { [EOL] Locale result = toLocale("_US"); [EOL] assertEquals(new Locale("", "US"), result); [EOL] }
public void testToLocaleWithUnderscoreCountryAndInvalidVariant() { [EOL] try { [EOL] toLocale("_US_e"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: _US_e", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreCountryAndValidVariant() { [EOL] Locale result = toLocale("_US_variant"); [EOL] assertEquals(new Locale("", "US", "variant"), result); [EOL] }
public void testToLocaleWithInvalidLanguage() { [EOL] try { [EOL] toLocale("E_"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: E_", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithValidLanguage() { [EOL] Locale result = toLocale("en"); [EOL] assertEquals(new Locale("en"), result); [EOL] }
public void testToLocaleWithLanguageAndInvalidCountry() { [EOL] try { [EOL] toLocale("en_U"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en_U", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithLanguageCountryAndInvalidVariant() { [EOL] try { [EOL] toLocale("en_US_"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en_US_", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithLanguageCountryAndValidVariant() { [EOL] Locale result = toLocale("en_US_variant"); [EOL] assertEquals(new Locale("en", "US", "variant"), result); [EOL] }
public void testLanguagesByCountry_withNullCountryCode() { [EOL] List<Locale> result = LocaleUtils.languagesByCountry(null); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testLanguagesByCountry_withNonExistentCountryCode() { [EOL] List<Locale> result = LocaleUtils.languagesByCountry("XX"); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testLanguagesByCountry_withExistentCountryCode() { [EOL] List<Locale> result = LocaleUtils.languagesByCountry("US"); [EOL] assertFalse(result.isEmpty()); [EOL] for (Locale locale : result) { [EOL] assertEquals("US", locale.getCountry()); [EOL] assertTrue(locale.getVariant().isEmpty()); [EOL] } [EOL] }
public void testHashCode_withNullArray() { [EOL] int result = ArrayUtils.hashCode(null); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testHashCode_withEmptyArray() { [EOL] int[] emptyArray = new int[0]; [EOL] int result = ArrayUtils.hashCode(emptyArray); [EOL] assertNotEquals(0, result); [EOL] } [EOL] public void testHashCode_withNonEmptyArray() { [EOL] int[] nonEmptyArray = new int[] {1, 2, 3}; [EOL] int result = ArrayUtils.hashCode(nonEmptyArray); [EOL] int expected = new HashCodeBuilder().append(nonEmptyArray).toHashCode(); [EOL] assertEquals(expected, result); [EOL] }
public void testClone_NullArray() { [EOL] long[] array = null; [EOL] long[] clonedArray = clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] long[] array = new long[0]; [EOL] long[] clonedArray = clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] long[] array = {1L, 2L, 3L}; [EOL] long[] clonedArray = clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testClone_NullArray() { [EOL] byte[] array = null; [EOL] byte[] clonedArray = clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] byte[] array = new byte[0]; [EOL] byte[] clonedArray = clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] byte[] array = {1, 2, 3}; [EOL] byte[] clonedArray = clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(array.length, clonedArray.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(array[i], clonedArray[i]); [EOL] } [EOL] }
public void testClone_NullArray() { [EOL] double[] array = null; [EOL] double[] clonedArray = ArrayUtils.clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] double[] array = {}; [EOL] double[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] Object[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Object[] emptyArray = new Object[0]; [EOL] Object[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Object[] nonEmptyArray = new Object[] {"element"}; [EOL] Object[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmpty_givenNull_shouldReturnEmptyArray() { [EOL] float[] result = nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testNullToEmpty_givenEmptyArray_shouldReturnEmptyArray() { [EOL] float[] emptyArray = new float[0]; [EOL] float[] result = nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] } [EOL] public void testNullToEmpty_givenNonEmptyArray_shouldReturnSameArray() { [EOL] float[] nonEmptyArray = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] result = nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] Character[] result = nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Character[] emptyArray = new Character[0]; [EOL] Character[] result = nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Character[] nonEmptyArray = new Character[] {'a', 'b', 'c'}; [EOL] Character[] result = nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] Double[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Double[] emptyArray = new Double[0]; [EOL] Double[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Double[] nonEmptyArray = new Double[]{1.0, 2.0, 3.0}; [EOL] Double[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testSubarray_NullArray() { [EOL] byte[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] }
public void testSubarray_NegativeStartIndex() { [EOL] byte[] array = new byte[] {1, 2, 3}; [EOL] byte[] result = ArrayUtils.subarray(array, -1, 2); [EOL] assertArrayEquals(new byte[] {1, 2}, result); [EOL] }
public void testSubarray_EndIndexGreaterThanLength() { [EOL] byte[] array = new byte[] {1, 2, 3}; [EOL] byte[] result = ArrayUtils.subarray(array, 1, 5); [EOL] assertArrayEquals(new byte[] {2, 3}, result); [EOL] }
public void testSubarray_ZeroLengthResult() { [EOL] byte[] array = new byte[] {1, 2, 3}; [EOL] byte[] result = ArrayUtils.subarray(array, 2, 2); [EOL] assertArrayEquals(new byte[] {}, result); [EOL] }
public void testSubarray_ValidSubarray() { [EOL] byte[] array = new byte[] {1, 2, 3, 4, 5}; [EOL] byte[] result = ArrayUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new byte[] {2, 3, 4}, result); [EOL] }
public void testSubarray_NullArray() { [EOL] double[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_StartIndexNegative() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.subarray(array, -1, 2); [EOL] assertArrayEquals(new double[]{1.0, 2.0}, result); [EOL] } [EOL] public void testSubarray_EndIndexExceedsLength() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.subarray(array, 1, 5); [EOL] assertArrayEquals(new double[]{2.0, 3.0}, result); [EOL] } [EOL] public void testSubarray_EmptyResultByIndices() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.subarray(array, 2, 2); [EOL] assertArrayEquals(new double[]{}, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0, 5.0}; [EOL] double[] result = ArrayUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new double[]{2.0, 3.0, 4.0}, result); [EOL] }
public void testReverse_NullArray() { [EOL] float[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "Reversing a null array should not change it."); [EOL] }
public void testReverse_EmptyArray() { [EOL] float[] array = new float[0]; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length, "Reversing an empty array should not change its length."); [EOL] }
public void testReverse_NonEmptyArray() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] ArrayUtils.reverse(array); [EOL] float[] expectedArray = {3.0f, 2.0f, 1.0f}; [EOL] assertArrayEquals(expectedArray, array, "Reversing a non-empty array should reverse its elements."); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] int result = ArrayUtils.lastIndexOf(null, "a", 0); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_StartIndexOutOfBounds() { [EOL] Object[] array = new Object[] {"a", "b", "c"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "a", -1); [EOL] assertEquals(-1, result); [EOL] result = ArrayUtils.lastIndexOf(array, "a", array.length); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testLastIndexOf_NullObjectToFind() { [EOL] Object[] array = new Object[] {null, "b", null}; [EOL] int result = ArrayUtils.lastIndexOf(array, null, 2); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOf_ObjectToFind() { [EOL] Object[] array = new Object[] {"a", "b", "a"}; [EOL] int result = ArrayUtils.lastIndexOf(array, "a", 2); [EOL] assertEquals(2, result); [EOL] result = ArrayUtils.lastIndexOf(array, "a", 1); [EOL] assertEquals(0, result); [EOL] result = ArrayUtils.lastIndexOf(array, "c", 2); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_LongArray() { [EOL] final long[] array = {1L, 2L, 3L, 2L}; [EOL] int index = indexOf(array, 2L); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_LongArrayNotFound() { [EOL] final long[] array = {1L, 2L, 3L, 2L}; [EOL] int index = indexOf(array, 4L); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_LongArrayEmpty() { [EOL] final long[] array = {}; [EOL] int index = indexOf(array, 1L); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_LongArrayNull() { [EOL] int index = indexOf(null, 1L); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_NullArray() { [EOL] final long[] array = null; [EOL] final long valueToFind = 1L; [EOL] final int startIndex = 0; [EOL] final int expected = -1; [EOL] final int actual = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testIndexOf_StartIndexLessThanZero() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 3L; [EOL] final int startIndex = -1; [EOL] final int expected = 2; [EOL] final int actual = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 6L; [EOL] final int startIndex = 0; [EOL] final int expected = -1; [EOL] final int actual = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testIndexOf_ValueFound() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 3L; [EOL] final int startIndex = 0; [EOL] final int expected = 2; [EOL] final int actual = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testIndexOf_ValueFoundAfterStartIndex() { [EOL] final long[] array = {1L, 2L, 3L, 4L, 5L}; [EOL] final long valueToFind = 3L; [EOL] final int startIndex = 1; [EOL] final int expected = 2; [EOL] final int actual = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(expected, actual); [EOL] }
public void testIndexOf_withValuePresent() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 3; [EOL] int expectedIndex = 2; [EOL] int actualIndex = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(expectedIndex, actualIndex); [EOL] }
public void testIndexOf_withValueNotPresent() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 6; [EOL] int expectedIndex = -1; [EOL] int actualIndex = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(expectedIndex, actualIndex); [EOL] }
public void testIndexOf_withEmptyArray() { [EOL] int[] array = {}; [EOL] int valueToFind = 1; [EOL] int expectedIndex = -1; [EOL] int actualIndex = ArrayUtils.indexOf(array, valueToFind); [EOL] assertEquals(expectedIndex, actualIndex); [EOL] }
public void testIndexOf_withNullArray() { [EOL] int[] array = null; [EOL] int valueToFind = 1; [EOL] try { [EOL] ArrayUtils.indexOf(array, valueToFind); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testIndexOf_NullArray() { [EOL] int[] array = null; [EOL] int valueToFind = 3; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_StartIndexLessThanZero() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 3; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 6; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueFound() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 3; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ValueFoundAfterStartIndex() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 3; [EOL] int startIndex = 2; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanArrayLength() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] int valueToFind = 3; [EOL] int startIndex = 10; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_CharArrayChar() { [EOL] final char[] array = {'a', 'b', 'c', 'd'}; [EOL] int index = indexOf(array, 'a'); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOf_CharArrayCharNotFound() { [EOL] final char[] array = {'a', 'b', 'c', 'd'}; [EOL] int index = indexOf(array, 'e'); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_EmptyArray() { [EOL] final char[] array = new char[0]; [EOL] int index = indexOf(array, 'a'); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_NullArray() { [EOL] int index = indexOf(null, 'a'); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_NullArray() { [EOL] final int result = ClassName.indexOf(null, 'a', 0); [EOL] assertEquals(ClassName.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ClassName.indexOf(array, 'a', -1); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_ValidCharFound() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ClassName.indexOf(array, 'b', 0); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_ValidCharNotFound() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ClassName.indexOf(array, 'd', 0); [EOL] assertEquals(ClassName.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValidCharFoundWithStartIndex() { [EOL] final char[] array = {'a', 'b', 'c', 'b'}; [EOL] final int result = ClassName.indexOf(array, 'b', 2); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanArrayLength() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ClassName.indexOf(array, 'a', array.length + 1); [EOL] assertEquals(ClassName.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] int result = ArrayUtils.lastIndexOf(null, (byte) 0); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_EmptyArray() { [EOL] int result = ArrayUtils.lastIndexOf(new byte[0], (byte) 0); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ArrayWithoutMatch() { [EOL] byte[] array = new byte[] {1, 2, 3}; [EOL] int result = ArrayUtils.lastIndexOf(array, (byte) 4); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_ArrayWithMatch() { [EOL] byte[] array = new byte[] {1, 2, 3, 2}; [EOL] int result = ArrayUtils.lastIndexOf(array, (byte) 2); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_ArrayWithMatchAtEnd() { [EOL] byte[] array = new byte[] {1, 2, 3, 2}; [EOL] int result = ArrayUtils.lastIndexOf(array, (byte) 2, array.length - 1); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_ArrayWithMatchAtStart() { [EOL] byte[] array = new byte[] {2, 1, 2, 3}; [EOL] int result = ArrayUtils.lastIndexOf(array, (byte) 2, 0); [EOL] assertEquals(0, result); [EOL] }
public void testLastIndexOf_NullArray() { [EOL] final byte[] array = null; [EOL] final byte valueToFind = 0x00; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_NegativeStartIndex() { [EOL] final byte[] array = new byte[] {1, 2, 3, 4, 5}; [EOL] final byte valueToFind = 0x01; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_StartIndexGreaterThanLength() { [EOL] final byte[] array = new byte[] {1, 2, 3, 4, 5}; [EOL] final byte valueToFind = 0x03; [EOL] int startIndex = 10; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testLastIndexOf_ValueNotFound() { [EOL] final byte[] array = new byte[] {1, 2, 3, 4, 5}; [EOL] final byte valueToFind = 0x06; [EOL] int startIndex = 4; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_ValueFound() { [EOL] final byte[] array = new byte[] {1, 2, 3, 4, 5}; [EOL] final byte valueToFind = 0x04; [EOL] int startIndex = 4; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOf_withEmptyArray() { [EOL] double[] array = {}; [EOL] double valueToFind = 1.0; [EOL] int index = indexOf(array, valueToFind); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_withSingleElementArrayAndValuePresent() { [EOL] double[] array = {1.0}; [EOL] double valueToFind = 1.0; [EOL] int index = indexOf(array, valueToFind); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOf_withSingleElementArrayAndValueAbsent() { [EOL] double[] array = {2.0}; [EOL] double valueToFind = 1.0; [EOL] int index = indexOf(array, valueToFind); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_withMultipleElementsArrayAndValuePresent() { [EOL] double[] array = {2.0, 1.0, 3.0}; [EOL] double valueToFind = 1.0; [EOL] int index = indexOf(array, valueToFind); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_withMultipleElementsArrayAndValueAbsent() { [EOL] double[] array = {2.0, 3.0, 4.0}; [EOL] double valueToFind = 1.0; [EOL] int index = indexOf(array, valueToFind); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_ArrayIsEmpty() { [EOL] double[] array = {}; [EOL] int index = ArrayUtils.indexOf(array, 1.0, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_StartIndexIsNegative() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.indexOf(array, 1.0, -1); [EOL] assertEquals(0, index); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.indexOf(array, 4.0, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_ValueFound() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.indexOf(array, 2.0, 0); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_ValueFoundAfterStartIndex() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] int index = ArrayUtils.indexOf(array, 2.0, 2); [EOL] assertEquals(3, index); [EOL] }
public void testLastIndexOf_withValuePresent() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 2.0); [EOL] assertEquals(3, index); [EOL] }
public void testLastIndexOf_withValueNotPresent() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = ArrayUtils.lastIndexOf(array, 4.0); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withEmptyArray() { [EOL] double[] array = {}; [EOL] int index = ArrayUtils.lastIndexOf(array, 1.0); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_withNullArray() { [EOL] double[] array = null; [EOL] int index = ArrayUtils.lastIndexOf(array, 1.0); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_emptyArray() { [EOL] double[] array = {}; [EOL] int valueToFind = 1; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_startIndexLessThanZero() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_startIndexGreaterThanArrayLength() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = 5; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_valuePresentInArray() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0}; [EOL] double valueToFind = 2.0; [EOL] int startIndex = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOf_valueNotPresentInArray() { [EOL] double[] array = {1.0, 2.0, 3.0, 4.0}; [EOL] double valueToFind = 5.0; [EOL] int startIndex = 3; [EOL] int result = ArrayUtils.lastIndexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] int[] result = ArrayUtils.toPrimitive(null); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Integer[] emptyArray = new Integer[0]; [EOL] int[] result = ArrayUtils.toPrimitive(emptyArray); [EOL] assertArrayEquals(ArrayUtils.EMPTY_INT_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullArray() { [EOL] Integer[] arrayWithValues = new Integer[] {1, 2, 3}; [EOL] int[] result = ArrayUtils.toPrimitive(arrayWithValues); [EOL] int[] expected = new int[] {1, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Short[] array = null; [EOL] short[] result = ArrayUtils.toPrimitive(array); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyInput() { [EOL] Short[] array = new Short[0]; [EOL] short[] result = ArrayUtils.toPrimitive(array); [EOL] assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, result); [EOL] }
public void testToPrimitiveWithValidInput() { [EOL] Short[] array = new Short[] {1, 2, 3}; [EOL] short[] result = ArrayUtils.toPrimitive(array); [EOL] short[] expected = new short[] {1, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToObjectWithNullArray() { [EOL] Byte[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObjectWithEmptyArray() { [EOL] byte[] emptyArray = new byte[0]; [EOL] Byte[] result = ArrayUtils.toObject(emptyArray); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObjectWithNonEmptyArray() { [EOL] byte[] byteArray = new byte[] {1, 2, 3}; [EOL] Byte[] result = ArrayUtils.toObject(byteArray); [EOL] assertNotNull(result); [EOL] assertEquals(byteArray.length, result.length); [EOL] for (int i = 0; i < byteArray.length; i++) { [EOL] assertEquals(Byte.valueOf(byteArray[i]), result[i]); [EOL] } [EOL] }
public void testIsEmpty_NullArray() { [EOL] assertTrue(ArrayUtils.isEmpty(null)); [EOL] }
public void testIsEmpty_EmptyArray() { [EOL] assertTrue(ArrayUtils.isEmpty(new Object[0])); [EOL] }
public void testIsEmpty_NonEmptyArray() { [EOL] assertFalse(ArrayUtils.isEmpty(new Object[1])); [EOL] }
public void testIsEmpty_NullArray() { [EOL] assertTrue(ArrayUtils.isEmpty(null)); [EOL] }
public void testIsEmpty_EmptyArray() { [EOL] assertTrue(ArrayUtils.isEmpty(new double[]{})); [EOL] }
public void testIsEmpty_NonEmptyArray() { [EOL] assertFalse(ArrayUtils.isEmpty(new double[]{1.0, 2.0, 3.0})); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = ArrayUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(emptyArray); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] String[] nonEmptyArray = new String[]{"element"}; [EOL] boolean result = ArrayUtils.isNotEmpty(nonEmptyArray); [EOL] assertTrue(result); [EOL] }
public void testAddAllWithBothArraysNull() { [EOL] Integer[] result = ArrayUtils.addAll(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddAllWithFirstArrayNull() { [EOL] Integer[] array2 = new Integer[] {1, 2}; [EOL] Integer[] result = ArrayUtils.addAll(null, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array2, result); [EOL] } [EOL] public void testAddAllWithSecondArrayNull() { [EOL] Integer[] array1 = new Integer[] {1, 2}; [EOL] Integer[] result = ArrayUtils.addAll(array1, null); [EOL] assertNotNull(result); [EOL] assertArrayEquals(array1, result); [EOL] } [EOL] public void testAddAllWithNoArrayNull() { [EOL] Integer[] array1 = new Integer[] {1, 2}; [EOL] Integer[] array2 = new Integer[] {3, 4}; [EOL] Integer[] result = ArrayUtils.addAll(array1, array2); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new Integer[] {1, 2, 3, 4}, result); [EOL] } [EOL] public void testAddAllWithTypeMismatch() { [EOL] Integer[] array1 = new Integer[] {1, 2}; [EOL] String[] array2 = new String[] {"3", "4"}; [EOL] try { [EOL] ArrayUtils.addAll(array1, array2); [EOL] fail("Expected ArrayStoreException to be thrown"); [EOL] } catch (ArrayStoreException e) { [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRemove_NullArray() { [EOL] Integer[] array = null; [EOL] Integer[] result = ArrayUtils.remove(array, 1); [EOL] assertNull(result); [EOL] }
public void testRemove_EmptyArray() { [EOL] Integer[] array = new Integer[0]; [EOL] Integer[] result = ArrayUtils.remove(array, 1); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemove_ArrayWithOneElement() { [EOL] Integer[] array = new Integer[] {1}; [EOL] Integer[] result = ArrayUtils.remove(array, 0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testRemove_PositiveIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.remove(array, 1); [EOL] assertArrayEquals(new Integer[] {1, 3}, result); [EOL] }
public void testRemove_NegativeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.remove(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_IndexOutOfBounds() { [EOL] Integer[] array = new Integer[] {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.remove(array, 3); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_NullArray() { [EOL] byte[] result = ArrayUtils.remove((byte[]) null, 1); [EOL] assertNull(result); [EOL] }
public void testRemove_EmptyArray() { [EOL] byte[] emptyArray = new byte[0]; [EOL] try { [EOL] ArrayUtils.remove(emptyArray, 0); [EOL] fail("Should throw an IndexOutOfBoundsException because the array is empty"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_ArrayWithOneElement() { [EOL] byte[] array = new byte[] { 1 }; [EOL] byte[] result = ArrayUtils.remove(array, 0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testRemove_PositiveIndex() { [EOL] byte[] array = new byte[] { 1, 2, 3 }; [EOL] byte[] result = ArrayUtils.remove(array, 1); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(3, result[1]); [EOL] }
public void testRemove_NegativeIndex() { [EOL] byte[] array = new byte[] { 1, 2, 3 }; [EOL] try { [EOL] ArrayUtils.remove(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException because the index is negative"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_IndexOutOfBounds() { [EOL] byte[] array = new byte[] { 1, 2, 3 }; [EOL] try { [EOL] ArrayUtils.remove(array, 3); [EOL] fail("Should throw an IndexOutOfBoundsException because the index is equal to the array length"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElement_ArrayWithElement() { [EOL] byte[] array = {1, 2, 3, 4, 3}; [EOL] byte elementToRemove = 3; [EOL] byte[] result = ArrayUtils.removeElement(array, elementToRemove); [EOL] byte[] expected = {1, 2, 4}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_ArrayWithoutElement() { [EOL] byte[] array = {1, 2, 3, 4}; [EOL] byte elementToRemove = 5; [EOL] byte[] result = ArrayUtils.removeElement(array, elementToRemove); [EOL] byte[] expected = {1, 2, 3, 4}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_NullArray() { [EOL] byte[] result = ArrayUtils.removeElement(null, (byte) 1); [EOL] assertNull(result); [EOL] }
public void testRemoveElement_EmptyArray() { [EOL] byte[] array = {}; [EOL] byte elementToRemove = 1; [EOL] byte[] result = ArrayUtils.removeElement(array, elementToRemove); [EOL] byte[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] double[] array = new double[] {1.0, 2.0, 3.0}; [EOL] double element = 4.0; [EOL] double[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElement_ArrayContainsElement() { [EOL] double[] array = new double[] {1.0, 2.0, 3.0}; [EOL] double element = 2.0; [EOL] double[] expected = new double[] {1.0, 3.0}; [EOL] double[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_EmptyArray() { [EOL] double[] array = new double[] {}; [EOL] double element = 1.0; [EOL] double[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElement_NullArray() { [EOL] double[] result = ArrayUtils.removeElement(null, 1.0); [EOL] assertNull(result); [EOL] }
public void testRemove_LongArrayIndex_NullInput() { [EOL] long[] result = ArrayUtils.remove((long[]) null, 1); [EOL] assertNull(result); [EOL] }
public void testRemove_LongArrayIndex_EmptyArray() { [EOL] long[] array = {}; [EOL] try { [EOL] ArrayUtils.remove(array, 1); [EOL] fail("Should throw an IndexOutOfBoundsException because the array is empty"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_LongArrayIndex_ValidIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] long[] result = ArrayUtils.remove(array, 1); [EOL] long[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemove_LongArrayIndex_NegativeIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.remove(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException because the index is negative"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_LongArrayIndex_IndexOutOfBounds() { [EOL] long[] array = {1, 2, 3}; [EOL] try { [EOL] ArrayUtils.remove(array, 3); [EOL] fail("Should throw an IndexOutOfBoundsException because the index is equal to the array length"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long element = 6; [EOL] long[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElement_ArrayContainsElement() { [EOL] long[] array = {1, 2, 3, 4, 5}; [EOL] long element = 3; [EOL] long[] expected = {1, 2, 4, 5}; [EOL] long[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_NullArray() { [EOL] long[] result = ArrayUtils.removeElement(null, 1); [EOL] assertNull(result); [EOL] }
public void testRemoveElement_EmptyArray() { [EOL] long[] array = {}; [EOL] long element = 1; [EOL] long[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAllShortArrayNullArray() { [EOL] short[] array = null; [EOL] int[] indices = new int[]{1, 2}; [EOL] short[] result = ArrayUtils.removeAll(array, indices); [EOL] assertNull(result); [EOL] }
public void testRemoveAllShortArrayEmptyIndices() { [EOL] short[] array = new short[]{1, 2, 3}; [EOL] int[] indices = new int[0]; [EOL] short[] result = ArrayUtils.removeAll(array, indices); [EOL] assertArrayEquals(new short[]{1, 2, 3}, result); [EOL] }
public void testRemoveAllShortArrayValidIndices() { [EOL] short[] array = new short[]{1, 2, 3}; [EOL] int[] indices = new int[]{1}; [EOL] short[] result = ArrayUtils.removeAll(array, indices); [EOL] assertArrayEquals(new short[]{1, 3}, result); [EOL] }
public void testRemoveAllShortArrayAllIndices() { [EOL] short[] array = new short[]{1, 2, 3}; [EOL] int[] indices = new int[]{0, 1, 2}; [EOL] short[] result = ArrayUtils.removeAll(array, indices); [EOL] assertArrayEquals(new short[0], result); [EOL] }
public void testRemoveAllShortArrayDuplicateIndices() { [EOL] short[] array = new short[]{1, 2, 3, 4}; [EOL] int[] indices = new int[]{2, 2}; [EOL] short[] result = ArrayUtils.removeAll(array, indices); [EOL] assertArrayEquals(new short[]{1, 2, 4}, result); [EOL] }
public void testRemoveAllShortArrayOutOfBoundsIndices() { [EOL] short[] array = new short[]{1, 2, 3}; [EOL] int[] indices = new int[]{4}; [EOL] try { [EOL] ArrayUtils.removeAll(array, indices); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NullArray() { [EOL] int[] result = ArrayUtils.removeAll((int[]) null, 1, 2); [EOL] assertNull(result); [EOL] }
public void testRemoveAll_EmptyArray() { [EOL] int[] array = new int[0]; [EOL] int[] result = ArrayUtils.removeAll(array, 1, 2); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_NoIndices() { [EOL] int[] array = {1, 2, 3}; [EOL] int[] result = ArrayUtils.removeAll(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_ValidIndices() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int[] result = ArrayUtils.removeAll(array, 1, 3); [EOL] int[] expected = {1, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_OutOfBoundsIndices() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] try { [EOL] ArrayUtils.removeAll(array, 4, 5); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NegativeIndices() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] try { [EOL] ArrayUtils.removeAll(array, -1, -2); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElementsWithEmptyArray() { [EOL] int[] array = {}; [EOL] int[] valuesToRemove = {1, 2, 3}; [EOL] int[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertArrayEquals(new int[]{}, result); [EOL] }
public void testRemoveElementsWithEmptyValues() { [EOL] int[] array = {1, 2, 3}; [EOL] int[] valuesToRemove = {}; [EOL] int[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertArrayEquals(new int[]{1, 2, 3}, result); [EOL] }
public void testRemoveElementsWithNonEmptyArrayAndValues() { [EOL] int[] array = {1, 2, 3, 4, 3, 2, 1}; [EOL] int[] valuesToRemove = {2, 3}; [EOL] int[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertArrayEquals(new int[]{1, 4, 1}, result); [EOL] }
public void testRemoveElementsWithValuesNotInArray() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int[] valuesToRemove = {5, 6}; [EOL] int[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertArrayEquals(new int[]{1, 2, 3, 4}, result); [EOL] }
public void testRemoveElementsWithNullArray() { [EOL] int[] result = ArrayUtils.removeElements(null, 1, 2, 3); [EOL] assertNull(result); [EOL] }
public void testRemoveElementsWithNullValues() { [EOL] int[] array = {1, 2, 3, 4}; [EOL] int[] result = ArrayUtils.removeElements(array, (int[]) null); [EOL] assertArrayEquals(new int[]{1, 2, 3, 4}, result); [EOL] }
public void testRemoveElementsWithDuplicateValues() { [EOL] int[] array = {1, 2, 3, 4, 3, 2, 1}; [EOL] int[] valuesToRemove = {2, 2, 3}; [EOL] int[] result = ArrayUtils.removeElements(array, valuesToRemove); [EOL] assertArrayEquals(new int[]{1, 4, 1}, result); [EOL] }
public void testRemoveElements_NullArray() { [EOL] double[] result = ArrayUtils.removeElements(null, 1.0, 2.0); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElements_EmptyArray() { [EOL] double[] array = {}; [EOL] double[] result = ArrayUtils.removeElements(array, 1.0, 2.0); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesToRemove() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.removeElements(array); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_RemoveSingleValue() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 2.0); [EOL] double[] expected = {1.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveMultipleValues() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0, 4.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 2.0, 4.0); [EOL] double[] expected = {1.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveNonExistentValue() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 4.0); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_RemoveValueWithMultipleOccurrences() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0, 2.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 2.0); [EOL] double[] expected = {1.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveValueFromStartAndEnd() { [EOL] double[] array = {2.0, 1.0, 2.0, 3.0, 2.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 2.0); [EOL] double[] expected = {1.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_RemoveValueWithCountGreaterThanArray() { [EOL] double[] array = {1.0, 2.0, 3.0, 2.0, 2.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 2.0, 2.0, 2.0, 2.0); [EOL] double[] expected = {1.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElements_RemoveAllValues() { [EOL] double[] array = {2.0, 2.0, 2.0}; [EOL] double[] result = ArrayUtils.removeElements(array, 2.0); [EOL] double[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAllWithEmptyIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, new int[]{}); [EOL] assertArrayEquals("Result should be the same as the original array when indices are empty", array, result); [EOL] } [EOL] public void testRemoveAllWithValidIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, new int[]{1, 3}); [EOL] Integer[] expected = new Integer[] {1, 3, 5}; [EOL] assertArrayEquals("Result should have specific elements removed", expected, result); [EOL] } [EOL] public void testRemoveAllWithDuplicateIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, new int[]{2, 2}); [EOL] Integer[] expected = new Integer[] {1, 2, 4, 5}; [EOL] assertArrayEquals("Result should handle duplicate indices by removing the element once", expected, result); [EOL] } [EOL] public void testRemoveAllWithOutOfBoundsIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] try { [EOL] removeAll(array, new int[]{5}); [EOL] fail("Should throw IndexOutOfBoundsException for index out of bounds"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithNegativeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] try { [EOL] removeAll(array, new int[]{-1}); [EOL] fail("Should throw IndexOutOfBoundsException for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithNullArray() { [EOL] try { [EOL] removeAll(null, new int[]{0}); [EOL] fail("Should throw NullPointerException for null array"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithEmptyArray() { [EOL] Integer[] array = new Integer[] {}; [EOL] Integer[] result = (Integer[]) removeAll(array, new int[]{0}); [EOL] assertArrayEquals("Result should be an empty array when input array is empty", array, result); [EOL] }
public void testRemoveAllWithIndicesSorted() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, new int[]{4, 2, 0}); [EOL] Integer[] expected = new Integer[] {2, 4}; [EOL] assertArrayEquals("Result should have elements removed and indices should be sorted", expected, result); [EOL] }
public void testRemoveAllWithAllIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, new int[]{0, 1, 2, 3, 4}); [EOL] Integer[] expected = new Integer[] {}; [EOL] assertArrayEquals("Result should be an empty array when all indices are provided", expected, result); [EOL] }
public void testRemoveAllWithEmptyArray() { [EOL] Object array = new int[]{}; [EOL] BitSet indices = new BitSet(); [EOL] Object result = ArrayUtils.removeAll(array, indices); [EOL] assertNotNull(result); [EOL] assertEquals(0, Array.getLength(result)); [EOL] }
public void testRemoveAllWithNoIndicesSet() { [EOL] Object array = new int[]{1, 2, 3, 4, 5}; [EOL] BitSet indices = new BitSet(); [EOL] Object result = ArrayUtils.removeAll(array, indices); [EOL] assertNotNull(result); [EOL] assertEquals(5, Array.getLength(result)); [EOL] for (int i = 0; i < Array.getLength(result); i++) { [EOL] assertEquals(Array.get(array, i), Array.get(result, i)); [EOL] } [EOL] }
public void testRemoveAllWithSomeIndicesSet() { [EOL] Object array = new int[]{1, 2, 3, 4, 5}; [EOL] BitSet indices = new BitSet(); [EOL] indices.set(1); [EOL] indices.set(3); [EOL] Object result = ArrayUtils.removeAll(array, indices); [EOL] assertNotNull(result); [EOL] assertEquals(3, Array.getLength(result)); [EOL] assertEquals(1, Array.getInt(result, 0)); [EOL] assertEquals(3, Array.getInt(result, 1)); [EOL] assertEquals(5, Array.getInt(result, 2)); [EOL] }
public void testRemoveAllWithAllIndicesSet() { [EOL] Object array = new int[]{1, 2, 3, 4, 5}; [EOL] BitSet indices = new BitSet(); [EOL] indices.set(0, 5); [EOL] Object result = ArrayUtils.removeAll(array, indices); [EOL] assertNotNull(result); [EOL] assertEquals(0, Array.getLength(result)); [EOL] }
public void testRemoveAllWithNullArray() { [EOL] Object array = null; [EOL] BitSet indices = new BitSet(); [EOL] try { [EOL] ArrayUtils.removeAll(array, indices); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRemoveAllWithNullIndices() { [EOL] Object array = new int[]{1, 2, 3, 4, 5}; [EOL] BitSet indices = null; [EOL] try { [EOL] ArrayUtils.removeAll(array, indices); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
static boolean isAccessible(final Member m) { [EOL] return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES={ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE };
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) { [EOL] final float leftCost = getTotalTransformationCost(actual, left); [EOL] final float rightCost = getTotalTransformationCost(actual, right); [EOL] return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0; [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }];
private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) { [EOL] float totalCost = 0.0f; [EOL] for (int i = 0; i < srcArgs.length; i++) { [EOL] Class<?> srcClass, destClass; [EOL] srcClass = srcArgs[i]; [EOL] destClass = destArgs[i]; [EOL] totalCost += getObjectTransformationCost(srcClass, destClass); [EOL] } [EOL] return totalCost; [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }];
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL] if (destClass.isPrimitive()) { [EOL] return getPrimitivePromotionCost(srcClass, destClass); [EOL] } [EOL] float cost = 0.0f; [EOL] while (srcClass != null && !destClass.equals(srcClass)) { [EOL] if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL] cost += 0.25f; [EOL] break; [EOL] } [EOL] cost++; [EOL] srcClass = srcClass.getSuperclass(); [EOL] } [EOL] if (srcClass == null) { [EOL] cost += 1.5f; [EOL] } [EOL] return cost; [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }];
private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) { [EOL] float cost = 0.0f; [EOL] Class<?> cls = srcClass; [EOL] if (!cls.isPrimitive()) { [EOL] cost += 0.1f; [EOL] cls = ClassUtils.wrapperToPrimitive(cls); [EOL] } [EOL] for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { [EOL] if (cls == ORDERED_PRIMITIVE_TYPES[i]) { [EOL] cost += 0.1f; [EOL] if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { [EOL] cls = ORDERED_PRIMITIVE_TYPES[i + 1]; [EOL] } [EOL] } [EOL] } [EOL] return cost; [EOL] } [EOL] static void setAccessibleWorkaround(final AccessibleObject o); [EOL] static boolean isPackageAccess(final int modifiers); [EOL] static boolean isAccessible(final Member m); [EOL] static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); [EOL] private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); [EOL] private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); [EOL] private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); [EOL] int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; [EOL] Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }];
public void testIsAssignableWithNullType() { [EOL] boolean result = TypeUtils.isAssignable(null, null); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithTypeToSameType() { [EOL] boolean result = TypeUtils.isAssignable(String.class, String.class); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithTypeToDifferentType() { [EOL] boolean result = TypeUtils.isAssignable(String.class, Object.class); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithUnassignableTypes() { [EOL] boolean result = TypeUtils.isAssignable(Object.class, String.class); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithNullToType() { [EOL] boolean result = isAssignable(String.class, null, null); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithClassToType() { [EOL] boolean result = isAssignable(String.class, Object.class, null); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithParameterizedTypeToType() { [EOL] Type type = String.class; [EOL] Type toType = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {String.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] boolean result = isAssignable(type, toType, typeVarAssigns); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithGenericArrayTypeToType() { [EOL] Type type = String[].class; [EOL] Type toType = new GenericArrayType() { [EOL] @Override [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] boolean result = isAssignable(type, toType, typeVarAssigns); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithWildcardTypeToType() { [EOL] Type type = String.class; [EOL] Type toType = new WildcardType() { [EOL] @Override [EOL] public Type[] getUpperBounds() { [EOL] return new Type[] {Object.class}; [EOL] } [EOL] @Override [EOL] public Type[] getLowerBounds() { [EOL] return new Type[0]; [EOL] } [EOL] }; [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] boolean result = isAssignable(type, toType, typeVarAssigns); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithTypeVariableToType() { [EOL] Type type = String.class; [EOL] Type toType = new TypeVariable<Class<?>>() { [EOL] @Override [EOL] public Type[] getBounds() { [EOL] return new Type[] {Object.class}; [EOL] } [EOL] @Override [EOL] public String getName() { [EOL] return "T"; [EOL] } [EOL] @Override [EOL] public GenericDeclaration getGenericDeclaration() { [EOL] return String.class; [EOL] } [EOL] @Override [EOL] public AnnotatedType[] getAnnotatedBounds() { [EOL] return new AnnotatedType[0]; [EOL] } [EOL] }; [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] boolean result = isAssignable(type, toType, typeVarAssigns); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableUnhandledType() { [EOL] Type type = String.class; [EOL] Type toType = new Type() { [EOL] }; [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] try { [EOL] isAssignable(type, toType, typeVarAssigns); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("found an unhandled type: " + toType, e.getMessage()); [EOL] } [EOL] }
public void testIsAssignableWithNullTypeAndNullClass() { [EOL] boolean result = isAssignable(null, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithNullTypeAndPrimitiveClass() { [EOL] boolean result = isAssignable(null, int.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithNullTypeAndNonPrimitiveClass() { [EOL] boolean result = isAssignable(null, Integer.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithNullToClass() { [EOL] boolean result = isAssignable(String.class, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableWithEqualTypeAndToClass() { [EOL] boolean result = isAssignable(String.class, String.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithClassAndSuperclass() { [EOL] boolean result = isAssignable(String.class, Object.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithParameterizedType() { [EOL] ParameterizedType parameterizedType = (ParameterizedType) ArrayList<String>.class.getGenericSuperclass(); [EOL] boolean result = isAssignable(parameterizedType, List.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithTypeVariable() { [EOL] TypeVariable<?> typeVariable = (TypeVariable<?>) getClass().getTypeParameters()[0]; [EOL] boolean result = isAssignable(typeVariable, Object.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithGenericArrayType() { [EOL] GenericArrayType genericArrayType = (GenericArrayType) new TypeToken<List<String>[]>() {}.getType(); [EOL] boolean result = isAssignable(genericArrayType, List[].class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAssignableWithWildcardType() { [EOL] WildcardType wildcardType = (WildcardType) new TypeToken<? extends Number>() {}.getType(); [EOL] boolean result = isAssignable(wildcardType, Number.class); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAssignableUnhandledType() { [EOL] try { [EOL] Type unhandledType = new Type() {}; [EOL] isAssignable(unhandledType, Object.class); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testIsAssignableWithNullType() { [EOL] ParameterizedType toParameterizedType = mock(ParameterizedType.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] boolean result = isAssignable(null, toParameterizedType, typeVarAssigns); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithNullToParameterizedType() { [EOL] Type type = mock(Type.class); [EOL] boolean result = isAssignable(type, null, null); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithTypeEqualsToParameterizedType() { [EOL] Type type = mock(Type.class); [EOL] ParameterizedType toParameterizedType = mock(ParameterizedType.class); [EOL] when(toParameterizedType.equals(type)).thenReturn(true); [EOL] boolean result = isAssignable(type, toParameterizedType, null); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithFromTypeVarAssignsNull() { [EOL] Type type = mock(Type.class); [EOL] ParameterizedType toParameterizedType = mock(ParameterizedType.class); [EOL] Class<?> toClass = mock(Class.class); [EOL] when(toParameterizedType.equals(type)).thenReturn(false); [EOL] when(getRawType(toParameterizedType)).thenReturn(toClass); [EOL] when(getTypeArguments(type, toClass, null)).thenReturn(null); [EOL] boolean result = isAssignable(type, toParameterizedType, null); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithEmptyFromTypeVarAssigns() { [EOL] Type type = mock(Type.class); [EOL] ParameterizedType toParameterizedType = mock(ParameterizedType.class); [EOL] Class<?> toClass = mock(Class.class); [EOL] Map<TypeVariable<?>, Type> fromTypeVarAssigns = new HashMap<>(); [EOL] when(toParameterizedType.equals(type)).thenReturn(false); [EOL] when(getRawType(toParameterizedType)).thenReturn(toClass); [EOL] when(getTypeArguments(type, toClass, null)).thenReturn(fromTypeVarAssigns); [EOL] boolean result = isAssignable(type, toParameterizedType, null); [EOL] assertTrue(result); [EOL] }
public void testIsAssignableWithNonEmptyFromTypeVarAssigns() { [EOL] Type type = mock(Type.class); [EOL] ParameterizedType toParameterizedType = mock(ParameterizedType.class); [EOL] Class<?> toClass = mock(Class.class); [EOL] Map<TypeVariable<?>, Type> fromTypeVarAssigns = new HashMap<>(); [EOL] Map<TypeVariable<?>, Type> toTypeVarAssigns = new HashMap<>(); [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] Type toTypeArg = mock(Type.class); [EOL] Type fromTypeArg = mock(Type.class); [EOL] fromTypeVarAssigns.put(typeVariable, fromTypeArg); [EOL] toTypeVarAssigns.put(typeVariable, toTypeArg); [EOL] when(toParameterizedType.equals(type)).thenReturn(false); [EOL] when(getRawType(toParameterizedType)).thenReturn(toClass); [EOL] when(getTypeArguments(type, toClass, null)).thenReturn(fromTypeVarAssigns); [EOL] when(getTypeArguments(toParameterizedType, toClass, null)).thenReturn(toTypeVarAssigns); [EOL] when(unrollVariableAssignments(typeVariable, toTypeVarAssigns)).thenReturn(toTypeArg); [EOL] when(unrollVariableAssignments(typeVariable, fromTypeVarAssigns)).thenReturn(fromTypeArg); [EOL] when(toTypeArg.equals(fromTypeArg)).thenReturn(false); [EOL] when(toTypeArg instanceof WildcardType).thenReturn(false); [EOL] boolean result = isAssignable(type, toParameterizedType, null); [EOL] assertFalse(result); [EOL] }
public void testIsAssignableWithWildcardType() { [EOL] Type type = mock(Type.class); [EOL] ParameterizedType toParameterizedType = mock(ParameterizedType.class); [EOL] Class<?> toClass = mock(Class.class); [EOL] Map<TypeVariable<?>, Type> fromTypeVarAssigns = new HashMap<>(); [EOL] Map<TypeVariable<?>, Type> toTypeVarAssigns = new HashMap<>(); [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] Type toTypeArg = mock(WildcardType.class); [EOL] Type fromTypeArg = mock(Type.class); [EOL] fromTypeVarAssigns.put(typeVariable, fromTypeArg); [EOL] toTypeVarAssigns.put(typeVariable, toTypeArg); [EOL] when(toParameterizedType.equals(type)).thenReturn(false); [EOL] when(getRawType(toParameterizedType)).thenReturn(toClass); [EOL] when(getTypeArguments(type, toClass, null)).thenReturn(fromTypeVarAssigns); [EOL] when(getTypeArguments(toParameterizedType, toClass, null)).thenReturn(toTypeVarAssigns); [EOL] when(unrollVariableAssignments(typeVariable, toTypeVarAssigns)).thenReturn(toTypeArg); [EOL] when(unrollVariableAssignments(typeVariable, fromTypeVarAssigns)).thenReturn(fromTypeArg); [EOL] when(toTypeArg.equals(fromTypeArg)).thenReturn(false); [EOL] when(toTypeArg instanceof WildcardType).thenReturn(true); [EOL] when(isAssignable(fromTypeArg, toTypeArg, null)).thenReturn(true); [EOL] boolean result = isAssignable(type, toParameterizedType, null); [EOL] assertTrue(result); [EOL] }
public void testUnrollVariableAssignmentsWithNonTypeVariable() { [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] TypeVariable<?> var = mock(TypeVariable.class); [EOL] Type nonTypeVariable = mock(Type.class); [EOL] typeVarAssigns.put(var, nonTypeVariable); [EOL] Type result = unrollVariableAssignments(var, typeVarAssigns); [EOL] assertSame(nonTypeVariable, result); [EOL] }
public void testUnrollVariableAssignmentsWithTypeVariable() { [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] TypeVariable<?> var1 = mock(TypeVariable.class); [EOL] TypeVariable<?> var2 = mock(TypeVariable.class); [EOL] when(var1.equals(var2)).thenReturn(false); [EOL] typeVarAssigns.put(var1, var2); [EOL] typeVarAssigns.put(var2, var1); [EOL] Type result = unrollVariableAssignments(var1, typeVarAssigns); [EOL] assertSame(var1, result); [EOL] }
public void testUnrollVariableAssignmentsWithEqualTypeVariable() { [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] TypeVariable<?> var = mock(TypeVariable.class); [EOL] when(var.equals(var)).thenReturn(true); [EOL] typeVarAssigns.put(var, var); [EOL] Type result = unrollVariableAssignments(var, typeVarAssigns); [EOL] assertSame(var, result); [EOL] }
public void testIsAssignableWithNullType() { [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] assertTrue(isAssignable(null, toGenericArrayType, typeVarAssigns)); [EOL] }
public void testIsAssignableWithNullToGenericArrayType() { [EOL] Type type = mock(Type.class); [EOL] assertFalse(isAssignable(type, null, null)); [EOL] }
public void testIsAssignableWithEqualTypes() { [EOL] Type type = mock(Type.class); [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] when(toGenericArrayType.equals(type)).thenReturn(true); [EOL] assertTrue(isAssignable(type, toGenericArrayType, null)); [EOL] }
public void testIsAssignableWithClassTypeArray() { [EOL] Class<?> cls = mock(Class.class); [EOL] when(cls.isArray()).thenReturn(true); [EOL] Type toComponentType = mock(Type.class); [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] when(toGenericArrayType.getGenericComponentType()).thenReturn(toComponentType); [EOL] when(cls.getComponentType()).thenReturn(toComponentType); [EOL] assertTrue(isAssignable(cls, toGenericArrayType, null)); [EOL] }
public void testIsAssignableWithGenericArrayType() { [EOL] GenericArrayType type = mock(GenericArrayType.class); [EOL] Type toComponentType = mock(Type.class); [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] when(toGenericArrayType.getGenericComponentType()).thenReturn(toComponentType); [EOL] when(type.getGenericComponentType()).thenReturn(toComponentType); [EOL] assertTrue(isAssignable(type, toGenericArrayType, null)); [EOL] }
public void testIsAssignableWithWildcardType() { [EOL] WildcardType type = mock(WildcardType.class); [EOL] Type boundType = mock(Type.class); [EOL] Type[] bounds = new Type[]{boundType}; [EOL] when(type.getUpperBounds()).thenReturn(bounds); [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] when(toGenericArrayType.equals(boundType)).thenReturn(true); [EOL] assertTrue(isAssignable(type, toGenericArrayType, null)); [EOL] }
public void testIsAssignableWithTypeVariable() { [EOL] TypeVariable<?> type = mock(TypeVariable.class); [EOL] Type boundType = mock(Type.class); [EOL] Type[] bounds = new Type[]{boundType}; [EOL] when(type.getBounds()).thenReturn(bounds); [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] when(toGenericArrayType.equals(boundType)).thenReturn(true); [EOL] assertTrue(isAssignable(type, toGenericArrayType, null)); [EOL] }
public void testIsAssignableWithParameterizedType() { [EOL] ParameterizedType type = mock(ParameterizedType.class); [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] assertFalse(isAssignable(type, toGenericArrayType, null)); [EOL] }
public void testIsAssignableWithUnhandledType() { [EOL] Type type = new Type() { [EOL] }; [EOL] GenericArrayType toGenericArrayType = mock(GenericArrayType.class); [EOL] try { [EOL] isAssignable(type, toGenericArrayType, null); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testIsAssignableWithNullType() { [EOL] WildcardType wildcardType = mock(WildcardType.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] assertTrue(isAssignable(null, wildcardType, typeVarAssigns)); [EOL] }
public void testIsAssignableWithNullWildcardType() { [EOL] Type type = mock(Type.class); [EOL] assertFalse(isAssignable(type, null, null)); [EOL] }
public void testIsAssignableWithEqualTypes() { [EOL] Type type = mock(Type.class); [EOL] WildcardType wildcardType = mock(WildcardType.class); [EOL] when(wildcardType.equals(type)).thenReturn(true); [EOL] assertTrue(isAssignable(type, wildcardType, null)); [EOL] }
public void testIsAssignableWithWildcardTypeUpperBoundsNotAssignable() { [EOL] WildcardType type = mock(WildcardType.class); [EOL] WildcardType toWildcardType = mock(WildcardType.class); [EOL] Type boundType = mock(Type.class); [EOL] Type toBoundType = mock(Type.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] when(type.getUpperBounds()).thenReturn(new Type[]{boundType}); [EOL] when(toWildcardType.getUpperBounds()).thenReturn(new Type[]{toBoundType}); [EOL] when(toWildcardType.getLowerBounds()).thenReturn(new Type[]{}); [EOL] when(toWildcardType.equals(type)).thenReturn(false); [EOL] assertFalse(isAssignable(type, toWildcardType, typeVarAssigns)); [EOL] }
public void testIsAssignableWithWildcardTypeLowerBoundsNotAssignable() { [EOL] WildcardType type = mock(WildcardType.class); [EOL] WildcardType toWildcardType = mock(WildcardType.class); [EOL] Type boundType = mock(Type.class); [EOL] Type toBoundType = mock(Type.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] when(type.getLowerBounds()).thenReturn(new Type[]{boundType}); [EOL] when(toWildcardType.getLowerBounds()).thenReturn(new Type[]{toBoundType}); [EOL] when(toWildcardType.getUpperBounds()).thenReturn(new Type[]{}); [EOL] when(toWildcardType.equals(type)).thenReturn(false); [EOL] assertFalse(isAssignable(type, toWildcardType, typeVarAssigns)); [EOL] }
public void testIsAssignableWithTypeUpperBoundsNotAssignable() { [EOL] Type type = mock(Type.class); [EOL] WildcardType toWildcardType = mock(WildcardType.class); [EOL] Type toBoundType = mock(Type.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] when(toWildcardType.getUpperBounds()).thenReturn(new Type[]{toBoundType}); [EOL] when(toWildcardType.getLowerBounds()).thenReturn(new Type[]{}); [EOL] when(toWildcardType.equals(type)).thenReturn(false); [EOL] assertFalse(isAssignable(type, toWildcardType, typeVarAssigns)); [EOL] }
public void testIsAssignableWithTypeLowerBoundsNotAssignable() { [EOL] Type type = mock(Type.class); [EOL] WildcardType toWildcardType = mock(WildcardType.class); [EOL] Type toBoundType = mock(Type.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] when(toWildcardType.getLowerBounds()).thenReturn(new Type[]{toBoundType}); [EOL] when(toWildcardType.getUpperBounds()).thenReturn(new Type[]{}); [EOL] when(toWildcardType.equals(type)).thenReturn(false); [EOL] assertFalse(isAssignable(type, toWildcardType, typeVarAssigns)); [EOL] }
public void testSubstituteTypeVariablesWithTypeVariableAndNonNullAssigns() { [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] Type expectedType = mock(Type.class); [EOL] typeVarAssigns.put(typeVariable, expectedType); [EOL] Type result = substituteTypeVariables(typeVariable, typeVarAssigns); [EOL] assertEquals(expectedType, result); [EOL] }
public void testSubstituteTypeVariablesWithTypeVariableAndNullAssigns() { [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] try { [EOL] substituteTypeVariables(typeVariable, typeVarAssigns); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSubstituteTypeVariablesWithNonTypeVariable() { [EOL] Type nonTypeVariable = mock(Type.class); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] Type result = substituteTypeVariables(nonTypeVariable, typeVarAssigns); [EOL] assertEquals(nonTypeVariable, result); [EOL] }
public void testSubstituteTypeVariablesWithNullType() { [EOL] Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<>(); [EOL] Type result = substituteTypeVariables(null, typeVarAssigns); [EOL] assertNull(result); [EOL] }
public void testSubstituteTypeVariablesWithNullAssigns() { [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] Type result = substituteTypeVariables(typeVariable, null); [EOL] assertEquals(typeVariable, result); [EOL] }
public void testGetTypeArgumentsWithNullType() { [EOL] Map<TypeVariable<?>, Type> result = TypeUtils.getTypeArguments(null, Object.class); [EOL] assertNull(result); [EOL] } [EOL] public void testGetTypeArgumentsWithNonNullType() { [EOL] Map<TypeVariable<?>, Type> result = TypeUtils.getTypeArguments(String.class, Object.class); [EOL] assertNotNull(result); [EOL] }
public void testGetTypeArgumentsWithClass() { [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(String.class, String.class, new HashMap<TypeVariable<?>, Type>()); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetTypeArgumentsWithParameterizedType() throws NoSuchFieldException { [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(type, List.class, new HashMap<TypeVariable<?>, Type>()); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(String.class, result.values().iterator().next()); [EOL] }
public void testGetTypeArgumentsWithGenericArrayType() throws NoSuchFieldException { [EOL] Type type = getClass().getDeclaredField("arrayOfListOfString").getGenericType(); [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(type, List[].class, new HashMap<TypeVariable<?>, Type>()); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(String.class, ((Type[]) result.values().toArray())[0]); [EOL] }
public void testGetTypeArgumentsWithWildcardType() throws NoSuchFieldException { [EOL] Type type = getClass().getDeclaredField("wildcardType").getGenericType(); [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(type, Class.forName("java.util.Collection"), new HashMap<TypeVariable<?>, Type>()); [EOL] assertNull(result); [EOL] }
public void testGetTypeArgumentsWithTypeVariable() throws NoSuchFieldException { [EOL] Type type = getClass().getTypeParameters()[0]; [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(type, Object.class, new HashMap<TypeVariable<?>, Type>()); [EOL] assertNull(result); [EOL] }
public void testGetTypeArgumentsWithUnhandledType() { [EOL] try { [EOL] getTypeArguments(new Type() {}, String.class, new HashMap<TypeVariable<?>, Type>()); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL] final Class<?> cls = getRawType(parameterizedType); [EOL] if (!isAssignable(cls, toClass)) { [EOL] return null; [EOL] } [EOL] final Type ownerType = parameterizedType.getOwnerType(); [EOL] Map<TypeVariable<?>, Type> typeVarAssigns; [EOL] if (ownerType instanceof ParameterizedType) { [EOL] final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL] typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL] } else { [EOL] typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL] } [EOL] final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL] final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL] for (int i = 0; i < typeParams.length; i++) { [EOL] final Type typeArg = typeArgs[i]; [EOL] typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL] } [EOL] if (toClass.equals(cls)) { [EOL] return typeVarAssigns; [EOL] } [EOL] return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
public void testGetTypeArguments_NotAssignable() { [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(String.class, Integer.class, null); [EOL] assertNull(result); [EOL] }
public void testGetTypeArguments_PrimitiveToClass() { [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(int.class, Integer.class, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetTypeArguments_PrimitiveToPrimitive() { [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(int.class, int.class, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetTypeArguments_ClassToSameClass() { [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(String.class, String.class, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetTypeArguments_WithSubtypeVarAssigns() { [EOL] Map<TypeVariable<?>, Type> subtypeVarAssigns = new HashMap<>(); [EOL] subtypeVarAssigns.put(String.class.getTypeParameters()[0], Integer.class); [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(String.class, String.class, subtypeVarAssigns); [EOL] assertNotNull(result); [EOL] assertEquals(subtypeVarAssigns, result); [EOL] }
public void testGetTypeArguments_RecursiveCase() { [EOL] Map<TypeVariable<?>, Type> result = getTypeArguments(ArrayList.class, List.class, null); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetClosestParentTypeWithInterfaceSuperClass() { [EOL] Class<?> cls = ArrayList.class; [EOL] Class<?> superClass = List.class; [EOL] Type result = getClosestParentType(cls, superClass); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedType = (ParameterizedType) result; [EOL] assertEquals(superClass, parameterizedType.getRawType()); [EOL] }
public void testGetClosestParentTypeWithNonInterfaceSuperClass() { [EOL] Class<?> cls = Integer.class; [EOL] Class<?> superClass = Number.class; [EOL] Type result = getClosestParentType(cls, superClass); [EOL] assertTrue(result instanceof Class<?>); [EOL] Class<?> resultClass = (Class<?>) result; [EOL] assertEquals(superClass, resultClass); [EOL] }
public void testGetClosestParentTypeWithUnrelatedSuperClass() { [EOL] Class<?> cls = Integer.class; [EOL] Class<?> superClass = List.class; [EOL] try { [EOL] getClosestParentType(cls, superClass); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetClosestParentTypeWithClassImplementingMultipleInterfaces() { [EOL] Class<?> cls = LinkedHashMap.class; [EOL] Class<?> superClass = Map.class; [EOL] Type result = getClosestParentType(cls, superClass); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedType = (ParameterizedType) result; [EOL] assertEquals(superClass, parameterizedType.getRawType()); [EOL] }
public void testNormalizeUpperBounds_SingleElement() { [EOL] Type[] singleBound = new Type[] { String.class }; [EOL] Type[] result = TypeUtils.normalizeUpperBounds(singleBound); [EOL] assertEquals("Array should be the same as the input array when there is only one element.", singleBound, result); [EOL] } [EOL] public void testNormalizeUpperBounds_MultipleElementsNoSubtypes() { [EOL] Type[] multipleBounds = new Type[] { String.class, Integer.class }; [EOL] Type[] result = TypeUtils.normalizeUpperBounds(multipleBounds); [EOL] assertEquals("Array should be the same as the input array when there are no subtypes.", multipleBounds, result); [EOL] } [EOL] public void testNormalizeUpperBounds_MultipleElementsWithSubtypes() { [EOL] Type[] multipleBounds = new Type[] { Integer.class, Number.class }; [EOL] Type[] result = TypeUtils.normalizeUpperBounds(multipleBounds); [EOL] assertEquals("Array should contain only the supertype when subtypes are present.", 1, result.length); [EOL] assertEquals("Array should contain Number.class as it is the supertype of Integer.class.", Number.class, result[0]); [EOL] }
public void testNormalizeUpperBounds_MultipleElementsWithDuplicates() { [EOL] Type[] multipleBoundsWithDuplicates = new Type[] { Integer.class, Integer.class }; [EOL] Type[] result = TypeUtils.normalizeUpperBounds(multipleBoundsWithDuplicates); [EOL] assertEquals("Array should contain only one instance of the element when duplicates are present.", 1, result.length); [EOL] assertEquals("Array should contain Integer.class.", Integer.class, result[0]); [EOL] }
public void testGetImplicitUpperBounds_WithNoUpperBounds() { [EOL] WildcardType wildcardType = mock(WildcardType.class); [EOL] when(wildcardType.getUpperBounds()).thenReturn(new Type[0]); [EOL] Type[] result = TypeUtils.getImplicitUpperBounds(wildcardType); [EOL] assertEquals(1, result.length); [EOL] assertEquals(Object.class, result[0]); [EOL] }
public void testGetImplicitUpperBounds_WithUpperBounds() { [EOL] WildcardType wildcardType = mock(WildcardType.class); [EOL] Type[] upperBounds = new Type[] { String.class }; [EOL] when(wildcardType.getUpperBounds()).thenReturn(upperBounds); [EOL] Type[] result = TypeUtils.getImplicitUpperBounds(wildcardType); [EOL] assertArrayEquals(upperBounds, result); [EOL] }
public void testGetImplicitLowerBoundsWithNoLowerBounds() { [EOL] WildcardType wildcardType = mock(WildcardType.class); [EOL] when(wildcardType.getLowerBounds()).thenReturn(new Type[0]); [EOL] Type[] result = TypeUtils.getImplicitLowerBounds(wildcardType); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertNull(result[0]); [EOL] }
public void testGetImplicitLowerBoundsWithLowerBounds() { [EOL] WildcardType wildcardType = mock(WildcardType.class); [EOL] Type[] expectedBounds = new Type[] { String.class }; [EOL] when(wildcardType.getLowerBounds()).thenReturn(expectedBounds); [EOL] Type[] result = TypeUtils.getImplicitLowerBounds(wildcardType); [EOL] assertNotNull(result); [EOL] assertEquals(expectedBounds.length, result.length); [EOL] assertSame(expectedBounds[0], result[0]); [EOL] }
public void testGetRawTypeWithParameterizedType() { [EOL] ParameterizedType parameterizedType = Mockito.mock(ParameterizedType.class); [EOL] Class<?> expectedRawType = List.class; [EOL] Mockito.when(parameterizedType.getRawType()).thenReturn(expectedRawType); [EOL] Class<?> actualRawType = getRawType(parameterizedType); [EOL] assertEquals(expectedRawType, actualRawType); [EOL] } [EOL] public void testGetRawTypeWithNonClassRawType() { [EOL] ParameterizedType parameterizedType = Mockito.mock(ParameterizedType.class); [EOL] Type nonClassRawType = Mockito.mock(Type.class); [EOL] Mockito.when(parameterizedType.getRawType()).thenReturn(nonClassRawType); [EOL] try { [EOL] getRawType(parameterizedType); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Wait... What!? Type of rawType: " + nonClassRawType, e.getMessage()); [EOL] } [EOL] }
public void testGetArrayComponentTypeWithClass() { [EOL] Type type = String[].class; [EOL] Type result = YourClass.getArrayComponentType(type); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] type = String.class; [EOL] result = YourClass.getArrayComponentType(type); [EOL] assertNull(result); [EOL] }
public void testGetArrayComponentTypeWithGenericArrayType() { [EOL] Type genericArrayType = new GenericArrayType() { [EOL] @Override [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] Type result = YourClass.getArrayComponentType(genericArrayType); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetArrayComponentTypeWithNonArrayType() { [EOL] Type type = new Type() {}; [EOL] Type result = YourClass.getArrayComponentType(type); [EOL] assertNull(result); [EOL] }
public void testGetContextLabelsEmpty() { [EOL] Context context = new Context(); [EOL] Set<String> labels = context.getContextLabels(); [EOL] assertTrue(labels.isEmpty()); [EOL] }
public void testGetContextLabelsSingleElement() { [EOL] Context context = new Context(); [EOL] context.addValue("label1", "value1"); [EOL] Set<String> labels = context.getContextLabels(); [EOL] assertEquals(1, labels.size()); [EOL] assertTrue(labels.contains("label1")); [EOL] }
public void testGetContextLabelsMultipleElements() { [EOL] Context context = new Context(); [EOL] context.addValue("label1", "value1"); [EOL] context.addValue("label2", "value2"); [EOL] Set<String> labels = context.getContextLabels(); [EOL] assertEquals(2, labels.size()); [EOL] assertTrue(labels.contains("label1")); [EOL] assertTrue(labels.contains("label2")); [EOL] }
public void testGetContextEntries() { [EOL] YourExceptionClass instance = new YourExceptionClass(); [EOL] List<Pair<String, Object>> expected = new ArrayList<>(); [EOL] instance.contextValues = expected; [EOL] List<Pair<String, Object>> result = instance.getContextEntries(); [EOL] assertSame("Context entries should be the same as expected", expected, result); [EOL] }
public void testGetNullText() { [EOL] String expected = "someValue"; [EOL] MyClass instance = new MyClass(expected); [EOL] String result = instance.getNullText(); [EOL] assertEquals(expected, result); [EOL] }
public void testAppendNewLine_WithDefaultNewLine() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendNewLine(); [EOL] assertEquals(SystemUtils.LINE_SEPARATOR, builder.toString()); [EOL] } [EOL] public void testAppendNewLine_WithCustomNewLine() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNewLine("\n"); [EOL] builder.appendNewLine(); [EOL] assertEquals("\n", builder.toString()); [EOL] }
public void testAppendStringValid() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] sb.append(str, 1, 3); [EOL] assertEquals("bcd", sb.toString()); [EOL] } [EOL] public void testAppendStringNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(null, 0, 0); [EOL] assertEquals("null", sb.toString()); [EOL] } [EOL] public void testAppendStringInvalidStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, -1, 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringInvalidLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, 1, -1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringStartIndexGreaterThanLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, 7, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringLengthExceedsStrLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, 1, 6); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringZeroLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] sb.append(str, 2, 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendWithFormatAndMultipleObjects() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String format = "Hello %s and %s"; [EOL] String obj1 = "World"; [EOL] String obj2 = "Everyone"; [EOL] sb.append(format, obj1, obj2); [EOL] assertEquals("Hello World and Everyone", sb.toString()); [EOL] }
public void testAppendWithFormatAndNoObjects() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String format = "Hello World"; [EOL] sb.append(format); [EOL] assertEquals("Hello World", sb.toString()); [EOL] }
public void testAppendWithFormatAndNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String format = null; [EOL] Object[] objs = null; [EOL] sb.append(format, objs); [EOL] assertEquals("null", sb.toString()); [EOL] }
public void testAppendWithFormatAndSingleObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String format = "Value: %d"; [EOL] int value = 10; [EOL] sb.append(format, value); [EOL] assertEquals("Value: 10", sb.toString()); [EOL] }
public void testAppendStringBufferWithValidParams() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuffer strBuffer = new StringBuffer("abcdef"); [EOL] sb.append(strBuffer, 1, 3); [EOL] assertEquals("bcd", sb.toString()); [EOL] }
public void testAppendStringBufferWithNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((StringBuffer) null, 0, 0); [EOL] assertEquals("null", sb.toString()); [EOL] }
public void testAppendStringBufferWithInvalidStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuffer strBuffer = new StringBuffer("abcdef"); [EOL] try { [EOL] sb.append(strBuffer, -1, 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendStringBufferWithInvalidLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuffer strBuffer = new StringBuffer("abcdef"); [EOL] try { [EOL] sb.append(strBuffer, 1, -1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendStringBufferWithLengthExceedingBuffer() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuffer strBuffer = new StringBuffer("abcdef"); [EOL] try { [EOL] sb.append(strBuffer, 4, 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendStringBufferWithStartIndexExceedingBufferLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuffer strBuffer = new StringBuffer("abcdef"); [EOL] try { [EOL] sb.append(strBuffer, 7, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendStringBuilderNull() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = null; [EOL] builder.append(str, 0, 0); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendStringBuilderInvalidStartIndex() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] try { [EOL] builder.append(str, 4, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendStringBuilderInvalidLength() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] try { [EOL] builder.append(str, 1, 5); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendStringBuilderValid() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abc"); [EOL] builder.append(str, 1, 2); [EOL] assertEquals("bc", builder.toString()); [EOL] }
public void testAppendCharArrayNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = null; [EOL] sb.append(chars, 0, 0); [EOL] assertEquals("appendNull should be called", "null", sb.toString()); [EOL] } [EOL] public void testAppendCharArrayInvalidStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] try { [EOL] sb.append(chars, -1, 1); [EOL] fail("Should throw StringIndexOutOfBoundsException for invalid startIndex"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendCharArrayInvalidLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] try { [EOL] sb.append(chars, 0, -1); [EOL] fail("Should throw StringIndexOutOfBoundsException for invalid length"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendCharArrayOutOfBounds() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] try { [EOL] sb.append(chars, 1, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException when startIndex + length > chars.length"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendCharArrayValid() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.append(chars, 0, 3); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testAppendCharArrayPartial() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] sb.append(chars, 1, 3); [EOL] assertEquals("bcd", sb.toString()); [EOL] }
public void testAppendTrue() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(true); [EOL] assertEquals("true", sb.toString()); [EOL] }
public void testAppendFalse() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(false); [EOL] assertEquals("false", sb.toString()); [EOL] }
public void testAppendChar() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append('a'); [EOL] assertEquals("a", sb.toString()); [EOL] assertEquals(1, sb.length()); [EOL] assertEquals(1, sb.size()); [EOL] }
public void testAppendCharAtCapacity() { [EOL] StrBuilder sb = new StrBuilder(1); [EOL] sb.append('a'); [EOL] sb.append('b'); [EOL] assertEquals("ab", sb.toString()); [EOL] assertEquals(2, sb.length()); [EOL] assertEquals(2, sb.size()); [EOL] }
public void testAppendlnWithValidInput() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] sb.appendln(str, 0, 3); [EOL] assertEquals("abc" + System.lineSeparator(), sb.toString()); [EOL] } [EOL] public void testAppendlnWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = ""; [EOL] sb.appendln(str, 0, 0); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] } [EOL] public void testAppendlnWithNullString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln(null, 0, 0); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] } [EOL] public void testAppendlnWithInvalidRange() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.appendln(str, 0, 10); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendlnWithNegativeStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.appendln(str, -1, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendlnWithNegativeLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.appendln(str, 0, -1); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }

public void testAppendlnWithFormatAndObjects() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln("%s %s", "Hello", "World"); [EOL] assertEquals("Hello World" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithNullFormat() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln(null, (Object) null); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithEmptyFormat() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln("", (Object) null); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnWithFormatAndNoObjects() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln("Test"); [EOL] assertEquals("Test" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnStringBuilderStartIndexLength_NullStringBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((StringBuilder) null, 0, 5); [EOL] assertEquals(sb.length(), sb.getNewLineText().length()); [EOL] } [EOL] public void testAppendlnStringBuilderStartIndexLength_InvalidStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abcdef"); [EOL] try { [EOL] sb.appendln(str, -1, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendlnStringBuilderStartIndexLength_InvalidLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abcdef"); [EOL] try { [EOL] sb.appendln(str, 2, -1); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendlnStringBuilderStartIndexLength_ValidInputs() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abcdef"); [EOL] sb.appendln(str, 1, 3); [EOL] assertEquals("bcde" + sb.getNewLineText(), sb.toString()); [EOL] }
public void testAppendlnStringBuilderStartIndexLength_LengthExceeds() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abcdef"); [EOL] sb.appendln(str, 2, 10); [EOL] assertEquals("cdef" + sb.getNewLineText(), sb.toString()); [EOL] }
public void testAppendlnStringBuilderStartIndexLength_StartIndexAtEnd() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StringBuilder str = new StringBuilder("abcdef"); [EOL] sb.appendln(str, 6, 2); [EOL] assertEquals(sb.getNewLineText(), sb.toString()); [EOL] }
public void testAppendSeparator_StringInt_LoopIndexGreaterThanZero() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(":", 1); [EOL] assertEquals(":", sb.toString()); [EOL] }
public void testAppendSeparator_StringInt_LoopIndexZero() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(":", 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendSeparator_StringInt_LoopIndexLessThanZero() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(":", -1); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendSeparator_StringInt_SeparatorIsNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator(null, 1); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_PositiveWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 5, 'X'); [EOL] assertEquals("abcXX", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_WidthEqualToLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 3, 'X'); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_WidthLessThanLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 2, 'X'); [EOL] assertEquals("ab", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_NullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNullText("null"); [EOL] sb.appendFixedWidthPadRight(null, 5, 'X'); [EOL] assertEquals("nullX", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_EmptyObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("", 5, 'X'); [EOL] assertEquals("XXXXX", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_NegativeWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", -1, 'X'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_ZeroWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 0, 'X'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_PositiveWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight(123, 5, '0'); [EOL] assertEquals("12300", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_NegativeWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight(123, -1, '0'); [EOL] assertEquals("123", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_ZeroWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight(123, 0, '0'); [EOL] assertEquals("123", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_WidthEqualLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight(12345, 5, '0'); [EOL] assertEquals("12345", sb.toString()); [EOL] }
public void testDeleteFirst_CharNotFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrBuilder result = strBuilder.deleteFirst('d'); [EOL] assertEquals("abc", result.toString()); [EOL] }
public void testDeleteFirst_CharFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrBuilder result = strBuilder.deleteFirst('b'); [EOL] assertEquals("ac", result.toString()); [EOL] }
public void testDeleteFirst_EmptyBuilder() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StrBuilder result = strBuilder.deleteFirst('b'); [EOL] assertEquals("", result.toString()); [EOL] }
public void testReplaceFirstWithNonNullSearchAndReplace() { [EOL] StrBuilder builder = new StrBuilder("abcabc"); [EOL] builder.replaceFirst("a", "z"); [EOL] assertEquals("zbcabc", builder.toString()); [EOL] }
public void testReplaceFirstWithNullSearch() { [EOL] StrBuilder builder = new StrBuilder("abcabc"); [EOL] builder.replaceFirst(null, "z"); [EOL] assertEquals("abcabc", builder.toString()); [EOL] }
public void testReplaceFirstWithEmptySearch() { [EOL] StrBuilder builder = new StrBuilder("abcabc"); [EOL] builder.replaceFirst("", "z"); [EOL] assertEquals("abcabc", builder.toString()); [EOL] }
public void testReplaceFirstWithNonNullSearchAndNullReplace() { [EOL] StrBuilder builder = new StrBuilder("abcabc"); [EOL] builder.replaceFirst("a", null); [EOL] assertEquals("bcabc", builder.toString()); [EOL] }
public void testReplaceFirstWithSearchNotFound() { [EOL] StrBuilder builder = new StrBuilder("abcabc"); [EOL] builder.replaceFirst("d", "z"); [EOL] assertEquals("abcabc", builder.toString()); [EOL] }
public void testReplaceFirst_NullMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] String replaceStr = "x"; [EOL] builder.replaceFirst(null, replaceStr); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testReplaceFirst_EmptyMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.noneMatcher(); [EOL] String replaceStr = "x"; [EOL] builder.replaceFirst(matcher, replaceStr); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testReplaceFirst_NoMatch() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("d"); [EOL] String replaceStr = "x"; [EOL] builder.replaceFirst(matcher, replaceStr); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testReplaceFirst_Match() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "x"; [EOL] builder.replaceFirst(matcher, replaceStr); [EOL] assertEquals("axc", builder.toString()); [EOL] }
public void testReplaceFirst_MatchAtStart() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("a"); [EOL] String replaceStr = "x"; [EOL] builder.replaceFirst(matcher, replaceStr); [EOL] assertEquals("xbc", builder.toString()); [EOL] }
public void testReplaceFirst_MatchAtEnd() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("c"); [EOL] String replaceStr = "x"; [EOL] builder.replaceFirst(matcher, replaceStr); [EOL] assertEquals("abx", builder.toString()); [EOL] }
public void testReplaceFirst_ReplaceWithNull() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] builder.replaceFirst(matcher, null); [EOL] assertEquals("ac", builder.toString()); [EOL] }
public void testReplaceFirst_ReplaceWithEmpty() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] builder.replaceFirst(matcher, ""); [EOL] assertEquals("ac", builder.toString()); [EOL] }
public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_NullMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] String replaceStr = "xyz"; [EOL] StrBuilder result = builder.replace(null, replaceStr, 0, 3, 1); [EOL] assertEquals("xyz", result.toString()); [EOL] } [EOL] public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_ValidMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "xyz"; [EOL] StrBuilder result = builder.replace(matcher, replaceStr, 0, 3, 1); [EOL] assertEquals("axyzc", result.toString()); [EOL] } [EOL] public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_NoMatch() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("d"); [EOL] String replaceStr = "xyz"; [EOL] StrBuilder result = builder.replace(matcher, replaceStr, 0, 3, 1); [EOL] assertEquals("abc", result.toString()); [EOL] } [EOL] public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_InvalidRange() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "xyz"; [EOL] try { [EOL] builder.replace(matcher, replaceStr, 4, 3, 1); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_ReplaceCountZero() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "xyz"; [EOL] StrBuilder result = builder.replace(matcher, replaceStr, 0, 3, 0); [EOL] assertEquals("abc", result.toString()); [EOL] } [EOL] public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_ReplaceCountNegative() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "xyz"; [EOL] StrBuilder result = builder.replace(matcher, replaceStr, 0, 3, -1); [EOL] assertEquals("axyzc", result.toString()); [EOL] }
public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_EndIndexGreaterThanLength() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "xyz"; [EOL] StrBuilder result = builder.replace(matcher, replaceStr, 0, 10, 1); [EOL] assertEquals("axyzc", result.toString()); [EOL] } [EOL] public void testReplace_StrMatcher_String_StartIndexEndIndexReplaceCount_StartIndexNegative() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.stringMatcher("b"); [EOL] String replaceStr = "xyz"; [EOL] try { [EOL] builder.replace(matcher, replaceStr, -1, 3, 1); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReplaceImpl_MatcherNull() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replaceImpl(null, "xyz", 0, builder.length(), 2); [EOL] assertEquals("abc", result.toString()); [EOL] } [EOL] public void testReplaceImpl_EmptyBuilder() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('a'), "xyz", 0, builder.length(), 2); [EOL] assertEquals("", result.toString()); [EOL] } [EOL] public void testReplaceImpl_NoMatch() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('d'), "xyz", 0, builder.length(), 2); [EOL] assertEquals("abc", result.toString()); [EOL] } [EOL] public void testReplaceImpl_ReplaceOnce() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('b'), "xyz", 0, builder.length(), 1); [EOL] assertEquals("axyzc", result.toString()); [EOL] } [EOL] public void testReplaceImpl_ReplaceAll() { [EOL] StrBuilder builder = new StrBuilder("abbc"); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('b'), "xyz", 0, builder.length(), -1); [EOL] assertEquals("axyzxyzc", result.toString()); [EOL] } [EOL] public void testReplaceImpl_ReplaceNoneDueToCount() { [EOL] StrBuilder builder = new StrBuilder("abbc"); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('b'), "xyz", 0, builder.length(), 0); [EOL] assertEquals("abbc", result.toString()); [EOL] } [EOL] public void testReplaceImpl_ReplaceWithNull() { [EOL] StrBuilder builder = new StrBuilder("abbc"); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('b'), null, 0, builder.length(), -1); [EOL] assertEquals("ac", result.toString()); [EOL] } [EOL] public void testReplaceImpl_InvalidRange() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] StrBuilder result = builder.replaceImpl(StrMatcher.charMatcher('a'), "xyz", 1, 0, 2); [EOL] assertEquals("abc", result.toString()); [EOL] }

public void testReverse_EmptyStrBuilder() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StrBuilder reversed = strBuilder.reverse(); [EOL] assertEquals("", reversed.toString()); [EOL] }
public void testReverse_NonEmptyStrBuilder() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrBuilder reversed = strBuilder.reverse(); [EOL] assertEquals("cba", reversed.toString()); [EOL] }
public void testTrim_EmptyStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals(0, trimmed.length()); [EOL] assertSame(sb, trimmed); [EOL] }
public void testTrim_NoTrimNeeded() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] assertSame(sb, trimmed); [EOL] }
public void testTrim_TrimStart() { [EOL] StrBuilder sb = new StrBuilder("  abc"); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] }
public void testTrim_TrimEnd() { [EOL] StrBuilder sb = new StrBuilder("abc  "); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] }
public void testTrim_TrimStartAndEnd() { [EOL] StrBuilder sb = new StrBuilder("  abc  "); [EOL] StrBuilder trimmed = sb.trim(); [EOL] assertEquals("abc", trimmed.toString()); [EOL] }
public void testSubSequence_StartIndexNegative_ThrowsException() { [EOL] try { [EOL] someObject.subSequence(-1, 2); [EOL] fail("Expected StringIndexOutOfBoundsException for negative startIndex"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubSequence_EndIndexGreaterThanSize_ThrowsException() { [EOL] try { [EOL] someObject.subSequence(0, someObject.size() + 1); [EOL] fail("Expected StringIndexOutOfBoundsException for endIndex greater than size"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubSequence_StartIndexGreaterThanEndIndex_ThrowsException() { [EOL] try { [EOL] someObject.subSequence(3, 2); [EOL] fail("Expected StringIndexOutOfBoundsException for startIndex greater than endIndex"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubSequence_ValidIndices_ReturnsSubstring() { [EOL] CharSequence result = someObject.subSequence(1, 3); [EOL] assertEquals("Expected substring does not match", "expected_substring", result.toString()); [EOL] }
public void testRightString_LengthLessThanOrEqualToZero() { [EOL] final int length = 0; [EOL] StringUtils su = new StringUtils(new char[]{'a', 'b', 'c'}, 3); [EOL] String result = su.rightString(length); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRightString_LengthGreaterThanOrEqualToSize() { [EOL] final int length = 3; [EOL] StringUtils su = new StringUtils(new char[]{'a', 'b', 'c'}, 3); [EOL] String result = su.rightString(length); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testRightString_LengthLessThanSize() { [EOL] final int length = 2; [EOL] StringUtils su = new StringUtils(new char[]{'a', 'b', 'c'}, 3); [EOL] String result = su.rightString(length); [EOL] assertEquals("bc", result); [EOL] }
public boolean contains(final String str) { [EOL] return indexOf(str, 0) >= 0; [EOL] }
public void testContains_MatcherNotNull_Found() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('a'); [EOL] boolean result = strBuilder.contains(matcher); [EOL] assertTrue(result); [EOL] }
public void testContains_MatcherNotNull_NotFound() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] StrMatcher matcher = StrMatcher.charMatcher('d'); [EOL] boolean result = strBuilder.contains(matcher); [EOL] assertFalse(result); [EOL] }
public void testContains_MatcherNull() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] boolean result = strBuilder.contains(null); [EOL] assertFalse(result); [EOL] }
public void testLastIndexOf_NullInput() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] int index = stringUtils.lastIndexOf(null); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_EmptyString() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] int index = stringUtils.lastIndexOf(""); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_ValidInput() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] stringUtils.append("abcabc"); [EOL] int index = stringUtils.lastIndexOf("abc"); [EOL] assertEquals(3, index); [EOL] }
public void testLastIndexOf_NotFound() { [EOL] StringUtils stringUtils = new StringUtils(); [EOL] stringUtils.append("hello"); [EOL] int index = stringUtils.lastIndexOf("world"); [EOL] assertEquals(-1, index); [EOL] }
public void testEqualsIgnoreCase_SameObject() { [EOL] StrBuilder sb = new StrBuilder("test"); [EOL] assertTrue(sb.equalsIgnoreCase(sb)); [EOL] } [EOL] public void testEqualsIgnoreCase_DifferentSize() { [EOL] StrBuilder sb1 = new StrBuilder("test"); [EOL] StrBuilder sb2 = new StrBuilder("testing"); [EOL] assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL] } [EOL] public void testEqualsIgnoreCase_DifferentContent() { [EOL] StrBuilder sb1 = new StrBuilder("test"); [EOL] StrBuilder sb2 = new StrBuilder("Test"); [EOL] assertTrue(sb1.equalsIgnoreCase(sb2)); [EOL] } [EOL] public void testEqualsIgnoreCase_CompletelyDifferent() { [EOL] StrBuilder sb1 = new StrBuilder("test"); [EOL] StrBuilder sb2 = new StrBuilder("abcd"); [EOL] assertFalse(sb1.equalsIgnoreCase(sb2)); [EOL] }
public void testToStringBuffer_Empty() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StringBuffer stringBuffer = strBuilder.toStringBuffer(); [EOL] assertEquals(0, stringBuffer.length()); [EOL] }
public void testToStringBuffer_WithContent() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.append("abc"); [EOL] StringBuffer stringBuffer = strBuilder.toStringBuffer(); [EOL] assertEquals("abc", stringBuffer.toString()); [EOL] }
public void testValidateRange_StartIndexNegative() { [EOL] try { [EOL] validateRange(-1, 10); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("String index out of range: -1", e.getMessage()); [EOL] } [EOL] }
public void testValidateRange_EndIndexGreaterThanSize() { [EOL] final int size = 5; [EOL] int endIndex = validateRange(0, 10); [EOL] assertEquals(size, endIndex); [EOL] }
public void testValidateRange_StartIndexGreaterThanEndIndex() { [EOL] try { [EOL] validateRange(5, 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assertEquals("end < start", e.getMessage()); [EOL] } [EOL] }
public void testValidateRange_ValidRange() { [EOL] final int size = 5; [EOL] int endIndex = validateRange(1, 3); [EOL] assertEquals(3, endIndex); [EOL] }
public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL] return printer.format(obj, toAppendTo, pos); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=2L; int FULL=DateFormat.FULL; int LONG=DateFormat.LONG; int MEDIUM=DateFormat.MEDIUM; int SHORT=DateFormat.SHORT; FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] } [EOL] }
public void testParseObject() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Object parsedObj = fdf.parseObject("2023-04-01", pos); [EOL] assertNotNull(parsedObj); [EOL] assertTrue(parsedObj instanceof Date); [EOL] }
public void testGetInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] assertNotNull(fdf); [EOL] }
public void testGetInstanceWithPattern() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] assertNotNull(fdf); [EOL] assertEquals("yyyy-MM-dd", fdf.getPattern()); [EOL] }
public void testGetInstanceWithPatternAndTimeZone() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd", timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetInstanceWithPatternAndLocale() { [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd", locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetInstanceWithPatternTimeZoneAndLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd", timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateInstanceWithLocale() { [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateInstanceWithTimeZone() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetDateInstanceWithTimeZoneAndLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetTimeInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(FastDateFormat.SHORT); [EOL] assertNotNull(fdf); [EOL] }
public void testGetTimeInstanceWithLocale() { [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(FastDateFormat.SHORT, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetTimeInstanceWithTimeZone() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(FastDateFormat.SHORT, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetTimeInstanceWithTimeZoneAndLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(FastDateFormat.SHORT, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateTimeInstance() { [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT); [EOL] assertNotNull(fdf); [EOL] }
public void testGetDateTimeInstanceWithLocale() { [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateTimeInstanceWithTimeZone() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetDateTimeInstanceWithTimeZoneAndLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("UTC"); [EOL] Locale locale = Locale.FRANCE; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetPattern() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] String pattern = fdf.getPattern(); [EOL] assertEquals("Pattern should match the one provided", "yyyy-MM-dd", pattern); [EOL] }
public void testEquals_Same() { [EOL] FastDateFormat fdf1 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] assertEquals("Instances with the same pattern should be equal", fdf1, fdf2); [EOL] }
public void testEquals_DifferentPattern() { [EOL] FastDateFormat fdf1 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("MM/dd/yyyy"); [EOL] assertNotEquals("Instances with different patterns should not be equal", fdf1, fdf2); [EOL] }
public void testHashCode_Same() { [EOL] FastDateFormat fdf1 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] assertEquals("Hash codes should be the same for instances with the same pattern", fdf1.hashCode(), fdf2.hashCode()); [EOL] }
public void testHashCode_DifferentPattern() { [EOL] FastDateFormat fdf1 = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] FastDateFormat fdf2 = FastDateFormat.getInstance("MM/dd/yyyy"); [EOL] assertNotEquals("Hash codes should be different for instances with different patterns", fdf1.hashCode(), fdf2.hashCode()); [EOL] }
public void testFormat_Date() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] Date date = new Date(); [EOL] String formattedDate = fdf.format(date); [EOL] assertNotNull("Formatted date should not be null", formattedDate); [EOL] }
public void testParse_ValidString() throws ParseException { [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] String dateString = "2023-01-01"; [EOL] Date parsedDate = fdf.parse(dateString); [EOL] assertNotNull("Parsed date should not be null", parsedDate); [EOL] }
public void testParse_InvalidString() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance("yyyy-MM-dd"); [EOL] String dateString = "invalid-date"; [EOL] try { [EOL] fdf.parse(dateString); [EOL] fail("ParseException should have been thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public String toString() { [EOL] return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public void testMutableTripleConstructor() { [EOL] MutableTriple<Object, Object, Object> mutableTriple = new MutableTriple<>(); [EOL] assertNull(mutableTriple.left); [EOL] assertNull(mutableTriple.middle); [EOL] assertNull(mutableTriple.right); [EOL] }
public void testGetDeclaredFieldWithNullClass() { [EOL] try { [EOL] ClassUtils.getDeclaredField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testGetDeclaredFieldWithNullFieldName() { [EOL] try { [EOL] ClassUtils.getDeclaredField(String.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testGetDeclaredFieldWithNonExistingField() { [EOL] Field field = ClassUtils.getDeclaredField(String.class, "nonExistingField", false); [EOL] assertNull("Should return null for non-existing field", field); [EOL] }
public void testGetDeclaredFieldWithoutForceAccess() { [EOL] Field field = ClassUtils.getDeclaredField(String.class, "value", false); [EOL] assertNull("Should return null when forceAccess is false and field is not accessible", field); [EOL] }
public void testGetDeclaredFieldWithForceAccess() { [EOL] Field field = ClassUtils.getDeclaredField(String.class, "value", true); [EOL] assertNotNull("Should return field when forceAccess is true", field); [EOL] assertTrue("Field should be accessible", field.isAccessible()); [EOL] }
public void testGetAllFieldsWithNullClass() { [EOL] Field[] fields = ClassUtils.getAllFields(null); [EOL] assertNull(fields); [EOL] } [EOL] public void testGetAllFieldsWithRegularClass() { [EOL] Field[] fields = ClassUtils.getAllFields(SomeClass.class); [EOL] assertNotNull(fields); [EOL] assertTrue(fields.length > 0); [EOL] } [EOL] public void testGetAllFieldsWithClassHavingNoFields() { [EOL] Field[] fields = ClassUtils.getAllFields(EmptyClass.class); [EOL] assertNotNull(fields); [EOL] assertEquals(0, fields.length); [EOL] } [EOL] public void testGetAllFieldsWithInheritedFields() { [EOL] Field[] fields = ClassUtils.getAllFields(ChildClass.class); [EOL] assertNotNull(fields); [EOL] assertTrue(fields.length > ParentClass.class.getDeclaredFields().length); [EOL] }
public void testReadFieldWithNullField() { [EOL] try { [EOL] FieldUtils.readField(null, new Object(), true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field must not be null", e.getMessage()); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadFieldWithInaccessibleField() throws NoSuchFieldException { [EOL] class TestClass { [EOL] private String privateField = "private value"; [EOL] } [EOL] TestClass testInstance = new TestClass(); [EOL] Field privateField = TestClass.class.getDeclaredField("privateField"); [EOL] try { [EOL] Object fieldValue = FieldUtils.readField(privateField, testInstance, true); [EOL] assertEquals("private value", fieldValue); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadFieldWithoutForceAccess() throws NoSuchFieldException { [EOL] class TestClass { [EOL] private String privateField = "private value"; [EOL] } [EOL] TestClass testInstance = new TestClass(); [EOL] Field privateField = TestClass.class.getDeclaredField("privateField"); [EOL] try { [EOL] FieldUtils.readField(privateField, testInstance, false); [EOL] fail("Should have thrown IllegalAccessException because field is not accessible"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testReadFieldWithValidArguments() throws IllegalAccessException { [EOL] MyClass target = new MyClass(); [EOL] String fieldName = "existingField"; [EOL] Object fieldValue = FieldUtils.readField(target, fieldName); [EOL] assertNotNull(fieldValue); [EOL] assertEquals("Expected field value", target.existingField, fieldValue); [EOL] }
public void testReadFieldWithInvalidFieldName() { [EOL] MyClass target = new MyClass(); [EOL] String fieldName = "nonExistingField"; [EOL] try { [EOL] FieldUtils.readField(target, fieldName); [EOL] fail("Should have thrown NoSuchFieldException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testReadFieldWithNullTarget() { [EOL] String fieldName = "anyField"; [EOL] try { [EOL] FieldUtils.readField(null, fieldName); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadFieldWithNullTarget() { [EOL] try { [EOL] FieldUtils.readField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null target"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("target object must not be null", e.getMessage()); [EOL] } [EOL] }
public void testReadFieldWithNonExistentField() { [EOL] try { [EOL] FieldUtils.readField(new Object(), "nonExistentField", true); [EOL] fail("Should have thrown IllegalArgumentException for non-existent field"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Cannot locate field nonExistentField on class java.lang.Object")); [EOL] } [EOL] }
public void testReadFieldWithExistingField() throws IllegalAccessException { [EOL] class TestClass { [EOL] private String privateField = "privateValue"; [EOL] } [EOL] TestClass testObj = new TestClass(); [EOL] Object fieldValue = FieldUtils.readField(testObj, "privateField", true); [EOL] assertEquals("privateValue", fieldValue); [EOL] }
public void testWriteDeclaredStaticField_ValidField() throws IllegalAccessException { [EOL] ClassWithStaticField.reset(); [EOL] String fieldName = "staticField"; [EOL] String newValue = "newValue"; [EOL] Lang3.writeDeclaredStaticField(ClassWithStaticField.class, fieldName, newValue); [EOL] assertEquals("Field should be updated to new value", newValue, ClassWithStaticField.staticField); [EOL] }
public void testWriteDeclaredStaticField_FieldDoesNotExist() { [EOL] try { [EOL] Lang3.writeDeclaredStaticField(ClassWithStaticField.class, "nonExistingField", "newValue"); [EOL] fail("Should throw NoSuchFieldException"); [EOL] } catch (NoSuchFieldException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for non-existing fields"); [EOL] } [EOL] }
public void testWriteDeclaredStaticField_NullClass() { [EOL] try { [EOL] Lang3.writeDeclaredStaticField(null, "anyField", "newValue"); [EOL] fail("Should throw NullPointerException for null class"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for null class"); [EOL] } [EOL] }
public void testWriteDeclaredStaticField_NullFieldName() { [EOL] try { [EOL] Lang3.writeDeclaredStaticField(ClassWithStaticField.class, null, "newValue"); [EOL] fail("Should throw NullPointerException for null field name"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for null field name"); [EOL] } [EOL] }
public void testWriteDeclaredStaticField_InaccessibleField() { [EOL] try { [EOL] Lang3.writeDeclaredStaticField(ClassWithPrivateStaticField.class, "privateStaticField", "newValue"); [EOL] fail("Should throw IllegalAccessException for private fields"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testWriteDeclaredStaticField_ValidField() throws Exception { [EOL] final String fieldName = "staticField"; [EOL] final String newValue = "new value"; [EOL] TestClassWithFields.staticField = "initial value"; [EOL] FieldUtils.writeDeclaredStaticField(TestClassWithFields.class, fieldName, newValue, true); [EOL] assertEquals("Field should be changed to new value", newValue, TestClassWithFields.staticField); [EOL] } [EOL] public void testWriteDeclaredStaticField_FieldNotFound() { [EOL] final String fieldName = "nonExistingField"; [EOL] final String newValue = "new value"; [EOL] try { [EOL] FieldUtils.writeDeclaredStaticField(TestClassWithFields.class, fieldName, newValue, false); [EOL] fail("Should throw IllegalArgumentException for non-existing field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (Exception e) { [EOL] fail("Unexpected exception type thrown"); [EOL] } [EOL] } [EOL] public void testWriteDeclaredStaticField_NoForceAccess() throws Exception { [EOL] final String fieldName = "privateStaticField"; [EOL] final String newValue = "new value"; [EOL] TestClassWithFields.privateStaticField = "initial value"; [EOL] try { [EOL] FieldUtils.writeDeclaredStaticField(TestClassWithFields.class, fieldName, newValue, false); [EOL] fail("Should throw IllegalAccessException for private field when forceAccess is false"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] } [EOL] public void testWriteDeclaredStaticField_ForceAccess() throws Exception { [EOL] final String fieldName = "privateStaticField"; [EOL] final String newValue = "new value"; [EOL] TestClassWithFields.privateStaticField = "initial value"; [EOL] FieldUtils.writeDeclaredStaticField(TestClassWithFields.class, fieldName, newValue, true); [EOL] assertEquals("Field should be changed to new value with force access", newValue, TestClassWithFields.privateStaticField); [EOL] }
public void testWriteFieldWithNullTarget() throws IllegalAccessException { [EOL] try { [EOL] FieldUtils.writeField(null, "fieldName", "value"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteFieldWithEmptyFieldName() throws IllegalAccessException { [EOL] try { [EOL] FieldUtils.writeField(new Object(), "", "value"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteFieldWithNullFieldName() throws IllegalAccessException { [EOL] try { [EOL] FieldUtils.writeField(new Object(), null, "value"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteFieldWithValidArguments() throws IllegalAccessException { [EOL] MyClass target = new MyClass(); [EOL] String fieldName = "privateField"; [EOL] String value = "newValue"; [EOL] FieldUtils.writeField(target, fieldName, value); [EOL] assertEquals("Field should be updated with new value", value, target.getPrivateField()); [EOL] }
public void testWriteFieldWithNullTarget() { [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] ReflectionUtils.writeField(null, "fieldName", "value", false); [EOL] }); [EOL] assertEquals("target object must not be null", exception.getMessage()); [EOL] }
public void testWriteFieldWithNonExistentField() { [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] ReflectionUtils.writeField(new Object(), "nonExistentField", "value", false); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Cannot locate declared field")); [EOL] }
public void testWriteFieldWithExistingField() throws IllegalAccessException { [EOL] class TestClass { [EOL] private String field; [EOL] } [EOL] TestClass target = new TestClass(); [EOL] ReflectionUtils.writeField(target, "field", "newValue", true); [EOL] assertEquals("newValue", target.field); [EOL] }
public void testGetInstance_NullInput() { [EOL] CharSet result = CharSet.getInstance((String[]) null); [EOL] assertNull(result); [EOL] }
public void testGetInstance_SingleElementInCommonMap() { [EOL] CharSet result = CharSet.getInstance("a"); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_SingleElementNotInCommonMap() { [EOL] CharSet result = CharSet.getInstance("not_in_common"); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_MultipleElements() { [EOL] CharSet result = CharSet.getInstance("a", "b", "c"); [EOL] assertNotNull(result); [EOL] }
public void testToString_WhenSetIsNotEmpty_ShouldReturnSetToString() { [EOL] Set<String> testSet = new HashSet<>(); [EOL] testSet.add("element1"); [EOL] testSet.add("element2"); [EOL] this.set = testSet; [EOL] String result = this.toString(); [EOL] assertEquals("[" + String.join(", ", testSet) + "]", result); [EOL] }
public void testToString_WhenSetIsEmpty_ShouldReturnEmptySetToString() { [EOL] this.set = new HashSet<>(); [EOL] String result = this.toString(); [EOL] assertEquals("[]", result); [EOL] }
public void testContextedExceptionConstructor() { [EOL] ContextedException exception = new ContextedException(); [EOL] assertNotNull("Exception context should not be null", exception.getContext()); [EOL] assertTrue("Exception context should be instance of DefaultExceptionContext", exception.getContext() instanceof DefaultExceptionContext); [EOL] }
public void testContextedExceptionWithNullCause() { [EOL] Throwable cause = null; [EOL] ContextedException exception = new ContextedException(cause); [EOL] assertNull(exception.getCause()); [EOL] assertNotNull(exception.getContextLabels()); [EOL] assertTrue(exception.getContextLabels().isEmpty()); [EOL] }
public void testContextedExceptionWithNonNullCause() { [EOL] Throwable cause = new Throwable(); [EOL] ContextedException exception = new ContextedException(cause); [EOL] assertEquals(cause, exception.getCause()); [EOL] assertNotNull(exception.getContextLabels()); [EOL] assertTrue(exception.getContextLabels().isEmpty()); [EOL] }
public void testMutablePairOf_withNonNullValues() { [EOL] String left = "leftValue"; [EOL] String right = "rightValue"; [EOL] MutablePair<String, String> pair = MutablePair.of(left, right); [EOL] assertEquals("leftValue", pair.getLeft()); [EOL] assertEquals("rightValue", pair.getRight()); [EOL] }
public void testMutablePairOf_withNullValues() { [EOL] MutablePair<Object, Object> pair = MutablePair.of(null, null); [EOL] assertNull(pair.getLeft()); [EOL] assertNull(pair.getRight()); [EOL] }
public void testMutablePairWithNonNullValues() { [EOL] String left = "leftValue"; [EOL] String right = "rightValue"; [EOL] MutablePair<String, String> pair = new MutablePair<>(left, right); [EOL] assertEquals(left, pair.left); [EOL] assertEquals(right, pair.right); [EOL] }
public void testMutablePairWithNullValues() { [EOL] MutablePair<Object, Object> pair = new MutablePair<>(null, null); [EOL] assertNull(pair.left); [EOL] assertNull(pair.right); [EOL] }
public void testGetLeft() { [EOL] Pair<Integer, String> pair = Pair.of(1, "test"); [EOL] Integer left = pair.getLeft(); [EOL] assertEquals(Integer.valueOf(1), left); [EOL] }
public void testSetLeft_NullValue() { [EOL] Pair<Integer, String> pair = new MutablePair<>(1, "right"); [EOL] pair.setLeft(null); [EOL] assertNull(pair.getLeft()); [EOL] }
public void testSetLeft_NonNullValue() { [EOL] Pair<Integer, String> pair = new MutablePair<>(1, "right"); [EOL] pair.setLeft(2); [EOL] assertEquals(Integer.valueOf(2), pair.getLeft()); [EOL] }
public void testGetRight_ShouldReturnRightValue() { [EOL] Pair<Integer, String> pair = Pair.of(1, "RightValue"); [EOL] String right = pair.getRight(); [EOL] assertEquals("RightValue", right); [EOL] }
public void testSetRight() { [EOL] Pair<String, Integer> pair = new Pair<>("Left", 1); [EOL] Integer newRight = 2; [EOL] pair.setRight(newRight); [EOL] assertEquals(newRight, pair.getRight()); [EOL] }
public void testInvokeConstructorWithNullArgs() throws Exception { [EOL] Class<StringBuilder> cls = StringBuilder.class; [EOL] StringBuilder result = invokeConstructor(cls, (Object[]) null); [EOL] assertNotNull(result); [EOL] }
public void testInvokeConstructorWithEmptyArgs() throws Exception { [EOL] Class<StringBuilder> cls = StringBuilder.class; [EOL] StringBuilder result = invokeConstructor(cls); [EOL] assertNotNull(result); [EOL] }
public void testInvokeConstructorWithValidArgs() throws Exception { [EOL] Class<StringBuilder> cls = StringBuilder.class; [EOL] StringBuilder result = invokeConstructor(cls, "test"); [EOL] assertNotNull(result); [EOL] assertEquals("test", result.toString()); [EOL] }
public void testInvokeConstructorWithInvalidArgs() { [EOL] Class<StringBuilder> cls = StringBuilder.class; [EOL] try { [EOL] invokeConstructor(cls, 123); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } [EOL] }
public void testInvokeConstructorWithNullParameterTypesAndArgs() throws Exception { [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] Constructor<String> ctor = String.class.getConstructor(new Class<?>[0]); [EOL] String created = invokeConstructor(String.class, args, parameterTypes); [EOL] assertNotNull(created); [EOL] }
public void testInvokeConstructorWithEmptyParameterTypesAndArgs() throws Exception { [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class<?>[0]; [EOL] Constructor<String> ctor = String.class.getConstructor(parameterTypes); [EOL] String created = invokeConstructor(String.class, args, parameterTypes); [EOL] assertNotNull(created); [EOL] }
public void testInvokeConstructorWithInvalidParameterTypes() throws Exception { [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class<?>[] {Integer.class}; [EOL] try { [EOL] invokeConstructor(String.class, args, parameterTypes); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } [EOL] }
public void testInvokeConstructorWithValidParameterTypes() throws Exception { [EOL] Object[] args = new Object[] {"test"}; [EOL] Class<?>[] parameterTypes = new Class<?>[] {String.class}; [EOL] Constructor<StringBuffer> ctor = StringBuffer.class.getConstructor(parameterTypes); [EOL] StringBuffer created = invokeConstructor(StringBuffer.class, args, parameterTypes); [EOL] assertNotNull(created); [EOL] assertEquals("test", created.toString()); [EOL] }
public void testInvokeExactConstructorWithNullArgs() throws Exception { [EOL] Class<StringBuffer> cls = StringBuffer.class; [EOL] StringBuffer result = invokeExactConstructor(cls, (Object[]) null); [EOL] assertNotNull(result); [EOL] }
public void testInvokeExactConstructorWithEmptyArgs() throws Exception { [EOL] Class<StringBuffer> cls = StringBuffer.class; [EOL] StringBuffer result = invokeExactConstructor(cls); [EOL] assertNotNull(result); [EOL] }
public void testInvokeExactConstructorWithValidArgs() throws Exception { [EOL] Class<String> cls = String.class; [EOL] Object[] args = new Object[]{"test"}; [EOL] String result = invokeExactConstructor(cls, args); [EOL] assertEquals("test", result); [EOL] }
public void testInvokeExactConstructorWithInvalidArgs() throws Exception { [EOL] Class<String> cls = String.class; [EOL] Object[] args = new Object[]{123}; [EOL] try { [EOL] invokeExactConstructor(cls, args); [EOL] fail("Should have thrown NoSuchMethodException"); [EOL] } catch (NoSuchMethodException e) { [EOL] } [EOL] }
public void testInvokeExactConstructorWithNullArgsAndParameterTypes() throws Exception { [EOL] Class<String> cls = String.class; [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] String result = MethodUtils.invokeExactConstructor(cls, args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testInvokeExactConstructorWithEmptyArgsAndParameterTypes() throws Exception { [EOL] Class<String> cls = String.class; [EOL] Object[] args = new Object[0]; [EOL] Class<?>[] parameterTypes = new Class[0]; [EOL] String result = MethodUtils.invokeExactConstructor(cls, args, parameterTypes); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testInvokeExactConstructorWithInvalidClass() { [EOL] Class<InvalidClass> cls = InvalidClass.class; [EOL] Object[] args = null; [EOL] Class<?>[] parameterTypes = null; [EOL] assertThrows(NoSuchMethodException.class, () -> { [EOL] MethodUtils.invokeExactConstructor(cls, args, parameterTypes); [EOL] }); [EOL] }
public void testInvokeExactConstructorWithInvalidParameterTypes() { [EOL] Class<String> cls = String.class; [EOL] Object[] args = new Object[] {"test"}; [EOL] Class<?>[] parameterTypes = new Class[] {Integer.class}; [EOL] assertThrows(NoSuchMethodException.class, () -> { [EOL] MethodUtils.invokeExactConstructor(cls, args, parameterTypes); [EOL] }); [EOL] }
public void testGetAccessibleConstructor_Valid() throws Exception { [EOL] Constructor<String> constructor = StringUtils.class.getConstructor(String.class); [EOL] Constructor<String> result = MethodUtils.getAccessibleConstructor(StringUtils.class, String.class); [EOL] assertNotNull(result); [EOL] assertEquals(constructor, result); [EOL] } [EOL] public void testGetAccessibleConstructor_InValid() { [EOL] Constructor<String> result = MethodUtils.getAccessibleConstructor(StringUtils.class, Integer.class); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleConstructor_PublicConstructor() { [EOL] Constructor<String> ctor = String.class.getConstructor(); [EOL] Constructor<String> result = SomeClass.getAccessibleConstructor(ctor); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetAccessibleConstructor_PrivateConstructor() { [EOL] Constructor<SomePrivateClass> ctor = SomePrivateClass.class.getDeclaredConstructor(); [EOL] ctor.setAccessible(true); [EOL] Constructor<SomePrivateClass> result = SomeClass.getAccessibleConstructor(ctor); [EOL] assertNull(result); [EOL] } [EOL] public void testGetAccessibleConstructor_NullInput() { [EOL] Constructor<?> result = SomeClass.getAccessibleConstructor(null); [EOL] assertNull(result); [EOL] }

public void testIsSupportedWithNullName() { [EOL] boolean result = isSupported(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithUnsupportedName() { [EOL] boolean result = isSupported("unsupported_charset_name"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithSupportedName() { [EOL] boolean result = isSupported("UTF-8"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsSupportedWithIllegalCharsetName() { [EOL] boolean result = isSupported("Illegal*Charset//Name"); [EOL] assertFalse(result); [EOL] }
public void testCheckCallableWithNonNull() throws Exception { [EOL] Callable<String> callable = () -> "Test"; [EOL] checkCallable(callable); [EOL] }
public void testCheckCallableWithNull() { [EOL] try { [EOL] checkCallable(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Callable must not be null!", e.getMessage()); [EOL] } [EOL] }
static Set<IDKey> getRegistry() { [EOL] return REGISTRY.get(); [EOL] }
public void testIsRegisteredWithNullValue() { [EOL] boolean result = YourClass.isRegistered(null); [EOL] assertFalse("Expected false when checking if null is registered", result); [EOL] }
public void testIsRegisteredWithUnregisteredValue() { [EOL] Object unregisteredValue = new Object(); [EOL] boolean result = YourClass.isRegistered(unregisteredValue); [EOL] assertFalse("Expected false when checking if an unregistered object is registered", result); [EOL] }
public void testIsRegisteredWithRegisteredValue() { [EOL] Object registeredValue = new Object(); [EOL] YourClass.register(registeredValue); [EOL] boolean result = YourClass.isRegistered(registeredValue); [EOL] assertTrue("Expected true when checking if a registered object is registered", result); [EOL] }
public void testReflectionAppendWithRegisteredObject() { [EOL] final Object object = new Object(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] HashCodeBuilder.register(object); [EOL] try { [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected no change in the hash code builder", 17, builder.toHashCode()); [EOL] } finally { [EOL] HashCodeBuilder.unregister(object); [EOL] } [EOL] }
public void testReflectionAppendWithUnregisteredObject() { [EOL] final Object object = new Object(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertNotEquals("Expected the hash code builder to change", 17, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithExcludedFields() { [EOL] final Object object = new ObjectWithFields(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = {"excludedField"}; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected the hash code builder to exclude certain fields", expectedHashCode, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithTransientFields() { [EOL] final Object object = new ObjectWithTransientFields(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = true; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected the hash code builder to include transient fields", expectedHashCode, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithStaticFields() { [EOL] final Object object = new ObjectWithStaticFields(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected the hash code builder to exclude static fields", expectedHashCode, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithInaccessibleFields() { [EOL] final Object object = new ObjectWithPrivateFields(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] try { [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] fail("Expected an InternalError due to inaccessible fields"); [EOL] } catch (InternalError e) { [EOL] assertEquals("Unexpected IllegalAccessException", e.getMessage()); [EOL] } [EOL] }
public void testReflectionHashCodeWithNullObject() { [EOL] try { [EOL] Object object = null; [EOL] reflectionHashCode(1, 1, object, false, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testReflectionHashCodeWithValidObject() { [EOL] Object object = new Object(); [EOL] int hashCode = reflectionHashCode(1, 1, object, false, null); [EOL] assertNotNull(hashCode); [EOL] } [EOL] public void testReflectionHashCodeWithExcludeFields() { [EOL] Object object = new Object(); [EOL] int hashCode1 = reflectionHashCode(1, 1, object, false, null, "field1"); [EOL] int hashCode2 = reflectionHashCode(1, 1, object, false, null, "field2"); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] } [EOL] public void testReflectionHashCodeWithTestTransients() { [EOL] Object object = new Object(); [EOL] int hashCode1 = reflectionHashCode(1, 1, object, false, null); [EOL] int hashCode2 = reflectionHashCode(1, 1, object, true, null); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] } [EOL] public void testReflectionHashCodeWithReflectUpToClass() { [EOL] Object object = new Object(); [EOL] int hashCode1 = reflectionHashCode(1, 1, object, false, Object.class); [EOL] int hashCode2 = reflectionHashCode(1, 1, object, false, null); [EOL] assertEquals(hashCode1, hashCode2); [EOL] }
public void testReflectionHashCodeWithSuperclass() { [EOL] class Parent {} [EOL] class Child extends Parent {} [EOL] Child object = new Child(); [EOL] int hashCode1 = reflectionHashCode(1, 1, object, false, Parent.class); [EOL] int hashCode2 = reflectionHashCode(1, 1, object, false, null); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testReflectionHashCodeWithNullObjectAndFalseTransients() { [EOL] int hashCode = ObjectUtils.reflectionHashCode(null, false); [EOL] assertEquals(17, hashCode); [EOL] }
public void testReflectionHashCodeWithNonNullObjectAndFalseTransients() { [EOL] Object obj = new Object(); [EOL] int hashCode = ObjectUtils.reflectionHashCode(obj, false); [EOL] assertNotEquals(17, hashCode); // Assuming a non-null object will have a different hash code [EOL] }
public void testReflectionHashCodeWithNonNullObjectAndTrueTransients() { [EOL] Object obj = new Object(); [EOL] int hashCode = ObjectUtils.reflectionHashCode(obj, true); [EOL] assertNotEquals(17, hashCode); // Assuming a non-null object with transients considered will have a different hash code [EOL] }
public void testRegisterWithNullValue() { [EOL] HashCodeBuilder.register(null); [EOL] assertTrue(HashCodeBuilder.getRegistry().contains(new IDKey(null))); [EOL] } [EOL] public void testRegisterWithNonNullValue() { [EOL] Object obj = new Object(); [EOL] HashCodeBuilder.register(obj); [EOL] assertTrue(HashCodeBuilder.getRegistry().contains(new IDKey(obj))); [EOL] } [EOL] public void testRegisterWithMultipleValues() { [EOL] Object obj1 = new Object(); [EOL] Object obj2 = new Object(); [EOL] HashCodeBuilder.register(obj1); [EOL] HashCodeBuilder.register(obj2); [EOL] assertTrue(HashCodeBuilder.getRegistry().contains(new IDKey(obj1))); [EOL] assertTrue(HashCodeBuilder.getRegistry().contains(new IDKey(obj2))); [EOL] } [EOL] public void testRegisterWithSameObjectTwice() { [EOL] Object obj = new Object(); [EOL] HashCodeBuilder.register(obj); [EOL] HashCodeBuilder.register(obj); [EOL] int count = 0; [EOL] for (IDKey idKey : HashCodeBuilder.getRegistry()) { [EOL] if (idKey.equals(new IDKey(obj))) { [EOL] count++; [EOL] } [EOL] } [EOL] assertEquals(1, count); [EOL] }
public void testUnregisterWithNonNullRegistryAndNonEmptyAfterRemove() { [EOL] final Object value = new Object(); [EOL] HashCodeBuilder.register(value); [EOL] HashCodeBuilder.unregister(value); [EOL] }
public void testUnregisterWithNonNullRegistryAndEmptyAfterRemove() { [EOL] final Object value = new Object(); [EOL] HashCodeBuilder.register(value); [EOL] HashCodeBuilder.unregister(value); [EOL] }
public void testUnregisterWithNullRegistry() { [EOL] final Object value = new Object(); [EOL] HashCodeBuilder.unregister(value); [EOL] }
public void testHashCodeBuilderDefaultConstructor() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] assertNotNull(builder); [EOL] assertEquals(37, ReflectionTestUtils.getField(builder, "iConstant")); [EOL] assertEquals(17, ReflectionTestUtils.getField(builder, "iTotal")); [EOL] }
public void testHashCodeBuilderValidArguments() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(3, 11); [EOL] assertNotNull(builder); [EOL] }
public void testHashCodeBuilderInitialValueZero() { [EOL] try { [EOL] new HashCodeBuilder(0, 11); [EOL] fail("Should have thrown IllegalArgumentException for zero initial value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testHashCodeBuilderInitialValueEven() { [EOL] try { [EOL] new HashCodeBuilder(2, 11); [EOL] fail("Should have thrown IllegalArgumentException for even initial value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testHashCodeBuilderMultiplierValueZero() { [EOL] try { [EOL] new HashCodeBuilder(3, 0); [EOL] fail("Should have thrown IllegalArgumentException for zero multiplier value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testHashCodeBuilderMultiplierValueEven() { [EOL] try { [EOL] new HashCodeBuilder(3, 2); [EOL] fail("Should have thrown IllegalArgumentException for even multiplier value"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testAppendWithNullFloatArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(17, 37); [EOL] float[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(hcb, result); [EOL] }
public void testAppendWithEmptyFloatArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(17, 37); [EOL] float[] array = new float[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(hcb, result); [EOL] }
public void testAppendWithNonEmptyFloatArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(17, 37); [EOL] float[] array = new float[]{1.0f, 2.0f, 3.0f}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] int initialHashCode = hcb.toHashCode(); [EOL] hcb.append(1.0f).append(2.0f).append(3.0f); [EOL] int expectedHashCode = hcb.toHashCode(); [EOL] assertEquals(expectedHashCode, result.toHashCode()); [EOL] }
public void testAppendWithNull() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) null); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithLongArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] long[] array = {1L, 2L, 3L}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithIntArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = {'a', 'b', 'c'}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithByteArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] byte[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithDoubleArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithFloatArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithBooleanArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] boolean[] array = {true, false, true}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithObjectArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object[] array = {new Object(), new Object(), new Object()}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithNonArrayObject() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object obj = new Object(); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(obj); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testToHashCode() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int expectedHashCode = builder.toHashCode(); [EOL] assertEquals(expectedHashCode, builder.iTotal); [EOL] }
public void testDeserializeWithNullInputStream() { [EOL] try { [EOL] SerializationUtils.deserialize(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testDeserializeWithValidInputStream() throws IOException, ClassNotFoundException { [EOL] final byte[] serializedObject = // obtain serialized object bytes [EOL] InputStream inputStream = new ByteArrayInputStream(serializedObject); [EOL] Object result = SerializationUtils.deserialize(inputStream); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithIOException() throws IOException { [EOL] InputStream inputStream = mock(InputStream.class); [EOL] when(inputStream.read(any(byte[].class))).thenThrow(new IOException()); [EOL] try { [EOL] SerializationUtils.deserialize(inputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] } [EOL] }
public void testDeserializeWithClassCastException() throws IOException, ClassNotFoundException { [EOL] InputStream inputStream = mock(InputStream.class); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(inputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenThrow(new ClassCastException()); [EOL] try { [EOL] SerializationUtils.deserialize(inputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] } [EOL] }
public void testDeserializeWithClassNotFoundException() throws IOException, ClassNotFoundException { [EOL] InputStream inputStream = mock(InputStream.class); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] whenNew(ObjectInputStream.class).withArguments(inputStream).thenReturn(objectInputStream); [EOL] when(objectInputStream.readObject()).thenThrow(new ClassNotFoundException()); [EOL] try { [EOL] SerializationUtils.deserialize(inputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] } [EOL] }
public void testIsAsciiAlphanumeric_withUpperCaseLetter() { [EOL] boolean result = isAsciiAlphanumeric('A'); [EOL] assert result; [EOL] } [EOL] public void testIsAsciiAlphanumeric_withLowerCaseLetter() { [EOL] boolean result = isAsciiAlphanumeric('a'); [EOL] assert result; [EOL] } [EOL] public void testIsAsciiAlphanumeric_withDigit() { [EOL] boolean result = isAsciiAlphanumeric('0'); [EOL] assert result; [EOL] } [EOL] public void testIsAsciiAlphanumeric_withNonAlphanumeric() { [EOL] boolean result = isAsciiAlphanumeric('#'); [EOL] assert !result; [EOL] } [EOL] public void testIsAsciiAlphanumeric_withAsciiBoundaryChar() { [EOL] boolean resultLowerBound = isAsciiAlphanumeric((char) (0x00)); [EOL] boolean resultUpperBound = isAsciiAlphanumeric((char) (0x7F)); [EOL] assert !resultLowerBound; [EOL] assert !resultUpperBound; [EOL] }
public void testBetweenWithNullComparator() { [EOL] Integer start = 1; [EOL] Integer end = 3; [EOL] Range<Integer> range = Range.between(start, end); [EOL] assertNotNull(range); [EOL] assertEquals(start, range.getMinimum()); [EOL] assertEquals(end, range.getMaximum()); [EOL] }
public void testBetweenWithEqualStartAndEnd() { [EOL] Integer sameValue = 1; [EOL] Range<Integer> range = Range.between(sameValue, sameValue); [EOL] assertNotNull(range); [EOL] assertEquals(sameValue, range.getMinimum()); [EOL] assertEquals(sameValue, range.getMaximum()); [EOL] }
public void testBetweenWithNonNullComparator() { [EOL] Comparator<Integer> comparator = Integer::compare; [EOL] Range<Integer> range = Range.between(1, 5, comparator); [EOL] assertNotNull(range); [EOL] assertEquals(Integer.valueOf(1), range.getMinimum()); [EOL] assertEquals(Integer.valueOf(5), range.getMaximum()); [EOL] }
public void testBetweenWithNullComparator() { [EOL] Range<Integer> range = Range.between(1, 5, null); [EOL] assertNotNull(range); [EOL] assertEquals(Integer.valueOf(1), range.getMinimum()); [EOL] assertEquals(Integer.valueOf(5), range.getMaximum()); [EOL] }
public void testRangeConstructor_NullElements_ThrowsException() { [EOL] try { [EOL] new Range<>(null, "element2", Comparator.naturalOrder()); [EOL] fail("Expected IllegalArgumentException for null element1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] new Range<>("element1", null, Comparator.naturalOrder()); [EOL] fail("Expected IllegalArgumentException for null element2"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRangeConstructor_NullComparator_UsesNaturalOrder() { [EOL] Range<String> range = new Range<>("element1", "element2", null); [EOL] assertNotNull(range); [EOL] assertEquals("element1", range.getMinimum()); [EOL] assertEquals("element2", range.getMaximum()); [EOL] }
public void testRangeConstructor_ElementsInOrder() { [EOL] Range<String> range = new Range<>("element1", "element2", Comparator.naturalOrder()); [EOL] assertNotNull(range); [EOL] assertEquals("element1", range.getMinimum()); [EOL] assertEquals("element2", range.getMaximum()); [EOL] }
public void testRangeConstructor_ElementsOutOfOrder() { [EOL] Range<String> range = new Range<>("element2", "element1", Comparator.naturalOrder()); [EOL] assertNotNull(range); [EOL] assertEquals("element1", range.getMinimum()); [EOL] assertEquals("element2", range.getMaximum()); [EOL] }
public void testIsStartedBy_NullElement() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isStartedBy(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsStartedBy_ElementEqualToMinimum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isStartedBy(1); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsStartedBy_ElementNotEqualToMinimum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isStartedBy(2); [EOL] assertFalse(result); [EOL] }
public void testIsEndedBy_NullElement() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isEndedBy(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsEndedBy_ElementEqualToMaximum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isEndedBy(10); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsEndedBy_ElementNotEqualToMaximum() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isEndedBy(9); [EOL] assertFalse(result); [EOL] }
public void testElementCompareToWithNullElement() { [EOL] try { [EOL] elementCompareTo(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Element is null", e.getMessage()); [EOL] } [EOL] }
public void testElementCompareToWithElementAfter() { [EOL] when(isAfter(any())).thenReturn(true); [EOL] when(isBefore(any())).thenReturn(false); [EOL] int result = elementCompareTo(mockElement); [EOL] assertEquals(-1, result); [EOL] }
public void testElementCompareToWithElementBefore() { [EOL] when(isAfter(any())).thenReturn(false); [EOL] when(isBefore(any())).thenReturn(true); [EOL] int result = elementCompareTo(mockElement); [EOL] assertEquals(1, result); [EOL] }
public void testElementCompareToWithElementEqual() { [EOL] when(isAfter(any())).thenReturn(false); [EOL] when(isBefore(any())).thenReturn(false); [EOL] int result = elementCompareTo(mockElement); [EOL] assertEquals(0, result); [EOL] }
public void testToStringWhenResultIsNull() { [EOL] YourClass instance = new YourClass(minValue, maxValue); [EOL] String expected = "[" + minValue + ".." + maxValue + "]"; [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testToStringWhenResultIsNotNull() { [EOL] YourClass instance = new YourClass(minValue, maxValue); [EOL] String initialToString = "[" + minValue + ".." + maxValue + "]"; [EOL] setToStringThroughReflection(instance, initialToString); [EOL] String actual = instance.toString(); [EOL] assertEquals(initialToString, actual); [EOL] }
public void testToStringWithNullObject() { [EOL] String result = StringUtils.toString(null); [EOL] assertNull(result); [EOL] }
public void testToStringWithNonNullObject() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.toString(obj); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith("java.lang.Object@")); [EOL] }
public void testToStringWithNullObject() { [EOL] String result = StringUtils.toString(null, ToStringStyle.DEFAULT_STYLE, false, false, null); [EOL] assertEquals("<null>", result); [EOL] } [EOL] public void testToStringWithValidObjectAndDefaultStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.toString(obj, ToStringStyle.DEFAULT_STYLE, false, false, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(obj.getClass().getName() + "@")); [EOL] } [EOL] public void testToStringWithValidObjectAndNoFieldStyle() { [EOL] Object obj = new Object(); [EOL] String result = StringUtils.toString(obj, ToStringStyle.NO_FIELD_NAMES_STYLE, false, false, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(obj.getClass().getName() + "@")); [EOL] } [EOL] public void testToStringWithValidObjectAndTransientFields() { [EOL] Object obj = new ExampleClassWithTransients(); [EOL] String result = StringUtils.toString(obj, ToStringStyle.DEFAULT_STYLE, true, false, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("transientField")); [EOL] } [EOL] public void testToStringWithValidObjectAndStaticFields() { [EOL] Object obj = new ExampleClassWithStatics(); [EOL] String result = StringUtils.toString(obj, ToStringStyle.DEFAULT_STYLE, false, true, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("staticField")); [EOL] } [EOL] public void testToStringWithValidObjectAndSpecificSuperclass() { [EOL] Object obj = new ExampleSubClass(); [EOL] String result = StringUtils.toString(obj, ToStringStyle.DEFAULT_STYLE, false, false, ExampleSuperClass.class); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("ExampleSuperClassField")); [EOL] assertFalse(result.contains("ExampleSubClassField")); [EOL] }
public void testToStringWithValidObjectAndAllTrue() { [EOL] Object obj = new ExampleClassWithTransientsAndStatics(); [EOL] String result = StringUtils.toString(obj, ToStringStyle.DEFAULT_STYLE, true, true, null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("transientField")); [EOL] assertTrue(result.contains("staticField")); [EOL] }
public void testToNoNullStringArray_withNullElements() { [EOL] Object[] array = new Object[] { "String1", null, "String3", null }; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(2, result.length); [EOL] assertEquals("String1", result[0]); [EOL] assertEquals("String3", result[1]); [EOL] } [EOL] public void testToNoNullStringArray_withAllNonNullElements() { [EOL] Object[] array = new Object[] { "String1", "String2", "String3" }; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(3, result.length); [EOL] assertEquals("String1", result[0]); [EOL] assertEquals("String2", result[1]); [EOL] assertEquals("String3", result[2]); [EOL] } [EOL] public void testToNoNullStringArray_withAllNullElements() { [EOL] Object[] array = new Object[] { null, null, null }; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testToNoNullStringArray_withEmptyArray() { [EOL] Object[] array = new Object[] {}; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testToNoNullStringArray_withSingleNonNullElement() { [EOL] Object[] array = new Object[] { "String1" }; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(1, result.length); [EOL] assertEquals("String1", result[0]); [EOL] } [EOL] public void testToNoNullStringArray_withSingleNullElement() { [EOL] Object[] array = new Object[] { null }; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(0, result.length); [EOL] }
public void testToStringExcludeWithNullObject() { [EOL] String result = StringUtils.toStringExclude(null, "id", "name"); [EOL] assertNull(result); [EOL] }
public void testToStringExcludeWithNonNullObjectAndNullExcludes() { [EOL] Object object = new Object(); [EOL] String result = StringUtils.toStringExclude(object, (String[]) null); [EOL] assertNotNull(result); [EOL] }
public void testToStringExcludeWithNonNullObjectAndEmptyExcludes() { [EOL] Object object = new Object(); [EOL] String result = StringUtils.toStringExclude(object); [EOL] assertNotNull(result); [EOL] }
public void testToStringExcludeWithNonNullObjectAndNonNullExcludes() { [EOL] Object object = new ExampleObject(); // Assuming ExampleObject is a valid class with fields [EOL] String result = StringUtils.toStringExclude(object, "field1", "field2"); [EOL] assertNotNull(result); [EOL] assertFalse(result.contains("field1=")); [EOL] assertFalse(result.contains("field2=")); [EOL] }
public void testReflectionToStringBuilderWithNullObject() { [EOL] ReflectionToStringBuilder reflectionToStringBuilder = new ReflectionToStringBuilder(null); [EOL] assertNull("Expected object to be null", reflectionToStringBuilder.getObject()); [EOL] }
public void testReflectionToStringBuilderWithNonNullObject() { [EOL] Object testObject = new Object(); [EOL] ReflectionToStringBuilder reflectionToStringBuilder = new ReflectionToStringBuilder(testObject); [EOL] assertNotNull("Expected object to be non-null", reflectionToStringBuilder.getObject()); [EOL] assertSame("Expected object to be the same as the one passed to constructor", testObject, reflectionToStringBuilder.getObject()); [EOL] }
public void testReflectionToStringBuilderWithNullObject() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, null, null, false, false); [EOL] assertNull("Expected object to be null", builder.getObject()); [EOL] }
public void testReflectionToStringBuilderWithNonNullObject() { [EOL] Object testObject = new Object(); [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(testObject, ToStringStyle.DEFAULT_STYLE, null, null, false, false); [EOL] assertEquals("Expected object to be the same as the one passed in", testObject, builder.getObject()); [EOL] }
public void testReflectionToStringBuilderWithStyle() { [EOL] Object testObject = new Object(); [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(testObject, ToStringStyle.NO_FIELD_NAMES_STYLE, null, null, false, false); [EOL] assertNotNull("Expected ToStringStyle to be NO_FIELD_NAMES_STYLE", builder.getStyle()); [EOL] }
public void testReflectionToStringBuilderWithBuffer() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, buffer, null, false, false); [EOL] assertSame("Expected StringBuffer to be the same as the one passed in", buffer, builder.getStringBuffer()); [EOL] }
public void testReflectionToStringBuilderWithReflectUpToClass() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, null, Object.class, false, false); [EOL] assertEquals("Expected reflectUpToClass to be Object.class", Object.class, builder.getUpToClass()); [EOL] }
public void testReflectionToStringBuilderWithOutputTransients() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, null, null, true, false); [EOL] assertTrue("Expected outputTransients to be true", builder.isAppendTransients()); [EOL] }
public void testReflectionToStringBuilderWithOutputStatics() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null, ToStringStyle.DEFAULT_STYLE, null, null, false, true); [EOL] assertTrue("Expected outputStatics to be true", builder.isAppendStatics()); [EOL] }
public void testAcceptWithInnerClassField() { [EOL] Field innerClassField = MyClass.InnerClass.class.getDeclaredField("someField"); [EOL] boolean result = accept(innerClassField); [EOL] assertFalse(result); [EOL] } [EOL] public void testAcceptWithTransientFieldWhenAppendTransientsIsFalse() { [EOL] Field transientField = MyClass.class.getDeclaredField("transientField"); [EOL] setAppendTransients(false); [EOL] boolean result = accept(transientField); [EOL] assertFalse(result); [EOL] } [EOL] public void testAcceptWithTransientFieldWhenAppendTransientsIsTrue() { [EOL] Field transientField = MyClass.class.getDeclaredField("transientField"); [EOL] setAppendTransients(true); [EOL] boolean result = accept(transientField); [EOL] assertTrue(result); [EOL] } [EOL] public void testAcceptWithStaticFieldWhenAppendStaticsIsFalse() { [EOL] Field staticField = MyClass.class.getDeclaredField("staticField"); [EOL] setAppendStatics(false); [EOL] boolean result = accept(staticField); [EOL] assertFalse(result); [EOL] } [EOL] public void testAcceptWithStaticFieldWhenAppendStaticsIsTrue() { [EOL] Field staticField = MyClass.class.getDeclaredField("staticField"); [EOL] setAppendStatics(true); [EOL] boolean result = accept(staticField); [EOL] assertTrue(result); [EOL] } [EOL] public void testAcceptWithExcludedFieldName() { [EOL] Field excludedField = MyClass.class.getDeclaredField("excludedField"); [EOL] setExcludeFieldNames(new String[]{"excludedField"}); [EOL] boolean result = accept(excludedField); [EOL] assertFalse(result); [EOL] } [EOL] public void testAcceptWithNonExcludedFieldName() { [EOL] Field nonExcludedField = MyClass.class.getDeclaredField("nonExcludedField"); [EOL] setExcludeFieldNames(new String[]{"excludedField"}); [EOL] boolean result = accept(nonExcludedField); [EOL] assertTrue(result); [EOL] }
protected void appendFieldsIn(final Class<?> clazz) { [EOL] if (clazz.isArray()) { [EOL] this.reflectionAppendArray(this.getObject()); [EOL] return; [EOL] } [EOL] final Field[] fields = clazz.getDeclaredFields(); [EOL] AccessibleObject.setAccessible(fields, true); [EOL] for (final Field field : fields) { [EOL] final String fieldName = field.getName(); [EOL] if (this.accept(field)) { [EOL] try { [EOL] final Object fieldValue = this.getValue(field); [EOL] this.append(fieldName, fieldValue); [EOL] } catch (final IllegalAccessException ex) { [EOL] throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage()); [EOL] } [EOL] } [EOL] } [EOL] }
public Class<?> getUpToClass() { [EOL] return this.upToClass; [EOL] }
protected Object getValue(final Field field) throws IllegalArgumentException, IllegalAccessException { [EOL] return field.get(this.getObject()); [EOL] }
public void testIsAppendStaticsTrue() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] builder.setAppendStatics(true); [EOL] assertTrue(builder.isAppendStatics()); [EOL] }
public void testIsAppendStaticsFalse() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] builder.setAppendStatics(false); [EOL] assertFalse(builder.isAppendStatics()); [EOL] }
public void testSetAppendStatics() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setAppendStatics(true); [EOL] assertTrue(instance.isAppendStatics()); [EOL] instance.setAppendStatics(false); [EOL] assertFalse(instance.isAppendStatics()); [EOL] }
public void testSetAppendTransientsTrue() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] builder.setAppendTransients(true); [EOL] assertTrue(builder.isAppendTransients()); [EOL] }
public void testSetAppendTransientsFalse() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] builder.setAppendTransients(false); [EOL] assertFalse(builder.isAppendTransients()); [EOL] }
public void testSetExcludeFieldNamesWithNull() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] builder.setExcludeFieldNames((String[]) null); [EOL] assertNull("Exclude field names should be null", builder.getExcludeFieldNames()); [EOL] }
public void testSetExcludeFieldNamesWithNonNull() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(new Object()); [EOL] String[] excludeFields = {"field1", "field2", "field3"}; [EOL] builder.setExcludeFieldNames(excludeFields); [EOL] assertNotNull("Exclude field names should not be null", builder.getExcludeFieldNames()); [EOL] assertTrue("Exclude field names should contain 'field1'", Arrays.asList(builder.getExcludeFieldNames()).contains("field1")); [EOL] assertTrue("Exclude field names should contain 'field2'", Arrays.asList(builder.getExcludeFieldNames()).contains("field2")); [EOL] assertTrue("Exclude field names should contain 'field3'", Arrays.asList(builder.getExcludeFieldNames()).contains("field3")); [EOL] }
public void testSetUpToClassWithNullClass() { [EOL] setUpToClass(null); [EOL] } [EOL] public void testSetUpToClassWithValidSuperclass() { [EOL] Object testObject = new TestSubClass(); [EOL] setUpToClass(TestSuperClass.class); [EOL] } [EOL] public void testSetUpToClassWithInvalidClass() { [EOL] try { [EOL] Object testObject = new TestSubClass(); [EOL] setUpToClass(TestOtherClass.class); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }

public void testToStringWithNullObject() { [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(null, someStyle, null); [EOL] String result = objUnderTest.toString(); [EOL] assertEquals(someStyle.getNullText(), result); [EOL] }
public void testToStringWithNonNullObjectNoSuperclass() { [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(new Object(), someStyle, null); [EOL] String result = objUnderTest.toString(); [EOL] String expected = ...; // Expected string after fields of Object class are appended [EOL] assertEquals(expected, result); [EOL] }
public void testToStringWithNonNullObjectWithSuperclass() { [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(new ChildClass(), someStyle, ParentClass.class); [EOL] String result = objUnderTest.toString(); [EOL] String expected = ...; // Expected string after fields of ChildClass and ParentClass are appended [EOL] assertEquals(expected, result); [EOL] }
public void testAtLeast_RequiredVersionIsLess() { [EOL] JavaVersion currentVersion = JavaVersion.JAVA_1_7; [EOL] JavaVersion requiredVersion = JavaVersion.JAVA_1_6; [EOL] boolean result = currentVersion.atLeast(requiredVersion); [EOL] assertTrue(result); [EOL] }
public void testAtLeast_RequiredVersionIsEqual() { [EOL] JavaVersion currentVersion = JavaVersion.JAVA_1_7; [EOL] JavaVersion requiredVersion = JavaVersion.JAVA_1_7; [EOL] boolean result = currentVersion.atLeast(requiredVersion); [EOL] assertTrue(result); [EOL] }
public void testAtLeast_RequiredVersionIsMore() { [EOL] JavaVersion currentVersion = JavaVersion.JAVA_1_7; [EOL] JavaVersion requiredVersion = JavaVersion.JAVA_1_8; [EOL] boolean result = currentVersion.atLeast(requiredVersion); [EOL] assertFalse(result); [EOL] }
public void testIncrement() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] mutableInt.increment(); [EOL] assertEquals(1, mutableInt.intValue()); [EOL] }
public void testAddWithNullOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] try { [EOL] arithmeticUtils.add(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testAddWithPositiveOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] arithmeticUtils.add(10); [EOL] assertEquals(15, arithmeticUtils.value); [EOL] } [EOL] public void testAddWithNegativeOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] arithmeticUtils.add(-10); [EOL] assertEquals(-5, arithmeticUtils.value); [EOL] } [EOL] public void testAddWithZeroOperand() { [EOL] ArithmeticUtils arithmeticUtils = new ArithmeticUtils(); [EOL] arithmeticUtils.value = 5; [EOL] arithmeticUtils.add(0); [EOL] assertEquals(5, arithmeticUtils.value); [EOL] }
public void testToLong_PositiveValue() { [EOL] MutableLong mutableLong = new MutableLong(123L); [EOL] Long result = mutableLong.toLong(); [EOL] assertEquals(Long.valueOf(123L), result); [EOL] }
public void testToLong_NegativeValue() { [EOL] MutableLong mutableLong = new MutableLong(-123L); [EOL] Long result = mutableLong.toLong(); [EOL] assertEquals(Long.valueOf(-123L), result); [EOL] }
public void testToLong_ZeroValue() { [EOL] MutableLong mutableLong = new MutableLong(0L); [EOL] Long result = mutableLong.toLong(); [EOL] assertEquals(Long.valueOf(0L), result); [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableLong first = new MutableLong(1); [EOL] MutableLong second = new MutableLong(2); [EOL] int result = first.compareTo(second); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_Equal() { [EOL] MutableLong first = new MutableLong(5); [EOL] MutableLong second = new MutableLong(5); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] MutableLong first = new MutableLong(10); [EOL] MutableLong second = new MutableLong(5); [EOL] int result = first.compareTo(second); [EOL] assertEquals(1, result); [EOL] }
public void testDecrement_PositiveValue() { [EOL] MutableInt mutableInt = new MutableInt(1); [EOL] mutableInt.decrement(); [EOL] assertEquals(0, mutableInt.intValue()); [EOL] }
public void testDecrement_NegativeValue() { [EOL] MutableInt mutableInt = new MutableInt(-1); [EOL] mutableInt.decrement(); [EOL] assertEquals(-2, mutableInt.intValue()); [EOL] }
public void testDecrement_ZeroValue() { [EOL] MutableInt mutableInt = new MutableInt(0); [EOL] mutableInt.decrement(); [EOL] assertEquals(-1, mutableInt.intValue()); [EOL] }
public void testFloatValue_Positive() { [EOL] MutableFloat mutableFloat = new MutableFloat(1.0f); [EOL] assertEquals(1.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testFloatValue_Negative() { [EOL] MutableFloat mutableFloat = new MutableFloat(-1.0f); [EOL] assertEquals(-1.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testFloatValue_Zero() { [EOL] MutableFloat mutableFloat = new MutableFloat(0.0f); [EOL] assertEquals(0.0f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testDoubleValue_Positive() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] assertEquals(1.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] MutableDouble mutableDouble = new MutableDouble(-1.0); [EOL] assertEquals(-1.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] MutableDouble mutableDouble = new MutableDouble(0.0); [EOL] assertEquals(0.0, mutableDouble.doubleValue(), 0.0); [EOL] }
public void testHashCodeWithNullObject() { [EOL] int expected = 0; [EOL] int actual = ObjectUtils.hashCode(null); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCodeWithNonNullObject() { [EOL] Object obj = new Object(); [EOL] int expected = obj.hashCode(); [EOL] int actual = ObjectUtils.hashCode(obj); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCodeMulti_WithNullArray() { [EOL] int expected = 1; [EOL] int actual = hashCodeMulti((Object[]) null); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testHashCodeMulti_WithEmptyArray() { [EOL] int expected = 1; [EOL] int actual = hashCodeMulti(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testHashCodeMulti_WithNonNullArray() { [EOL] int expected = 31 * 1 + ObjectUtils.hashCode("test"); [EOL] int actual = hashCodeMulti("test"); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testHashCodeMulti_WithMultipleElements() { [EOL] int expected = 31 * (31 * 1 + ObjectUtils.hashCode("test1")) + ObjectUtils.hashCode("test2"); [EOL] int actual = hashCodeMulti("test1", "test2"); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testHashCodeMulti_WithNullElement() { [EOL] int expected = 31 * 1 + ObjectUtils.hashCode(null); [EOL] int actual = hashCodeMulti((Object) null); [EOL] assertEquals(expected, actual); [EOL] }
public void testIdentityToStringWithNullObject() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] try { [EOL] LangUtils.identityToString(builder, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Cannot get the toString of a null identity", ex.getMessage()); [EOL] } [EOL] }
public void testIdentityToStringWithNonNullObject() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] Object obj = new Object(); [EOL] String expected = obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj)); [EOL] LangUtils.identityToString(builder, obj); [EOL] assertEquals(expected, builder.toString()); [EOL] }
public void testToStringWithNonNullObject() { [EOL] Object obj = new Object() { [EOL] @Override [EOL] public String toString() { [EOL] return "Test Object"; [EOL] } [EOL] }; [EOL] String result = StringUtils.toString(obj, "null"); [EOL] assertEquals("Test Object", result); [EOL] }
public void testToStringWithNullObject() { [EOL] Object obj = null; [EOL] String nullStr = "null"; [EOL] String result = StringUtils.toString(obj, nullStr); [EOL] assertEquals(nullStr, result); [EOL] }
public void testMedianWithNonEmptyNoNullElements() { [EOL] Integer[] numbers = {2, 4, 5, 3, 1}; [EOL] Integer median = ArrayUtils.median(numbers); [EOL] assertEquals(Integer.valueOf(3), median); [EOL] }
public void testMedianWithEmptyArray() { [EOL] Integer[] numbers = {}; [EOL] try { [EOL] ArrayUtils.median(numbers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMedianWithNullArray() { [EOL] Integer[] numbers = null; [EOL] try { [EOL] ArrayUtils.median(numbers); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testMedianWithNullElement() { [EOL] Integer[] numbers = {1, null, 3}; [EOL] try { [EOL] ArrayUtils.median(numbers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testMedianWithSingleElement() { [EOL] Integer[] numbers = {1}; [EOL] Integer median = ArrayUtils.median(numbers); [EOL] assertEquals(Integer.valueOf(1), median); [EOL] }
public void testMedianWithEvenNumberOfElements() { [EOL] Integer[] numbers = {1, 2, 3, 4}; [EOL] Integer median = ArrayUtils.median(numbers); [EOL] assertEquals(Integer.valueOf(2), median); [EOL] }
public void testNullConstructor() { [EOL] try { [EOL] new Null(); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception: " + e.getMessage()); [EOL] } [EOL] }
public void testIDKeyWithNonNullValue() { [EOL] Object obj = new Object(); [EOL] IDKey idKey = new IDKey(obj); [EOL] assertNotNull(idKey); [EOL] assertEquals(System.identityHashCode(obj), idKey.id); [EOL] assertSame(obj, idKey.value); [EOL] }
public void testIDKeyWithNullValue() { [EOL] IDKey idKey = new IDKey(null); [EOL] assertNotNull(idKey); [EOL] assertEquals(System.identityHashCode(null), idKey.id); [EOL] assertNull(idKey.value); [EOL] }
public void testHashCode() { [EOL] MyClass obj = new MyClass(1); [EOL] int expectedHashCode = 1; [EOL] assertEquals(expectedHashCode, obj.hashCode()); [EOL] }
public void testEquals_SameIDKeyObject_ShouldReturnTrue() { [EOL] IDKey idKey1 = new IDKey(1, new Object()); [EOL] assertTrue(idKey1.equals(idKey1)); [EOL] } [EOL] public void testEquals_DifferentClass_ShouldReturnFalse() { [EOL] IDKey idKey = new IDKey(1, new Object()); [EOL] Object other = new Object(); [EOL] assertFalse(idKey.equals(other)); [EOL] } [EOL] public void testEquals_DifferentID_ShouldReturnFalse() { [EOL] IDKey idKey1 = new IDKey(1, new Object()); [EOL] IDKey idKey2 = new IDKey(2, new Object()); [EOL] assertFalse(idKey1.equals(idKey2)); [EOL] } [EOL] public void testEquals_DifferentValue_ShouldReturnFalse() { [EOL] Object value = new Object(); [EOL] IDKey idKey1 = new IDKey(1, value); [EOL] IDKey idKey2 = new IDKey(1, new Object()); [EOL] assertFalse(idKey1.equals(idKey2)); [EOL] } [EOL] public void testEquals_SameIDAndValue_ShouldReturnTrue() { [EOL] Object value = new Object(); [EOL] IDKey idKey1 = new IDKey(1, value); [EOL] IDKey idKey2 = new IDKey(1, value); [EOL] assertTrue(idKey1.equals(idKey2)); [EOL] }
public void testIsTrueWithTrueExpression() { [EOL] Validate.isTrue(true, "This should not throw an exception"); [EOL] }
public void testIsTrueWithFalseExpression() { [EOL] try { [EOL] Validate.isTrue(false, "This should throw an exception because the expression is false"); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("This should throw an exception because the expression is false", e.getMessage()); [EOL] } [EOL] }
public void testIsTrueWithFalseExpressionAndFormattedMessage() { [EOL] try { [EOL] Validate.isTrue(false, "This should throw an exception, value: %d", 100); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("This should throw an exception, value: 100", e.getMessage()); [EOL] } [EOL] }
public void testIsTrueWithTrueExpression() { [EOL] Validate.isTrue(true); [EOL] }
public void testIsTrueWithFalseExpression() { [EOL] try { [EOL] Validate.isTrue(false); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(Validate.DEFAULT_IS_TRUE_EX_MESSAGE, e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_ValidCollection() { [EOL] List<String> collection = Arrays.asList("a", "b", "c"); [EOL] List<String> result = CollectionUtils.validIndex(collection, 1); [EOL] assertEquals(collection, result); [EOL] } [EOL] public void testValidIndex_InvalidIndex() { [EOL] try { [EOL] List<String> collection = Arrays.asList("a", "b", "c"); [EOL] CollectionUtils.validIndex(collection, 4); [EOL] fail("Expected IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testValidIndex_NullCollection() { [EOL] try { [EOL] CollectionUtils.validIndex(null, 1); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testValidIndex_NegativeIndex() { [EOL] try { [EOL] List<String> collection = Arrays.asList("a", "b", "c"); [EOL] CollectionUtils.validIndex(collection, -1); [EOL] fail("Expected IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }

public void testMatchesPattern_ValidPattern() { [EOL] String input = "123abc"; [EOL] String pattern = "\\d+\\w+"; [EOL] StringUtils.matchesPattern(input, pattern); [EOL] }
public void testMatchesPattern_InvalidPattern() { [EOL] String input = "123abc"; [EOL] String pattern = "\\d+"; [EOL] try { [EOL] StringUtils.matchesPattern(input, pattern); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The character sequence 123abc does not match the pattern \\d+", e.getMessage()); [EOL] } [EOL] }
public void testMatchesPattern_NullInput() { [EOL] String pattern = "\\d+"; [EOL] try { [EOL] StringUtils.matchesPattern(null, pattern); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The character sequence null does not match the pattern \\d+", e.getMessage()); [EOL] } [EOL] }
public void testMatchesPattern_NullPattern() { [EOL] String input = "123abc"; [EOL] try { [EOL] StringUtils.matchesPattern(input, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testIsInstanceOfWithValidInstance() { [EOL] Object obj = new String("Test"); [EOL] Class<?> type = String.class; [EOL] isInstanceOf(type, obj); [EOL] }
public void testIsInstanceOfWithInvalidInstance() { [EOL] Object obj = new Integer(123); [EOL] Class<?> type = String.class; [EOL] try { [EOL] isInstanceOf(type, obj); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Expected instance of: java.lang.String, got: java.lang.Integer", e.getMessage()); [EOL] } [EOL] }
public void testIsInstanceOfWithNullObject() { [EOL] Object obj = null; [EOL] Class<?> type = String.class; [EOL] try { [EOL] isInstanceOf(type, obj); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Expected instance of: java.lang.String, got: null", e.getMessage()); [EOL] } [EOL] }
public void testIsInstanceOfWithNullType() { [EOL] Object obj = new String("Test"); [EOL] Class<?> type = null; [EOL] try { [EOL] isInstanceOf(type, obj); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testOf_withNonNullValues() { [EOL] String left = "left"; [EOL] String middle = "middle"; [EOL] String right = "right"; [EOL] ImmutableTriple<String, String, String> result = ImmutableTriple.of(left, middle, right); [EOL] assertNotNull(result); [EOL] assertEquals(left, result.getLeft()); [EOL] assertEquals(middle, result.getMiddle()); [EOL] assertEquals(right, result.getRight()); [EOL] }
public void testOf_withNullValues() { [EOL] ImmutableTriple<Object, Object, Object> result = ImmutableTriple.of(null, null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getLeft()); [EOL] assertNull(result.getMiddle()); [EOL] assertNull(result.getRight()); [EOL] }
public void testImmutableTripleWithAllNonNullValues() { [EOL] Object left = new Object(); [EOL] Object middle = new Object(); [EOL] Object right = new Object(); [EOL] ImmutableTriple<Object, Object, Object> triple = new ImmutableTriple<>(left, middle, right); [EOL] assertSame(left, triple.getLeft()); [EOL] assertSame(middle, triple.getMiddle()); [EOL] assertSame(right, triple.getRight()); [EOL] }
public void testImmutableTripleWithNullValues() { [EOL] ImmutableTriple<Object, Object, Object> triple = new ImmutableTriple<>(null, null, null); [EOL] assertNull(triple.getLeft()); [EOL] assertNull(triple.getMiddle()); [EOL] assertNull(triple.getRight()); [EOL] }
public void testGetMiddle_WhenMiddleIsSet_ShouldReturnMiddle() { [EOL] Object expectedMiddle = new Object(); [EOL] Triple<Object, Object, Object> triple = new ImmutableTriple<>(null, expectedMiddle, null); [EOL] Object actualMiddle = triple.getMiddle(); [EOL] assertEquals(expectedMiddle, actualMiddle); [EOL] }
public void testCompareTo_SameValue() { [EOL] MutableBoolean mutableBooleanTrue1 = new MutableBoolean(true); [EOL] MutableBoolean mutableBooleanTrue2 = new MutableBoolean(true); [EOL] assertEquals(0, mutableBooleanTrue1.compareTo(mutableBooleanTrue2)); [EOL] }
public void testCompareTo_DifferentValueTrueFirst() { [EOL] MutableBoolean mutableBooleanTrue = new MutableBoolean(true); [EOL] MutableBoolean mutableBooleanFalse = new MutableBoolean(false); [EOL] assertEquals(1, mutableBooleanTrue.compareTo(mutableBooleanFalse)); [EOL] }
public void testCompareTo_DifferentValueFalseFirst() { [EOL] MutableBoolean mutableBooleanFalse = new MutableBoolean(false); [EOL] MutableBoolean mutableBooleanTrue = new MutableBoolean(true); [EOL] assertEquals(-1, mutableBooleanFalse.compareTo(mutableBooleanTrue)); [EOL] }
public void testFormatDurationHMS_Zero() { [EOL] String result = DurationFormatUtils.formatDurationHMS(0); [EOL] assertEquals("0:00:00.000", result); [EOL] }
public void testFormatDurationHMS_OneHour() { [EOL] String result = DurationFormatUtils.formatDurationHMS(3600000); [EOL] assertEquals("1:00:00.000", result); [EOL] }
public void testFormatDurationHMS_OneMinute() { [EOL] String result = DurationFormatUtils.formatDurationHMS(60000); [EOL] assertEquals("0:01:00.000", result); [EOL] }
public void testFormatDurationHMS_OneSecond() { [EOL] String result = DurationFormatUtils.formatDurationHMS(1000); [EOL] assertEquals("0:00:01.000", result); [EOL] }
public void testFormatDurationHMS_OneMillisecond() { [EOL] String result = DurationFormatUtils.formatDurationHMS(1); [EOL] assertEquals("0:00:00.001", result); [EOL] }
public void testFormatDurationHMS_ComplexTime() { [EOL] String result = DurationFormatUtils.formatDurationHMS(3661001); [EOL] assertEquals("1:01:01.001", result); [EOL] }
public void testFormatPeriodWithSameStartAndEnd() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis; [EOL] String format = "y M d H m s S"; [EOL] boolean padWithZeros = false; [EOL] TimeZone timezone = TimeZone.getDefault(); [EOL] String result = formatPeriod(startMillis, endMillis, format, padWithZeros, timezone); [EOL] assertEquals("0 0 0 0 0 0 0", result); [EOL] }
public void testFormatPeriodWithDifferentStartAndEnd() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 1000 + 60 * 1000 + 60 * 60 * 1000 + 24 * 60 * 60 * 1000; // 1 second + 1 minute + 1 hour + 1 day [EOL] String format = "y M d H m s S"; [EOL] boolean padWithZeros = false; [EOL] TimeZone timezone = TimeZone.getDefault(); [EOL] String result = formatPeriod(startMillis, endMillis, format, padWithZeros, timezone); [EOL] assertEquals("0 0 1 1 1 1 0", result); [EOL] }
public void testFormatPeriodWithNegativeMilliseconds() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis - 1; // negative millisecond difference [EOL] String format = "S"; [EOL] boolean padWithZeros = false; [EOL] TimeZone timezone = TimeZone.getDefault(); [EOL] String result = formatPeriod(startMillis, endMillis, format, padWithZeros, timezone); [EOL] assertEquals("999", result); [EOL] }
public void testFormatPeriodWithTokenY() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 12 * 30 * 24 * 60 * 60 * 1000L; // approximately 1 year [EOL] String format = "y"; [EOL] boolean padWithZeros = false; [EOL] TimeZone timezone = TimeZone.getDefault(); [EOL] String result = formatPeriod(startMillis, endMillis, format, padWithZeros, timezone); [EOL] assertEquals("1", result); [EOL] }
public void testFormatPeriodWithTokenMAndNoTokenY() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 13 * 30 * 24 * 60 * 60 * 1000L; // more than 1 year [EOL] String format = "M"; [EOL] boolean padWithZeros = false; [EOL] TimeZone timezone = TimeZone.getDefault(); [EOL] String result = formatPeriod(startMillis, endMillis, format, padWithZeros, timezone); [EOL] assertEquals("13", result); [EOL] }
public void testFormatPeriodWithLeapYear() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTimeInMillis(startMillis); [EOL] cal.set(Calendar.YEAR, 2020); // leap year [EOL] cal.set(Calendar.MONTH, Calendar.FEBRUARY); [EOL] cal.set(Calendar.DAY_OF_MONTH, 28); [EOL] startMillis = cal.getTimeInMillis(); [EOL] long endMillis = startMillis + 2 * 24 * 60 * 60 * 1000L; // 2 days, crossing over to March 1st [EOL] String format = "d"; [EOL] boolean padWithZeros = false; [EOL] TimeZone timezone = TimeZone.getDefault(); [EOL] String result = formatPeriod(startMillis, endMillis, format, padWithZeros, timezone); [EOL] assertEquals("2", result); [EOL] }
public void testTokenWithNullValue() { [EOL] Token token = new Token(null, 5); [EOL] assertNull(token.value); [EOL] assertEquals(5, token.count); [EOL] }
public void testTokenWithNonNullValue() { [EOL] Object obj = new Object(); [EOL] Token token = new Token(obj, 10); [EOL] assertSame(obj, token.value); [EOL] assertEquals(10, token.count); [EOL] }
public void testEquals_SameToken() { [EOL] Token token1 = new Token("value", 1); [EOL] Token token2 = new Token("value", 1); [EOL] assertTrue(token1.equals(token2)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] Token token1 = new Token("value", 1); [EOL] Object token2 = new Object(); [EOL] assertFalse(token1.equals(token2)); [EOL] } [EOL] public void testEquals_DifferentCount() { [EOL] Token token1 = new Token("value", 1); [EOL] Token token2 = new Token("value", 2); [EOL] assertFalse(token1.equals(token2)); [EOL] } [EOL] public void testEquals_StringBuilder() { [EOL] Token token1 = new Token(new StringBuilder("value"), 1); [EOL] Token token2 = new Token(new StringBuilder("value"), 1); [EOL] assertTrue(token1.equals(token2)); [EOL] } [EOL] public void testEquals_Number() { [EOL] Token token1 = new Token(Integer.valueOf(123), 1); [EOL] Token token2 = new Token(Integer.valueOf(123), 1); [EOL] assertTrue(token1.equals(token2)); [EOL] } [EOL] public void testEquals_DifferentValue() { [EOL] Token token1 = new Token("value1", 1); [EOL] Token token2 = new Token("value2", 1); [EOL] assertFalse(token1.equals(token2)); [EOL] }
public void testToString_WhenCountIsZero_ShouldReturnEmptyString() { [EOL] RepeatableString repeatableString = new RepeatableString("abc", 0); [EOL] String result = repeatableString.toString(); [EOL] assertEquals("", result); [EOL] }
public void testToString_WhenCountIsOne_ShouldReturnOriginalString() { [EOL] RepeatableString repeatableString = new RepeatableString("abc", 1); [EOL] String result = repeatableString.toString(); [EOL] assertEquals("abc", result); [EOL] }
public void testToString_WhenCountIsMultiple_ShouldReturnRepeatedString() { [EOL] RepeatableString repeatableString = new RepeatableString("abc", 3); [EOL] String result = repeatableString.toString(); [EOL] assertEquals("abcabcabc", result); [EOL] }
public void testContainsAnyWithEmptyStringAndEmptySet() { [EOL] boolean result = StringUtils.containsAny("", (String[]) null); [EOL] assertFalse(result); [EOL] }
public void testContainsAnyWithNonEmptyStringAndEmptySet() { [EOL] boolean result = StringUtils.containsAny("abc", (String[]) null); [EOL] assertFalse(result); [EOL] }
public void testContainsAnyWithEmptyStringAndNonEmptySet() { [EOL] boolean result = StringUtils.containsAny("", "a", "b"); [EOL] assertFalse(result); [EOL] }
public void testContainsAnyWithNonEmptyStringAndNonEmptySetNotContainingChars() { [EOL] boolean result = StringUtils.containsAny("abc", "d", "e"); [EOL] assertFalse(result); [EOL] }
public void testContainsAnyWithNonEmptyStringAndNonEmptySetContainingChars() { [EOL] boolean result = StringUtils.containsAny("abc", "b", "c"); [EOL] assertTrue(result); [EOL] }
public void testDeepEmptyWithNullArray() { [EOL] boolean result = deepEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testDeepEmptyWithEmptyArray() { [EOL] String[] strings = new String[]{}; [EOL] boolean result = deepEmpty(strings); [EOL] assertTrue(result); [EOL] }
public void testDeepEmptyWithAllEmptyStrings() { [EOL] String[] strings = new String[]{"", "", ""}; [EOL] boolean result = deepEmpty(strings); [EOL] assertTrue(result); [EOL] }
public void testDeepEmptyWithNonEmptyString() { [EOL] String[] strings = new String[]{"", "non-empty", ""}; [EOL] boolean result = deepEmpty(strings); [EOL] assertFalse(result); [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable) { [EOL] return getCause(throwable, CAUSE_METHOD_NAMES); [EOL] } [EOL] public ExceptionUtils(); [EOL] public static String[] getDefaultCauseMethodNames(); [EOL] public static Throwable getCause(final Throwable throwable); [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames); [EOL] public static Throwable getRootCause(final Throwable throwable); [EOL] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); [EOL] public static int getThrowableCount(final Throwable throwable); [EOL] public static Throwable[] getThrowables(final Throwable throwable); [EOL] public static List<Throwable> getThrowableList(Throwable throwable); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); [EOL] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); [EOL] public static void printRootCauseStackTrace(final Throwable throwable); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); [EOL] public static String[] getRootCauseStackTrace(final Throwable throwable); [EOL] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); [EOL] public static String getStackTrace(final Throwable throwable); [EOL] public static String[] getStackFrames(final Throwable throwable); [EOL] static String[] getStackFrames(final String stackTrace); [EOL] static List<String> getStackFrameList(final Throwable t); [EOL] public static String getMessage(final Throwable th); [EOL] public static String getRootCauseMessage(final Throwable th); [EOL] String WRAPPED_MARKER=Optional[" [wrapped] "]; [EOL] String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public void testGetCause_NullThrowable() { [EOL] Throwable result = ExceptionUtils.getCause(null, null); [EOL] assertNull(result); [EOL] }
public void testGetCause_NullMethodNames() { [EOL] Throwable throwable = new RuntimeException(); [EOL] Throwable result = ExceptionUtils.getCause(throwable, null); [EOL] assertNotNull(result); [EOL] }
public void testGetCause_EmptyMethodNames() { [EOL] Throwable throwable = new RuntimeException(); [EOL] String[] methodNames = new String[0]; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNull(result); [EOL] }
public void testGetCause_ValidMethodNames() { [EOL] Throwable throwable = new RuntimeException(new IllegalArgumentException()); [EOL] String[] methodNames = {"getCause"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IllegalArgumentException); [EOL] }
public void testGetCause_InvalidMethodNames() { [EOL] Throwable throwable = new RuntimeException(new IllegalArgumentException()); [EOL] String[] methodNames = {"invalidMethodName"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNull(result); [EOL] }
public void testGetCause_NullInMethodNames() { [EOL] Throwable throwable = new RuntimeException(new IllegalArgumentException()); [EOL] String[] methodNames = {null, "getCause"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof IllegalArgumentException); [EOL] }
public void testGetRootCause_NullInput() { [EOL] Throwable root = ExceptionUtils.getRootCause(null); [EOL] assertNull(root); [EOL] }
public void testGetRootCause_NoCause() { [EOL] Throwable throwable = new Throwable(); [EOL] Throwable root = ExceptionUtils.getRootCause(throwable); [EOL] assertNull(root); [EOL] }
public void testGetRootCause_SingleCause() { [EOL] Throwable cause = new Throwable(); [EOL] Throwable throwable = new Throwable(cause); [EOL] Throwable root = ExceptionUtils.getRootCause(throwable); [EOL] assertSame(cause, root); [EOL] }
public void testGetRootCause_MultipleCauses() { [EOL] Throwable cause = new Throwable(); [EOL] Throwable middle = new Throwable(cause); [EOL] Throwable throwable = new Throwable(middle); [EOL] Throwable root = ExceptionUtils.getRootCause(throwable); [EOL] assertSame(cause, root); [EOL] }
private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) { [EOL] Method method = null; [EOL] try { [EOL] method = throwable.getClass().getMethod(methodName); [EOL] } catch (final NoSuchMethodException ignored) { [EOL] } catch (final SecurityException ignored) { [EOL] } [EOL] if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) { [EOL] try { [EOL] return (Throwable) method.invoke(throwable); [EOL] } catch (final IllegalAccessException ignored) { [EOL] } catch (final IllegalArgumentException ignored) { [EOL] } catch (final InvocationTargetException ignored) { [EOL] } [EOL] } [EOL] return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public void testGetThrowableCount_withNullThrowable() { [EOL] int count = ExceptionUtils.getThrowableCount(null); [EOL] assertEquals("Expected count to be 0 for null throwable", 0, count); [EOL] }
public void testGetThrowableCount_withNonNullThrowable() { [EOL] Throwable throwable = new Throwable(); [EOL] int count = ExceptionUtils.getThrowableCount(throwable); [EOL] assertEquals("Expected count to be 1 for non-null throwable without cause", 1, count); [EOL] }
public void testGetThrowableCount_withNestedThrowable() { [EOL] Throwable cause = new Throwable(); [EOL] Throwable throwable = new Throwable(cause); [EOL] int count = ExceptionUtils.getThrowableCount(throwable); [EOL] assertEquals("Expected count to be 2 for throwable with one cause", 2, count); [EOL] }
public void testGetThrowableCount_withDeeplyNestedThrowable() { [EOL] Throwable cause3 = new Throwable(); [EOL] Throwable cause2 = new Throwable(cause3); [EOL] Throwable cause1 = new Throwable(cause2); [EOL] Throwable throwable = new Throwable(cause1); [EOL] int count = ExceptionUtils.getThrowableCount(throwable); [EOL] assertEquals("Expected count to be 4 for throwable with multiple nested causes", 4, count); [EOL] }
public void testGetThrowables_NullInput() { [EOL] Throwable[] throwables = ExceptionUtils.getThrowables(null); [EOL] assertNotNull(throwables); [EOL] assertEquals(0, throwables.length); [EOL] }
public void testGetThrowables_SingleThrowable() { [EOL] Throwable throwable = new Throwable(); [EOL] Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL] assertNotNull(throwables); [EOL] assertEquals(1, throwables.length); [EOL] assertSame(throwable, throwables[0]); [EOL] }
public void testGetThrowables_NestedThrowables() { [EOL] Throwable throwable1 = new Throwable(); [EOL] Throwable throwable2 = new Throwable(throwable1); [EOL] Throwable throwable3 = new Throwable(throwable2); [EOL] Throwable[] throwables = ExceptionUtils.getThrowables(throwable3); [EOL] assertNotNull(throwables); [EOL] assertEquals(3, throwables.length); [EOL] assertSame(throwable3, throwables[0]); [EOL] assertSame(throwable2, throwables[1]); [EOL] assertSame(throwable1, throwables[2]); [EOL] }
public void testGetThrowableList_withNullThrowable() { [EOL] List<Throwable> result = ExceptionUtils.getThrowableList(null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testGetThrowableList_withNonNullThrowableWithoutCause() { [EOL] Throwable throwable = new Throwable(); [EOL] List<Throwable> result = ExceptionUtils.getThrowableList(throwable); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertSame(throwable, result.get(0)); [EOL] }
public void testGetThrowableList_withNonNullThrowableWithCause() { [EOL] Throwable cause = new Throwable(); [EOL] Throwable throwable = new Throwable(cause); [EOL] List<Throwable> result = ExceptionUtils.getThrowableList(throwable); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertSame(throwable, result.get(0)); [EOL] assertSame(cause, result.get(1)); [EOL] }
public void testGetThrowableList_withCyclicCause() { [EOL] Throwable cause = new Throwable(); [EOL] Throwable throwable = new Throwable(cause); [EOL] setCause(cause, throwable); [EOL] List<Throwable> result = ExceptionUtils.getThrowableList(throwable); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertSame(throwable, result.get(0)); [EOL] assertSame(cause, result.get(1)); [EOL] } [EOL] private void setCause(Throwable target, Throwable cause) { [EOL] try { [EOL] Field causeField = Throwable.class.getDeclaredField("cause"); [EOL] causeField.setAccessible(true); [EOL] causeField.set(target, cause); [EOL] } catch (Exception e) { [EOL] throw new RuntimeException("Could not set the cause on Throwable", e); [EOL] } [EOL] }
public void testGetRootCauseStackTrace_NullThrowable() { [EOL] String[] result = ExceptionUtils.getRootCauseStackTrace(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testGetRootCauseStackTrace_SingleThrowable() { [EOL] Throwable throwable = new Throwable("Single Throwable"); [EOL] String[] result = ExceptionUtils.getRootCauseStackTrace(throwable); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] assertTrue(result[0].contains("Single Throwable")); [EOL] }
public void testGetRootCauseStackTrace_NestedThrowable() { [EOL] Throwable rootCause = new Throwable("Root Cause"); [EOL] Throwable nested = new Exception("Nested Exception", rootCause); [EOL] Throwable top = new Exception("Top Level Exception", nested); [EOL] String[] result = ExceptionUtils.getRootCauseStackTrace(top); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] assertTrue(result[0].contains("Root Cause")); [EOL] boolean wrappedMarkerFound = false; [EOL] for (String frame : result) { [EOL] if (frame.contains(ExceptionUtils.WRAPPED_MARKER)) { [EOL] wrappedMarkerFound = true; [EOL] break; [EOL] } [EOL] } [EOL] assertTrue(wrappedMarkerFound); [EOL] }
public void testGetRootCauseStackTrace_ThrowableWithCommonFrames() { [EOL] Throwable rootCause = new Throwable("Root Cause"); [EOL] Throwable nested = new Exception("Nested Exception", rootCause); [EOL] Throwable top = new Exception("Top Level Exception", nested); [EOL] Throwable withCommonFrames = new Exception("With Common Frames", top); [EOL] String[] result = ExceptionUtils.getRootCauseStackTrace(withCommonFrames); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] assertTrue(result[0].contains("Root Cause")); [EOL] int commonFramesCount = 0; [EOL] for (int i = 1; i < result.length; i++) { [EOL] if (result[i].contains(ExceptionUtils.WRAPPED_MARKER)) { [EOL] commonFramesCount++; [EOL] } [EOL] } [EOL] assertTrue(commonFramesCount > 0); [EOL] }
public void testRemoveCommonFrames_NullLists() { [EOL] try { [EOL] ExceptionUtils.removeCommonFrames(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRemoveCommonFrames_OneNullList() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("frame2"); [EOL] try { [EOL] ExceptionUtils.removeCommonFrames(causeFrames, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] try { [EOL] ExceptionUtils.removeCommonFrames(null, causeFrames); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRemoveCommonFrames_NoCommonFrames() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("frame2"); [EOL] List<String> wrapperFrames = new ArrayList<>(); [EOL] wrapperFrames.add("frame3"); [EOL] wrapperFrames.add("frame4"); [EOL] ExceptionUtils.removeCommonFrames(causeFrames, wrapperFrames); [EOL] assertEquals("Expected no frames to be removed", 2, causeFrames.size()); [EOL] } [EOL] public void testRemoveCommonFrames_CommonFrames() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("frame2"); [EOL] causeFrames.add("frame3"); [EOL] List<String> wrapperFrames = new ArrayList<>(); [EOL] wrapperFrames.add("frame2"); [EOL] wrapperFrames.add("frame3"); [EOL] ExceptionUtils.removeCommonFrames(causeFrames, wrapperFrames); [EOL] assertEquals("Expected common frames to be removed", 1, causeFrames.size()); [EOL] assertEquals("Expected first frame to remain", "frame1", causeFrames.get(0)); [EOL] }
public void testRemoveCommonFrames_AllCommonFrames() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("frame2"); [EOL] List<String> wrapperFrames = new ArrayList<>(); [EOL] wrapperFrames.add("frame1"); [EOL] wrapperFrames.add("frame2"); [EOL] ExceptionUtils.removeCommonFrames(causeFrames, wrapperFrames); [EOL] assertTrue("Expected all frames to be removed", causeFrames.isEmpty()); [EOL] }
public void testGetStackTraceWithNullException() { [EOL] try { [EOL] ExceptionUtils.getStackTrace(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testGetStackTrace() { [EOL] Throwable throwable = new Throwable("Test Throwable"); [EOL] String stackTrace = ExceptionUtils.getStackTrace(throwable); [EOL] assertNotNull("The stack trace should not be null", stackTrace); [EOL] assertTrue("The stack trace should contain the throwable message", [EOL] stackTrace.contains("Test Throwable")); [EOL] }
public void testGetStackTraceWithDerivedException() { [EOL] Throwable throwable = new Exception("Derived Exception") { [EOL] @Override [EOL] public void printStackTrace(PrintWriter pw) { [EOL] pw.println("Custom stack trace"); [EOL] } [EOL] }; [EOL] String stackTrace = ExceptionUtils.getStackTrace(throwable); [EOL] assertNotNull("The stack trace should not be null", stackTrace); [EOL] assertTrue("The stack trace should contain the custom stack trace", [EOL] stackTrace.contains("Custom stack trace")); [EOL] }
static List<String> getStackFrameList(final Throwable t) { [EOL] final String stackTrace = getStackTrace(t); [EOL] final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL] final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL] final List<String> list = new ArrayList<String>(); [EOL] boolean traceStarted = false; [EOL] while (frames.hasMoreTokens()) { [EOL] final String token = frames.nextToken(); [EOL] final int at = token.indexOf("at"); [EOL] if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL] traceStarted = true; [EOL] list.add(token); [EOL] } else if (traceStarted) { [EOL] break; [EOL] } [EOL] } [EOL] return list; [EOL] }
public void testToShort() { [EOL] NumberUtils numUtils = new NumberUtils((short) 1); [EOL] Short result = numUtils.toShort(); [EOL] assertEquals("The short value should be equal to 1", Short.valueOf((short) 1), result); [EOL] }
public void testStart_WhenStopped_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_STOPPED; [EOL] try { [EOL] stopwatch.start(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch must be reset before being restarted. ", e.getMessage()); [EOL] } [EOL] }
public void testStart_WhenAlreadyStarted_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_RUNNING; [EOL] try { [EOL] stopwatch.start(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch already started. ", e.getMessage()); [EOL] } [EOL] }
public void testStart_WhenUnstarted_ShouldStartStopwatch() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.runningState = Stopwatch.STATE_UNSTARTED; [EOL] stopwatch.start(); [EOL] assertEquals(Stopwatch.STATE_RUNNING, stopwatch.runningState); [EOL] assertTrue(stopwatch.startTime > 0); [EOL] assertTrue(stopwatch.startTimeMillis > 0); [EOL] }
public void testStopWhenNotRunning() { [EOL] stopwatch.runningState = STATE_UNSTARTED; [EOL] try { [EOL] stopwatch.stop(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch is not running. ", e.getMessage()); [EOL] } [EOL] } [EOL] public void testStopWhenSuspended() { [EOL] stopwatch.runningState = STATE_SUSPENDED; [EOL] stopwatch.stop(); [EOL] assertEquals(STATE_STOPPED, stopwatch.runningState); [EOL] } [EOL] public void testStopWhenRunning() { [EOL] stopwatch.runningState = STATE_RUNNING; [EOL] stopwatch.stop(); [EOL] assertEquals(STATE_STOPPED, stopwatch.runningState); [EOL] assertTrue(stopwatch.stopTime > 0); [EOL] }
public void testSplit_WhenNotRunning_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.split(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch is not running. ", e.getMessage()); [EOL] } [EOL] }
public void testSplit_WhenRunning_ShouldUpdateSplitTime() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.split(); [EOL] assertTrue(stopwatch.getSplitTime() > 0); [EOL] assertEquals(Stopwatch.STATE_SPLIT, stopwatch.getSplitState()); [EOL] }
public void testUnsplitWhenNotSplit() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.unsplit(); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException ex) { [EOL] assertEquals("Stopwatch has not been split. ", ex.getMessage()); [EOL] } [EOL] }
public void testUnsplitWhenSplit() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.split(); [EOL] try { [EOL] stopwatch.unsplit(); [EOL] assertEquals(Stopwatch.STATE_UNSPLIT, stopwatch.getSplitState()); [EOL] } catch (IllegalStateException ex) { [EOL] fail("Should not have thrown IllegalStateException"); [EOL] } [EOL] }
public void testSuspend_WhenRunning() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.suspend(); [EOL] assertEquals(Stopwatch.STATE_SUSPENDED, stopwatch.getRunningState()); [EOL] assertTrue(stopwatch.getStopTime() > 0); [EOL] }
public void testSuspend_WhenNotRunning_ThrowsException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.suspend(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch must be running to suspend. ", e.getMessage()); [EOL] } [EOL] }
public void testResume_NotSuspended_ThrowsException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.resume(); [EOL] fail("Expected IllegalStateException not thrown."); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch must be suspended to resume. ", e.getMessage()); [EOL] } [EOL] }
public void testResume_Suspended_ResumesCorrectly() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] stopwatch.suspend(); [EOL] long beforeResume = System.nanoTime(); [EOL] stopwatch.resume(); [EOL] long afterResume = System.nanoTime(); [EOL] assertTrue(stopwatch.isRunning()); [EOL] assertTrue(stopwatch.getStartTime() >= beforeResume && stopwatch.getStartTime() <= afterResume); [EOL] }
public void testGetNanoTime_StoppedOrSuspended() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] stopWatch.stop(); [EOL] long expected = stopWatch.getStopTime() - stopWatch.getStartTime(); [EOL] long actual = stopWatch.getNanoTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetNanoTime_Unstarted() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] long expected = 0; [EOL] long actual = stopWatch.getNanoTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetNanoTime_Running() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] long startTime = stopWatch.getStartTime(); [EOL] long expected = System.nanoTime() - startTime; [EOL] long actual = stopWatch.getNanoTime(); [EOL] assertTrue(Math.abs(expected - actual) < 100); // Allowing a small margin for execution time [EOL] }
public void testGetNanoTime_IllegalState() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] try { [EOL] Field stateField = StopWatch.class.getDeclaredField("runningState"); [EOL] stateField.setAccessible(true); [EOL] stateField.set(stopWatch, Integer.MAX_VALUE); // Setting to an arbitrary illegal state value [EOL] stopWatch.getNanoTime(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Illegal running state has occurred.", e.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Unexpected exception type thrown"); [EOL] } [EOL] }
public void testGetSplitNanoTime_WhenNotSplit_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.getSplitNanoTime(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch must be split to get the split time. ", e.getMessage()); [EOL] } [EOL] }
public void testGetSplitNanoTime_WhenSplit_ShouldReturnCorrectNanoTime() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] try { [EOL] Thread.sleep(10); [EOL] } catch (InterruptedException e) { [EOL] Thread.currentThread().interrupt(); [EOL] } [EOL] stopwatch.split(); [EOL] long expectedSplitTime = stopwatch.getSplitNanoTime(); [EOL] assertTrue(expectedSplitTime > 0); [EOL] }
public void testToString() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] try { [EOL] Thread.sleep(1000); [EOL] } catch (InterruptedException ie) { [EOL] } [EOL] stopWatch.stop(); [EOL] String result = stopWatch.toString(); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith("0:00:01")); [EOL] }
public void testCompareToBuilderConstructor() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] assertEquals("comparison should be zero after initialization", 0, compareToBuilder.toComparison()); [EOL] }
public void testAppend_BothObjectsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, null, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_LeftObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, new Object(), null); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppend_RightObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(new Object(), null, null); [EOL] assertEquals(+1, builder.toComparison()); [EOL] }
public void testAppend_BothObjectsSame() { [EOL] Object obj = new Object(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(obj, obj, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_WithComparator() { [EOL] Object lhs = new Object(); [EOL] Object rhs = new Object(); [EOL] Comparator<Object> comparator = Comparator.naturalOrder(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(comparator.compare(lhs, rhs), builder.toComparison()); [EOL] }
public void testAppend_WithoutComparator() { [EOL] Comparable<Object> lhs = "a"; [EOL] Comparable<Object> rhs = "b"; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs, null); [EOL] assertEquals(lhs.compareTo(rhs), builder.toComparison()); [EOL] }
public void testAppend_WithArray() { [EOL] long[] lhsArray = {1L, 2L, 3L}; [EOL] long[] rhsArray = {1L, 2L, 3L}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_WithDifferentTypeArray() { [EOL] int[] lhsArray = {1, 2, 3}; [EOL] long[] rhsArray = {1L, 2L, 3L}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhsArray, rhsArray, null); [EOL] assertNotEquals(0, builder.toComparison()); [EOL] }
public void testAppend_LongEqual() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(5L, 5L); [EOL] assertEquals(0, compareToBuilder.toComparison()); [EOL] }
public void testAppend_LongLessThan() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(3L, 5L); [EOL] assertEquals(-1, compareToBuilder.toComparison()); [EOL] }
public void testAppend_LongGreaterThan() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(10L, 5L); [EOL] assertEquals(1, compareToBuilder.toComparison()); [EOL] }
public void testAppend_LongWithNonZeroComparison() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(5L, 5L); [EOL] compareToBuilder.append(10L, 5L); // This should not affect the comparison since the first call resulted in 0 [EOL] assertEquals(0, compareToBuilder.toComparison()); [EOL] }
public void testAppendObjectArraysWithNullComparator() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] { "a", "b", "c" }; [EOL] Object[] rhs = new Object[] { "a", "b", "c" }; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() == 0); [EOL] }
public void testAppendObjectArraysDifferentLengths() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] { "a", "b" }; [EOL] Object[] rhs = new Object[] { "a", "b", "c" }; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendObjectArraysDifferentElements() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] { "a", "b" }; [EOL] Object[] rhs = new Object[] { "a", "c" }; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendObjectArraysFirstArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = new Object[] { "a", "b", "c" }; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppendObjectArraysSecondArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] { "a", "b", "c" }; [EOL] Object[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppendObjectArraysBothNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() == 0); [EOL] }
public void testAppend_BothArraysNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = null; [EOL] Comparator<?> comparator = null; [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_LeftArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = new Object[]{}; [EOL] Comparator<?> comparator = null; [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppend_RightArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[]{}; [EOL] Object[] rhs = null; [EOL] Comparator<?> comparator = null; [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppend_ArraysWithDifferentLength() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[]{1}; [EOL] Object[] rhs = new Object[]{1, 2}; [EOL] Comparator<?> comparator = null; [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppend_ArraysWithSameLength() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[]{1, 2}; [EOL] Object[] rhs = new Object[]{1, 2}; [EOL] Comparator<?> comparator = null; [EOL] builder.append(lhs, rhs, comparator); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_ArraysWithSameLengthButDifferentElements() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[]{1, 2}; [EOL] Object[] rhs = new Object[]{1, 3}; [EOL] Comparator<?> comparator = Comparator.naturalOrder(); [EOL] builder.append(lhs, rhs, comparator); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_NonZeroComparison() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] Object[] lhs = new Object[]{1, 2}; [EOL] Object[] rhs = new Object[]{1, 2}; [EOL] Comparator<?> comparator = null; [EOL] builder.append(lhs, rhs, comparator); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppendSameLongArrays() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] long[] array1 = {1L, 2L, 3L}; [EOL] long[] array2 = array1; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] } [EOL] public void testAppendDifferentLongArraysSameLength() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] long[] array1 = {1L, 2L, 3L}; [EOL] long[] array2 = {1L, 2L, 3L}; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] } [EOL] public void testAppendDifferentLongArraysDifferentLengths() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] long[] array1 = {1L, 2L, 3L}; [EOL] long[] array2 = {1L, 2L}; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] } [EOL] public void testAppendLongArrayToNull() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] long[] array1 = null; [EOL] long[] array2 = {1L, 2L, 3L}; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] } [EOL] public void testAppendNullToLongArray() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] long[] array1 = {1L, 2L, 3L}; [EOL] long[] array2 = null; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] } [EOL] public void testAppendNonNullLongArraysDifferentElements() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] long[] array1 = {1L, 2L, 3L}; [EOL] long[] array2 = {4L, 5L, 6L}; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] } [EOL] public void testAppendLongArraysWithInitialNonZeroComparison() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(1L, 2L); // This will set comparison to a non-zero value [EOL] long[] array1 = {1L, 2L, 3L}; [EOL] long[] array2 = {1L, 2L, 3L}; [EOL] CompareToBuilder result = compareToBuilder.append(array1, array2); [EOL] assertSame(result, compareToBuilder); [EOL] }
public void testAppendSameArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] array = new int[] {1, 2, 3}; [EOL] builder.append(array, array); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendDifferentLengthArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendDifferentArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 4}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendNullLeftArray() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = null; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendNullRightArray() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppendNonNullArraysAlreadyCompared() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] int[] lhs = new int[] {1, 2, 3}; [EOL] int[] rhs = new int[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendBooleanArraysWithEqualArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysFirstArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = null; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysSecondArrayNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false, true}; [EOL] boolean[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysDifferentLengths() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {true, false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppendBooleanArraysSameLengthDifferentElements() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {false, true}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendBooleanArraysAlreadyNonZeroComparison() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 0); // This will set comparison to a non-zero value [EOL] boolean[] lhs = {true, false}; [EOL] boolean[] rhs = {true, false}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testToComparison_Positive() { [EOL] ComparisonChain chain = ComparisonChain.start().compare(1, 1); [EOL] assertEquals(0, chain.toComparison()); [EOL] }
public void testToComparison_Negative() { [EOL] ComparisonChain chain = ComparisonChain.start().compare(1, 2); [EOL] assertTrue(chain.toComparison() < 0); [EOL] }
public void testToComparison_Greater() { [EOL] ComparisonChain chain = ComparisonChain.start().compare(2, 1); [EOL] assertTrue(chain.toComparison() > 0); [EOL] }
public void testStringUtilsConstructor() throws Exception { [EOL] Constructor<StringUtils> constructor = StringUtils.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Expected an InvocationTargetException to be thrown"); [EOL] } catch (InvocationTargetException e) { [EOL] assertTrue(e.getCause() instanceof UnsupportedOperationException); [EOL] } [EOL] }
public void testIsEmpty_NullInput() { [EOL] boolean result = StringUtils.isEmpty(null); [EOL] assertTrue(result); [EOL] }
public void testIsEmpty_EmptyString() { [EOL] boolean result = StringUtils.isEmpty(""); [EOL] assertTrue(result); [EOL] }
public void testIsEmpty_NonEmptyString() { [EOL] boolean result = StringUtils.isEmpty("abc"); [EOL] assertFalse(result); [EOL] }
public void testTrimToNull_NullInput() { [EOL] String result = StringUtils.trimToNull(null); [EOL] assertNull(result); [EOL] }
public void testTrimToNull_EmptyString() { [EOL] String result = StringUtils.trimToNull(""); [EOL] assertNull(result); [EOL] }
public void testTrimToNull_OnlyWhitespaces() { [EOL] String result = StringUtils.trimToNull("   "); [EOL] assertNull(result); [EOL] }
public void testTrimToNull_NonEmptyString() { [EOL] String result = StringUtils.trimToNull("  abc  "); [EOL] assertEquals("abc", result); [EOL] }
public void testStripStart_NullString() { [EOL] String result = StringUtils.stripStart(null, "abc"); [EOL] assertNull(result); [EOL] } [EOL] public void testStripStart_EmptyString() { [EOL] String result = StringUtils.stripStart("", "abc"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStripStart_NullStripChars() { [EOL] String result = StringUtils.stripStart("abc", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_EmptyStripChars() { [EOL] String result = StringUtils.stripStart("abc", ""); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_NoStripChars() { [EOL] String result = StringUtils.stripStart("abc", "xyz"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_StripStartChars() { [EOL] String result = StringUtils.stripStart("abcabc", "ab"); [EOL] assertEquals("cabc", result); [EOL] } [EOL] public void testStripStart_AllStripped() { [EOL] String result = StringUtils.stripStart("abc", "abc"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStripStart_WhiteSpace() { [EOL] String result = StringUtils.stripStart("   abc", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripStart_NoStripWithWhiteSpace() { [EOL] String result = StringUtils.stripStart("abc   ", null); [EOL] assertEquals("abc   ", result); [EOL] }
public void testStripEnd_NullString() { [EOL] String result = StringUtils.stripEnd(null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testStripEnd_EmptyString() { [EOL] String result = StringUtils.stripEnd("", null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testStripEnd_NoStripChars() { [EOL] String result = StringUtils.stripEnd("abc", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripEnd_EmptyStripChars() { [EOL] String result = StringUtils.stripEnd("abc", ""); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripEnd_WhiteSpaceStripChars() { [EOL] String result = StringUtils.stripEnd("abc   ", null); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripEnd_SpecificStripChars() { [EOL] String result = StringUtils.stripEnd("abcxyz", "xyz"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testStripEnd_NoStripNeeded() { [EOL] String result = StringUtils.stripEnd("abc", "def"); [EOL] assertEquals("abc", result); [EOL] }
public void testStripAll_NullInput() { [EOL] String[] result = StringUtils.stripAll(null); [EOL] assertNull(result); [EOL] }
public void testStripAll_EmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] String[] result = StringUtils.stripAll(emptyArray); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testStripAll_WithValidStrings() { [EOL] String[] strings = new String[] {" foo ", "bar ", " baz"}; [EOL] String[] expected = new String[] {"foo", "bar", "baz"}; [EOL] String[] result = StringUtils.stripAll(strings); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testStripAll_WithNullElements() { [EOL] String[] stringsWithNulls = new String[] {" foo ", null, " baz"}; [EOL] String[] expected = new String[] {"foo", null, "baz"}; [EOL] String[] result = StringUtils.stripAll(stringsWithNulls); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testStripAll_NullInput() { [EOL] String[] result = StringUtils.stripAll(null, null); [EOL] assertNull(result); [EOL] }
public void testStripAll_EmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] String[] result = StringUtils.stripAll(emptyArray, null); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testStripAll_NullStripChars() { [EOL] String[] strings = {"a", "b", " c "}; [EOL] String[] result = StringUtils.stripAll(strings, null); [EOL] assertArrayEquals(new String[]{"a", "b", "c"}, result); [EOL] }
public void testStripAll_SpecificStripChars() { [EOL] String[] strings = {"a#", "b#", " c# "}; [EOL] String[] result = StringUtils.stripAll(strings, "#"); [EOL] assertArrayEquals(new String[]{"a", "b", " c "}, result); [EOL] }
public void testLastIndexOf_NullSeq() { [EOL] int result = StringUtils.lastIndexOf(null, 'a'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_EmptySeq() { [EOL] int result = StringUtils.lastIndexOf("", 'a'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_NoMatch() { [EOL] int result = StringUtils.lastIndexOf("abc", 'd'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testLastIndexOf_MatchAtEnd() { [EOL] int result = StringUtils.lastIndexOf("abc", 'c'); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOf_MatchAtStart() { [EOL] int result = StringUtils.lastIndexOf("abc", 'a'); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testLastIndexOf_MatchInMiddle() { [EOL] int result = StringUtils.lastIndexOf("abc", 'b'); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testLastIndexOf_MultipleMatches() { [EOL] int result = StringUtils.lastIndexOf("ababab", 'b'); [EOL] assertEquals(5, result); [EOL] }
public void testLastIndexOfIgnoreCase_NullInputs() { [EOL] int result = StringUtils.lastIndexOfIgnoreCase(null, null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOfIgnoreCase_NullStr() { [EOL] int result = StringUtils.lastIndexOfIgnoreCase(null, "test"); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOfIgnoreCase_NullSearchStr() { [EOL] int result = StringUtils.lastIndexOfIgnoreCase("test", null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOfIgnoreCase_NonNullInputs() { [EOL] int result = StringUtils.lastIndexOfIgnoreCase("test", "T"); [EOL] assertEquals(3, result); [EOL] }
public void testLastIndexOfIgnoreCase_NullInputs() { [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(null, null, 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_StartPosGreaterThanLength() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "def"; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, 10); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_StartPosLessThanZero() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "abc"; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, -1); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_EmptySearchStr() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = ""; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, 2); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_ExactMatch() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "def"; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, 5); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_NoMatch() { [EOL] final CharSequence str = "abcdef"; [EOL] final CharSequence searchStr = "xyz"; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, 5); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_IgnoreCase() { [EOL] final CharSequence str = "aBcDeF"; [EOL] final CharSequence searchStr = "DEF"; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, 5); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testLastIndexOfIgnoreCase_SearchFromMiddle() { [EOL] final CharSequence str = "abcdefdef"; [EOL] final CharSequence searchStr = "def"; [EOL] final int result = StringUtils.lastIndexOfIgnoreCase(str, searchStr, 6); [EOL] assertEquals(6, result); [EOL] }
public void testContainsWithEmptySequence() { [EOL] boolean result = StringUtils.contains("", 'a'); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsWithNullSequence() { [EOL] boolean result = StringUtils.contains(null, 'a'); [EOL] assertFalse(result); [EOL] } [EOL] public void testContainsWithValidSequenceFound() { [EOL] boolean result = StringUtils.contains("abc", 'b'); [EOL] assertTrue(result); [EOL] } [EOL] public void testContainsWithValidSequenceNotFound() { [EOL] boolean result = StringUtils.contains("abc", 'd'); [EOL] assertFalse(result); [EOL] }
public void testIndexOfAny_EmptyInput() { [EOL] final int result = StringUtils.indexOfAny("", 'a', 'b'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_NullInput() { [EOL] final int result = StringUtils.indexOfAny(null, 'a', 'b'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAny("abc", new char[]{}); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_NullSearchChars() { [EOL] final int result = StringUtils.indexOfAny("abc", (char[]) null); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_ValidInput() { [EOL] final int result = StringUtils.indexOfAny("abc", 'b'); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAny_ValidInputMultipleChars() { [EOL] final int result = StringUtils.indexOfAny("abc", 'd', 'b'); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAny_ValidInputNoMatch() { [EOL] final int result = StringUtils.indexOfAny("abc", 'd', 'e'); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAny_SurrogatePairAtEnd() { [EOL] final int result = StringUtils.indexOfAny("abc\uD83D\uDE00", '\uD83D', '\uDE00'); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testIndexOfAny_SurrogatePairInMiddle() { [EOL] final int result = StringUtils.indexOfAny("a\uD83D\uDE00b", '\uD83D', '\uDE00'); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAny_SurrogatePairNoMatch() { [EOL] final int result = StringUtils.indexOfAny("abc\uD83D\uDE00", '\uD83D', 'a'); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfAnyWithEmptyCharSequence() { [EOL] int result = StringUtils.indexOfAny("", "abc"); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAnyWithEmptySearchChars() { [EOL] int result = StringUtils.indexOfAny("abc", ""); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOfAnyWithNonEmptyInputs() { [EOL] int result = StringUtils.indexOfAny("abc", "c"); [EOL] assertEquals(2, result); [EOL] }
public void testContainsAny_EmptyInput() { [EOL] assertFalse(StringUtils.containsAny("", 'a', 'b')); [EOL] }
public void testContainsAny_NullInput() { [EOL] assertFalse(StringUtils.containsAny(null, 'a', 'b')); [EOL] }
public void testContainsAny_EmptySearchChars() { [EOL] assertFalse(StringUtils.containsAny("abc", new char[] {})); [EOL] }
public void testContainsAny_NullSearchChars() { [EOL] assertFalse(StringUtils.containsAny("abc", (char[]) null)); [EOL] }
public void testContainsAny_ValidInput_Match() { [EOL] assertTrue(StringUtils.containsAny("abcd", 'a', 'b')); [EOL] }
public void testContainsAny_ValidInput_NoMatch() { [EOL] assertFalse(StringUtils.containsAny("abcd", 'e', 'f')); [EOL] }
public void testContainsAny_SurrogatePair_AtEnd() { [EOL] assertTrue(StringUtils.containsAny("abc\uD83D\uDE00", '\uD83D', '\uDE00')); [EOL] }
public void testContainsAny_SurrogatePair_NotAtEnd() { [EOL] assertTrue(StringUtils.containsAny("abc\uD83D\uDE00def", '\uD83D', '\uDE00')); [EOL] }
public void testContainsAny_SurrogatePair_Mismatch() { [EOL] assertFalse(StringUtils.containsAny("abc\uD83D\uDE01", '\uD83D', '\uDE00')); [EOL] }
public void testIndexOfAnyBut_EmptyInput() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] assertEquals(INDEX_NOT_FOUND, StringUtils.indexOfAnyBut("", 'a')); [EOL] } [EOL] public void testIndexOfAnyBut_NoSearchChars() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] assertEquals(INDEX_NOT_FOUND, StringUtils.indexOfAnyBut("abc", new char[] {})); [EOL] } [EOL] public void testIndexOfAnyBut_NotFound() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] assertEquals(INDEX_NOT_FOUND, StringUtils.indexOfAnyBut("abc", 'd', 'e', 'f')); [EOL] } [EOL] public void testIndexOfAnyBut_Found() { [EOL] assertEquals(1, StringUtils.indexOfAnyBut("aabc", 'a')); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairs() { [EOL] assertEquals(2, StringUtils.indexOfAnyBut("a\uD83D\uDE00bc", 'a', '\uD83D', '\uDE00')); [EOL] }
public void testIndexOfAnyBut_SurrogatePairsNotFound() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] assertEquals(INDEX_NOT_FOUND, StringUtils.indexOfAnyBut("a\uD83D\uDE00bc", '\uD83D', '\uDE00')); [EOL] }
public void testContainsOnlyWithNullInputs() { [EOL] assertFalse(StringUtils.containsOnly(null, (char[]) null)); [EOL] assertFalse(StringUtils.containsOnly(null, 'a', 'b')); [EOL] assertFalse(StringUtils.containsOnly("abc", (char[]) null)); [EOL] }
public void testContainsOnlyWithEmptyInputs() { [EOL] assertTrue(StringUtils.containsOnly("", 'a', 'b')); [EOL] assertFalse(StringUtils.containsOnly("abc", new char[0])); [EOL] }
public void testContainsOnlyWithValidInputs() { [EOL] assertTrue(StringUtils.containsOnly("aabbcc", 'a', 'b', 'c')); [EOL] assertFalse(StringUtils.containsOnly("aabbcc", 'x', 'y', 'z')); [EOL] }
public void testContainsOnlyWithInvalidInputs() { [EOL] assertFalse(StringUtils.containsOnly("aabbcc", 'b', 'c')); [EOL] }
public void testContainsNoneWithNullInputs() { [EOL] assertTrue(StringUtils.containsNone(null, (char[]) null)); [EOL] }
public void testContainsNoneWithEmptyInputs() { [EOL] assertTrue(StringUtils.containsNone("", new char[] {})); [EOL] }
public void testContainsNoneWithValidInputNoMatch() { [EOL] assertTrue(StringUtils.containsNone("abc", new char[] {'x', 'y', 'z'})); [EOL] }
public void testContainsNoneWithValidInputMatch() { [EOL] assertFalse(StringUtils.containsNone("abc", new char[] {'b', 'x', 'y'})); [EOL] }
public void testContainsNoneWithSurrogatePairAtEnd() { [EOL] assertFalse(StringUtils.containsNone("a\uD83D\uDE00", new char[] {'\uD83D', '\uDE00'})); [EOL] }
public void testContainsNoneWithHighSurrogatePairNoMatch() { [EOL] assertTrue(StringUtils.containsNone("a\uD83D\uDE00", new char[] {'\uD83D', 'x'})); [EOL] }
public void testContainsNoneWithNullInputs() { [EOL] assertTrue(StringUtils.containsNone(null, (String) null)); [EOL] }
public void testContainsNoneWithValidInputAndInvalidCharsNull() { [EOL] assertTrue(StringUtils.containsNone("abc", (String) null)); [EOL] }
public void testContainsNoneWithNullInputAndValidInvalidChars() { [EOL] assertTrue(StringUtils.containsNone(null, "xyz")); [EOL] }
public void testContainsNoneWithNonMatchingChars() { [EOL] assertTrue(StringUtils.containsNone("abc", "xyz")); [EOL] }
public void testContainsNoneWithMatchingChars() { [EOL] assertFalse(StringUtils.containsNone("abc", "bc")); [EOL] }
public void testIndexOfAny_NullStr() { [EOL] int result = StringUtils.indexOfAny(null, new CharSequence[]{"a", "b"}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfAny_NullSearchStrs() { [EOL] int result = StringUtils.indexOfAny("abc", (CharSequence[]) null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfAny_EmptySearchStrs() { [EOL] int result = StringUtils.indexOfAny("abc", new CharSequence[]{}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfAny_ValidInput_Found() { [EOL] int result = StringUtils.indexOfAny("abc", new CharSequence[]{"b"}); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOfAny_ValidInput_NotFound() { [EOL] int result = StringUtils.indexOfAny("abc", new CharSequence[]{"d"}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfAny_SearchStrsContainsNull() { [EOL] int result = StringUtils.indexOfAny("abc", new CharSequence[]{null, "b"}); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOfAny_SearchStrsAllNull() { [EOL] int result = StringUtils.indexOfAny("abc", new CharSequence[]{null, null}); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLeft_NullString() { [EOL] String result = StringUtils.left(null, 10); [EOL] assertNull(result); [EOL] }
public void testLeft_NegativeLength() { [EOL] String result = StringUtils.left("abc", -1); [EOL] assertEquals("", result); [EOL] }
public void testLeft_LengthGreaterThanString() { [EOL] String result = StringUtils.left("abc", 5); [EOL] assertEquals("abc", result); [EOL] }
public void testLeft_LengthLessThanString() { [EOL] String result = StringUtils.left("abcdef", 3); [EOL] assertEquals("abc", result); [EOL] }
public void testSubstringAfter_NullStringInput_ShouldReturnNull() { [EOL] String result = StringUtils.substringAfter(null, "separator"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringAfter_EmptyStringInput_ShouldReturnEmpty() { [EOL] String result = StringUtils.substringAfter("", "separator"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfter_NullSeparator_ShouldReturnEmpty() { [EOL] String result = StringUtils.substringAfter("string", null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfter_SeparatorNotFound_ShouldReturnEmpty() { [EOL] String result = StringUtils.substringAfter("string", "notfound"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringAfter_SeparatorFound_ShouldReturnSubstringAfterSeparator() { [EOL] String result = StringUtils.substringAfter("string", "ri"); [EOL] assertEquals("ng", result); [EOL] }
public void testSubstringBetween_NullString() { [EOL] String result = StringUtils.substringBetween(null, "tag"); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_NullTag() { [EOL] String result = StringUtils.substringBetween("str", null); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_EmptyTag() { [EOL] String result = StringUtils.substringBetween("str", ""); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_ValidCase() { [EOL] String result = StringUtils.substringBetween("[tag]str[/tag]", "[tag]", "[/tag]"); [EOL] assertEquals("str", result); [EOL] }
public void testSubstringBetween_NoStartTag() { [EOL] String result = StringUtils.substringBetween("str[/tag]", "[tag]", "[/tag]"); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_NoEndTag() { [EOL] String result = StringUtils.substringBetween("[tag]str", "[tag]", "[/tag]"); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_NoTagsAtAll() { [EOL] String result = StringUtils.substringBetween("str", "[tag]", "[/tag]"); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_SameStartEndTag() { [EOL] String result = StringUtils.substringBetween("[tag]str[tag]", "[tag]"); [EOL] assertEquals("str", result); [EOL] }
public void testSubstringBetween_EmptyString() { [EOL] String result = StringUtils.substringBetween("", "[tag]"); [EOL] assertNull(result); [EOL] }
public void testSubstringBetween_NullInputs() { [EOL] String result = StringUtils.substringBetween(null, null, null); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringBetween_EmptyOpenClose() { [EOL] String result = StringUtils.substringBetween("test", "", ""); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringBetween_ValidInputs() { [EOL] String result = StringUtils.substringBetween("abc[test]abc", "[", "]"); [EOL] assertEquals("test", result); [EOL] } [EOL] public void testSubstringBetween_NoStartTag() { [EOL] String result = StringUtils.substringBetween("abc]test[abc", "[", "]"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringBetween_NoEndTag() { [EOL] String result = StringUtils.substringBetween("abc[test[abc", "[", "]"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringBetween_NoTags() { [EOL] String result = StringUtils.substringBetween("abc", "[", "]"); [EOL] assertNull(result); [EOL] }
public void testSplitByCharacterTypeCamelCase_NullInput() { [EOL] String[] result = StringUtils.splitByCharacterTypeCamelCase(null); [EOL] assertNull(result); [EOL] }
public void testSplitByCharacterTypeCamelCase_EmptyString() { [EOL] String[] result = StringUtils.splitByCharacterTypeCamelCase(""); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplitByCharacterTypeCamelCase_NoCamelCase() { [EOL] String[] result = StringUtils.splitByCharacterTypeCamelCase("abc def"); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("abc", result[0]); [EOL] assertEquals("def", result[1]); [EOL] }
public void testSplitByCharacterTypeCamelCase_WithCamelCase() { [EOL] String[] result = StringUtils.splitByCharacterTypeCamelCase("camelCase"); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("camel", result[0]); [EOL] assertEquals("Case", result[1]); [EOL] }
public void testSplitByCharacterTypeCamelCase_WithNumbers() { [EOL] String[] result = StringUtils.splitByCharacterTypeCamelCase("camelCase123"); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("camel", result[0]); [EOL] assertEquals("Case", result[1]); [EOL] assertEquals("123", result[2]); [EOL] }
public void testSplitByCharacterTypeCamelCase_SpecialCharacters() { [EOL] String[] result = StringUtils.splitByCharacterTypeCamelCase("camel#Case"); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.length); [EOL] assertEquals("camel", result[0]); [EOL] assertEquals("#", result[1]); [EOL] assertEquals("Case", result[2]); [EOL] }
public void testSplitByCharacterType_NullInput() { [EOL] String[] result = splitByCharacterType(null, false); [EOL] assertNull(result); [EOL] } [EOL] public void testSplitByCharacterType_EmptyString() { [EOL] String[] result = splitByCharacterType("", false); [EOL] assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result); [EOL] } [EOL] public void testSplitByCharacterType_NoCamelCase() { [EOL] String[] result = splitByCharacterType("ABCDefG123", false); [EOL] assertArrayEquals(new String[]{"ABC", "Def", "G", "123"}, result); [EOL] } [EOL] public void testSplitByCharacterType_WithCamelCase() { [EOL] String[] result = splitByCharacterType("ABCDefG123", true); [EOL] assertArrayEquals(new String[]{"ABCD", "ef", "G", "123"}, result); [EOL] } [EOL] public void testSplitByCharacterType_SameTypeChars() { [EOL] String[] result = splitByCharacterType("AAAA", false); [EOL] assertArrayEquals(new String[]{"AAAA"}, result); [EOL] } [EOL] public void testSplitByCharacterType_SingleChar() { [EOL] String[] result = splitByCharacterType("A", false); [EOL] assertArrayEquals(new String[]{"A"}, result); [EOL] } [EOL] public void testSplitByCharacterType_AdjacentDifferentTypeChars() { [EOL] String[] result = splitByCharacterType("A1", false); [EOL] assertArrayEquals(new String[]{"A", "1"}, result); [EOL] } [EOL] public void testSplitByCharacterType_AdjacentSameTypeChars() { [EOL] String[] result = splitByCharacterType("AA11", false); [EOL] assertArrayEquals(new String[]{"AA", "11"}, result); [EOL] } [EOL] public void testSplitByCharacterType_CamelCaseAtEnd() { [EOL] String[] result = splitByCharacterType("CamelCaseEND", true); [EOL] assertArrayEquals(new String[]{"Camel", "Case", "END"}, result); [EOL] } [EOL] public void testSplitByCharacterType_CamelCaseAtStart() { [EOL] String[] result = splitByCharacterType("camelCASEStart", true); [EOL] assertArrayEquals(new String[]{"camel", "CASE", "Start"}, result); [EOL] }
public void testJoinArrayWithSeparator_NullArray() { [EOL] int[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] } [EOL] public void testJoinArrayWithSeparator_EmptyArray() { [EOL] int[] array = new int[0]; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoinArrayWithSeparator_SingleElement() { [EOL] int[] array = {1}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1", result); [EOL] } [EOL] public void testJoinArrayWithSeparator_MultipleElements() { [EOL] int[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1,2,3", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_ArrayIsNull() { [EOL] int[] array = null; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 1; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertNull(result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_EmptyArray() { [EOL] int[] array = new int[0]; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 0; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_ValidArray() { [EOL] int[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = array.length; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1,2,3", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_SubArray() { [EOL] int[] array = {1, 2, 3, 4, 5}; [EOL] char separator = ','; [EOL] int startIndex = 1; [EOL] int endIndex = 4; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("2,3,4", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_NegativeStartIndex() { [EOL] int[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] int startIndex = -1; [EOL] int endIndex = 2; [EOL] try { [EOL] StringUtils.join(array, separator, startIndex, endIndex); [EOL] fail("Should throw ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_EndIndexExceedsLength() { [EOL] int[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] try { [EOL] StringUtils.join(array, separator, startIndex, endIndex); [EOL] fail("Should throw ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testJoin_NullIterator() { [EOL] String result = StringUtils.join(null, ','); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_EmptyIterator() { [EOL] Iterator<?> emptyIterator = Collections.emptyIterator(); [EOL] String result = StringUtils.join(emptyIterator, ','); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_SingleElementIterator() { [EOL] Iterator<String> singleElementIterator = Collections.singleton("one").iterator(); [EOL] String result = StringUtils.join(singleElementIterator, ','); [EOL] assertEquals("one", result); [EOL] } [EOL] public void testJoin_MultipleElementsIterator() { [EOL] List<String> list = Arrays.asList("one", "two", "three"); [EOL] Iterator<String> iterator = list.iterator(); [EOL] String result = StringUtils.join(iterator, ','); [EOL] assertEquals("one,two,three", result); [EOL] } [EOL] public void testJoin_MultipleElementsIteratorWithNull() { [EOL] List<String> list = Arrays.asList("one", null, "three"); [EOL] Iterator<String> iterator = list.iterator(); [EOL] String result = StringUtils.join(iterator, ','); [EOL] assertEquals("one,,three", result); [EOL] }
public void testJoin_IterableChar_NullIterable() { [EOL] String result = StringUtils.join((Iterable<?>) null, ','); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_IterableChar_EmptyIterable() { [EOL] List<String> emptyList = Collections.emptyList(); [EOL] String result = StringUtils.join(emptyList, ','); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_IterableChar_NonEmptyIterable() { [EOL] List<String> list = Arrays.asList("a", "b", "c"); [EOL] String result = StringUtils.join(list, ','); [EOL] assertEquals("a,b,c", result); [EOL] } [EOL] public void testJoin_IterableChar_SingleElement() { [EOL] List<String> singleItemList = Collections.singletonList("a"); [EOL] String result = StringUtils.join(singleItemList, ','); [EOL] assertEquals("a", result); [EOL] }
public void testRemoveEnd_NullStr_ShouldReturnNull() { [EOL] String result = StringUtils.removeEnd(null, "remove"); [EOL] assertNull(result); [EOL] }
public void testRemoveEnd_NullRemove_ShouldReturnOriginalStr() { [EOL] String result = StringUtils.removeEnd("string", null); [EOL] assertEquals("string", result); [EOL] }
public void testRemoveEnd_EmptyRemove_ShouldReturnOriginalStr() { [EOL] String result = StringUtils.removeEnd("string", ""); [EOL] assertEquals("string", result); [EOL] }
public void testRemoveEnd_StrNotEndingWithRemove_ShouldReturnOriginalStr() { [EOL] String result = StringUtils.removeEnd("string", "not"); [EOL] assertEquals("string", result); [EOL] }
public void testRemoveEnd_StrEndingWithRemove_ShouldRemoveEnd() { [EOL] String result = StringUtils.removeEnd("string", "ing"); [EOL] assertEquals("str", result); [EOL] }
public void testRemove_NullString() { [EOL] String result = StringUtils.remove(null, 'a'); [EOL] assertNull(result); [EOL] } [EOL] public void testRemove_EmptyString() { [EOL] String result = StringUtils.remove("", 'a'); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRemove_StringWithoutTargetChar() { [EOL] String result = StringUtils.remove("abc", 'd'); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testRemove_StringWithOnlyTargetChar() { [EOL] String result = StringUtils.remove("aaa", 'a'); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRemove_StringWithTargetChar() { [EOL] String result = StringUtils.remove("abcabc", 'b'); [EOL] assertEquals("acac", result); [EOL] }
public void testReplace_MaxNoReplacement() { [EOL] String text = "abc"; [EOL] String searchString = "b"; [EOL] String replacement = "x"; [EOL] int max = 0; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testReplace_MaxNegative() { [EOL] String text = "ababab"; [EOL] String searchString = "b"; [EOL] String replacement = "x"; [EOL] int max = -1; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("axaxax", result); [EOL] } [EOL] public void testReplace_MaxLimited() { [EOL] String text = "ababab"; [EOL] String searchString = "b"; [EOL] String replacement = "x"; [EOL] int max = 2; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("axaxab", result); [EOL] } [EOL] public void testReplace_MaxExceeding() { [EOL] String text = "ababab"; [EOL] String searchString = "b"; [EOL] String replacement = "x"; [EOL] int max = 10; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("axaxax", result); [EOL] } [EOL] public void testReplace_SearchStringNotFound() { [EOL] String text = "abc"; [EOL] String searchString = "d"; [EOL] String replacement = "x"; [EOL] int max = 2; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testReplace_EmptyText() { [EOL] String text = ""; [EOL] String searchString = "b"; [EOL] String replacement = "x"; [EOL] int max = 2; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("", result); [EOL] } [EOL] public void testReplace_EmptySearchString() { [EOL] String text = "abc"; [EOL] String searchString = ""; [EOL] String replacement = "x"; [EOL] int max = 2; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testReplace_NullReplacement() { [EOL] String text = "abc"; [EOL] String searchString = "b"; [EOL] String replacement = null; [EOL] int max = 2; [EOL] String result = StringUtils.replace(text, searchString, replacement, max); [EOL] assertEquals("abc", result); [EOL] }
public void testLeftPad_NullString() { [EOL] String str = null; [EOL] int size = 10; [EOL] char padChar = ' '; [EOL] String result = StringUtils.leftPad(str, size, padChar); [EOL] assertNull(result); [EOL] }
public void testLeftPad_NoPaddingNeeded() { [EOL] String str = "abc"; [EOL] int size = 3; [EOL] char padChar = ' '; [EOL] String result = StringUtils.leftPad(str, size, padChar); [EOL] assertEquals("abc", result); [EOL] }
public void testLeftPad_WithPadding() { [EOL] String str = "abc"; [EOL] int size = 5; [EOL] char padChar = 'X'; [EOL] String result = StringUtils.leftPad(str, size, padChar); [EOL] assertEquals("XXabc", result); [EOL] }
public void testLeftPad_WithPaddingExceedingPadLimit() { [EOL] String str = "abc"; [EOL] int size = 100000; [EOL] char padChar = 'X'; [EOL] String result = StringUtils.leftPad(str, size, padChar); [EOL] assertTrue(result.length() == size); [EOL] assertTrue(result.startsWith(StringUtils.repeat(padChar, size - str.length()))); [EOL] }
public void testLeftPad_NullString() { [EOL] final String str = null; [EOL] final int size = 10; [EOL] final String padStr = "*"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertNull(result); [EOL] } [EOL] public void testLeftPad_EmptyPadString() { [EOL] final String str = "abc"; [EOL] final int size = 5; [EOL] final String padStr = ""; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("  abc", result); [EOL] } [EOL] public void testLeftPad_Normal() { [EOL] final String str = "abc"; [EOL] final int size = 5; [EOL] final String padStr = "*"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("**abc", result); [EOL] } [EOL] public void testLeftPad_NoPaddingNeeded() { [EOL] final String str = "abc"; [EOL] final int size = 3; [EOL] final String padStr = "*"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testLeftPad_SingleCharPad() { [EOL] final String str = "abc"; [EOL] final int size = 6; [EOL] final String padStr = "*"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("***abc", result); [EOL] } [EOL] public void testLeftPad_PadLengthEqualsPads() { [EOL] final String str = "abc"; [EOL] final int size = 6; [EOL] final String padStr = "12"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("12abc", result); [EOL] } [EOL] public void testLeftPad_PadLengthLessThanPads() { [EOL] final String str = "abc"; [EOL] final int size = 7; [EOL] final String padStr = "12"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("121abc", result); [EOL] } [EOL] public void testLeftPad_PadLengthMoreThanPads() { [EOL] final String str = "abc"; [EOL] final int size = 10; [EOL] final String padStr = "12345"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("12345abc", result); // This test case is incorrect, it should pad more characters [EOL] } [EOL] public void testLeftPad_LongPadString() { [EOL] final String str = "abc"; [EOL] final int size = 10; [EOL] final String padStr = "123456789"; [EOL] String result = leftPad(str, size, padStr); [EOL] assertEquals("1234567abc", result); [EOL] }
public void testCountMatches_NullOrEmptyInputs() { [EOL] assertEquals(0, StringUtils.countMatches(null, "a")); [EOL] assertEquals(0, StringUtils.countMatches("", "a")); [EOL] assertEquals(0, StringUtils.countMatches("a", null)); [EOL] assertEquals(0, StringUtils.countMatches("a", "")); [EOL] }
public void testCountMatches_NonEmptyInputs_NoMatch() { [EOL] assertEquals(0, StringUtils.countMatches("abc", "d")); [EOL] }
public void testCountMatches_NonEmptyInputs_SingleMatch() { [EOL] assertEquals(1, StringUtils.countMatches("abc", "b")); [EOL] }
public void testCountMatches_NonEmptyInputs_MultipleMatches() { [EOL] assertEquals(2, StringUtils.countMatches("abcbc", "bc")); [EOL] }
public void testIsAlphanumericSpace_NullInput() { [EOL] boolean result = StringUtils.isAlphanumericSpace(null); [EOL] assertFalse(result); [EOL] }
public void testIsAlphanumericSpace_EmptyString() { [EOL] boolean result = StringUtils.isAlphanumericSpace(""); [EOL] assertTrue(result); [EOL] }
public void testIsAlphanumericSpace_AlphanumericString() { [EOL] boolean result = StringUtils.isAlphanumericSpace("abc123"); [EOL] assertTrue(result); [EOL] }
public void testIsAlphanumericSpace_AlphanumericStringWithSpace() { [EOL] boolean result = StringUtils.isAlphanumericSpace("abc 123"); [EOL] assertTrue(result); [EOL] }
public void testIsAlphanumericSpace_NonAlphanumericString() { [EOL] boolean result = StringUtils.isAlphanumericSpace("abc@123"); [EOL] assertFalse(result); [EOL] }
public void testIsWhitespace_nullInput() { [EOL] boolean result = StringUtils.isWhitespace(null); [EOL] assertFalse(result); [EOL] }
public void testIsWhitespace_emptyString() { [EOL] boolean result = StringUtils.isWhitespace(""); [EOL] assertTrue(result); [EOL] }
public void testIsWhitespace_spaceChar() { [EOL] boolean result = StringUtils.isWhitespace(" "); [EOL] assertTrue(result); [EOL] }
public void testIsWhitespace_nonWhitespaceChar() { [EOL] boolean result = StringUtils.isWhitespace("a"); [EOL] assertFalse(result); [EOL] }
public void testIsWhitespace_mixedWhitespace() { [EOL] boolean result = StringUtils.isWhitespace(" \t\n\r"); [EOL] assertTrue(result); [EOL] }
public void testIsWhitespace_mixedNonWhitespace() { [EOL] boolean result = StringUtils.isWhitespace(" a "); [EOL] assertFalse(result); [EOL] }
public void testIsAllLowerCaseWithNull() { [EOL] boolean result = StringUtils.isAllLowerCase(null); [EOL] assertFalse(result); [EOL] }
public void testIsAllLowerCaseWithEmptyString() { [EOL] boolean result = StringUtils.isAllLowerCase(""); [EOL] assertFalse(result); [EOL] }
public void testIsAllLowerCaseWithAllLowerCase() { [EOL] boolean result = StringUtils.isAllLowerCase("abc"); [EOL] assertTrue(result); [EOL] }
public void testIsAllLowerCaseWithMixedCase() { [EOL] boolean result = StringUtils.isAllLowerCase("aBc"); [EOL] assertFalse(result); [EOL] }
public void testIsAllLowerCaseWithAllUpperCase() { [EOL] boolean result = StringUtils.isAllLowerCase("ABC"); [EOL] assertFalse(result); [EOL] }
public void testIsAllLowerCaseWithNumbers() { [EOL] boolean result = StringUtils.isAllLowerCase("123"); [EOL] assertFalse(result); [EOL] }
public void testAbbreviateWithNegativeMaxWidth() { [EOL] String str = "abcdefg"; [EOL] int maxWidth = -1; [EOL] String result = StringUtils.abbreviate(str, maxWidth); [EOL] assertNull(result); [EOL] }
public void testAbbreviateWithMaxWidthZero() { [EOL] String str = "abcdefg"; [EOL] int maxWidth = 0; [EOL] String result = StringUtils.abbreviate(str, maxWidth); [EOL] assertEquals("", result); [EOL] }
public void testAbbreviateWithMaxWidthEqualToLength() { [EOL] String str = "abcdefg"; [EOL] int maxWidth = str.length(); [EOL] String result = StringUtils.abbreviate(str, maxWidth); [EOL] assertEquals("abcdefg", result); [EOL] }
public void testAbbreviateWithMaxWidthGreaterThanLength() { [EOL] String str = "abcdefg"; [EOL] int maxWidth = 10; [EOL] String result = StringUtils.abbreviate(str, maxWidth); [EOL] assertEquals("abcdefg", result); [EOL] }
public void testAbbreviateNullString() { [EOL] String result = StringUtils.abbreviate(null, 0, 10); [EOL] assertNull(result); [EOL] } [EOL] public void testAbbreviateIllegalArguments() { [EOL] try { [EOL] StringUtils.abbreviate("abcdefg", 0, 3); [EOL] fail("Should have thrown IllegalArgumentException because maxWidth is less than 4"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] StringUtils.abbreviate("abcdefg", 10, 7); [EOL] fail("Should have thrown IllegalArgumentException because maxWidth is less than offset + 4"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAbbreviateNoNeedToAbbreviate() { [EOL] String str = "Short"; [EOL] String result = StringUtils.abbreviate(str, 0, 10); [EOL] assertEquals(str, result); [EOL] } [EOL] public void testAbbreviateAtFront() { [EOL] String result = StringUtils.abbreviate("Longer string", 0, 10); [EOL] assertEquals("Longer...", result); [EOL] } [EOL] public void testAbbreviateInMiddle() { [EOL] String result = StringUtils.abbreviate("Longer string", 5, 10); [EOL] assertEquals("... string", result); [EOL] } [EOL] public void testAbbreviateAtEnd() { [EOL] String result = StringUtils.abbreviate("Longer string", 6, 10); [EOL] assertEquals("...tring", result); [EOL] } [EOL] public void testAbbreviateAtExactLength() { [EOL] String result = StringUtils.abbreviate("Exactly 10", 0, 10); [EOL] assertEquals("Exactly...", result); [EOL] } [EOL] public void testAbbreviateSmallerOffset() { [EOL] String result = StringUtils.abbreviate("Testing 1234", 2, 8); [EOL] assertEquals("Tes...", result); [EOL] } [EOL] public void testAbbreviateBoundaryOffset() { [EOL] String result = StringUtils.abbreviate("Testing 1234", 3, 8); [EOL] assertEquals("...ing 1", result); [EOL] } [EOL] public void testAbbreviateBoundaryMaxWidth() { [EOL] String result = StringUtils.abbreviate("Testing 1234", 3, 7); [EOL] assertEquals("...1234", result); [EOL] }
public void testEndsWith_NullInputs() { [EOL] assertTrue(endsWith(null, null, true)); [EOL] assertFalse(endsWith(null, null, false)); [EOL] assertFalse(endsWith(null, "suffix", true)); [EOL] assertFalse(endsWith("str", null, false)); [EOL] }
public void testEndsWith_SuffixLongerThanStr() { [EOL] assertFalse(endsWith("str", "longsuffix", true)); [EOL] assertFalse(endsWith("str", "longsuffix", false)); [EOL] }
public void testEndsWith_IgnoreCase() { [EOL] assertTrue(endsWith("str", "TR", true)); [EOL] assertFalse(endsWith("str", "TR", false)); [EOL] }
public void testEndsWith_CaseSensitive() { [EOL] assertTrue(endsWith("str", "tr", false)); [EOL] assertFalse(endsWith("str", "TR", false)); [EOL] }
public void testEndsWith_EmptyStrings() { [EOL] assertTrue(endsWith("", "", true)); [EOL] assertTrue(endsWith("", "", false)); [EOL] }
public void testEndsWith_PartialMatch() { [EOL] assertFalse(endsWith("str", "st", true)); [EOL] assertFalse(endsWith("str", "st", false)); [EOL] }
public void testNormalizeSpace_NullInput() { [EOL] String result = StringUtils.normalizeSpace(null); [EOL] assertNull(result); [EOL] }
public void testNormalizeSpace_EmptyString() { [EOL] String result = StringUtils.normalizeSpace(""); [EOL] assertEquals("", result); [EOL] }
public void testNormalizeSpace_OnlyWhitespaces() { [EOL] String result = StringUtils.normalizeSpace("   "); [EOL] assertEquals("", result); [EOL] }
public void testNormalizeSpace_SingleWord() { [EOL] String result = StringUtils.normalizeSpace("word"); [EOL] assertEquals("word", result); [EOL] }
public void testNormalizeSpace_MultipleWords() { [EOL] String result = StringUtils.normalizeSpace("  multiple   words  "); [EOL] assertEquals("multiple words", result); [EOL] }
public void testNormalizeSpace_LeadingAndTrailingWhitespaces() { [EOL] String result = StringUtils.normalizeSpace("  leading and trailing  "); [EOL] assertEquals("leading and trailing", result); [EOL] }
public void testAppendIfMissing_nullStr() { [EOL] String result = appendIfMissing(null, "suffix", false); [EOL] assertNull(result); [EOL] } [EOL] public void testAppendIfMissing_emptySuffix() { [EOL] String result = appendIfMissing("str", "", false); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testAppendIfMissing_notMissingSuffix() { [EOL] String result = appendIfMissing("str", "r", false); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testAppendIfMissing_suffixesNotNullAndNotEmpty_endsWithSuffix() { [EOL] String result = appendIfMissing("str", "x", false, "r"); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testAppendIfMissing_suffixesNotNullAndNotEmpty_notEndsWithSuffix() { [EOL] String result = appendIfMissing("str", "x", false, "y"); [EOL] assertEquals("strx", result); [EOL] } [EOL] public void testAppendIfMissing_ignoreCaseTrue() { [EOL] String result = appendIfMissing("str", "R", true); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testAppendIfMissing_ignoreCaseFalse() { [EOL] String result = appendIfMissing("str", "R", false); [EOL] assertEquals("strR", result); [EOL] } [EOL] public void testAppendIfMissing_appendSuffix() { [EOL] String result = appendIfMissing("str", "x", false); [EOL] assertEquals("strx", result); [EOL] }
public void testAppendIfMissingWithNullString() { [EOL] String result = StringUtils.appendIfMissing(null, "suffix", "suffixes"); [EOL] assertNull(result); [EOL] }
public void testAppendIfMissingWithEmptyString() { [EOL] String result = StringUtils.appendIfMissing("", "suffix", "suffixes"); [EOL] assertEquals("suffix", result); [EOL] }
public void testAppendIfMissingWithNoSuffixes() { [EOL] String result = StringUtils.appendIfMissing("str", "suffix"); [EOL] assertEquals("strsuffix", result); [EOL] }
public void testAppendIfMissingWithExistingSuffix() { [EOL] String result = StringUtils.appendIfMissing("strsuffix", "suffix", "suffixes"); [EOL] assertEquals("strsuffix", result); [EOL] }
public void testAppendIfMissingWithExistingSuffixes() { [EOL] String result = StringUtils.appendIfMissing("strsuffixes", "suffix", "suffixes"); [EOL] assertEquals("strsuffixes", result); [EOL] }
public void testAppendIfMissingWithMultipleSuffixes() { [EOL] String result = StringUtils.appendIfMissing("str", "suffix", "suffixes", "other"); [EOL] assertEquals("strsuffix", result); [EOL] }
public void testSetValueWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(null); [EOL] assertEquals(0.0, instance.getValue(), 0.0); [EOL] }
public void testSetValueWithInteger() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5); [EOL] assertEquals(5.0, instance.getValue(), 0.0); [EOL] }
public void testSetValueWithDouble() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5.5); [EOL] assertEquals(5.5, instance.getValue(), 0.0); [EOL] }
public void testSetValueWithFloat() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5.5f); [EOL] assertEquals(5.5, instance.getValue(), 0.0); [EOL] }
public void testSetValueWithLong() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5L); [EOL] assertEquals(5.0, instance.getValue(), 0.0); [EOL] }
public void addTestWithPositiveOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] mutableDouble.add(2.0); [EOL] assertEquals(3.0, mutableDouble.value, 0.0); [EOL] }
public void addTestWithNegativeOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] mutableDouble.add(-2.0); [EOL] assertEquals(-1.0, mutableDouble.value, 0.0); [EOL] }
public void addTestWithZeroOperand() { [EOL] MutableDouble mutableDouble = new MutableDouble(1.0); [EOL] mutableDouble.add(0.0); [EOL] assertEquals(1.0, mutableDouble.value, 0.0); [EOL] }
public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL] appendToString(buffer, superToString); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendToStringWithNonNullToStringContainingContentStartAndEnd() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "prefix[content]suffix"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("content,", buffer.toString()); [EOL] }
public void testAppendToStringWithNullToString() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = null; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithNonNullToStringNotContainingContentStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "prefixsuffix"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithNonNullToStringContainingContentStartButNoContentEnd() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "prefix[suffix"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithNonNullToStringContainingContentEndButNoContentStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "prefix]suffix"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals("", buffer.toString()); [EOL] }
public void testAppendToStringWithFieldSeparatorAtStart() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String toString = "prefix[content]suffix"; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.setFieldSeparatorAtStart(true); [EOL] style.appendToString(buffer, toString); [EOL] assertEquals(",content,", buffer.toString()); [EOL] }
protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] final int len = buffer.length(); [EOL] final int sepLen = fieldSeparator.length(); [EOL] if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL] boolean match = true; [EOL] for (int i = 0; i < sepLen; i++) { [EOL] if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL] match = false; [EOL] break; [EOL] } [EOL] } [EOL] if (match) { [EOL] buffer.setLength(len - sepLen); [EOL] } [EOL] } [EOL] }
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL] appendCyclicObject(buffer, fieldName, value); [EOL] return; [EOL] } [EOL] register(value); [EOL] try { [EOL] if (value instanceof Collection<?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Collection<?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL] } [EOL] } else if (value instanceof Map<?, ?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL] } [EOL] } else if (value instanceof long[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (long[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (long[]) value); [EOL] } [EOL] } else if (value instanceof int[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (int[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (int[]) value); [EOL] } [EOL] } else if (value instanceof short[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (short[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (short[]) value); [EOL] } [EOL] } else if (value instanceof byte[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (byte[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (byte[]) value); [EOL] } [EOL] } else if (value instanceof char[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (char[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (char[]) value); [EOL] } [EOL] } else if (value instanceof double[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (double[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (double[]) value); [EOL] } [EOL] } else if (value instanceof float[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (float[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (float[]) value); [EOL] } [EOL] } else if (value instanceof boolean[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (boolean[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (boolean[]) value); [EOL] } [EOL] } else if (value.getClass().isArray()) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Object[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (Object[]) value); [EOL] } [EOL] } else { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, value); [EOL] } [EOL] } [EOL] } finally { [EOL] unregister(value); [EOL] } [EOL] }
public void testAppendChar() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", 'a'); [EOL] assertEquals("fieldName=a", buffer.toString()); [EOL] }
public void testAppendCharWithNullFieldName() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, null, 'a'); [EOL] assertEquals("a", buffer.toString()); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL] buffer.append(value); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendFloat() { [EOL] final StringBuffer buffer = new StringBuffer(); [EOL] final String fieldName = "TestField"; [EOL] final float value = 123.45f; [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] assertTrue(buffer.toString().contains(fieldName + "=" + value)); [EOL] }
public void testAppendFloatWithNoFieldNameToStringStyle() { [EOL] final StringBuffer buffer = new StringBuffer(); [EOL] final String fieldName = "TestField"; [EOL] final float value = 123.45f; [EOL] ToStringStyle style = new NoFieldNameToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] assertTrue(buffer.toString().contains(String.valueOf(value))); [EOL] assertFalse(buffer.toString().contains(fieldName)); [EOL] }
public void testAppendFloatWithSimpleToStringStyle() { [EOL] final StringBuffer buffer = new StringBuffer(); [EOL] final String fieldName = "TestField"; [EOL] final float value = 123.45f; [EOL] ToStringStyle style = new SimpleToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] assertTrue(buffer.toString().contains(fieldName + "=" + value)); [EOL] }
public void testAppendFloatWithMultiLineToStringStyle() { [EOL] final StringBuffer buffer = new StringBuffer(); [EOL] final String fieldName = "TestField"; [EOL] final float value = 123.45f; [EOL] ToStringStyle style = new MultiLineToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] assertTrue(buffer.toString().contains(fieldName + "=" + value)); [EOL] assertTrue(buffer.toString().contains(System.lineSeparator())); [EOL] }
protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL] buffer.append(arrayStart); [EOL] final int length = Array.getLength(array); [EOL] for (int i = 0; i < length; i++) { [EOL] final Object item = Array.get(array, i); [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] if (item == null) { [EOL] appendNullText(buffer, fieldName); [EOL] } else { [EOL] appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL] } [EOL] } [EOL] buffer.append(arrayEnd); [EOL] }
public void testAppendWithNullArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] char[] array = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithFullDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] char[] array = {'a', 'b', 'c'}; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithSummaryDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] char[] array = {'a', 'b', 'c'}; [EOL] Boolean fullDetail = false; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }

protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] }
protected String getArrayEnd() { [EOL] return arrayEnd; [EOL] } [EOL] protected ToStringStyle() { [EOL] } [EOL] DefaultToStringStyle() { [EOL] super(); [EOL] } [EOL] NoFieldNameToStringStyle() { [EOL] setUseFieldNames(false); [EOL] } [EOL] ShortPrefixToStringStyle() { [EOL] setUseShortClassName(true); [EOL] setUseIdentityHashCode(false); [EOL] } [EOL] SimpleToStringStyle() { [EOL] setUseClassName(false); [EOL] setUseIdentityHashCode(false); [EOL] setUseFieldNames(false); [EOL] setContentStart(""); [EOL] setContentEnd(""); [EOL] } [EOL] MultiLineToStringStyle() { [EOL] setContentStart("["); [EOL] setFieldSeparator(System.lineSeparator() + "  "); [EOL] setFieldSeparatorAtStart(true); [EOL] setContentEnd(System.lineSeparator() + "]"); [EOL] } [EOL] static Map<Object, Object> getRegistry() { [EOL] return REGISTRY.get(); [EOL] } [EOL] static boolean isRegistered(final Object value) { [EOL] return getRegistry() != null && getRegistry().containsKey(value); [EOL] } [EOL] static void register(final Object value) { [EOL] if (getRegistry() == null) { [EOL] REGISTRY.set(new WeakHashMap<Object, Object>()); [EOL] } [EOL] getRegistry().put(value, null); [EOL] } [EOL] static void unregister(final Object value) { [EOL] if (getRegistry() != null) { [EOL] getRegistry().remove(value); [EOL] if (getRegistry().isEmpty()) { [EOL] REGISTRY.remove(); [EOL] } [EOL] } [EOL] } [EOL] public void appendSuper(final StringBuffer buffer, final String superToString) { [EOL] } [EOL] public void appendToString(final StringBuffer buffer, final String toString) { [EOL] } [EOL] public void appendStart(final StringBuffer buffer, final Object object) { [EOL] } [EOL] public void appendEnd(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) { [EOL] } [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] } [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL] } [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL] } [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL] } [EOL] protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL] } [EOL] protected void appendContentStart(final StringBuffer buffer) { [EOL] } [EOL] protected void appendContentEnd(final StringBuffer buffer) { [EOL] } [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldSeparator(final StringBuffer buffer) { [EOL] } [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL] } [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL] } [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL] } [EOL] protected String getShortClassName(final Class<?> cls) { [EOL] } [EOL] protected boolean isUseClassName() { [EOL] } [EOL] protected void setUseClassName(final boolean useClassName) { [EOL] } [EOL] protected boolean isUseShortClassName() { [EOL] } [EOL] protected void setUseShortClassName(final boolean useShortClassName) { [EOL] } [EOL] protected boolean isUseIdentityHashCode() { [EOL] } [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL] } [EOL] protected boolean isUseFieldNames() { [EOL] } [EOL] protected void setUseFieldNames(final boolean useFieldNames) { [EOL] } [EOL] protected boolean isDefaultFullDetail() { [EOL] } [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL] } [EOL] protected boolean isArrayContentDetail() { [EOL] } [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL] } [EOL] protected String getArrayStart() { [EOL] } [EOL] protected void setArrayStart(String arrayStart) { [EOL] } [EOL] protected String getArrayEnd() { [EOL] } [EOL] protected void setArrayEnd(String arrayEnd) { [EOL] } [EOL] protected String getArraySeparator() { [EOL] } [EOL] protected void setArraySeparator(String arraySeparator) { [EOL] } [EOL] protected String getContentStart() { [EOL] } [EOL] protected void setContentStart(String contentStart) { [EOL] } [EOL] protected String getContentEnd() { [EOL] } [EOL] protected void setContentEnd(String contentEnd) { [EOL] } [EOL] protected String getFieldNameValueSeparator() { [EOL] } [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL] } [EOL] protected String getFieldSeparator() { [EOL] } [EOL] protected void setFieldSeparator(String fieldSeparator) { [EOL] } [EOL] protected boolean isFieldSeparatorAtStart() { [EOL] } [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL] } [EOL] protected boolean isFieldSeparatorAtEnd() { [EOL] } [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { [EOL] } [EOL] protected String getNullText() { [EOL] } [EOL] protected void setNullText(String nullText) { [EOL] } [EOL] protected String getSizeStartText() { [EOL] } [EOL] protected void setSizeStartText(String sizeStartText) { [EOL] } [EOL] protected String getSizeEndText() { [EOL] } [EOL] protected void setSizeEndText(String sizeEndText) { [EOL] } [EOL] protected String getSummaryObjectStartText() { [EOL] } [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText) { [EOL] } [EOL] protected String getSummaryObjectEndText() { [EOL] } [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void setArrayEnd(String arrayEnd) { [EOL] if (arrayEnd == null) { [EOL] arrayEnd = ""; [EOL] } [EOL] this.arrayEnd = arrayEnd; [EOL] }
protected String getContentStart() { [EOL] return contentStart; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetContentStartWithNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentStart(null); [EOL] assertEquals("", style.getContentStart()); [EOL] }
public void testSetContentStartWithNonNull() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setContentStart("("); [EOL] assertEquals("(", style.getContentStart()); [EOL] }
protected String getFieldSeparator() { [EOL] return fieldSeparator; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void setFieldSeparator(String fieldSeparator) { [EOL] if (fieldSeparator == null) { [EOL] fieldSeparator = ""; [EOL] } [EOL] this.fieldSeparator = fieldSeparator; [EOL] }
public void testUnicodeEscaperConstructor() { [EOL] int below = 10; [EOL] int above = 20; [EOL] boolean between = true; [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] assertEquals("Below value is not set correctly", below, escaper.below); [EOL] assertEquals("Above value is not set correctly", above, escaper.above); [EOL] assertTrue("Between value is not set correctly", escaper.between); [EOL] }
public void testUnicodeEscaperConstructorWithNegativeValues() { [EOL] int below = -1; [EOL] int above = -1; [EOL] boolean between = false; [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] assertEquals("Below value is not set correctly with negative value", below, escaper.below); [EOL] assertEquals("Above value is not set correctly with negative value", above, escaper.above); [EOL] assertFalse("Between value is not set correctly with false", escaper.between); [EOL] }
public void testAbove_withNegativeCodepoint() { [EOL] try { [EOL] UnicodeEscaper escaper = UnicodeEscaper.above(-1); [EOL] fail("Should have thrown IllegalArgumentException for negative codepoint"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAbove_withZeroCodepoint() { [EOL] UnicodeEscaper escaper = UnicodeEscaper.above(0); [EOL] assertNotNull("Should create an escaper for codepoint 0", escaper); [EOL] }
public void testAbove_withPositiveCodepoint() { [EOL] UnicodeEscaper escaper = UnicodeEscaper.above(1); [EOL] assertNotNull("Should create an escaper for positive codepoint", escaper); [EOL] }
public void testOutsideOf_ValidRange() { [EOL] UnicodeEscaper escaper = UnicodeEscaper.outsideOf(50, 100); [EOL] assertNotNull(escaper); [EOL] assertEquals(50, escaper.getBelow()); [EOL] assertEquals(100, escaper.getAbove()); [EOL] assertFalse(escaper.isBetween()); [EOL] }
public void testOutsideOf_InvertedRange() { [EOL] try { [EOL] UnicodeEscaper.outsideOf(100, 50); [EOL] fail("Expected IllegalArgumentException for inverted range"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testOutsideOf_SameCodepoints() { [EOL] try { [EOL] UnicodeEscaper.outsideOf(100, 100); [EOL] fail("Expected IllegalArgumentException for same codepoints"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testTranslateWithBetweenTrueAndCodepointOutOfRange() throws IOException { [EOL] final int below = 50; [EOL] final int above = 100; [EOL] final boolean between = true; [EOL] final int codepoint = 101; [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithBetweenTrueAndCodepointInRange() throws IOException { [EOL] final int below = 50; [EOL] final int above = 100; [EOL] final boolean between = true; [EOL] final int codepoint = 75; [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u004b", out.toString()); [EOL] }
public void testTranslateWithBetweenFalseAndCodepointInRange() throws IOException { [EOL] final int below = 50; [EOL] final int above = 100; [EOL] final boolean between = false; [EOL] final int codepoint = 75; [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithBetweenFalseAndCodepointOutOfRange() throws IOException { [EOL] final int below = 50; [EOL] final int above = 100; [EOL] final boolean between = false; [EOL] final int codepoint = 101; [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u0065", out.toString()); [EOL] }
public void testTranslateWithCodepointAbove0xffff() throws IOException { [EOL] final int codepoint = 0x1D11E; // A codepoint above 0xffff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals(escaper.toUtf16Escape(codepoint), out.toString()); [EOL] }
public void testTranslateWithCodepointJustBelow0xffff() throws IOException { [EOL] final int codepoint = 0xfff0; // A codepoint just below 0xffff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\ufff0", out.toString()); [EOL] }
public void testTranslateWithCodepointBelow0xfff() throws IOException { [EOL] final int codepoint = 0x0ff; // A codepoint below 0xfff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u00ff", out.toString()); [EOL] }
public void testTranslateWithCodepointBelow0xff() throws IOException { [EOL] final int codepoint = 0x00f; // A codepoint below 0xff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u000f", out.toString()); [EOL] }
public void testHexDigitMsb0ToBinary_0() { [EOL] boolean[] result = hexDigitMsb0ToBinary('0'); [EOL] assertArrayEquals(new boolean[] { false, false, false, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_1() { [EOL] boolean[] result = hexDigitMsb0ToBinary('1'); [EOL] assertArrayEquals(new boolean[] { false, false, false, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_2() { [EOL] boolean[] result = hexDigitMsb0ToBinary('2'); [EOL] assertArrayEquals(new boolean[] { false, false, true, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_3() { [EOL] boolean[] result = hexDigitMsb0ToBinary('3'); [EOL] assertArrayEquals(new boolean[] { false, false, true, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_4() { [EOL] boolean[] result = hexDigitMsb0ToBinary('4'); [EOL] assertArrayEquals(new boolean[] { false, true, false, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_5() { [EOL] boolean[] result = hexDigitMsb0ToBinary('5'); [EOL] assertArrayEquals(new boolean[] { false, true, false, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_6() { [EOL] boolean[] result = hexDigitMsb0ToBinary('6'); [EOL] assertArrayEquals(new boolean[] { false, true, true, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_7() { [EOL] boolean[] result = hexDigitMsb0ToBinary('7'); [EOL] assertArrayEquals(new boolean[] { false, true, true, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_8() { [EOL] boolean[] result = hexDigitMsb0ToBinary('8'); [EOL] assertArrayEquals(new boolean[] { true, false, false, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_9() { [EOL] boolean[] result = hexDigitMsb0ToBinary('9'); [EOL] assertArrayEquals(new boolean[] { true, false, false, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_A() { [EOL] boolean[] result = hexDigitMsb0ToBinary('A'); [EOL] assertArrayEquals(new boolean[] { true, false, true, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_a() { [EOL] boolean[] result = hexDigitMsb0ToBinary('a'); [EOL] assertArrayEquals(new boolean[] { true, false, true, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_B() { [EOL] boolean[] result = hexDigitMsb0ToBinary('B'); [EOL] assertArrayEquals(new boolean[] { true, false, true, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_b() { [EOL] boolean[] result = hexDigitMsb0ToBinary('b'); [EOL] assertArrayEquals(new boolean[] { true, false, true, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_C() { [EOL] boolean[] result = hexDigitMsb0ToBinary('C'); [EOL] assertArrayEquals(new boolean[] { true, true, false, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_c() { [EOL] boolean[] result = hexDigitMsb0ToBinary('c'); [EOL] assertArrayEquals(new boolean[] { true, true, false, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_D() { [EOL] boolean[] result = hexDigitMsb0ToBinary('D'); [EOL] assertArrayEquals(new boolean[] { true, true, false, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_d() { [EOL] boolean[] result = hexDigitMsb0ToBinary('d'); [EOL] assertArrayEquals(new boolean[] { true, true, false, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_E() { [EOL] boolean[] result = hexDigitMsb0ToBinary('E'); [EOL] assertArrayEquals(new boolean[] { true, true, true, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_e() { [EOL] boolean[] result = hexDigitMsb0ToBinary('e'); [EOL] assertArrayEquals(new boolean[] { true, true, true, false }, result); [EOL] }
public void testHexDigitMsb0ToBinary_F() { [EOL] boolean[] result = hexDigitMsb0ToBinary('F'); [EOL] assertArrayEquals(new boolean[] { true, true, true, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_f() { [EOL] boolean[] result = hexDigitMsb0ToBinary('f'); [EOL] assertArrayEquals(new boolean[] { true, true, true, true }, result); [EOL] }
public void testHexDigitMsb0ToBinary_Invalid() { [EOL] try { [EOL] hexDigitMsb0ToBinary('g'); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ThrowsIllegalArgumentExceptionForLargeSrcLength() { [EOL] boolean[] src = new boolean[9]; [EOL] int srcPos = 0; [EOL] try { [EOL] SomeClass.binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("src.length>8: src.length=9", e.getMessage()); [EOL] } [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ThrowsIllegalArgumentExceptionForSmallSrcLengthMinusSrcPos() { [EOL] boolean[] src = new boolean[4]; [EOL] int srcPos = 1; [EOL] try { [EOL] SomeClass.binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("src.length-srcPos<4: src.length=4, srcPos=1", e.getMessage()); [EOL] } [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ReturnsCorrectHexDigit() { [EOL] boolean[] src = {true, true, true, true}; [EOL] int srcPos = 0; [EOL] char result = SomeClass.binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ReturnsCorrectHexDigitForDifferentPositions() { [EOL] boolean[] src = {false, false, false, false, true, true, true, true}; [EOL] int srcPos = 4; [EOL] char result = SomeClass.binaryToHexDigitMsb0_4bits(src, srcPos); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryToHexDigitMsb0_4bits_ReturnsCorrectHexDigitForAllCombinations() { [EOL] boolean[][] srcCombinations = { [EOL] {false, false, false, false}, [EOL] {false, false, false, true}, [EOL] {false, false, true, false}, [EOL] {false, false, true, true}, [EOL] {false, true, false, false}, [EOL] {false, true, false, true}, [EOL] {false, true, true, false}, [EOL] {false, true, true, true}, [EOL] {true, false, false, false}, [EOL] {true, false, false, true}, [EOL] {true, false, true, false}, [EOL] {true, false, true, true}, [EOL] {true, true, false, false}, [EOL] {true, true, false, true}, [EOL] {true, true, true, false}, [EOL] {true, true, true, true} [EOL] }; [EOL] char[] expectedResults = {'0', '8', '4', 'c', '2', 'a', '6', 'e', '1', '9', '5', 'd', '3', 'b', '7', 'f'}; [EOL] for (int i = 0; i < srcCombinations.length; i++) { [EOL] char result = SomeClass.binaryToHexDigitMsb0_4bits(srcCombinations[i], 0); [EOL] assertEquals(expectedResults[i], result); [EOL] } [EOL] }
public void testShortArrayToIntEmptySource() { [EOL] short[] src = new short[0]; [EOL] int srcPos = 0; [EOL] int dstInit = 0; [EOL] int dstPos = 0; [EOL] int nShorts = 0; [EOL] int result = Lang3.shortArrayToInt(src, srcPos, dstInit, dstPos, nShorts); [EOL] assertEquals(dstInit, result); [EOL] }
public void testShortArrayToIntIllegalArgumentException() { [EOL] short[] src = {1, 2}; [EOL] int srcPos = 0; [EOL] int dstInit = 0; [EOL] int dstPos = 16; [EOL] int nShorts = 2; [EOL] try { [EOL] Lang3.shortArrayToInt(src, srcPos, dstInit, dstPos, nShorts); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testShortArrayToIntValidInput() { [EOL] short[] src = {1, 2}; [EOL] int srcPos = 0; [EOL] int dstInit = 0; [EOL] int dstPos = 0; [EOL] int nShorts = 2; [EOL] int result = Lang3.shortArrayToInt(src, srcPos, dstInit, dstPos, nShorts); [EOL] int expected = (src[0] << dstPos) | (src[1] << (16 + dstPos)); [EOL] assertEquals(expected, result); [EOL] }
public void testBinaryToByteEmptySourceAndZeroNBools() { [EOL] boolean[] src = {}; [EOL] int srcPos = 0; [EOL] byte dstInit = 0x00; [EOL] int dstPos = 0; [EOL] int nBools = 0; [EOL] byte result = binaryToByte(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(dstInit, result); [EOL] } [EOL] public void testBinaryToByteIllegalArgumentException() { [EOL] boolean[] src = {true, false, true, false}; [EOL] int srcPos = 0; [EOL] byte dstInit = 0x00; [EOL] int dstPos = 0; [EOL] int nBools = 9; // nBools - 1 + dstPos = 8 which should throw an exception [EOL] try { [EOL] binaryToByte(src, srcPos, dstInit, dstPos, nBools); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("nBools-1+dstPos is greather or equal to than 8", e.getMessage()); [EOL] } [EOL] } [EOL] public void testBinaryToByteValidConversion() { [EOL] boolean[] src = {true, false, true, false}; [EOL] int srcPos = 0; [EOL] byte dstInit = 0x00; [EOL] int dstPos = 0; [EOL] int nBools = 4; [EOL] byte result = binaryToByte(src, srcPos, dstInit, dstPos, nBools); [EOL] byte expected = 0x05; // binary 0101 [EOL] assertEquals(expected, result); [EOL] }
public void testBinaryToByteWithOffset() { [EOL] boolean[] src = {false, true, false, true, true}; [EOL] int srcPos = 1; [EOL] byte dstInit = 0x00; [EOL] int dstPos = 2; [EOL] int nBools = 3; [EOL] byte result = binaryToByte(src, srcPos, dstInit, dstPos, nBools); [EOL] byte expected = 0x14; // binary 00010100 [EOL] assertEquals(expected, result); [EOL] }
public void testIntToShortArray_ZeroLength() { [EOL] short[] dst = new short[10]; [EOL] short[] result = ArrayUtils.intToShortArray(0xABCD, 0, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testIntToShortArray_IllegalArgumentException() { [EOL] short[] dst = new short[10]; [EOL] try { [EOL] ArrayUtils.intToShortArray(0xABCD, 0, dst, 0, 3); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIntToShortArray_ValidConversion() { [EOL] short[] dst = new short[10]; [EOL] short[] expected = {0xCD, 0xAB, 0}; [EOL] short[] result = ArrayUtils.intToShortArray(0xABCD, 0, dst, 0, 2); [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testIntToShortArray_ValidConversionWithOffset() { [EOL] short[] dst = new short[10]; [EOL] short[] expected = new short[10]; [EOL] expected[5] = 0xCD; [EOL] expected[6] = 0xAB; [EOL] short[] result = ArrayUtils.intToShortArray(0xABCD, 0, dst, 5, 2); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testIntToBinary_ZeroBools() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] result = YourClass.intToBinary(123, 2, dst, 5, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testIntToBinary_IllegalArgumentException() { [EOL] boolean[] dst = new boolean[10]; [EOL] try { [EOL] YourClass.intToBinary(123, 30, dst, 5, 5); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("nBools-1+srcPos is greather or equal to than 32", e.getMessage()); [EOL] } [EOL] } [EOL] public void testIntToBinary_ValidInput() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = new boolean[10]; [EOL] expected[5] = false; [EOL] expected[6] = true; [EOL] expected[7] = true; [EOL] expected[8] = false; [EOL] expected[9] = true; [EOL] boolean[] result = YourClass.intToBinary(27, 0, dst, 5, 5); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testIntToBinary_ValidInputDifferentSrcPos() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = new boolean[10]; [EOL] expected[5] = true; [EOL] expected[6] = false; [EOL] expected[7] = true; [EOL] expected[8] = true; [EOL] expected[9] = false; [EOL] boolean[] result = YourClass.intToBinary(27, 1, dst, 5, 5); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testIntToBinary_ValidInputDifferentDstPos() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = new boolean[10]; [EOL] expected[3] = false; [EOL] expected[4] = true; [EOL] expected[5] = true; [EOL] expected[6] = false; [EOL] expected[7] = true; [EOL] boolean[] result = YourClass.intToBinary(27, 0, dst, 3, 5); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testShortToBinary_ZeroBools() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] result = MyClass.shortToBinary((short) 0, 0, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] }
public void testShortToBinary_IllegalArgumentException() { [EOL] boolean[] dst = new boolean[10]; [EOL] try { [EOL] MyClass.shortToBinary((short) 0, 0, dst, 0, 17); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("nBools-1+srcPos is greather or equal to than 16", e.getMessage()); [EOL] } [EOL] }
public void testShortToBinary_ValidInput() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = new boolean[10]; [EOL] expected[5] = true; [EOL] boolean[] result = MyClass.shortToBinary((short) 32, 5, dst, 5, 1); [EOL] assertArrayEquals(expected, result); [EOL] }
public StringEscapeUtils() { [EOL] super(); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; [EOL] CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }])];
public void testEscapeXml_withNullInput() { [EOL] String result = StringEscapeUtils.escapeXml(null); [EOL] assertNull(result); [EOL] } [EOL] public void testEscapeXml_withEmptyString() { [EOL] String result = StringEscapeUtils.escapeXml(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testEscapeXml_withContent() { [EOL] String result = StringEscapeUtils.escapeXml("test & < > \" '"); [EOL] assertEquals("test &amp; &lt; &gt; &quot; &apos;", result); [EOL] }
public void testEscapeXml_withAmpersand() { [EOL] String result = StringEscapeUtils.escapeXml("&"); [EOL] assertEquals("&amp;", result); [EOL] } [EOL] public void testEscapeXml_withLessThan() { [EOL] String result = StringEscapeUtils.escapeXml("<"); [EOL] assertEquals("&lt;", result); [EOL] } [EOL] public void testEscapeXml_withGreaterThan() { [EOL] String result = StringEscapeUtils.escapeXml(">"); [EOL] assertEquals("&gt;", result); [EOL] } [EOL] public void testEscapeXml_withQuote() { [EOL] String result = StringEscapeUtils.escapeXml("\""); [EOL] assertEquals("&quot;", result); [EOL] } [EOL] public void testEscapeXml_withApostrophe() { [EOL] String result = StringEscapeUtils.escapeXml("'"); [EOL] assertEquals("&apos;", result); [EOL] }
public static final String unescapeXml(final String input) { [EOL] return UNESCAPE_XML.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
public void testCompositeFormatWithNonNullParserAndFormatter() { [EOL] Format parser = new DecimalFormat(); [EOL] Format formatter = new DecimalFormat(); [EOL] CompositeFormat compositeFormat = new CompositeFormat(parser, formatter); [EOL] assertNotNull(compositeFormat.parser); [EOL] assertNotNull(compositeFormat.formatter); [EOL] }
public void testCompositeFormatWithNullParser() { [EOL] Format formatter = new DecimalFormat(); [EOL] CompositeFormat compositeFormat = new CompositeFormat(null, formatter); [EOL] assertNull(compositeFormat.parser); [EOL] assertNotNull(compositeFormat.formatter); [EOL] }
public void testCompositeFormatWithNullFormatter() { [EOL] Format parser = new DecimalFormat(); [EOL] CompositeFormat compositeFormat = new CompositeFormat(parser, null); [EOL] assertNotNull(compositeFormat.parser); [EOL] assertNull(compositeFormat.formatter); [EOL] }
public void testCompositeFormatWithNullParserAndFormatter() { [EOL] CompositeFormat compositeFormat = new CompositeFormat(null, null); [EOL] assertNull(compositeFormat.parser); [EOL] assertNull(compositeFormat.formatter); [EOL] }
public void testFormatWithValidInput() { [EOL] ExtendedMessageFormat formatter = new ExtendedMessageFormat("{0}"); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] Object obj = new Object(); [EOL] StringBuffer result = formatter.format(obj, toAppendTo, pos); [EOL] assertNotNull(result); [EOL] assertEquals(toAppendTo.toString(), result.toString()); [EOL] }
public void testFormatWithNullObj() { [EOL] ExtendedMessageFormat formatter = new ExtendedMessageFormat("{0}"); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] StringBuffer result = formatter.format(null, toAppendTo, pos); [EOL] assertNotNull(result); [EOL] assertEquals(toAppendTo.toString(), result.toString()); [EOL] }
public void testFormatWithNullToAppendTo() { [EOL] ExtendedMessageFormat formatter = new ExtendedMessageFormat("{0}"); [EOL] FieldPosition pos = new FieldPosition(0); [EOL] Object obj = new Object(); [EOL] try { [EOL] formatter.format(obj, null, pos); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testFormatWithNullFieldPosition() { [EOL] ExtendedMessageFormat formatter = new ExtendedMessageFormat("{0}"); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] Object obj = new Object(); [EOL] StringBuffer result = formatter.format(obj, toAppendTo, null); [EOL] assertNotNull(result); [EOL] assertEquals(toAppendTo.toString(), result.toString()); [EOL] }
public void testParseObjectWithNullSource() { [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Object result = parseObject(null, pos); [EOL] assertNull(result); [EOL] assertEquals(0, pos.getIndex()); [EOL] }
public void testParseObjectWithValidSource() { [EOL] ParsePosition pos = new ParsePosition(0); [EOL] String validSource = "valid source string"; [EOL] Object result = parseObject(validSource, pos); [EOL] assertNotNull(result); [EOL] assertTrue(pos.getIndex() > 0); [EOL] }
public void testParseObjectWithInvalidSource() { [EOL] ParsePosition pos = new ParsePosition(0); [EOL] String invalidSource = "invalid source string"; [EOL] Object result = parseObject(invalidSource, pos); [EOL] assertNull(result); [EOL] assertEquals(0, pos.getIndex()); [EOL] }
public void testReformatWithValidInput() throws ParseException { [EOL] String input = "validInput"; [EOL] String expected = "expectedFormat"; [EOL] when(mockedObject.parseObject(input)).thenReturn(expected); [EOL] String result = instance.reformat(input); [EOL] assertEquals(expected, result); [EOL] }
public void testReformatWithParseException() { [EOL] String input = "invalidInput"; [EOL] when(mockedObject.parseObject(input)).thenThrow(new ParseException("Error", 0)); [EOL] try { [EOL] instance.reformat(input); [EOL] fail("Expected a ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] assertEquals("Error", e.getMessage()); [EOL] } [EOL] }
