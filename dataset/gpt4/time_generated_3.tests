public void testGetValues_Empty() { [EOL] Time time = new Time(); [EOL] int[] expected = new int[0]; [EOL] int[] actual = time.getValues(); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testGetValues_NonEmpty() { [EOL] Time time = new Time(); [EOL] time.add(10); // Assuming there is a method to add values [EOL] time.add(20); [EOL] int[] expected = {10, 20}; [EOL] int[] actual = time.getValues(); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testIndexOf_WithExistingType() { [EOL] DurationFieldType testType = DurationFieldType.minutes(); [EOL] int index = indexOf(testType); [EOL] assertTrue(index >= 0); [EOL] } [EOL] public void testIndexOf_WithNonExistingType() { [EOL] DurationFieldType testType = DurationFieldType.years(); [EOL] int index = indexOf(testType); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOfSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = DurationFieldType.seconds(); [EOL] try { [EOL] indexOfSupported(unsupportedType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported type"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIndexOfSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = DurationFieldType.minutes(); [EOL] int index = indexOfSupported(supportedType); [EOL] assertTrue("Index should be non-negative for supported type", index >= 0); [EOL] }
public void testEquals_SameObject() { [EOL] ReadablePartial partial = createReadablePartial(); [EOL] assertTrue(partial.equals(partial)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadablePartial partial = createReadablePartial(); [EOL] assertFalse(partial.equals(new Object())); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadablePartial partial = createReadablePartial(); [EOL] assertFalse(partial.equals(null)); [EOL] } [EOL] public void testEquals_DifferentSize() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentSize(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_DifferentValues() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentValues(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_DifferentFieldTypes() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentFieldTypes(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_DifferentChronology() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentChronology(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_EqualReadablePartials() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartial(); [EOL] assertTrue(partial1.equals(partial2)); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial mockPartial = createMockPartial(); [EOL] int result = mockPartial.compareTo(mockPartial); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_DifferentSize() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithSize(2); [EOL] ReadablePartial mockPartial2 = createMockPartialWithSize(3); [EOL] try { [EOL] mockPartial1.compareTo(mockPartial2); [EOL] fail("Expected ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testCompareTo_DifferentFieldTypes() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithFieldTypes(new FieldType[]{FieldType.YEAR, FieldType.MONTH_OF_YEAR}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithFieldTypes(new FieldType[]{FieldType.YEAR, FieldType.DAY_OF_MONTH}); [EOL] try { [EOL] mockPartial1.compareTo(mockPartial2); [EOL] fail("Expected ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testCompareTo_GreaterValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{5, 10}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{5, 9}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCompareTo_LessValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{5, 10}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{5, 11}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_EqualValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{5, 10}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{5, 10}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(0, result); [EOL] }

public void testIsBefore_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] LocalTime time = new LocalTime(); [EOL] time.isBefore(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsBefore_PartialBefore_ReturnsTrue() { [EOL] LocalTime time = new LocalTime(10, 0); [EOL] LocalTime earlier = new LocalTime(9, 0); [EOL] assertTrue(time.isBefore(earlier)); [EOL] }
public void testIsBefore_PartialAfter_ReturnsFalse() { [EOL] LocalTime time = new LocalTime(10, 0); [EOL] LocalTime later = new LocalTime(11, 0); [EOL] assertFalse(time.isBefore(later)); [EOL] }
public void testFromCalendarFieldsWithNullCalendar() { [EOL] try { [EOL] YearMonthDay.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testFromCalendarFieldsWithNonNullCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.JANUARY, 1); // Set a known date [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertEquals(2023, ymd.getYear()); [EOL] assertEquals(1, ymd.getMonthOfYear()); // Calendar.JANUARY is 0, YearMonthDay expects 1 for January [EOL] assertEquals(1, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayLongChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDay() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertNotNull(ymd); [EOL] assertEquals(zone, ymd.getChronology().getZone()); [EOL] }
public void testYearMonthDayChronology() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayObject() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayObjectChronology() { [EOL] Date date = new Date(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(date, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayInts() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5); [EOL] assertNotNull(ymd); [EOL] assertEquals(2023, ymd.getYear()); [EOL] assertEquals(4, ymd.getMonthOfYear()); [EOL] assertEquals(5, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntsChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 5, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] assertEquals(2023, ymd.getYear()); [EOL] assertEquals(4, ymd.getMonthOfYear()); [EOL] assertEquals(5, ymd.getDayOfMonth()); [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] YearMonthDay ymd = new YearMonthDay(); // Assuming default constructor uses current system chronology [EOL] Chronology chronology = ymd.getChronology(); [EOL] YearMonthDay result = ymd.withChronologyRetainFields(chronology); [EOL] assertSame("Should be the same object as the chronology is the same", ymd, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] YearMonthDay ymd = new YearMonthDay(); // Assuming default constructor uses current system chronology [EOL] Chronology newChronology = ISOChronology.getInstanceUTC(); // Different chronology [EOL] if (!newChronology.equals(ymd.getChronology())) { [EOL] YearMonthDay result = ymd.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Should not be the same object as the chronology is different", ymd, result); [EOL] assertEquals("The new YearMonthDay should have the UTC chronology", newChronology, result.getChronology()); [EOL] } [EOL] }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (value == getValue(index)) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).set(this, index, newValues, value); [EOL] return new YearMonthDay(this, newValues); [EOL] }
public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (amount == 0) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).add(this, index, newValues, amount); [EOL] return new YearMonthDay(this, newValues); [EOL] } [EOL] public YearMonthDay() { } [EOL] public YearMonthDay(DateTimeZone zone) { } [EOL] public YearMonthDay(Chronology chronology) { } [EOL] public YearMonthDay(long instant) { } [EOL] public YearMonthDay(long instant, Chronology chronology) { } [EOL] public YearMonthDay(Object instant) { } [EOL] public YearMonthDay(Object instant, Chronology chronology) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { } [EOL] YearMonthDay(YearMonthDay partial, int[] values) { } [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono) { } [EOL] Property(YearMonthDay partial, int fieldIndex) { } [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar) { } [EOL] public static YearMonthDay fromDateFields(Date date) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public YearMonthDay plus(ReadablePeriod period) { } [EOL] public YearMonthDay plusYears(int years) { } [EOL] public YearMonthDay plusMonths(int months) { } [EOL] public YearMonthDay plusDays(int days) { } [EOL] public YearMonthDay minus(ReadablePeriod period) { } [EOL] public YearMonthDay minusYears(int years) { } [EOL] public YearMonthDay minusMonths(int months) { } [EOL] public YearMonthDay minusDays(int days) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalDate toLocalDate() { } [EOL] public DateTime toDateTimeAtMidnight() { } [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) { } [EOL] public DateTime toDateTimeAtCurrentTime() { } [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { } [EOL] public DateMidnight toDateMidnight() { } [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) { } [EOL] public DateTime toDateTime(TimeOfDay time) { } [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) { } [EOL] public Interval toInterval() { } [EOL] public Interval toInterval(DateTimeZone zone) { } [EOL] public int getYear() { } [EOL] public int getMonthOfYear() { } [EOL] public int getDayOfMonth() { } [EOL] public YearMonthDay withYear(int year) { } [EOL] public YearMonthDay withMonthOfYear(int monthOfYear) { } [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth) { } [EOL] public Property year() { } [EOL] public Property monthOfYear() { } [EOL] public Property dayOfMonth() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public YearMonthDay getYearMonthDay() { } [EOL] public int get() { } [EOL] public YearMonthDay addToCopy(int valueToAdd) { } [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public YearMonthDay setCopy(int value) { } [EOL] public YearMonthDay setCopy(String text, Locale locale) { } [EOL] public YearMonthDay setCopy(String text) { } [EOL] public YearMonthDay withMaximumValue() { } [EOL] public YearMonthDay withMinimumValue() { } [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testMinusMonths() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); // Assuming a constructor with year, month, day exists [EOL] YearMonthDay result = ymd.minusMonths(1); [EOL] assertEquals(new YearMonthDay(2023, 3, 15), result); // Assuming a correct equals method exists [EOL] }
public void testMinusMonthsAcrossYearBoundary() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 1, 15); [EOL] YearMonthDay result = ymd.minusMonths(2); [EOL] assertEquals(new YearMonthDay(2022, 11, 15), result); [EOL] }
public void testMinusMonthsNegative() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] YearMonthDay result = ymd.minusMonths(-1); [EOL] assertEquals(new YearMonthDay(2023, 5, 15), result); [EOL] }
public void testMinusMonthsToZero() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] YearMonthDay result = ymd.minusMonths(4); [EOL] assertEquals(new YearMonthDay(2023, 12, 15), result); // Assuming it wraps to the previous year [EOL] }
public void testMinusMonthsMaxInt() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] YearMonthDay result = ymd.minusMonths(Integer.MAX_VALUE); [EOL] assertNotNull(result); [EOL] }
public Property property(DateTimeFieldType type) { [EOL] return new Property(this, indexOfSupported(type)); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testToDateTimeAtCurrentTime() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTime dt = ymd.toDateTimeAtCurrentTime(); [EOL] assertNotNull(dt); [EOL] }
public void testYearMonthDayLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayLongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight(chronology.getZone()).getMillis()); [EOL] assertSame(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayObject() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertEquals(date.getTime(), ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayObjectChronology() { [EOL] Date date = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(date, chronology); [EOL] assertEquals(date.getTime(), ymd.toDateTimeAtMidnight(chronology.getZone()).getMillis()); [EOL] assertSame(chronology, ymd.getChronology()); [EOL] }
public void testYearMonthDayInts() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntsChronology() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chronology); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] assertSame(chronology, ymd.getChronology()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertEquals(calendar.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = YearMonthDay.fromDateFields(date); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testToDateTimeAtCurrentTimeWithNullZone() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTime result = ymd.toDateTimeAtCurrentTime(null); [EOL] assertNotNull("DateTime should not be null", result); [EOL] assertEquals("Chronology should be UTC", DateTimeZone.UTC, result.getChronology().getZone()); [EOL] }
public void testToDateTimeAtCurrentTimeWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTime result = ymd.toDateTimeAtCurrentTime(zone); [EOL] assertNotNull("DateTime should not be null", result); [EOL] assertEquals("Chronology should be the same as the zone", zone, result.getChronology().getZone()); [EOL] }
public void testAddToCopy_ValueToAdd() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); // Assuming this constructor creates a valid YearMonthDay object [EOL] YearMonthDay result = ymd.addToCopy(5); [EOL] int expectedYear = ymd.getYear(); [EOL] int expectedMonth = ymd.getMonthOfYear(); [EOL] int expectedDay = ymd.getDayOfMonth(); [EOL] DateTimeField field = ymd.getField(); [EOL] int fieldIndex = ymd.getField().getFieldIndex(); // Assuming getFieldIndex is a method that returns the index of the field [EOL] if (fieldIndex == 0) { [EOL] expectedYear += 5; [EOL] } else if (fieldIndex == 1) { [EOL] expectedMonth += 5; [EOL] } else if (fieldIndex == 2) { [EOL] expectedDay += 5; [EOL] } [EOL] assertEquals(expectedYear, result.getYear()); [EOL] assertEquals(expectedMonth, result.getMonthOfYear()); [EOL] assertEquals(expectedDay, result.getDayOfMonth()); [EOL] }

public void testWithMinimumValue() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay minValYMD = ymd.withMinimumValue(); [EOL] assertNotNull(minValYMD); [EOL] assertEquals(minValYMD.getYear(), ymd.getMinimumValue(DateTimeFieldType.year())); [EOL] assertEquals(minValYMD.getMonthOfYear(), ymd.getMinimumValue(DateTimeFieldType.monthOfYear())); [EOL] assertEquals(minValYMD.getDayOfMonth(), ymd.getMinimumValue(DateTimeFieldType.dayOfMonth())); [EOL] }
public void testYearMonthDayConstructors() { [EOL] YearMonthDay ymdDefault = new YearMonthDay(); [EOL] assertNotNull(ymdDefault); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymdZone = new YearMonthDay(zone); [EOL] assertNotNull(ymdZone); [EOL] assertEquals(zone, ymdZone.getChronology().getZone()); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymdChronology = new YearMonthDay(chronology); [EOL] assertNotNull(ymdChronology); [EOL] assertEquals(chronology, ymdChronology.getChronology()); [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymdInstant = new YearMonthDay(instant); [EOL] assertNotNull(ymdInstant); [EOL] YearMonthDay ymdInstantChronology = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymdInstantChronology); [EOL] assertEquals(chronology, ymdInstantChronology.getChronology()); [EOL] YearMonthDay ymdFromObject = new YearMonthDay((Object) instant); [EOL] assertNotNull(ymdFromObject); [EOL] YearMonthDay ymdFromObjectChronology = new YearMonthDay((Object) instant, chronology); [EOL] assertNotNull(ymdFromObjectChronology); [EOL] assertEquals(chronology, ymdFromObjectChronology.getChronology()); [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymdYMD = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymdYMD); [EOL] assertEquals(year, ymdYMD.getYear()); [EOL] assertEquals(month, ymdYMD.getMonthOfYear()); [EOL] assertEquals(day, ymdYMD.getDayOfMonth()); [EOL] YearMonthDay ymdYMDChronology = new YearMonthDay(year, month, day, chronology); [EOL] assertNotNull(ymdYMDChronology); [EOL] assertEquals(chronology, ymdYMDChronology.getChronology()); [EOL] }
public void testReadablePartialConverterConstructor() { [EOL] ReadablePartialConverter converter = new ReadablePartialConverter(); [EOL] assertNotNull(converter); [EOL] }
public void testLongConverterConstructor() { [EOL] LongConverter converter = new LongConverter(); [EOL] assertNotNull(converter); [EOL] }
public void testFieldDifference_WithNullStart_ThrowsIllegalArgumentException() { [EOL] ReadablePartial end = new LocalDate(); [EOL] try { [EOL] Period result = Time.fieldDifference(null, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testFieldDifference_WithNullEnd_ThrowsIllegalArgumentException() { [EOL] ReadablePartial start = new LocalDate(); [EOL] try { [EOL] Period result = Time.fieldDifference(start, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testFieldDifference_WithDifferentSizes_ThrowsIllegalArgumentException() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDateTime(); [EOL] try { [EOL] Period result = Time.fieldDifference(start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testFieldDifference_WithDifferentFieldTypes_ThrowsIllegalArgumentException() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDate() { [EOL] @Override [EOL] public DurationFieldType getFieldType(int index) { [EOL] if (index == 0) { [EOL] return DurationFieldType.weeks(); [EOL] } [EOL] return super.getFieldType(index); [EOL] } [EOL] }; [EOL] try { [EOL] Period result = Time.fieldDifference(start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testFieldDifference_WithOverlappingFields_ThrowsIllegalArgumentException() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDate() { [EOL] @Override [EOL] public DurationFieldType getFieldType(int index) { [EOL] if (index == 1) { [EOL] return DurationFieldType.days(); [EOL] } [EOL] return super.getFieldType(index); [EOL] } [EOL] }; [EOL] try { [EOL] Period result = Time.fieldDifference(start, end); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must not have overlapping fields", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testFieldDifference_ValidInput_ReturnsCorrectPeriod() { [EOL] ReadablePartial start = new LocalDate(2020, 1, 1); [EOL] ReadablePartial end = new LocalDate(2020, 1, 2); [EOL] Period result = Time.fieldDifference(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getDays()); [EOL] }
public void testPeriod_AllFields() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] assertEquals(1, period.getYears()); [EOL] assertEquals(2, period.getMonths()); [EOL] assertEquals(3, period.getWeeks()); [EOL] assertEquals(4, period.getDays()); [EOL] assertEquals(5, period.getHours()); [EOL] assertEquals(6, period.getMinutes()); [EOL] assertEquals(7, period.getSeconds()); [EOL] assertEquals(8, period.getMillis()); [EOL] }
public void testPeriodWithReadablePartials() { [EOL] ReadablePartial start = new LocalDate(2020, 1, 1); [EOL] ReadablePartial end = new LocalDate(2020, 12, 31); [EOL] Period period = new Period(start, end); [EOL] assertNotNull(period); [EOL] assertEquals(new PeriodType(), period.getPeriodType()); [EOL] }
public void testPeriodWithNullStart() { [EOL] ReadablePartial end = new LocalDate(2020, 12, 31); [EOL] try { [EOL] new Period(null, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodWithNullEnd() { [EOL] ReadablePartial start = new LocalDate(2020, 1, 1); [EOL] try { [EOL] new Period(start, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodWithBothNulls() { [EOL] try { [EOL] new Period(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodWithNullStart() { [EOL] try { [EOL] new Period(null, new LocalDate(), PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for null start"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testPeriodWithNullEnd() { [EOL] try { [EOL] new Period(new LocalDate(), null, PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for null end"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testPeriodWithNullType() { [EOL] LocalDate start = new LocalDate(); [EOL] LocalDate end = new LocalDate(); [EOL] Period period = new Period(start, end, null); [EOL] assertNotNull("Period should not be null even if type is null", period); [EOL] }
public void testPeriodWithNonNullStartEndType() { [EOL] LocalDate start = new LocalDate(); [EOL] LocalDate end = new LocalDate().plusDays(1); [EOL] PeriodType type = PeriodType.days(); [EOL] Period period = new Period(start, end, type); [EOL] assertNotNull("Period should not be null with non-null start, end, and type", period); [EOL] assertEquals("Period should be one day", 1, period.getDays()); [EOL] }
public void testPeriodWithNonNullArguments() { [EOL] ReadableDuration mockDuration = mock(ReadableDuration.class); [EOL] ReadableInstant mockEndInstant = mock(ReadableInstant.class); [EOL] Period period = new Period(mockDuration, mockEndInstant); [EOL] assertNotNull(period); [EOL] }
public void testWithField_NullField_ThrowsIllegalArgumentException() { [EOL] try { [EOL] Period period = new Period(); [EOL] period.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidField_ReturnsNewPeriod() { [EOL] Period period = new Period(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); [EOL] int newValue = 10; [EOL] Period newPeriod = period.withField(fieldType, newValue); [EOL] assertNotNull(newPeriod); [EOL] assertEquals(newValue, newPeriod.get(fieldType)); [EOL] }
public void testWithFieldAdded_NullField() { [EOL] try { [EOL] Period period = new Period(); [EOL] period.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroValue() { [EOL] Period period = new Period(); [EOL] Period result = period.withFieldAdded(DurationFieldType.minutes(), 0); [EOL] assertSame("Period should be the same as no field is added", period, result); [EOL] }
public void testWithFieldAdded_NonZeroValue() { [EOL] Period period = new Period(); [EOL] Period result = period.withFieldAdded(DurationFieldType.minutes(), 10); [EOL] assertNotNull("Resulting period must not be null", result); [EOL] assertNotSame("Resulting period must be a new instance", period, result); [EOL] }
public void testMinusWithNullPeriod() { [EOL] Period testPeriod = new Period(1, 1, 1, 1, 1, 1, 1, 1); [EOL] Period result = testPeriod.minus(null); [EOL] assertEquals(testPeriod, result); [EOL] }
public void testMinusWithNonEmptyPeriod() { [EOL] Period testPeriod = new Period(2, 2, 2, 2, 2, 2, 2, 2); [EOL] ReadablePeriod periodToSubtract = new MockPeriod(new int[]{1, 1, 1, 1, 1, 1, 1, 1}); [EOL] Period result = testPeriod.minus(periodToSubtract); [EOL] Period expected = new Period(1, 1, 1, 1, 1, 1, 1, 1); [EOL] assertEquals(expected, result); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Period testPeriod = Period.ZERO; [EOL] Period result = testPeriod.multipliedBy(5); [EOL] assertSame(testPeriod, result); [EOL] } [EOL] public void testMultipliedBy_One() { [EOL] Period testPeriod = new Period(new int[]{1, 2, 3}, PeriodType.standard()); [EOL] Period result = testPeriod.multipliedBy(1); [EOL] assertSame(testPeriod, result); [EOL] } [EOL] public void testMultipliedBy_NonOneScalar() { [EOL] Period testPeriod = new Period(new int[]{1, 2, 3}, PeriodType.standard()); [EOL] Period result = testPeriod.multipliedBy(2); [EOL] int[] expectedValues = new int[]{2, 4, 6}; [EOL] Period expectedPeriod = new Period(expectedValues, PeriodType.standard()); [EOL] assertEquals(expectedPeriod, result); [EOL] }
public void testNegated() { [EOL] Period period = Period.of(1, 2, 3); [EOL] Period result = period.negated(); [EOL] assertEquals(Period.of(-1, -2, -3), result); [EOL] }
public void testNegated_ZeroPeriod() { [EOL] Period period = Period.of(0, 0, 0); [EOL] Period result = period.negated(); [EOL] assertEquals(Period.of(0, 0, 0), result); [EOL] }
public void testToStandardHours_Zero() { [EOL] TimePeriod period = new TimePeriod(0, 0, 0, 0, 0, 0, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_OnlySeconds() { [EOL] TimePeriod period = new TimePeriod(0, 0, 0, 0, 0, 30, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_OnlyMinutes() { [EOL] TimePeriod period = new TimePeriod(0, 0, 0, 0, 30, 0, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_OnlyHours() { [EOL] TimePeriod period = new TimePeriod(0, 0, 0, 1, 0, 0, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(1, result.getHours()); [EOL] }
public void testToStandardHours_OnlyDays() { [EOL] TimePeriod period = new TimePeriod(0, 0, 1, 0, 0, 0, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(24, result.getHours()); [EOL] }
public void testToStandardHours_OnlyWeeks() { [EOL] TimePeriod period = new TimePeriod(0, 1, 0, 0, 0, 0, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(168, result.getHours()); [EOL] }
public void testToStandardHours_Complex() { [EOL] TimePeriod period = new TimePeriod(0, 1, 1, 1, 30, 30, 0); [EOL] Hours result = period.toStandardHours(); [EOL] assertEquals(193, result.getHours()); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] IslamicChronology chrono = IslamicChronology.getInstance(null, LeapYearPatternType.FIFTEEN); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] IslamicChronology chrono = IslamicChronology.getInstance(zone, LeapYearPatternType.FIFTEEN); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] }
public void testGetInstanceWithUTCZone() { [EOL] DateTimeZone utc = DateTimeZone.UTC; [EOL] IslamicChronology chrono = IslamicChronology.getInstance(utc, LeapYearPatternType.FIFTEEN); [EOL] assertNotNull(chrono); [EOL] assertEquals(utc, chrono.getZone()); [EOL] }
public void testGetTotalMillisByYearMonth_OddMonth() { [EOL] int year = 2021; [EOL] int oddMonth = 3; // March, which is an odd month (3 - 1) % 2 == 1 [EOL] long expected = (oddMonth / 2) * Time.MILLIS_PER_MONTH_PAIR + Time.MILLIS_PER_LONG_MONTH; [EOL] long result = new Time().getTotalMillisByYearMonth(year, oddMonth); [EOL] assertEquals(expected, result); [EOL] }
public void testGetTotalMillisByYearMonth_EvenMonth() { [EOL] int year = 2021; [EOL] int evenMonth = 4; // April, which is an even month (4 - 1) % 2 == 0 [EOL] long expected = (evenMonth / 2) * Time.MILLIS_PER_MONTH_PAIR; [EOL] long result = new Time().getTotalMillisByYearMonth(year, evenMonth); [EOL] assertEquals(expected, result); [EOL] }
public void testCalculateFirstDayOfYearMillis_MaxYear() { [EOL] int year = MAX_YEAR; [EOL] try { [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] } catch (ArithmeticException e) { [EOL] fail("Should not throw an exception for max year"); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_TooLargeYear() { [EOL] int year = MAX_YEAR + 1; [EOL] try { [EOL] calculateFirstDayOfYearMillis(year); [EOL] fail("Should have thrown an exception for year too large"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Year is too large: " + year + " > " + MAX_YEAR, e.getMessage()); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_MinYear() { [EOL] int year = MIN_YEAR; [EOL] try { [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] } catch (ArithmeticException e) { [EOL] fail("Should not throw an exception for min year"); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_TooSmallYear() { [EOL] int year = MIN_YEAR - 1; [EOL] try { [EOL] calculateFirstDayOfYearMillis(year); [EOL] fail("Should have thrown an exception for year too small"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Year is too small: " + year + " < " + MIN_YEAR, e.getMessage()); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_LeapYear() { [EOL] int year = SOME_LEAP_YEAR; // Replace with an actual leap year within the valid range [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] }
public void testCalculateFirstDayOfYearMillis_NonLeapYear() { [EOL] int year = SOME_NON_LEAP_YEAR; // Replace with an actual non-leap year within the valid range [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] }
public void testGetDateTimeMillis_BaseChronology() { [EOL] Chronology mockBase = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockBase.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt())).thenReturn(1234567890L); [EOL] setBase(mockBase); // Assuming a method to set the base chronology [EOL] long result = getDateTimeMillis(2023, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_GregorianChronology() { [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt())).thenReturn(1234567890L); [EOL] setBase(null); // Assuming a method to set the base chronology to null [EOL] long result = getDateTimeMillis(2023, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_IllegalFieldValueException_NotFebruary29() { [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenThrow(new IllegalFieldValueException("monthOfYear", 1, "is not valid")); [EOL] setBase(null); // Assuming a method to set the base chronology to null [EOL] try { [EOL] getDateTimeMillis(2023, 1, 1, 12, 0, 0, 0); [EOL] fail("Expected IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] }
public void testGetDateTimeMillis_IllegalFieldValueException_February29() { [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), eq(2), eq(29), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenThrow(new IllegalFieldValueException("dayOfMonth", 29, "is not valid")); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), eq(2), eq(28), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenReturn(1234567890L); [EOL] setBase(null); // Assuming a method to set the base chronology to null [EOL] setCutoverMillis(1234567891L); // Assuming a method to set the cutover milliseconds [EOL] long result = getDateTimeMillis(2023, 2, 29, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_IllegalFieldValueException_February29_AfterCutover() { [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), eq(2), eq(29), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenThrow(new IllegalFieldValueException("dayOfMonth", 29, "is not valid")); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), eq(2), eq(28), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenReturn(1234567891L); [EOL] setBase(null); // Assuming a method to set the base chronology to null [EOL] setCutoverMillis(1234567890L); // Assuming a method to set the cutover milliseconds [EOL] try { [EOL] getDateTimeMillis(2023, 2, 29, 12, 0, 0, 0); [EOL] fail("Expected IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] }
public void testGetDateTimeMillis_JulianChronology_BeforeCutover() { [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenReturn(1234567889L); [EOL] setBase(null); // Assuming a method to set the base chronology to null [EOL] setCutoverMillis(1234567890L); // Assuming a method to set the cutover milliseconds [EOL] long result = getDateTimeMillis(2023, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567889L, result); [EOL] }
public void testGetDateTimeMillis_JulianChronology_AfterCutover() { [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyInt())) [EOL] .thenReturn(1234567890L); [EOL] setBase(null); // Assuming a method to set the base chronology to null [EOL] setCutoverMillis(1234567889L); // Assuming a method to set the cutover milliseconds [EOL] try { [EOL] getDateTimeMillis(2023, 1, 1, 12, 0, 0, 0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testToStringWithDefaultCutoverAndDefaultMinimumDays() { [EOL] GJChronology gjChronology = GJChronology.getInstance(); [EOL] String result = gjChronology.toString(); [EOL] assertTrue(result.startsWith("GJChronology[")); [EOL] assertTrue(result.endsWith("]")); [EOL] assertFalse(result.contains("cutover=")); [EOL] assertFalse(result.contains("mdfw=")); [EOL] } [EOL] public void testToStringWithNonDefaultCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long nonDefaultCutover = new DateTime(1970, 1, 1, 0, 0, zone).getMillis(); [EOL] GJChronology gjChronology = GJChronology.getInstance(zone, nonDefaultCutover); [EOL] String result = gjChronology.toString(); [EOL] assertTrue(result.contains("cutover=")); [EOL] assertTrue(result.contains(zone.getID())); [EOL] assertFalse(result.contains("mdfw=")); [EOL] } [EOL] public void testToStringWithNonDefaultMinimumDays() { [EOL] GJChronology gjChronology = GJChronology.getInstance(DateTimeZone.UTC, GJChronology.DEFAULT_CUTOVER.getMillis(), 5); [EOL] String result = gjChronology.toString(); [EOL] assertTrue(result.contains("mdfw=5")); [EOL] assertFalse(result.contains("cutover=")); [EOL] } [EOL] public void testToStringWithNonDefaultCutoverAndMinimumDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long nonDefaultCutover = new DateTime(1970, 1, 1, 0, 0, zone).getMillis(); [EOL] GJChronology gjChronology = GJChronology.getInstance(zone, nonDefaultCutover, 6); [EOL] String result = gjChronology.toString(); [EOL] assertTrue(result.contains("cutover=")); [EOL] assertTrue(result.contains("mdfw=6")); [EOL] assertTrue(result.contains(zone.getID())); [EOL] }

public void testSetWithInstantGreaterThanOrEqualToCutoverAndResultingInstantLessThanCutover() { [EOL] long instant = iCutover; [EOL] int value = 10; [EOL] try { [EOL] long result = set(instant, value); [EOL] assertTrue(result < iCutover); [EOL] assertEquals(value, get(result)); [EOL] } catch (IllegalFieldValueException e) { [EOL] fail("Should not throw an exception"); [EOL] } [EOL] }
public void testSetWithInstantGreaterThanOrEqualToCutoverAndResultingInstantNotLessThanCutover() { [EOL] long instant = iCutover; [EOL] int value = 10; [EOL] long result = set(instant + iGapDuration, value); [EOL] assertTrue(result >= iCutover); [EOL] assertEquals(value, get(result)); [EOL] }
public void testSetWithInstantLessThanCutoverAndResultingInstantGreaterThanOrEqualToCutover() { [EOL] long instant = iCutover - 1; [EOL] int value = 10; [EOL] try { [EOL] long result = set(instant, value); [EOL] assertTrue(result >= iCutover); [EOL] assertEquals(value, get(result)); [EOL] } catch (IllegalFieldValueException e) { [EOL] fail("Should not throw an exception"); [EOL] } [EOL] }
public void testSetWithInstantLessThanCutoverAndResultingInstantNotGreaterThanOrEqualToCutover() { [EOL] long instant = iCutover - 1; [EOL] int value = 10; [EOL] long result = set(instant - iGapDuration, value); [EOL] assertTrue(result < iCutover); [EOL] assertEquals(value, get(result)); [EOL] }
public void testSetWithInvalidValueForGregorianField() { [EOL] long instant = iCutover; [EOL] int invalidValue = -1; // Assuming this is an invalid value for the field [EOL] try { [EOL] set(instant, invalidValue); [EOL] fail("Should have thrown an IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testSetWithInvalidValueForJulianField() { [EOL] long instant = iCutover - 1; [EOL] int invalidValue = -1; // Assuming this is an invalid value for the field [EOL] try { [EOL] set(instant, invalidValue); [EOL] fail("Should have thrown an IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testSetWithInstantGreaterThanOrEqualToCutover() { [EOL] long instant = iCutover; [EOL] String text = "someText"; [EOL] Locale locale = Locale.getDefault(); [EOL] long expected = iGregorianField.set(instant, text, locale); [EOL] if (expected < iCutover) { [EOL] if (expected + iGapDuration < iCutover) { [EOL] expected = gregorianToJulian(expected); [EOL] } [EOL] } [EOL] long result = set(instant, text, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithInstantLessThanCutover() { [EOL] long instant = iCutover - 1; [EOL] String text = "someText"; [EOL] Locale locale = Locale.getDefault(); [EOL] long expected = iJulianField.set(instant, text, locale); [EOL] if (expected >= iCutover) { [EOL] if (expected - iGapDuration >= iCutover) { [EOL] expected = julianToGregorian(expected); [EOL] } [EOL] } [EOL] long result = set(instant, text, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithInstantAtCutoverAndGapDuration() { [EOL] long instant = iCutover; [EOL] String text = "someText"; [EOL] Locale locale = Locale.getDefault(); [EOL] long expected = iGregorianField.set(instant, text, locale); [EOL] if (expected < iCutover) { [EOL] if (expected + iGapDuration >= iCutover) { [EOL] } [EOL] } [EOL] long result = set(instant, text, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithInstantJustBeforeCutoverAndGapDuration() { [EOL] long instant = iCutover - 1; [EOL] String text = "someText"; [EOL] Locale locale = Locale.getDefault(); [EOL] long expected = iJulianField.set(instant, text, locale); [EOL] if (expected >= iCutover) { [EOL] if (expected - iGapDuration < iCutover) { [EOL] } [EOL] } [EOL] long result = set(instant, text, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloor_AfterCutover() { [EOL] long instant = iCutover + 1; // Any value after cutover [EOL] long expected = iGregorianField.roundFloor(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_AtCutover() { [EOL] long instant = iCutover; [EOL] long expected = iGregorianField.roundFloor(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_BeforeCutover() { [EOL] long instant = iCutover - 1; // Any value before cutover [EOL] long expected = iJulianField.roundFloor(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_GapBeforeCutover() { [EOL] long instant = iCutover - 1; // Any value before cutover [EOL] when(iGregorianField.roundFloor(instant)).thenReturn(instant); [EOL] when(iJulianField.roundFloor(instant)).thenReturn(instant); [EOL] long expected = gregorianToJulian(instant); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long add(long instant, int value) { [EOL] if (instant >= iCutover) { [EOL] instant = iGregorianField.add(instant, value); [EOL] if (instant < iCutover) { [EOL] if (instant + iGapDuration < iCutover) { [EOL] if (iConvertByWeekyear) { [EOL] int wyear = iGregorianChronology.weekyear().get(instant); [EOL] if (wyear <= 0) { [EOL] instant = iGregorianChronology.weekyear().add(instant, -1); [EOL] } [EOL] } else { [EOL] int year = iGregorianChronology.year().get(instant); [EOL] if (year <= 0) { [EOL] instant = iGregorianChronology.year().add(instant, -1); [EOL] } [EOL] } [EOL] instant = gregorianToJulian(instant); [EOL] } [EOL] } [EOL] } else { [EOL] instant = iJulianField.add(instant, value); [EOL] if (instant >= iCutover) { [EOL] if (instant - iGapDuration >= iCutover) { [EOL] instant = julianToGregorian(instant); [EOL] } [EOL] } [EOL] } [EOL] return instant; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL] if (minuendInstant >= iCutover) { [EOL] if (subtrahendInstant >= iCutover) { [EOL] return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } [EOL] minuendInstant = gregorianToJulian(minuendInstant); [EOL] return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } else { [EOL] if (subtrahendInstant < iCutover) { [EOL] return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } [EOL] minuendInstant = julianToGregorian(minuendInstant); [EOL] return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } [EOL] }
public void testAdd() { [EOL] long instant = 1000L; [EOL] int value = 5; [EOL] long expected = 2000L; [EOL] Field iFieldMock = mock(Field.class); [EOL] when(iFieldMock.add(instant, value)).thenReturn(expected); [EOL] MyClass myClass = new MyClass(iFieldMock); [EOL] long result = myClass.add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifference_Coverage() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expectedDifference = iField.getDifference(minuendInstant, subtrahendInstant); [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testAbstractConverterInstantiation() { [EOL] ConcreteConverter converter = new ConcreteConverter(); [EOL] assertNotNull(converter); [EOL] }
public void testToStringWithSupportedTypeNull() { [EOL] Converter converter = new Converter(); [EOL] converter.setSupportedType(null); [EOL] String result = converter.toString(); [EOL] assert result.equals("Converter[null]"); [EOL] }
public void testToStringWithSupportedTypeNotNull() { [EOL] Converter converter = new Converter(); [EOL] Type dummyType = new Type("DummyType"); [EOL] converter.setSupportedType(dummyType); [EOL] String result = converter.toString(); [EOL] assert result.equals("Converter[DummyType]"); [EOL] }
public void testStringConverterConstructor() { [EOL] new StringConverter(); [EOL] }
public void testGetPartialValues_WithParserZone() { [EOL] ReadablePartial mockFieldSource = mock(ReadablePartial.class); [EOL] Object mockObject = "2023-03-15T12:34:56"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] DateTimeFormatter mockParser = mock(DateTimeFormatter.class); [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] when(mockParser.getZone()).thenReturn(mockZone); [EOL] when(mockChrono.withZone(mockZone)).thenReturn(mockChrono); [EOL] when(mockParser.withChronology(mockChrono)).thenReturn(mockParser); [EOL] when(mockParser.parseMillis((String) mockObject)).thenReturn(1234567890L); [EOL] when(mockChrono.get(mockFieldSource, 1234567890L)).thenReturn(new int[]{1, 2, 3}); [EOL] int[] result = getPartialValues(mockFieldSource, mockObject, mockChrono, mockParser); [EOL] verify(mockParser).getZone(); [EOL] verify(mockChrono).withZone(mockZone); [EOL] verify(mockParser).withChronology(mockChrono); [EOL] verify(mockParser).parseMillis((String) mockObject); [EOL] verify(mockChrono).get(mockFieldSource, 1234567890L); [EOL] assertArrayEquals(new int[]{1, 2, 3}, result); [EOL] }
public void testGetPartialValues_WithoutParserZone() { [EOL] ReadablePartial mockFieldSource = mock(ReadablePartial.class); [EOL] Object mockObject = "2023-03-15T12:34:56"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] DateTimeFormatter mockParser = mock(DateTimeFormatter.class); [EOL] when(mockParser.getZone()).thenReturn(null); [EOL] when(mockParser.withChronology(mockChrono)).thenReturn(mockParser); [EOL] when(mockParser.parseMillis((String) mockObject)).thenReturn(1234567890L); [EOL] when(mockChrono.get(mockFieldSource, 1234567890L)).thenReturn(new int[]{4, 5, 6}); [EOL] int[] result = getPartialValues(mockFieldSource, mockObject, mockChrono, mockParser); [EOL] verify(mockParser).getZone(); [EOL] verify(mockParser).withChronology(mockChrono); [EOL] verify(mockParser).parseMillis((String) mockObject); [EOL] verify(mockChrono).get(mockFieldSource, 1234567890L); [EOL] assertArrayEquals(new int[]{4, 5, 6}, result); [EOL] }
public void testSetIntoWithValidString() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String validString = "PT1H"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] setInto(mockPeriod, validString, mockChrono); [EOL] verify(mockPeriod).clear(); [EOL] verifyNoMoreInteractions(mockPeriod); [EOL] }
public void testSetIntoWithInvalidString() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String invalidString = "Invalid"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] try { [EOL] setInto(mockPeriod, invalidString, mockChrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid format: \"Invalid\"", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithPartiallyInvalidString() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String partiallyInvalidString = "PT1HInvalid"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] try { [EOL] setInto(mockPeriod, partiallyInvalidString, mockChrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid format: \"PT1HInvalid\"", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithInvalidSeparator() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "invalidFormat"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to missing '/' separator"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format requires a '/' separator: invalidFormat", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithEmptyLeftPart() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "/P1Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to empty left part"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format invalid: /P1Y", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithEmptyRightPart() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to empty right part"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format invalid: P1Y/", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithTwoDurations() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/P2Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to interval composed of two durations"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Interval composed of two durations: P1Y/P2Y", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithValidDateTimeAndPeriod() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "2000-01-01T00:00:00/P1Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithValidPeriodAndDateTime() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/2001-01-01T00:00:00"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public Class<?> getSupportedType() { [EOL] return String.class; [EOL] }
public void testReadablePeriodConverterConstructor() { [EOL] class TestableReadablePeriodConverter extends ReadablePeriodConverter { [EOL] public TestableReadablePeriodConverter() { [EOL] super(); [EOL] } [EOL] } [EOL] TestableReadablePeriodConverter converter = new TestableReadablePeriodConverter(); [EOL] assertNotNull("The constructor should create an instance.", converter); [EOL] }
public void testToFormatter_Coverage() { [EOL] PeriodFormatter result = instance.toFormatter(); [EOL] assertNotNull(result); [EOL] }
public void testClear_WithNullElementPairs() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.iElementPairs = null; [EOL] builder.clear(); [EOL] assertEquals(1, builder.iMinPrintedDigits); [EOL] assertEquals(DateTimeFormatterBuilder.PRINT_ZERO_RARELY_LAST, builder.iPrintZeroSetting); [EOL] assertEquals(10, builder.iMaxParsedDigits); [EOL] assertFalse(builder.iRejectSignedValues); [EOL] assertNull(builder.iPrefix); [EOL] assertNotNull(builder.iElementPairs); [EOL] assertFalse(builder.iNotPrinter); [EOL] assertFalse(builder.iNotParser); [EOL] assertNotNull(builder.iFieldFormatters); [EOL] assertEquals(10, builder.iFieldFormatters.length); [EOL] }
public void testClear_WithNonNullElementPairs() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.iElementPairs = new ArrayList<Object>(); [EOL] builder.iElementPairs.add(new Object()); [EOL] builder.clear(); [EOL] assertEquals(1, builder.iMinPrintedDigits); [EOL] assertEquals(DateTimeFormatterBuilder.PRINT_ZERO_RARELY_LAST, builder.iPrintZeroSetting); [EOL] assertEquals(10, builder.iMaxParsedDigits); [EOL] assertFalse(builder.iRejectSignedValues); [EOL] assertNull(builder.iPrefix); [EOL] assertNotNull(builder.iElementPairs); [EOL] assertTrue(builder.iElementPairs.isEmpty()); [EOL] assertFalse(builder.iNotPrinter); [EOL] assertFalse(builder.iNotParser); [EOL] assertNotNull(builder.iFieldFormatters); [EOL] assertEquals(10, builder.iFieldFormatters.length); [EOL] }
public void testAppendPrefixWithNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.appendPrefix(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendPrefixWithNonNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendPrefix("Prefix"); [EOL] }
public void testAppendPrefixWithNullPrefix() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.appendPrefix(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendPrefixWithNonNullPrefix() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFieldAffix mockAffix = new MockPeriodFieldAffix(); [EOL] builder = builder.appendPrefix(mockAffix); [EOL] assertNotNull("Prefix should be set", builder.getPrefix()); [EOL] }
public void testAppendPrefixWithExistingPrefix() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFieldAffix mockAffix1 = new MockPeriodFieldAffix(); [EOL] PeriodFieldAffix mockAffix2 = new MockPeriodFieldAffix(); [EOL] builder = builder.appendPrefix(mockAffix1); [EOL] builder = builder.appendPrefix(mockAffix2); [EOL] assertTrue("Prefix should be instance of CompositeAffix", builder.getPrefix() instanceof CompositeAffix); [EOL] }
public void testAppendHours() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendHours(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
private void appendField(int type, int minPrintedDigits) { [EOL] if (type <= 0) { [EOL] throw new IllegalArgumentException("Invalid field type"); [EOL] } [EOL] if (minPrintedDigits < 0) { [EOL] minPrintedDigits = 0; [EOL] } [EOL] }
public void testAppendFieldWithValidTypeAndMinPrinted() { [EOL] TimeFormatter formatter = new TimeFormatter(); [EOL] int type = 1; // Assuming 1 is a valid type [EOL] int minPrinted = 3; // Arbitrary value for minPrinted [EOL] formatter.appendField(type, minPrinted); [EOL] assertNotNull(formatter.iFieldFormatters[type]); [EOL] assertEquals(minPrinted, formatter.iFieldFormatters[type].minPrinted); [EOL] assertNull(formatter.iPrefix); [EOL] }
public void testAppendSuffix_WithValidSingularAndPluralText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String singularText = "day"; [EOL] String pluralText = "days"; [EOL] builder.appendSuffix(singularText, pluralText); [EOL] }
public void testAppendSuffix_WithNullSingularText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String singularText = null; [EOL] String pluralText = "days"; [EOL] try { [EOL] builder.appendSuffix(singularText, pluralText); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSuffix_WithNullPluralText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String singularText = "day"; [EOL] String pluralText = null; [EOL] try { [EOL] builder.appendSuffix(singularText, pluralText); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppend0_WithNonNullPrinterAndParser() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] builder.append0(printer, parser); [EOL] assertFalse(builder.iNotPrinter); [EOL] assertFalse(builder.iNotParser); [EOL] assertEquals(2, builder.iElementPairs.size()); [EOL] assertSame(printer, builder.iElementPairs.get(0)); [EOL] assertSame(parser, builder.iElementPairs.get(1)); [EOL] }
public void testAppend0_WithNullPrinter() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] builder.append0(null, parser); [EOL] assertTrue(builder.iNotPrinter); [EOL] assertFalse(builder.iNotParser); [EOL] assertEquals(2, builder.iElementPairs.size()); [EOL] assertNull(builder.iElementPairs.get(0)); [EOL] assertSame(parser, builder.iElementPairs.get(1)); [EOL] }
public void testAppend0_WithNullParser() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] builder.append0(printer, null); [EOL] assertFalse(builder.iNotPrinter); [EOL] assertTrue(builder.iNotParser); [EOL] assertEquals(2, builder.iElementPairs.size()); [EOL] assertSame(printer, builder.iElementPairs.get(0)); [EOL] assertNull(builder.iElementPairs.get(1)); [EOL] }
public void testAppend0_WithBothNull() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.append0(null, null); [EOL] assertTrue(builder.iNotPrinter); [EOL] assertTrue(builder.iNotParser); [EOL] assertEquals(2, builder.iElementPairs.size()); [EOL] assertNull(builder.iElementPairs.get(0)); [EOL] assertNull(builder.iElementPairs.get(1)); [EOL] }
public void testToFormatter_ThrowsIllegalStateException() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] boolean notPrinter = true; [EOL] boolean notParser = true; [EOL] try { [EOL] toFormatter(elementPairs, notPrinter, notParser); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Builder has created neither a printer nor a parser", e.getMessage()); [EOL] } [EOL] }
public void testToFormatter_WithSeparatorAndNullAfterParserPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Separator(null, null, null, null, null)); [EOL] boolean notPrinter = false; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] }
public void testToFormatter_NotPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] boolean notPrinter = true; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void testToFormatter_NotParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] boolean notPrinter = false; [EOL] boolean notParser = true; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNull(result.getParser()); [EOL] }
public void testToFormatter_PrinterAndParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] boolean notPrinter = false; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void testCreateCompositeWithEmptyList() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] Object[] result = createComposite(elementPairs); [EOL] assertEquals("Expected array length is 2", 2, result.length); [EOL] assertSame("Expected both elements to be Literal.EMPTY", Literal.EMPTY, result[0]); [EOL] assertSame("Expected both elements to be Literal.EMPTY", Literal.EMPTY, result[1]); [EOL] }
public void testCreateCompositeWithOneElement() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add("Element1"); [EOL] elementPairs.add("Element2"); [EOL] Object[] result = createComposite(elementPairs); [EOL] assertEquals("Expected array length is 2", 2, result.length); [EOL] assertEquals("Expected first element to match", "Element1", result[0]); [EOL] assertEquals("Expected second element to match", "Element2", result[1]); [EOL] }
public void testCreateCompositeWithMultipleElements() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add("Element1"); [EOL] elementPairs.add("Element2"); [EOL] elementPairs.add("Element3"); [EOL] Object[] result = createComposite(elementPairs); [EOL] assertEquals("Expected array length is 2", 2, result.length); [EOL] assertTrue("Expected first element to be instance of Composite", result[0] instanceof Composite); [EOL] assertTrue("Expected second element to be instance of Composite", result[1] instanceof Composite); [EOL] assertSame("Expected both elements to be the same Composite instance", result[0], result[1]); [EOL] }
public void testSimpleAffixConstructorWithNonNullText() { [EOL] String text = "SampleText"; [EOL] SimpleAffix affix = new SimpleAffix(text); [EOL] assertNotNull(affix); [EOL] assertEquals(text, affix.getText()); [EOL] }
public void testSimpleAffixConstructorWithEmptyText() { [EOL] String text = "";// Empty string [EOL] SimpleAffix affix = new SimpleAffix(text); [EOL] assertNotNull(affix); [EOL] assertEquals(text, affix.getText()); [EOL] }
public void testSimpleAffixConstructorWithNullText() { [EOL] String text = null;// null value [EOL] SimpleAffix affix = new SimpleAffix(text); [EOL] assertNotNull(affix); [EOL] assertNull(affix.getText()); [EOL] }
public void testCalculatePrintedLength() { [EOL] int expectedLength = iText.length(); [EOL] int actualLength = calculatePrintedLength(someValue); [EOL] assertEquals(expectedLength, actualLength); [EOL] }
public void printToTestWithEmptyBuffer() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = 123; [EOL] printTo(buf, value); [EOL] assertEquals("Expected buffer to contain text", iText, buf.toString()); [EOL] }
public void printToTestWithExistingContentInBuffer() { [EOL] StringBuffer buf = new StringBuffer("Existing content "); [EOL] int value = 456; [EOL] printTo(buf, value); [EOL] assertEquals("Expected buffer to contain existing content followed by text", "Existing content " + iText, buf.toString()); [EOL] }
public void testPluralAffixWithNonNullValues() { [EOL] String singularText = "item"; [EOL] String pluralText = "items"; [EOL] PluralAffix pluralAffix = new PluralAffix(singularText, pluralText); [EOL] assertEquals(singularText, pluralAffix.iSingularText); [EOL] assertEquals(pluralText, pluralAffix.iPluralText); [EOL] }
public void testCalculatePrintedLengthSingular() { [EOL] int value = 1; [EOL] int result = calculatePrintedLength(value); [EOL] assertEquals(iSingularText.length(), result); [EOL] }
public void testCalculatePrintedLengthPlural() { [EOL] int value = 2; [EOL] int result = calculatePrintedLength(value); [EOL] assertEquals(iPluralText.length(), result); [EOL] }
public void printTo_withSingularValue_AppendsSingularText() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = 1; [EOL] printTo(buf, value); [EOL] assertEquals(iSingularText, buf.toString()); [EOL] }
public void printTo_withPluralValue_AppendsPluralText() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = 2; [EOL] printTo(buf, value); [EOL] assertEquals(iPluralText, buf.toString()); [EOL] }
public void testFieldFormatterConstructor() { [EOL] int minPrintedDigits = 1; [EOL] int printZeroSetting = 2; [EOL] int maxParsedDigits = 3; [EOL] boolean rejectSignedValues = true; [EOL] int fieldType = 4; [EOL] FieldFormatter[] fieldFormatters = new FieldFormatter[0]; [EOL] PeriodFieldAffix prefix = null; [EOL] PeriodFieldAffix suffix = null; [EOL] FieldFormatter formatter = new FieldFormatter(minPrintedDigits, printZeroSetting, maxParsedDigits, rejectSignedValues, fieldType, fieldFormatters, prefix, suffix); [EOL] assertEquals(minPrintedDigits, formatter.iMinPrintedDigits); [EOL] assertEquals(printZeroSetting, formatter.iPrintZeroSetting); [EOL] assertEquals(maxParsedDigits, formatter.iMaxParsedDigits); [EOL] assertEquals(rejectSignedValues, formatter.iRejectSignedValues); [EOL] assertEquals(fieldType, formatter.iFieldType); [EOL] assertArrayEquals(fieldFormatters, formatter.iFieldFormatters); [EOL] assertNull(formatter.iPrefix); [EOL] assertNull(formatter.iSuffix); [EOL] }
public void testCountFieldsToPrint_StopAtLessThanOrEqualToZero() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] int stopAt = 0; [EOL] Locale mockLocale = mock(Locale.class); [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountFieldsToPrint_PrintZeroAlways() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] int stopAt = 1; [EOL] Locale mockLocale = mock(Locale.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1L); [EOL] iPrintZeroSetting = PRINT_ZERO_ALWAYS; [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCountFieldsToPrint_FieldValueNotMax() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] int stopAt = 1; [EOL] Locale mockLocale = mock(Locale.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1L); [EOL] iPrintZeroSetting = PRINT_ZERO_RARELY; // Assuming PRINT_ZERO_RARELY is a valid setting [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(1, result); [EOL] }
public void testCountFieldsToPrint_FieldValueIsMaxAndPrintZeroRarely() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] int stopAt = 1; [EOL] Locale mockLocale = mock(Locale.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(Long.MAX_VALUE); [EOL] iPrintZeroSetting = PRINT_ZERO_RARELY; // Assuming PRINT_ZERO_RARELY is a valid setting [EOL] int result = countFieldsToPrint(mockPeriod, stopAt, mockLocale); [EOL] assertEquals(0, result); [EOL] }
public void testCalculatePrintedLength_MaxValue() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(Long.MAX_VALUE); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertEquals(0, result); [EOL] }
public void testCalculatePrintedLength_NegativeValue() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(-12345L); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 5); [EOL] }
public void testCalculatePrintedLength_PositiveValue() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(12345L); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 4); [EOL] }
public void testCalculatePrintedLength_WithPrefix() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(12345L); [EOL] when(iPrefix.calculatePrintedLength(anyInt())).thenReturn(2); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 6); [EOL] }
public void testCalculatePrintedLength_WithSuffix() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(12345L); [EOL] when(iSuffix.calculatePrintedLength(anyInt())).thenReturn(3); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 7); [EOL] }
public void testCalculatePrintedLength_WithSecondsOptionalMillis() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(DateTimeConstants.MILLIS_PER_SECOND); [EOL] when(iFieldType).thenReturn(SECONDS_OPTIONAL_MILLIS); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertEquals(1, result); [EOL] }
public void testPrintToWithMaxValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(Long.MAX_VALUE); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithSecondsMillis() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123456789L); [EOL] iFieldType = SECONDS_MILLIS; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().contains(".789")); [EOL] }
public void testPrintToWithPrefix() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iPrefix = mock(PeriodFieldAffix.class); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] verify(iPrefix).printTo(buf, 123); [EOL] }
public void testPrintToWithMinDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iMinPrintedDigits = 2; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().startsWith("0123")); [EOL] }
public void testPrintToWithSuffix() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iSuffix = mock(PeriodFieldAffix.class); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] verify(iSuffix).printTo(buf, 123); [EOL] }
public void testPrintToWithNegativeMillis() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(-123L); [EOL] iFieldType = SECONDS_MILLIS; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().startsWith("-0.123")); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndNotSupported() { [EOL] ReadablePeriod period = createMockPeriodWithUnsupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndSupported() { [EOL] ReadablePeriod period = createMockPeriodWithSupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_TypeNull() { [EOL] ReadablePeriod period = createMockPeriodWithNullType(); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_SupportedTypeAndFieldValueZero_PrintZeroNever() { [EOL] ReadablePeriod period = createMockPeriodWithSupportedTypeAndZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_SupportedTypeAndFieldValueZero_PrintZeroRarelyLast() { [EOL] ReadablePeriod period = createMockPeriodWithSupportedTypeAndZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_SupportedTypeAndFieldValueZero_PrintZeroRarelyFirst() { [EOL] ReadablePeriod period = createMockPeriodWithSupportedTypeAndZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_SupportedTypeAndNonZeroFieldValue() { [EOL] ReadablePeriod period = createMockPeriodWithSupportedTypeAndNonZeroValue(); [EOL] long result = getFieldValue(period); [EOL] assertEquals(expectedNonZeroValue, result); [EOL] }
public void testIsZeroWithAllZeros() { [EOL] ReadablePeriod period = new MockPeriod(new int[]{0, 0, 0, 0}); [EOL] boolean result = isZero(period); [EOL] assertTrue(result); [EOL] }
public void testIsZeroWithNonZeroValue() { [EOL] ReadablePeriod period = new MockPeriod(new int[]{0, 1, 0, 0}); [EOL] boolean result = isZero(period); [EOL] assertFalse(result); [EOL] }
public void testIsSupported_WithUnsupportedField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] boolean result = isSupported(mockType, -1); // Assuming -1 is an unsupported field [EOL] assertFalse(result); [EOL] }
public void testIsSupported_WithYearsField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.years())).thenReturn(true); [EOL] boolean result = isSupported(mockType, YEARS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithMonthsField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.months())).thenReturn(true); [EOL] boolean result = isSupported(mockType, MONTHS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithWeeksField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.weeks())).thenReturn(true); [EOL] boolean result = isSupported(mockType, WEEKS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithDaysField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.days())).thenReturn(true); [EOL] boolean result = isSupported(mockType, DAYS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithHoursField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.hours())).thenReturn(true); [EOL] boolean result = isSupported(mockType, HOURS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithMinutesField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.minutes())).thenReturn(true); [EOL] boolean result = isSupported(mockType, MINUTES); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(true); [EOL] boolean result = isSupported(mockType, SECONDS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithMillisField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(true); [EOL] boolean result = isSupported(mockType, MILLIS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsMillisField_SupportedSeconds() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(true); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(false); [EOL] boolean result = isSupported(mockType, SECONDS_MILLIS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsMillisField_SupportedMillis() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(false); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(true); [EOL] boolean result = isSupported(mockType, SECONDS_MILLIS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsOptionalMillisField_SupportedSeconds() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(true); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(false); [EOL] boolean result = isSupported(mockType, SECONDS_OPTIONAL_MILLIS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsOptionalMillisField_SupportedMillis() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(false); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(true); [EOL] boolean result = isSupported(mockType, SECONDS_OPTIONAL_MILLIS); [EOL] assertTrue(result); [EOL] }
public void testCompositeWithEmptyElementPairs() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] Composite(elementPairs); [EOL] assertNull(iPrinters); [EOL] assertNull(iParsers); [EOL] }
public void testCompositeWithNonEmptyPrinterListOnly() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new PeriodPrinter() {/* implementation here */}); [EOL] Composite(elementPairs); [EOL] assertNotNull(iPrinters); [EOL] assertNull(iParsers); [EOL] }
public void testCompositeWithNonEmptyParserListOnly() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new PeriodParser() {/* implementation here */}); [EOL] Composite(elementPairs); [EOL] assertNull(iPrinters); [EOL] assertNotNull(iParsers); [EOL] }
public void testCompositeWithNonEmptyPrinterAndParserLists() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new PeriodPrinter() {/* implementation here */}); [EOL] elementPairs.add(new PeriodParser() {/* implementation here */}); [EOL] Composite(elementPairs); [EOL] assertNotNull(iPrinters); [EOL] assertNotNull(iParsers); [EOL] }
public void testCountFieldsToPrintWithNullPeriod() { [EOL] int stopAt = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] int result = countFieldsToPrint(null, stopAt, locale); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountFieldsToPrintWithPositiveStopAt() { [EOL] ReadablePeriod period = new Period(); [EOL] int stopAt = 3; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter[] printers = new PeriodPrinter[] {new MockPeriodPrinter(1), new MockPeriodPrinter(2)}; [EOL] iPrinters = printers; [EOL] int result = countFieldsToPrint(period, stopAt, locale); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testCountFieldsToPrintWithStopAtGreaterThanPrinters() { [EOL] ReadablePeriod period = new Period(); [EOL] int stopAt = 10; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter[] printers = new PeriodPrinter[] {new MockPeriodPrinter(1), new MockPeriodPrinter(2)}; [EOL] iPrinters = printers; [EOL] int result = countFieldsToPrint(period, stopAt, locale); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testCountFieldsToPrintWithStopAtZero() { [EOL] ReadablePeriod period = new Period(); [EOL] int stopAt = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter[] printers = new PeriodPrinter[] {new MockPeriodPrinter(1), new MockPeriodPrinter(2)}; [EOL] iPrinters = printers; [EOL] int result = countFieldsToPrint(period, stopAt, locale); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCountFieldsToPrintWithNegativeStopAt() { [EOL] ReadablePeriod period = new Period(); [EOL] int stopAt = -1; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter[] printers = new PeriodPrinter[] {new MockPeriodPrinter(1), new MockPeriodPrinter(2)}; [EOL] iPrinters = printers; [EOL] int result = countFieldsToPrint(period, stopAt, locale); [EOL] assertEquals(0, result); [EOL] }
public void testCalculatePrintedLengthWithEmptyPrintersArray() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = mock(Locale.class); [EOL] PeriodPrinter[] printers = new PeriodPrinter[0]; [EOL] Time time = new Time(printers); [EOL] int result = time.calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(0, result); [EOL] }
public void testCalculatePrintedLengthWithSinglePrinter() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = mock(Locale.class); [EOL] PeriodPrinter mockPrinter = mock(PeriodPrinter.class); [EOL] when(mockPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] PeriodPrinter[] printers = new PeriodPrinter[] {mockPrinter}; [EOL] Time time = new Time(printers); [EOL] int result = time.calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(5, result); [EOL] }
public void testCalculatePrintedLengthWithMultiplePrinters() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = mock(Locale.class); [EOL] PeriodPrinter mockPrinter1 = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockPrinter2 = mock(PeriodPrinter.class); [EOL] when(mockPrinter1.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockPrinter2.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(7); [EOL] PeriodPrinter[] printers = new PeriodPrinter[] {mockPrinter1, mockPrinter2}; [EOL] Time time = new Time(printers); [EOL] int result = time.calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(10, result); [EOL] }
public void testPrintToWithNullArguments() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = null; [EOL] Locale locale = null; [EOL] PeriodFormatter formatter = new PeriodFormatter(null, new PeriodPrinter[]{}); [EOL] formatter.printTo(buf, period, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithEmptyPrinters() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = new PeriodFormatter(null, new PeriodPrinter[]{}); [EOL] formatter.printTo(buf, period, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithSinglePrinter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter printer = new MockPeriodPrinter(); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, new PeriodPrinter[]{printer}); [EOL] formatter.printTo(buf, period, locale); [EOL] assertEquals("MockPeriodPrinter", buf.toString()); [EOL] }
public void testPrintToWithMultiplePrinters() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter printer1 = new MockPeriodPrinter(); [EOL] PeriodPrinter printer2 = new MockPeriodPrinter(); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, new PeriodPrinter[]{printer1, printer2}); [EOL] formatter.printTo(buf, period, locale); [EOL] assertEquals("MockPeriodPrinterMockPeriodPrinter", buf.toString()); [EOL] }
public void testDecomposeWithEmptyList() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertTrue(printerList.isEmpty()); [EOL] assertTrue(parserList.isEmpty()); [EOL] }
public void testDecomposeWithNonCompositePrinter() { [EOL] List<Object> elementPairs = Arrays.asList(new PeriodPrinter() {}, "Not a printer"); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(1, printerList.size()); [EOL] assertTrue(parserList.isEmpty()); [EOL] }
public void testDecomposeWithNonCompositeParser() { [EOL] List<Object> elementPairs = Arrays.asList("Not a parser", new PeriodParser() {}); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertTrue(printerList.isEmpty()); [EOL] assertEquals(1, parserList.size()); [EOL] }
public void testDecomposeWithCompositePrinterAndParser() { [EOL] Composite compositePrinter = new Composite(new PeriodPrinter[] {new PeriodPrinter() {}}); [EOL] Composite compositeParser = new Composite(new PeriodParser[] {new PeriodParser() {}}); [EOL] List<Object> elementPairs = Arrays.asList(compositePrinter, compositeParser); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(1, printerList.size()); [EOL] assertEquals(1, parserList.size()); [EOL] }
public void testDecomposeWithMixedElements() { [EOL] Composite compositePrinter = new Composite(new PeriodPrinter[] {new PeriodPrinter() {}}); [EOL] PeriodPrinter nonCompositePrinter = new PeriodPrinter() {}; [EOL] Composite compositeParser = new Composite(new PeriodParser[] {new PeriodParser() {}}); [EOL] PeriodParser nonCompositeParser = new PeriodParser() {}; [EOL] List<Object> elementPairs = Arrays.asList(compositePrinter, "Not a parser", nonCompositePrinter, compositeParser, "Not a printer", nonCompositeParser); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(2, printerList.size()); [EOL] assertEquals(2, parserList.size()); [EOL] }
public boolean isLenient() { [EOL] return false; [EOL] }
public static DateTimeFormatter mediumTime() { [EOL] return createFormatterForStyleIndex(NONE, MEDIUM); [EOL] } [EOL] protected DateTimeFormat() { } [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] } [EOL] public static DateTimeFormatter forPattern(String pattern) { [EOL] } [EOL] public static DateTimeFormatter forStyle(String style) { [EOL] } [EOL] public static String patternForStyle(String style, Locale locale) { [EOL] } [EOL] public static DateTimeFormatter shortDate() { [EOL] } [EOL] public static DateTimeFormatter shortTime() { [EOL] } [EOL] public static DateTimeFormatter shortDateTime() { [EOL] } [EOL] public static DateTimeFormatter mediumDate() { [EOL] } [EOL] public static DateTimeFormatter mediumTime() { [EOL] } [EOL] public static DateTimeFormatter mediumDateTime() { [EOL] } [EOL] public static DateTimeFormatter longDate() { [EOL] } [EOL] public static DateTimeFormatter longTime() { [EOL] } [EOL] public static DateTimeFormatter longDateTime() { [EOL] } [EOL] public static DateTimeFormatter fullDate() { [EOL] } [EOL] public static DateTimeFormatter fullTime() { [EOL] } [EOL] public static DateTimeFormatter fullDateTime() { [EOL] } [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] } [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] } [EOL] private static String parseToken(String pattern, int[] indexRef) { [EOL] } [EOL] private static boolean isNumericToken(String token) { [EOL] } [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern) { [EOL] } [EOL] private static DateTimeFormatter createFormatterForStyle(String style) { [EOL] } [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) { [EOL] } [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL] } [EOL] private static int selectStyle(char ch) { [EOL] } [EOL] public int estimatePrintedLength() { [EOL] } [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL] } [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL] } [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL] } [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL] } [EOL] public int estimateParsedLength() { [EOL] } [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] } [EOL] private DateTimeFormatter getFormatter(Locale locale) { [EOL] } [EOL] String getPattern(Locale locale) { [EOL] } [EOL] int FULL = 0; [EOL] int LONG = 1; [EOL] int MEDIUM = 2; [EOL] int SHORT = 3; [EOL] int NONE = 4; [EOL] int DATE = 0; [EOL] int TIME = 1; [EOL] int DATETIME = 2; [EOL] int PATTERN_CACHE_SIZE = 500; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE = new LinkedHashMap<String, DateTimeFormatter>(7) { [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] } [EOL] };
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] int length = pattern.length(); [EOL] int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] String token = parseToken(pattern, indexRef); [EOL] i = indexRef[0]; [EOL] int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] builder.appendEraText(); [EOL] break; [EOL] case 'C': [EOL] builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL] break; [EOL] case 'x': [EOL] case 'y': [EOL] case 'Y': [EOL] if (tokenLen == 2) { [EOL] boolean lenientParse = true; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] lenientParse = false; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL] break; [EOL] case 'y': [EOL] case 'Y': [EOL] default: [EOL] builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL] break; [EOL] } [EOL] } else { [EOL] int maxDigits = 9; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] maxDigits = tokenLen; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendWeekyear(tokenLen, maxDigits); [EOL] break; [EOL] case 'y': [EOL] builder.appendYear(tokenLen, maxDigits); [EOL] break; [EOL] case 'Y': [EOL] builder.appendYearOfEra(tokenLen, maxDigits); [EOL] break; [EOL] } [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 3) { [EOL] if (tokenLen >= 4) { [EOL] builder.appendMonthOfYearText(); [EOL] } else { [EOL] builder.appendMonthOfYearShortText(); [EOL] } [EOL] } else { [EOL] builder.appendMonthOfYear(tokenLen); [EOL] } [EOL] break; [EOL] case 'd': [EOL] builder.appendDayOfMonth(tokenLen); [EOL] break; [EOL] case 'a': [EOL] builder.appendHalfdayOfDayText(); [EOL] break; [EOL] case 'h': [EOL] builder.appendClockhourOfHalfday(tokenLen); [EOL] break; [EOL] case 'H': [EOL] builder.appendHourOfDay(tokenLen); [EOL] break; [EOL] case 'k': [EOL] builder.appendClockhourOfDay(tokenLen); [EOL] break; [EOL] case 'K': [EOL] builder.appendHourOfHalfday(tokenLen); [EOL] break; [EOL] case 'm': [EOL] builder.appendMinuteOfHour(tokenLen); [EOL] break; [EOL] case 's': [EOL] builder.appendSecondOfMinute(tokenLen); [EOL] break; [EOL] case 'S': [EOL] builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL] break; [EOL] case 'e': [EOL] builder.appendDayOfWeek(tokenLen); [EOL] break; [EOL] case 'E': [EOL] if (tokenLen >= 4) { [EOL] builder.appendDayOfWeekText(); [EOL] } else { [EOL] builder.appendDayOfWeekShortText(); [EOL] } [EOL] break; [EOL] case 'D': [EOL] builder.appendDayOfYear(tokenLen); [EOL] break; [EOL] case 'w': [EOL] builder.appendWeekOfWeekyear(tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] builder.appendTimeZoneName(); [EOL] } else { [EOL] builder.appendTimeZoneShortName(null); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL] } else if (tokenLen == 2) { [EOL] builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL] } else { [EOL] builder.appendTimeZoneId(); [EOL] } [EOL] break; [EOL] case '\'': [EOL] String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] builder.appendLiteral(sub.charAt(0)); [EOL] } else { [EOL] builder.appendLiteral(new String(sub)); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] } [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ; [EOL] private static final long serialVersionUID = 23L;; ; [EOL] @Override; [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {; [EOL] return size() > PATTERN_CACHE_SIZE;; [EOL] }; [EOL] }]
public void testIsNumericTokenWithSingleCharacter() { [EOL] assertTrue(isNumericToken("c")); [EOL] assertTrue(isNumericToken("C")); [EOL] assertTrue(isNumericToken("x")); [EOL] assertTrue(isNumericToken("y")); [EOL] assertTrue(isNumericToken("Y")); [EOL] assertTrue(isNumericToken("d")); [EOL] assertTrue(isNumericToken("h")); [EOL] assertTrue(isNumericToken("H")); [EOL] assertTrue(isNumericToken("m")); [EOL] assertTrue(isNumericToken("s")); [EOL] assertTrue(isNumericToken("S")); [EOL] assertTrue(isNumericToken("e")); [EOL] assertTrue(isNumericToken("D")); [EOL] assertTrue(isNumericToken("F")); [EOL] assertTrue(isNumericToken("w")); [EOL] assertTrue(isNumericToken("W")); [EOL] assertTrue(isNumericToken("k")); [EOL] assertTrue(isNumericToken("K")); [EOL] assertTrue(isNumericToken("M")); [EOL] }
public void testIsNumericTokenWithEmptyString() { [EOL] assertFalse(isNumericToken("")); [EOL] }
public void testIsNumericTokenWithNonNumericToken() { [EOL] assertFalse(isNumericToken("nonNumeric")); [EOL] }
public void testIsNumericTokenWithMultiCharacterToken() { [EOL] assertTrue(isNumericToken("MM")); [EOL] assertFalse(isNumericToken("MMM")); [EOL] }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL] int type = DATETIME; [EOL] if (dateStyle == NONE) { [EOL] type = TIME; [EOL] } else if (timeStyle == NONE) { [EOL] type = DATE; [EOL] } [EOL] StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL] return new DateTimeFormatter(llf, llf); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }]
public void testSelectStyleWithShort() { [EOL] int result = selectStyle('S'); [EOL] assertEquals(SHORT, result); [EOL] } [EOL] public void testSelectStyleWithMedium() { [EOL] int result = selectStyle('M'); [EOL] assertEquals(MEDIUM, result); [EOL] } [EOL] public void testSelectStyleWithLong() { [EOL] int result = selectStyle('L'); [EOL] assertEquals(LONG, result); [EOL] } [EOL] public void testSelectStyleWithFull() { [EOL] int result = selectStyle('F'); [EOL] assertEquals(FULL, result); [EOL] } [EOL] public void testSelectStyleWithNone() { [EOL] int result = selectStyle('-'); [EOL] assertEquals(NONE, result); [EOL] } [EOL] public void testSelectStyleWithInvalidCharacter() { [EOL] try { [EOL] selectStyle('X'); [EOL] fail("Expected IllegalArgumentException for invalid style character"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
String getPattern(Locale locale) { [EOL] DateFormat f = null; [EOL] switch(iType) { [EOL] case DATE: [EOL] f = DateFormat.getDateInstance(iDateStyle, locale); [EOL] break; [EOL] case TIME: [EOL] f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL] break; [EOL] case DATETIME: [EOL] f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL] break; [EOL] } [EOL] if (f instanceof SimpleDateFormat == false) { [EOL] throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL] } [EOL] return ((SimpleDateFormat) f).toPattern(); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
public void testStandardHours_Zero() { [EOL] Duration result = Time.standardHours(0); [EOL] assertEquals(Duration.ZERO, result); [EOL] }
public void testStandardHours_Positive() { [EOL] long hours = 5; [EOL] Duration result = Time.standardHours(hours); [EOL] assertEquals(new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR), result); [EOL] }
public void testStandardHours_Negative() { [EOL] long hours = -3; [EOL] Duration result = Time.standardHours(hours); [EOL] assertEquals(new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR), result); [EOL] }
public void testDurationConstructor() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Duration duration = new Duration(startInstant, endInstant); [EOL] assertNotNull(duration); [EOL] }
public void testMinus_withNullAmount() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.minus(null); [EOL] assertEquals(duration, result); [EOL] }
public void testMinus_withValidAmount() { [EOL] Duration duration = new Duration(1000); [EOL] ReadableDuration amount = new Duration(500); [EOL] Duration result = duration.minus(amount); [EOL] assertEquals(new Duration(500), result); [EOL] }
public void testDividedBy_DivisorIsOne() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.dividedBy(1); [EOL] assertSame(duration, result); [EOL] }
public void testDividedBy_DivisorIsNotOne() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.dividedBy(2); [EOL] assertNotNull(result); [EOL] assertEquals(500, result.getMillis()); [EOL] }
public void testAlternateExtendedWithWeeks_NotInitialized() { [EOL] PeriodFormatter result = YourClass.alternateExtendedWithWeeks(); [EOL] assertNotNull(result); [EOL] assertEquals("P0000-00-W00-00T00:00:00.000", result.print(new Period(0))); [EOL] } [EOL] public void testAlternateExtendedWithWeeks_AlreadyInitialized() { [EOL] YourClass.alternateExtendedWithWeeks(); [EOL] PeriodFormatter result = YourClass.alternateExtendedWithWeeks(); [EOL] assertNotNull(result); [EOL] assertEquals("P0000-00-W00-00T00:00:00.000", result.print(new Period(0))); [EOL] }
public void testWriteMillis_MultipleOfHalfHour() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 30 * 60000L * 2; // Multiple of half an hour [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(anyInt()); [EOL] }
public void testWriteMillis_NotMultipleOfHalfHourButMultipleOfMinute() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 60000L * 45; // Not a multiple of half an hour but a multiple of a minute [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeInt(anyInt()); [EOL] }
public void testWriteMillis_NotMultipleOfMinuteButMultipleOfSecond() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 1000L * 45; // Not a multiple of a minute but a multiple of a second [EOL] Time.writeMillis(out, millis); [EOL] verify(out, times(1)).writeByte(anyInt()); [EOL] verify(out, times(1)).writeInt(anyInt()); [EOL] }
public void testWriteMillis_NotMultipleOfSecond() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 12345L; // Not a multiple of a second [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(anyInt()); [EOL] verify(out).writeLong(millis); [EOL] }
public void testWriteMillis_NegativeValue() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = -12345L; // Negative value [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(0xff); [EOL] verify(out).writeLong(millis); [EOL] }
public void testWriteMillis_MaxUnitsBoundary() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = (30 * 60000L) * ((1L << 6) - 1); // Maximum units that can be written as a byte [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(anyInt()); [EOL] }
public void testWriteMillis_OverflowUnitsBoundary() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = (30 * 60000L) * (1L << 6); // Just above the maximum units that can be written as a byte [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(anyInt()); [EOL] verify(out).writeLong(millis); [EOL] }
public void testWriteMillis_MaxMinutesBoundary() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 60000L * ((1L << 30) - 1); // Maximum minutes that can be written as an int [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeInt(anyInt()); [EOL] }
public void testWriteMillis_OverflowMinutesBoundary() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 60000L * (1L << 30); // Just above the maximum minutes that can be written as an int [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(anyInt()); [EOL] verify(out).writeLong(millis); [EOL] }
public void testWriteMillis_MaxSecondsBoundary() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 1000L * ((1L << 38) - 1); // Maximum seconds that can be written as a byte and an int [EOL] Time.writeMillis(out, millis); [EOL] verify(out, times(1)).writeByte(anyInt()); [EOL] verify(out, times(1)).writeInt(anyInt()); [EOL] }
public void testWriteMillis_OverflowSecondsBoundary() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] long millis = 1000L * (1L << 38); // Just above the maximum seconds that can be written as a byte and an int [EOL] Time.writeMillis(out, millis); [EOL] verify(out).writeByte(anyInt()); [EOL] verify(out).writeLong(millis); [EOL] }
public void testAddCutoverWithEmptyRuleSets() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder = builder.addCutover(2023, 'w', 3, 10, 2, true, 7200000); [EOL] assertEquals(1, builder.getRuleSets().size()); [EOL] }
public void testAddCutoverWithExistingRuleSets() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.addCutover(2020, 'u', 1, 1, 1, false, 0); // Add initial cutover [EOL] int initialSize = builder.getRuleSets().size(); [EOL] builder = builder.addCutover(2023, 'w', 3, 10, 2, true, 7200000); [EOL] assertEquals(initialSize + 1, builder.getRuleSets().size()); [EOL] RuleSet lastRuleSet = builder.getRuleSets().get(initialSize); [EOL] assertNotNull(lastRuleSet.getUpperLimit()); [EOL] }
public void testSetFixedSavings_WithValidNameKeyAndSaveMillis() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] String nameKey = "TestKey"; [EOL] int saveMillis = 3600000; // 1 hour in milliseconds [EOL] DateTimeZoneBuilder result = builder.setFixedSavings(nameKey, saveMillis); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); // Ensure it returns the same instance [EOL] }
public void testSetFixedSavings_WithNullNameKey() { [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] String nameKey = null; [EOL] int saveMillis = 3600000; // 1 hour in milliseconds [EOL] DateTimeZoneBuilder result = builder.setFixedSavings(nameKey, saveMillis); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); // Ensure it returns the same instance [EOL] }
public void testGetLastRuleSet_EmptyRuleSet() { [EOL] initializeEmptyRuleSetList(); [EOL] RuleSet result = getLastRuleSet(); [EOL] assertEquals("Expected a new RuleSet to be added", 1, iRuleSets.size()); [EOL] assertNotNull("Expected non-null RuleSet", result); [EOL] } [EOL] public void testGetLastRuleSet_NonEmptyRuleSet() { [EOL] initializeNonEmptyRuleSetList(); [EOL] RuleSet result = getLastRuleSet(); [EOL] RuleSet expected = iRuleSets.get(iRuleSets.size() - 1); [EOL] assertSame("Expected the last RuleSet to be returned", expected, result); [EOL] }
public void testAddTransitionWithEmptyList() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] boolean result = addTransition(transitions, tr); [EOL] assertTrue("Transition should be added when list is empty", result); [EOL] assertEquals("List should contain one transition", 1, transitions.size()); [EOL] assertTrue("The transition added should be the same as 'tr'", transitions.contains(tr)); [EOL] }
public void testAddTransitionWithNonEmptyListValidTransition() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr1 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] Transition tr2 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] transitions.add(tr1); [EOL] when(tr2.isTransitionFrom(tr1)).thenReturn(true); [EOL] when(tr1.getWallOffset()).thenReturn(0); [EOL] when(tr2.getWallOffset()).thenReturn(0); [EOL] when(tr1.getMillis()).thenReturn(0L); [EOL] when(tr2.getMillis()).thenReturn(1L); // Different millis to ensure they are not the same [EOL] boolean result = addTransition(transitions, tr2); [EOL] assertTrue("Transition should be added when it is valid", result); [EOL] assertEquals("List should contain two transitions", 2, transitions.size()); [EOL] assertTrue("The transition added should be 'tr2'", transitions.contains(tr2)); [EOL] }
public void testAddTransitionWithNonEmptyListInvalidTransition() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr1 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] Transition tr2 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] transitions.add(tr1); [EOL] when(tr2.isTransitionFrom(tr1)).thenReturn(false); [EOL] boolean result = addTransition(transitions, tr2); [EOL] assertFalse("Transition should not be added when it is invalid", result); [EOL] assertEquals("List should still contain one transition", 1, transitions.size()); [EOL] assertFalse("The transition 'tr2' should not be in the list", transitions.contains(tr2)); [EOL] }
public void testAddTransitionWithNonEmptyListSameLocalTime() { [EOL] ArrayList<Transition> transitions = new ArrayList<>(); [EOL] Transition tr1 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] Transition tr2 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] Transition tr3 = new Transition(); // Assuming Transition is a valid class and has a constructor [EOL] transitions.add(tr1); [EOL] transitions.add(tr2); [EOL] when(tr3.isTransitionFrom(tr2)).thenReturn(true); [EOL] when(tr1.getWallOffset()).thenReturn(0); [EOL] when(tr2.getWallOffset()).thenReturn(0); [EOL] when(tr3.getWallOffset()).thenReturn(0); [EOL] when(tr1.getMillis()).thenReturn(0L); [EOL] when(tr2.getMillis()).thenReturn(1L); [EOL] when(tr3.getMillis()).thenReturn(1L); // Same millis as tr2 to trigger removal [EOL] boolean result = addTransition(transitions, tr3); [EOL] assertTrue("Transition should be added when local times are the same", result); [EOL] assertEquals("List should contain two transitions after adding and removing", 2, transitions.size()); [EOL] assertTrue("The transition 'tr3' should replace 'tr2'", transitions.contains(tr3) && !transitions.contains(tr2)); [EOL] }
public void writeTo_withDataOutputInstance() throws IOException { [EOL] String zoneID = "UTC"; [EOL] ByteArrayOutputStream byteStream = new ByteArrayOutputStream(); [EOL] DataOutput dataOutput = new DataOutputStream(byteStream); [EOL] Time time = new Time(); [EOL] time.writeTo(zoneID, dataOutput); [EOL] } [EOL] public void writeTo_withNonDataOutputInstance() throws IOException { [EOL] String zoneID = "UTC"; [EOL] ByteArrayOutputStream byteStream = new ByteArrayOutputStream(); [EOL] OutputStream outputStream = new BufferedOutputStream(byteStream); [EOL] Time time = new Time(); [EOL] time.writeTo(zoneID, outputStream); [EOL] }
public void testWriteToWithFixedDateTimeZone() throws IOException { [EOL] String zoneID = "Fixed/UTC"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput out = new DataOutputStream(baos); [EOL] time.writeTo(zoneID, out); [EOL] byte[] result = baos.toByteArray(); [EOL] assertTrue(result.length > 0); [EOL] assertEquals('F', result[0]); [EOL] }
public void testWriteToWithCachedDateTimeZone() throws IOException { [EOL] String zoneID = "Cached/UTC"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput out = new DataOutputStream(baos); [EOL] time.writeTo(zoneID, out); [EOL] byte[] result = baos.toByteArray(); [EOL] assertTrue(result.length > 0); [EOL] assertEquals('C', result[0]); [EOL] }
public void testWriteToWithPrecalculatedZone() throws IOException { [EOL] String zoneID = "Precalculated/UTC"; [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput out = new DataOutputStream(baos); [EOL] time.writeTo(zoneID, out); [EOL] byte[] result = baos.toByteArray(); [EOL] assertTrue(result.length > 0); [EOL] assertEquals('P', result[0]); [EOL] }
public long setInstantTestWithModeW() { [EOL] int year = 2020; [EOL] int standardOffset = 3600000; // 1 hour in milliseconds [EOL] int saveMillis = 3600000; // 1 hour in milliseconds [EOL] Time time = new Time('w', 1, 0, 1, 0); // Assuming Time is the class name and it has a constructor [EOL] long result = time.setInstant(year, standardOffset, saveMillis); [EOL] long expected = /* expected instant */; [EOL] assertEquals(expected, result); [EOL] }
public long setInstantTestWithModeS() { [EOL] int year = 2020; [EOL] int standardOffset = 3600000; // 1 hour in milliseconds [EOL] int saveMillis = 3600000; // 1 hour in milliseconds [EOL] Time time = new Time('s', 1, 0, 1, 0); // Assuming Time is the class name and it has a constructor [EOL] long result = time.setInstant(year, standardOffset, saveMillis); [EOL] long expected = /* expected instant */; [EOL] assertEquals(expected, result); [EOL] }
public long setInstantTestWithModeOther() { [EOL] int year = 2020; [EOL] int standardOffset = 3600000; // 1 hour in milliseconds [EOL] int saveMillis = 3600000; // 1 hour in milliseconds [EOL] Time time = new Time('x', 1, 0, 1, 0); // 'x' is neither 'w' nor 's' [EOL] long result = time.setInstant(year, standardOffset, saveMillis); [EOL] long expected = /* expected instant */; [EOL] assertEquals(expected, result); [EOL] }
public void testNextWithModeW() { [EOL] Time time = new Time('w', 4, 500); // Example values for iMode, iMonthOfYear, iMillisOfDay [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long result = time.next(instant, standardOffset, saveMillis); [EOL] long expected = 1004500L; // This is a made-up expected value for demonstration [EOL] assertEquals(expected, result); [EOL] }
public void testNextWithModeS() { [EOL] Time time = new Time('s', 4, 500); [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long result = time.next(instant, standardOffset, saveMillis); [EOL] long expected = 1001000L; // This is a made-up expected value for demonstration [EOL] assertEquals(expected, result); [EOL] }
public void testNextWithModeOther() { [EOL] Time time = new Time('x', 4, 500); [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long result = time.next(instant, standardOffset, saveMillis); [EOL] long expected = 1000000L; // This is a made-up expected value for demonstration [EOL] assertEquals(expected, result); [EOL] }
public void testNextWithDayOfWeekZeroAndNextLessThanInstant() { [EOL] Time time = new Time('w', 4, 500, 0); // Assuming iDayOfWeek is also a field [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long result = time.next(instant, standardOffset, saveMillis); [EOL] }
public void testNextWithDayOfWeekNonZeroAndNextLessThanInstant() { [EOL] Time time = new Time('w', 4, 500, 3); // Assuming iDayOfWeek is also a field [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long result = time.next(instant, standardOffset, saveMillis); [EOL] }
public void testPreviousWithModeW() { [EOL] YourClass instance = new YourClass('w', 4, 10, 0); // iMode = 'w', iMonthOfYear = 4, iMillisOfDay = 10, iDayOfWeek = 0 [EOL] long instant = 1000000L; [EOL] int standardOffset = 0; [EOL] int saveMillis = 0; [EOL] long result = instance.previous(instant, standardOffset, saveMillis); [EOL] }
public void testPreviousWithModeS() { [EOL] YourClass instance = new YourClass('s', 4, 10, 0); // iMode = 's', iMonthOfYear = 4, iMillisOfDay = 10, iDayOfWeek = 0 [EOL] long instant = 1000000L; [EOL] int standardOffset = 0; [EOL] int saveMillis = 0; [EOL] long result = instance.previous(instant, standardOffset, saveMillis); [EOL] }
public void testPreviousWithModeOther() { [EOL] YourClass instance = new YourClass('x', 4, 10, 0); // iMode = 'x', iMonthOfYear = 4, iMillisOfDay = 10, iDayOfWeek = 0 [EOL] long instant = 1000000L; [EOL] int standardOffset = 0; [EOL] int saveMillis = 0; [EOL] long result = instance.previous(instant, standardOffset, saveMillis); [EOL] }
public void testPreviousWithDayOfWeekZero() { [EOL] YourClass instance = new YourClass('w', 4, 10, 0); // iMode = 'w', iMonthOfYear = 4, iMillisOfDay = 10, iDayOfWeek = 0 [EOL] long instant = 1000000L; [EOL] int standardOffset = 0; [EOL] int saveMillis = 0; [EOL] long result = instance.previous(instant, standardOffset, saveMillis); [EOL] }
public void testPreviousWithDayOfWeekNonZero() { [EOL] YourClass instance = new YourClass('w', 4, 10, 1); // iMode = 'w', iMonthOfYear = 4, iMillisOfDay = 10, iDayOfWeek = 1 [EOL] long instant = 1000000L; [EOL] int standardOffset = 0; [EOL] int saveMillis = 0; [EOL] long result = instance.previous(instant, standardOffset, saveMillis); [EOL] }
public void testWriteTo() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] DayOfWeekDateTimeField instance = new DayOfWeekDateTimeField(); [EOL] instance.writeTo(out); [EOL] verify(out).writeByte(anyInt()); // Assuming iMode, iMonthOfYear, iDayOfMonth, iDayOfWeek are integers [EOL] verify(out).writeBoolean(anyBoolean()); // Assuming iAdvance is a boolean [EOL] verify(out, times(5)).writeByte(anyInt()); // 4 writeByte calls for integers and 1 call for boolean [EOL] verify(out).writeLong(anyLong()); // Assuming writeMillis writes a long [EOL] }
public void testWriteTo_Coverage() throws IOException { [EOL] DataOutput outMock = mock(DataOutput.class); [EOL] DateTimeZoneStub zone = new DateTimeZoneStub("testZone", 12345); [EOL] zone.writeTo(outMock); [EOL] verify(outMock).writeInt(anyInt()); [EOL] verify(outMock).writeUTF(eq("testZone")); [EOL] verify(outMock, times(1)).writeLong(eq(12345L)); [EOL] }
public long next(final long instant, int standardOffset, int saveMillis) { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] final int wallOffset = standardOffset + saveMillis; [EOL] long testInstant = instant; [EOL] int year; [EOL] if (instant == Long.MIN_VALUE) { [EOL] year = Integer.MIN_VALUE; [EOL] } else { [EOL] year = chrono.year().get(instant + wallOffset); [EOL] } [EOL] if (year < iFromYear) { [EOL] testInstant = chrono.year().set(0, iFromYear) - wallOffset; [EOL] testInstant -= 1; [EOL] } [EOL] long next = iRecurrence.next(testInstant, standardOffset, saveMillis); [EOL] if (next > instant) { [EOL] year = chrono.year().get(next + wallOffset); [EOL] if (year > iToYear) { [EOL] next = instant; [EOL] } [EOL] } [EOL] return next; [EOL] }
public void testTransitionWithValidTransition() { [EOL] long testMillis = 1000L; [EOL] Transition testTransition = new Transition(500L, "testKey", 3600, 1800); [EOL] Transition newTransition = new Transition(testMillis, testTransition); [EOL] assertEquals(testMillis, newTransition.iMillis); [EOL] assertEquals("testKey", newTransition.iNameKey); [EOL] assertEquals(3600, newTransition.iWallOffset); [EOL] assertEquals(1800, newTransition.iStandardOffset); [EOL] }
public void testTransitionWithValidInput() { [EOL] long millis = 1000L; [EOL] String nameKey = "UTC"; [EOL] int wallOffset = 3600; [EOL] int standardOffset = 3600; [EOL] Transition transition = new Transition(millis, nameKey, wallOffset, standardOffset); [EOL] assertEquals(millis, transition.iMillis); [EOL] assertEquals(nameKey, transition.iNameKey); [EOL] assertEquals(wallOffset, transition.iWallOffset); [EOL] assertEquals(standardOffset, transition.iStandardOffset); [EOL] }
public void testSetFixedSavings_ValidInput() { [EOL] Time time = new Time(); [EOL] time.setFixedSavings("UTC", 3600000); [EOL] assertEquals("UTC", time.getInitialNameKey()); [EOL] assertEquals(3600000, time.getInitialSaveMillis()); [EOL] }
public void testSetUpperLimit() { [EOL] Time time = new Time(); [EOL] int year = 2021; [EOL] OfYear ofYear = new OfYear(); // Assuming OfYear is a valid class that can be instantiated [EOL] time.setUpperLimit(year, ofYear); [EOL] assertEquals(year, time.getUpperYear()); // Assuming getUpperYear() is a method to get iUpperYear [EOL] assertEquals(ofYear, time.getUpperOfYear()); // Assuming getUpperOfYear() is a method to get iUpperOfYear [EOL] }
public void testFirstTransitionWithInitialNameKey() { [EOL] TimeEnvironment env = new TimeEnvironment("initialNameKey", 0, 0); [EOL] long firstMillis = 12345L; [EOL] Transition result = env.firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] assertEquals("initialNameKey", result.getNameKey()); [EOL] assertEquals(firstMillis, result.getMillis()); [EOL] assertEquals(env.getStandardOffset(), result.getStandardOffset()); [EOL] }
public void testFirstTransitionWithMatchingMillis() { [EOL] TimeEnvironment env = new TimeEnvironment(null, 0, 0); [EOL] env.addRule(new Rule(...)); // Add rules such that nextTransition returns a transition with matching millis [EOL] long firstMillis = 12345L; [EOL] Transition result = env.firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] assertEquals(firstMillis, result.getMillis()); [EOL] }
public void testFirstTransitionWithMillisGreaterThanFirstMillis() { [EOL] TimeEnvironment env = new TimeEnvironment(null, 0, 0); [EOL] env.addRule(new Rule(...)); // Add rules such that nextTransition returns a transition with millis greater than firstMillis [EOL] long firstMillis = 12345L; [EOL] Transition result = env.firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] assertTrue(result.getMillis() > firstMillis); [EOL] }
public void testFirstTransitionWithNoMatchingRules() { [EOL] TimeEnvironment env = new TimeEnvironment(null, 0, 0); [EOL] env.addRule(new Rule(...)); // Add rules such that no rule has saveMillis == 0 [EOL] long firstMillis = 12345L; [EOL] Transition result = env.firstTransition(firstMillis); [EOL] assertNotNull(result); [EOL] assertEquals(env.getStandardOffset(), result.getStandardOffset()); [EOL] }
public void testFirstTransitionWithNullNextTransition() { [EOL] TimeEnvironment env = new TimeEnvironment(null, 0, 0); [EOL] long firstMillis = 12345L; [EOL] Transition result = env.firstTransition(firstMillis); [EOL] assertNull(result); [EOL] }
public void testNextTransition_NoRules() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] } [EOL] public void testNextTransition_RuleBeforeInstant() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] } [EOL] public void testNextTransition_RuleAfterInstant() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNotNull(result); [EOL] } [EOL] public void testNextTransition_MultipleRules() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNotNull(result); [EOL] } [EOL] public void testNextTransition_YearLimitExceeded() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] } [EOL] public void testNextTransition_UpperYearLimit() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNotNull(result); [EOL] } [EOL] public void testNextTransition_AboveUpperYearLimit() { [EOL] Transition result = timeObject.nextTransition(instant, saveMillis); [EOL] assertNull(result); [EOL] }
public void testGetUpperLimit_MaxYear() { [EOL] this.iUpperYear = Integer.MAX_VALUE; [EOL] long result = getUpperLimit(0); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetUpperLimit_StandardOffset() { [EOL] this.iUpperYear = 2023; // Example year that is not Integer.MAX_VALUE [EOL] this.iStandardOffset = 0; // Example standard offset [EOL] this.iUpperOfYear = new UpperOfYear(); // Replace with actual instantiation [EOL] long expected = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, 0); [EOL] long result = getUpperLimit(0); [EOL] assertEquals(expected, result); [EOL] }
public void testGetUpperLimit_WithSaveMillis() { [EOL] this.iUpperYear = 2023; // Example year that is not Integer.MAX_VALUE [EOL] this.iStandardOffset = 0; // Example standard offset [EOL] this.iUpperOfYear = new UpperOfYear(); // Replace with actual instantiation [EOL] int saveMillis = 3600000; // Example saveMillis (1 hour in milliseconds) [EOL] long expected = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] long result = getUpperLimit(saveMillis); [EOL] assertEquals(expected, result); [EOL] }
public void testBuildTailZoneWithTwoRulesBothInfinite() { [EOL] DSTZone zone = new DSTZone(); [EOL] Rule startRule = new Rule(); [EOL] startRule.setToYear(Integer.MAX_VALUE); [EOL] Rule endRule = new Rule(); [EOL] endRule.setToYear(Integer.MAX_VALUE); [EOL] zone.iRules.add(startRule); [EOL] zone.iRules.add(endRule); [EOL] DSTZone result = zone.buildTailZone("testID"); [EOL] assertNotNull(result); [EOL] assertEquals("testID", result.id); [EOL] assertEquals(zone.iStandardOffset, result.iStandardOffset); [EOL] assertEquals(startRule.iRecurrence, result.startRecurrence); [EOL] assertEquals(endRule.iRecurrence, result.endRecurrence); [EOL] }
public void testBuildTailZoneWithLessThanTwoRules() { [EOL] DSTZone zone = new DSTZone(); [EOL] Rule rule = new Rule(); [EOL] zone.iRules.add(rule); [EOL] DSTZone result = zone.buildTailZone("testID"); [EOL] assertNull(result); [EOL] }
public void testBuildTailZoneWithTwoRulesNotBothInfinite() { [EOL] DSTZone zone = new DSTZone(); [EOL] Rule startRule = new Rule(); [EOL] startRule.setToYear(Integer.MAX_VALUE); [EOL] Rule endRule = new Rule(); [EOL] endRule.setToYear(2023); // Not Integer.MAX_VALUE [EOL] zone.iRules.add(startRule); [EOL] zone.iRules.add(endRule); [EOL] DSTZone result = zone.buildTailZone("testID"); [EOL] assertNull(result); [EOL] }
public int getStandardOffsetTest() { [EOL] DateTimeZone zone = DateTimeZone.forOffsetHours(3); [EOL] long instant = System.currentTimeMillis(); [EOL] int expected = zone.getStandardOffset(instant); [EOL] int actual = zone.getStandardOffset(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testWriteTo_Coverage() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL] builder.setStandardOffset(123456); [EOL] builder.addCutover(789, 'w', 10, 20, 30, true, 456789); [EOL] builder.addRecurringSavings("test", 0, 1000, 2000, 's', 10, 20, 30, true, 456789); [EOL] DateTimeZone dtz = builder.toDateTimeZone("test", true); [EOL] dtz.writeTo(out); [EOL] verify(out).writeInt(123456); [EOL] verify(out).writeByte('w'); [EOL] verify(out).writeInt(789); [EOL] verify(out).writeByte(10); [EOL] verify(out).writeByte(20); [EOL] verify(out).writeByte(30); [EOL] verify(out).writeBoolean(true); [EOL] verify(out).writeInt(456789); [EOL] verify(out).writeByte('s'); [EOL] verify(out).writeInt(1000); [EOL] verify(out).writeInt(2000); [EOL] verify(out).writeByte(10); [EOL] verify(out).writeByte(20); [EOL] verify(out).writeByte(30); [EOL] verify(out).writeBoolean(true); [EOL] verify(out).writeInt(456789); [EOL] }
public void testGetNameKey_ExactMatch() { [EOL] long instant = 1000L; [EOL] long[] transitions = new long[] {500L, 1000L, 1500L}; [EOL] String[] nameKeys = new String[] {"Early", "OnPoint", "Later"}; [EOL] TimeZone tz = new TimeZone(transitions, nameKeys, null); [EOL] String result = tz.getNameKey(instant); [EOL] assertEquals("OnPoint", result); [EOL] }
public void testGetNameKey_BeforeFirstTransition() { [EOL] long instant = 250L; [EOL] long[] transitions = new long[] {500L, 1000L, 1500L}; [EOL] String[] nameKeys = new String[] {"Early", "OnPoint", "Later"}; [EOL] TimeZone tz = new TimeZone(transitions, nameKeys, null); [EOL] String result = tz.getNameKey(instant); [EOL] assertEquals("UTC", result); [EOL] }
public void testGetNameKey_BetweenTransitions() { [EOL] long instant = 750L; [EOL] long[] transitions = new long[] {500L, 1000L, 1500L}; [EOL] String[] nameKeys = new String[] {"Early", "OnPoint", "Later"}; [EOL] TimeZone tz = new TimeZone(transitions, nameKeys, null); [EOL] String result = tz.getNameKey(instant); [EOL] assertEquals("Early", result); [EOL] }
public void testGetNameKey_AfterLastTransition() { [EOL] long instant = 2000L; [EOL] long[] transitions = new long[] {500L, 1000L, 1500L}; [EOL] String[] nameKeys = new String[] {"Early", "OnPoint", "Later"}; [EOL] TailZone tailZone = new TailZone("Final"); [EOL] TimeZone tz = new TimeZone(transitions, nameKeys, tailZone); [EOL] String result = tz.getNameKey(instant); [EOL] assertEquals("Final", result); [EOL] }
public void testGetStandardOffset_ExactMatch() { [EOL] long instant = 1000L; // This should be a value that is an exact match in iTransitions [EOL] int expectedOffset = 10; // This should be the corresponding offset in iStandardOffsets [EOL] int actualOffset = getStandardOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testGetStandardOffset_BeforeFirstTransition() { [EOL] long instant = -1000L; // This should be a value before the first transition in iTransitions [EOL] int expectedOffset = 0; // The expected offset before the first transition is 0 [EOL] int actualOffset = getStandardOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testGetStandardOffset_BetweenTransitions() { [EOL] long instant = 1500L; // This should be a value between two transitions in iTransitions [EOL] int expectedOffset = 20; // This should be the corresponding offset for the period before the instant [EOL] int actualOffset = getStandardOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testGetStandardOffset_AfterLastTransition() { [EOL] long instant = 10000L; // This should be a value after the last transition in iTransitions [EOL] int expectedOffset = 30; // This should be the corresponding offset in iTailZone or iStandardOffsets [EOL] int actualOffset = getStandardOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testGetStandardOffset_WithTailZone() { [EOL] long instant = 20000L; // This should be a value after the last transition and iTailZone is not null [EOL] int expectedOffset = 40; // This should be the corresponding offset returned by iTailZone.getStandardOffset [EOL] int actualOffset = getStandardOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testWriteToWithSmallPool() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] initializeTransitionsAndNameKeys(new String[]{"UTC", "GMT"}, 2); [EOL] initializeTailZone(false); [EOL] instance.writeTo(out); [EOL] verify(out).writeShort(2); // poolSize [EOL] verify(out, times(2)).writeUTF(anyString()); // pool elements [EOL] verify(out).writeInt(2); // size [EOL] verify(out, times(6)).writeMillis(out, anyLong()); // transitions and offsets [EOL] verify(out, times(2)).writeByte(anyInt()); // nameKey indices [EOL] verify(out).writeBoolean(false); // iTailZone existence [EOL] verifyNoMoreInteractions(out); [EOL] }
public void testWriteToWithLargePool() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] initializeTransitionsAndNameKeys(generateLargePoolSet(70000), 70000); [EOL] initializeTailZone(false); [EOL] instance.writeTo(out); [EOL] verify(out).writeShort(70000); // poolSize [EOL] verify(out, times(70000)).writeUTF(anyString()); // pool elements [EOL] verify(out).writeInt(70000); // size [EOL] verify(out, times(210000)).writeMillis(out, anyLong()); // transitions and offsets [EOL] verify(out, times(70000)).writeShort(anyInt()); // nameKey indices [EOL] verify(out).writeBoolean(false); // iTailZone existence [EOL] verifyNoMoreInteractions(out); [EOL] }
public void testWriteToWithTailZone() throws IOException { [EOL] DataOutput out = mock(DataOutput.class); [EOL] initializeTransitionsAndNameKeys(new String[]{"UTC", "GMT"}, 2); [EOL] initializeTailZone(true); [EOL] instance.writeTo(out); [EOL] verify(out).writeBoolean(true); // iTailZone existence [EOL] verify(tailZone).writeTo(out); // iTailZone writing [EOL] }
public void testWriteToWithUnsupportedOperationException() { [EOL] DataOutput out = mock(DataOutput.class); [EOL] initializeTransitionsAndNameKeys(generateLargePoolSet(65536), 65536); [EOL] initializeTailZone(false); [EOL] assertThrows(UnsupportedOperationException.class, () -> instance.writeTo(out)); [EOL] }
public void testGetUncachedZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone uncachedZone = originalZone.getUncachedZone(); [EOL] assertNotNull(uncachedZone); [EOL] assertNotSame(originalZone, uncachedZone); [EOL] }
public void testGetOffset() { [EOL] Time time = new Time(); [EOL] long instant = 0L; // Example instant, typically the epoch (1970-01-01T00:00:00Z) [EOL] int expectedOffset = 0; // Example offset, could be any integer representing the offset in seconds or milliseconds [EOL] int actualOffset = time.getOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public int getStandardOffset(long instant) { [EOL] return getInfo(instant).getStandardOffset(instant); [EOL] }
public void testHashCode() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] int hashCode = zone.hashCode(); [EOL] assertNotNull(hashCode); [EOL] }
public void testGetInfo_CacheHit() { [EOL] long millis = 0x0000000100000000L; // period is 1, index is 0 [EOL] Info expectedInfo = new Info(); [EOL] iInfoCache[0] = expectedInfo; // Pre-populate cache [EOL] Info result = getInfo(millis); [EOL] assertEquals(expectedInfo, result); [EOL] }
public void testGetInfo_CacheMiss() { [EOL] long millis = 0x0000000100000000L; // period is 1, index is 0 [EOL] iInfoCache[0] = null; // Ensure cache miss [EOL] Info result = getInfo(millis); [EOL] assertNotNull(result); [EOL] assertEquals(1, (int) (result.iPeriodStart >> 32)); [EOL] }
public void testGetInfo_CacheMissAndPeriodMismatch() { [EOL] long millis = 0x0000000100000000L; // period is 1, index is 0 [EOL] Info mismatchedInfo = new Info(); [EOL] mismatchedInfo.iPeriodStart = 0x0000000200000000L; // period is 2 [EOL] iInfoCache[0] = mismatchedInfo; // Ensure period mismatch [EOL] Info result = getInfo(millis); [EOL] assertNotNull(result); [EOL] assertNotSame(mismatchedInfo, result); [EOL] assertEquals(1, (int) (result.iPeriodStart >> 32)); [EOL] }
public void testGetNameKey_BeforeNextInfoPeriod() { [EOL] long millisBeforeNextInfo = ...; // millis value before iNextInfo.iPeriodStart [EOL] String expectedNameKey = ...; // expected name key for the period [EOL] String actualNameKey = instance.getNameKey(millisBeforeNextInfo); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public void testGetNameKey_DuringNextInfoPeriod() { [EOL] long millisDuringNextInfo = ...; // millis value during iNextInfo.iPeriodStart [EOL] String expectedNameKey = ...; // expected name key for the period from iNextInfo [EOL] String actualNameKey = instance.getNameKey(millisDuringNextInfo); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public void testGetNameKey_WithNullNameKey() { [EOL] long millisBeforeNextInfo = ...; // millis value before iNextInfo.iPeriodStart [EOL] instance.iNameKey = null; // iNameKey is initially null [EOL] String expectedNameKey = ...; // expected name key after calling iZoneRef.getNameKey [EOL] String actualNameKey = instance.getNameKey(millisBeforeNextInfo); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public int getOffset(long millis) { [EOL] if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL] if (iOffset == Integer.MIN_VALUE) { [EOL] iOffset = iZoneRef.getOffset(iPeriodStart); [EOL] } [EOL] return iOffset; [EOL] } [EOL] return iNextInfo.getOffset(millis); [EOL] }
public int getStandardOffsetTest_withMillisBeforeNextInfoPeriod() { [EOL] long millis = SOME_VALUE_BEFORE_NEXT_INFO_PERIOD; [EOL] int expectedStandardOffset = SOME_EXPECTED_STANDARD_OFFSET; [EOL] int actualStandardOffset = getStandardOffset(millis); [EOL] assertEquals(expectedStandardOffset, actualStandardOffset); [EOL] }
public int getStandardOffsetTest_withMillisAfterNextInfoPeriod() { [EOL] long millis = SOME_VALUE_AFTER_NEXT_INFO_PERIOD; [EOL] int expectedStandardOffset = SOME_EXPECTED_STANDARD_OFFSET; [EOL] int actualStandardOffset = getStandardOffset(millis); [EOL] assertEquals(expectedStandardOffset, actualStandardOffset); [EOL] }
public int getStandardOffsetTest_withNextInfoNull() { [EOL] long millis = SOME_VALUE; [EOL] int expectedStandardOffset = SOME_EXPECTED_STANDARD_OFFSET; [EOL] int actualStandardOffset = getStandardOffset(millis); [EOL] assertEquals(expectedStandardOffset, actualStandardOffset); [EOL] }
public int getStandardOffsetTest_withStandardOffsetMinValue() { [EOL] long millis = SOME_VALUE_BEFORE_NEXT_INFO_PERIOD; [EOL] int expectedStandardOffset = SOME_EXPECTED_STANDARD_OFFSET_FROM_ZONE_REF; [EOL] int actualStandardOffset = getStandardOffset(millis); [EOL] assertEquals(expectedStandardOffset, actualStandardOffset); [EOL] }
public void testScaledDurationFieldConstructor_InvalidScalarZero() { [EOL] try { [EOL] DurationField mockField = new MockDurationField(); [EOL] DurationFieldType mockType = DurationFieldType.seconds(); [EOL] int invalidScalar = 0; [EOL] new ScaledDurationField(mockField, mockType, invalidScalar); [EOL] fail("Should have thrown IllegalArgumentException for scalar 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testScaledDurationFieldConstructor_InvalidScalarOne() { [EOL] try { [EOL] DurationField mockField = new MockDurationField(); [EOL] DurationFieldType mockType = DurationFieldType.seconds(); [EOL] int invalidScalar = 1; [EOL] new ScaledDurationField(mockField, mockType, invalidScalar); [EOL] fail("Should have thrown IllegalArgumentException for scalar 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testScaledDurationFieldConstructor_ValidScalar() { [EOL] DurationField mockField = new MockDurationField(); [EOL] DurationFieldType mockType = DurationFieldType.seconds(); [EOL] int validScalar = 2; [EOL] ScaledDurationField field = new ScaledDurationField(mockField, mockType, validScalar); [EOL] assertNotNull("ScaledDurationField should be created with valid scalar", field); [EOL] }
public long getValueAsLong(long duration) { [EOL] return getWrappedField().getValueAsLong(duration) / iScalar; [EOL] }
public void testAdd_withPositiveValue() { [EOL] long instant = 1L; [EOL] int value = 2; [EOL] long expected = getWrappedField().add(instant, (long) value * iScalar); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withNegativeValue() { [EOL] long instant = 1L; [EOL] int value = -2; [EOL] long expected = getWrappedField().add(instant, (long) value * iScalar); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withZeroValue() { [EOL] long instant = 1L; [EOL] int value = 0; [EOL] long expected = getWrappedField().add(instant, (long) value * iScalar); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withMaxIntValue() { [EOL] long instant = 1L; [EOL] int value = Integer.MAX_VALUE; [EOL] long expected = getWrappedField().add(instant, (long) value * iScalar); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withMinIntValue() { [EOL] long instant = 1L; [EOL] int value = Integer.MIN_VALUE; [EOL] long expected = getWrappedField().add(instant, (long) value * iScalar); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetInstanceUTC() { [EOL] ISOChronology instance = ISOChronology.getInstanceUTC(); [EOL] assertNotNull(instance); [EOL] assertSame(ISOChronology.INSTANCE_UTC, instance); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] ISOChronology result = ISOChronology.getInstance(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone nonDefaultZone = DateTimeZone.forID("Europe/Paris"); [EOL] ISOChronology result = ISOChronology.getInstance(nonDefaultZone); [EOL] assertNotNull(result); [EOL] assertEquals(nonDefaultZone, result.getZone()); [EOL] }
public void testGetInstanceWithSameZoneReturnsSameChronology() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] ISOChronology firstCall = ISOChronology.getInstance(zone); [EOL] ISOChronology secondCall = ISOChronology.getInstance(zone); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testEquals_SameObject() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] }
public void testEquals_DifferentObjectSameZone() { [EOL] ISOChronology chrono1 = ISOChronology.getInstance(DateTimeZone.UTC); [EOL] ISOChronology chrono2 = ISOChronology.getInstance(DateTimeZone.UTC); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentObjectDifferentZone() { [EOL] ISOChronology chrono1 = ISOChronology.getInstance(DateTimeZone.UTC); [EOL] ISOChronology chrono2 = ISOChronology.getInstance(DateTimeZone.forOffsetHours(1)); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_Null() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_NonChronologyObject() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] assertFalse(chrono.equals(new Object())); [EOL] }
public void testWriteReplace() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] Object result = instance.writeReplace(); [EOL] assertTrue(result instanceof Stub); [EOL] assertEquals(instance.getZone(), ((Stub) result).getZone()); [EOL] }
public void testStubWithNullZone() { [EOL] DateTimeZone zone = null; [EOL] Stub result = new Stub(zone); [EOL] assertNull(result.iZone); [EOL] }
public void testStubWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Stub result = new Stub(zone); [EOL] assertSame(DateTimeZone.UTC, result.iZone); [EOL] }
public void testReadResolve() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] ISOChronology originalChronology = ISOChronology.getInstance(originalZone); [EOL] ISOChronology deserializedChronology = (ISOChronology) originalChronology.readResolve(); [EOL] assertEquals(originalZone, deserializedChronology.getZone()); [EOL] }
private void writeObject(ObjectOutputStream out) throws IOException { [EOL] out.writeObject(iZone); [EOL] }
public void testReadObject() throws IOException, ClassNotFoundException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream out = new ObjectOutputStream(baos); [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] out.writeObject(originalZone); [EOL] out.close(); [EOL] ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] readObject(in); // Assuming this is an instance method of the class that contains readObject [EOL] assertEquals(originalZone, iZone); [EOL] }
public void testBaseDurationFieldWithNonNullType() { [EOL] DurationFieldType type = DurationFieldType.seconds(); [EOL] BaseDurationField field = new BaseDurationField(type); [EOL] assertNotNull(field); [EOL] assertEquals(type, field.getType()); [EOL] }
public void testBaseDurationFieldWithNullType() { [EOL] try { [EOL] new BaseDurationField(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The type must not be null", e.getMessage()); [EOL] } [EOL] }
public String testToString() { [EOL] DurationField field = new DurationField("seconds"); [EOL] String result = field.toString(); [EOL] assert result.equals("DurationField[seconds]"); [EOL] }
public void testGetInstanceWithNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = null; [EOL] int minDaysInFirstWeek = 4; [EOL] CopticChronology chrono = CopticChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(chrono.getMinimumDaysInFirstWeek(), minDaysInFirstWeek); [EOL] }
public void testGetInstanceWithNonNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] int minDaysInFirstWeek = 4; [EOL] CopticChronology chrono = CopticChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(chrono.getMinimumDaysInFirstWeek(), minDaysInFirstWeek); [EOL] }
public void testGetInstanceWithUTCZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] int minDaysInFirstWeek = 4; [EOL] CopticChronology chrono = CopticChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(chrono.getMinimumDaysInFirstWeek(), minDaysInFirstWeek); [EOL] }
public void testGetInstanceWithInvalidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] int minDaysInFirstWeek = 0; [EOL] try { [EOL] CopticChronology.getInstance(zone, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCopticChronologyConstructor() { [EOL] Chronology base = null; // Assuming Chronology is an abstract class or interface [EOL] Object param = new Object(); [EOL] int minDaysInFirstWeek = 4; [EOL] CopticChronology copticChronology = new CopticChronology(base, param, minDaysInFirstWeek); [EOL] assertNotNull(copticChronology); [EOL] }
public void testWithUTC() { [EOL] Chronology chronology = new SpecificChronology(); // Assuming SpecificChronology is a concrete implementation [EOL] Chronology utcChronology = chronology.withUTC(); [EOL] assertSame("Expected the UTC chronology instance", SpecificChronology.INSTANCE_UTC, utcChronology); [EOL] }
public void testAssembleWithNullBase() { [EOL] Fields fields = new Fields(); [EOL] MyDateTime myDateTime = new MyDateTime(null); [EOL] myDateTime.assemble(fields); [EOL] assertNotNull(fields.year); [EOL] assertNotNull(fields.weekyear); [EOL] assertNotNull(fields.era); [EOL] assertNotNull(fields.monthOfYear); [EOL] assertNotNull(fields.months); [EOL] } [EOL] public void testAssembleWithNonNullBase() { [EOL] Fields fields = new Fields(); [EOL] BaseDateTime baseDateTime = new BaseDateTime(); [EOL] MyDateTime myDateTime = new MyDateTime(baseDateTime); [EOL] myDateTime.assemble(fields); [EOL] assertNull(fields.year); [EOL] assertNull(fields.weekyear); [EOL] assertNull(fields.era); [EOL] assertNull(fields.monthOfYear); [EOL] assertNull(fields.months); [EOL] }
public void testDateConverterConstructor() { [EOL] new DateConverter(); [EOL] }
public void testMonthsBetweenWithLocalDates() { [EOL] LocalDate start = new LocalDate(2020, 1, 1); [EOL] LocalDate end = new LocalDate(2020, 4, 1); [EOL] Months result = time.monthsBetween(start, end); [EOL] assertEquals(3, result.getMonths()); [EOL] } [EOL] public void testMonthsBetweenWithNonLocalDates() { [EOL] ReadablePartial start = new YearMonth(2020, 1); [EOL] ReadablePartial end = new YearMonth(2020, 4); [EOL] Months result = time.monthsBetween(start, end); [EOL] assertEquals(3, result.getMonths()); [EOL] }
public void testGetFieldType_ReturnsMonths() { [EOL] DurationFieldType fieldType = new Duration().getFieldType(); [EOL] assertEquals(DurationFieldType.months(), fieldType); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Months months = Months.months(1); [EOL] Months result = months.multipliedBy(0); [EOL] assertEquals(Months.months(0), result); [EOL] }
public void testMultipliedBy_One() { [EOL] Months months = Months.months(1); [EOL] Months result = months.multipliedBy(1); [EOL] assertEquals(months, result); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Months months = Months.months(1); [EOL] Months result = months.multipliedBy(-1); [EOL] assertEquals(Months.months(-1), result); [EOL] }
public void testMultipliedBy_Positive() { [EOL] Months months = Months.months(2); [EOL] Months result = months.multipliedBy(3); [EOL] assertEquals(Months.months(6), result); [EOL] }
public void testGetInstanceWithNullField() { [EOL] DateTimeField result = Time.getInstance(null, null); [EOL] assertNull(result); [EOL] }
public void testGetInstanceWithStrictDateTimeField() { [EOL] StrictDateTimeField strictField = mock(StrictDateTimeField.class); [EOL] DateTimeField wrappedField = mock(DateTimeField.class); [EOL] when(strictField.getWrappedField()).thenReturn(wrappedField); [EOL] when(wrappedField.isLenient()).thenReturn(false); [EOL] Chronology base = mock(Chronology.class); [EOL] DateTimeField result = Time.getInstance(strictField, base); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof LenientDateTimeField); [EOL] }
public void testGetInstanceWithLenientField() { [EOL] DateTimeField lenientField = mock(DateTimeField.class); [EOL] when(lenientField.isLenient()).thenReturn(true); [EOL] DateTimeField result = Time.getInstance(lenientField, null); [EOL] assertSame(lenientField, result); [EOL] }
public void testGetInstanceWithNonLenientField() { [EOL] DateTimeField nonLenientField = mock(DateTimeField.class); [EOL] when(nonLenientField.isLenient()).thenReturn(false); [EOL] Chronology base = mock(Chronology.class); [EOL] DateTimeField result = Time.getInstance(nonLenientField, base); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof LenientDateTimeField); [EOL] }
public void testLenientDateTimeFieldWithNonNullFieldAndBase() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] LenientDateTimeField lenientDateTimeField = new LenientDateTimeField(mockField, mockChronology); [EOL] assertNotNull(lenientDateTimeField); [EOL] assertSame(mockField, lenientDateTimeField.getField()); [EOL] assertSame(mockChronology, lenientDateTimeField.getChronology()); [EOL] }
public void testLenientDateTimeFieldWithNullField() { [EOL] try { [EOL] new LenientDateTimeField(null, mock(Chronology.class)); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLenientDateTimeFieldWithNullBase() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] LenientDateTimeField lenientDateTimeField = new LenientDateTimeField(mockField, null); [EOL] assertNotNull(lenientDateTimeField); [EOL] assertSame(mockField, lenientDateTimeField.getField()); [EOL] assertNull(lenientDateTimeField.getChronology()); [EOL] }
public void testSet_WithinBounds() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int value = SOME_VALUE; // Replace with a value within the bounds of the field [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after setting the value [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSet_BelowMinimum() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int value = BELOW_MIN_VALUE; // Replace with a value below the minimum of the field [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after setting the value [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSet_AboveMaximum() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int value = ABOVE_MAX_VALUE; // Replace with a value above the maximum of the field [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after setting the value [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithValidString() { [EOL] String validIntervalString = "1:00-2:00"; [EOL] Interval result = Time.parse(validIntervalString); [EOL] assertNotNull(result); [EOL] assertEquals("1:00", result.getStart()); [EOL] assertEquals("2:00", result.getEnd()); [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidIntervalString = "invalid"; [EOL] try { [EOL] Time.parse(invalidIntervalString); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithNull() { [EOL] try { [EOL] Time.parse(null); [EOL] fail("Should have thrown an exception for null input"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testIntervalWithValidChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Interval interval = new Interval(startInstant, endInstant, chronology); [EOL] assertNotNull(interval); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertEquals(chronology, interval.getChronology()); [EOL] }
public void testIntervalWithNullChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Interval interval = new Interval(startInstant, endInstant, null); [EOL] assertNotNull(interval); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertNotNull(interval.getChronology()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), interval.getChronology()); [EOL] }
public void testOverlap_IntervalDoesNotOverlap() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getStartMillis()).thenReturn(10L); [EOL] when(interval.getEndMillis()).thenReturn(20L); [EOL] Interval testInterval = new Interval(30L, 40L); [EOL] Interval result = testInterval.overlap(interval); [EOL] assertNull(result); [EOL] }
public void testOverlap_IntervalOverlaps() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getStartMillis()).thenReturn(10L); [EOL] when(interval.getEndMillis()).thenReturn(20L); [EOL] Interval testInterval = new Interval(15L, 25L); [EOL] Interval result = testInterval.overlap(interval); [EOL] assertNotNull(result); [EOL] assertEquals(15L, result.getStartMillis()); [EOL] assertEquals(20L, result.getEndMillis()); [EOL] }
public void testOverlap_IntervalOverlapsExactly() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getStartMillis()).thenReturn(10L); [EOL] when(interval.getEndMillis()).thenReturn(20L); [EOL] Interval testInterval = new Interval(10L, 20L); [EOL] Interval result = testInterval.overlap(interval); [EOL] assertNotNull(result); [EOL] assertEquals(10L, result.getStartMillis()); [EOL] assertEquals(20L, result.getEndMillis()); [EOL] }
public void testWithChronology_SameChronology() { [EOL] Interval interval = new Interval(0, 10, ISOChronology.getInstance()); [EOL] Interval result = interval.withChronology(ISOChronology.getInstance()); [EOL] assertSame(interval, result); [EOL] }
public void testWithChronology_DifferentChronology() { [EOL] Interval interval = new Interval(0, 10, ISOChronology.getInstance()); [EOL] Interval result = interval.withChronology(GregorianChronology.getInstance()); [EOL] assertNotNull(result); [EOL] assertNotSame(interval, result); [EOL] assertEquals(GregorianChronology.getInstance(), result.getChronology()); [EOL] }
public void testWithEndMillis_SameEndMillis() { [EOL] long startMillis = 1000L; [EOL] long endMillis = 2000L; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withEndMillis(endMillis); [EOL] assertSame(interval, result); [EOL] } [EOL] public void testWithEndMillis_DifferentEndMillis() { [EOL] long startMillis = 1000L; [EOL] long endMillis = 2000L; [EOL] long newEndMillis = 3000L; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withEndMillis(newEndMillis); [EOL] assertNotNull(result); [EOL] assertEquals(newEndMillis, result.getEndMillis()); [EOL] assertEquals(startMillis, result.getStartMillis()); [EOL] }
public void testWithEnd_Null() { [EOL] Interval interval = new Interval(0, 10); [EOL] Interval result = interval.withEnd(null); [EOL] assertNull(result.getEnd()); [EOL] }
public void testWithEnd_ValidInstant() { [EOL] Interval interval = new Interval(0, 10); [EOL] ReadableInstant endInstant = new Instant(20); [EOL] Interval result = interval.withEnd(endInstant); [EOL] assertEquals(20, result.getEndMillis()); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] YearMonth.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithValidDate() { [EOL] Date date = new Date(120, 1, 1); // 2020-02-01 [EOL] YearMonth result = YearMonth.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(2020, result.getYear()); [EOL] assertEquals(2, result.getMonthOfYear()); [EOL] }
public void testWithField_SameValue() { [EOL] YearMonth test = new YearMonth(2009, 6); [EOL] YearMonth result = test.withField(DateTimeFieldType.monthOfYear(), 6); [EOL] assertSame("Expected same instance as no change in value", test, result); [EOL] }
public void testWithField_NewValue() { [EOL] YearMonth test = new YearMonth(2009, 6); [EOL] YearMonth result = test.withField(DateTimeFieldType.monthOfYear(), 7); [EOL] assertEquals("Expected different instance as value changed", 7, result.getMonthOfYear()); [EOL] }
public void testWithField_UnsupportedType() { [EOL] YearMonth test = new YearMonth(2009, 6); [EOL] try { [EOL] test.withField(DateTimeFieldType.hourOfDay(), 1); [EOL] fail("Expected exception as field type is not supported"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public YearMonth minusYears(int years) { [EOL] return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years)); [EOL] } [EOL] public YearMonth() {} [EOL] public YearMonth(DateTimeZone zone) {} [EOL] public YearMonth(Chronology chronology) {} [EOL] public YearMonth(long instant) {} [EOL] public YearMonth(long instant, Chronology chronology) {} [EOL] public YearMonth(Object instant) {} [EOL] public YearMonth(Object instant, Chronology chronology) {} [EOL] public YearMonth(int year, int monthOfYear) {} [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology) {} [EOL] YearMonth(YearMonth partial, int[] values) {} [EOL] YearMonth(YearMonth partial, Chronology chrono) {} [EOL] Property(YearMonth partial, int fieldIndex) {} [EOL] public static YearMonth now() {} [EOL] public static YearMonth now(DateTimeZone zone) {} [EOL] public static YearMonth now(Chronology chronology) {} [EOL] public static YearMonth parse(String str) {} [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter) {} [EOL] public static YearMonth fromCalendarFields(Calendar calendar) {} [EOL] public static YearMonth fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology) {} [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value) {} [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public YearMonth plus(ReadablePeriod period) {} [EOL] public YearMonth plusYears(int years) {} [EOL] public YearMonth plusMonths(int months) {} [EOL] public YearMonth minus(ReadablePeriod period) {} [EOL] public YearMonth minusMonths(int months) {} [EOL] public LocalDate toLocalDate(int dayOfMonth) {} [EOL] public Interval toInterval() {} [EOL] public Interval toInterval(DateTimeZone zone) {} [EOL] public int getYear() {} [EOL] public int getMonthOfYear() {} [EOL] public YearMonth withYear(int year) {} [EOL] public YearMonth withMonthOfYear(int monthOfYear) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property year() {} [EOL] public Property monthOfYear() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public YearMonth getYearMonth() {} [EOL] public int get() {} [EOL] public YearMonth addToCopy(int valueToAdd) {} [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd) {} [EOL] public YearMonth setCopy(int value) {} [EOL] public YearMonth setCopy(String text, Locale locale) {} [EOL] public YearMonth setCopy(String text) {} [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
public String toString() { [EOL] return ISODateTimeFormat.yearMonth().print(this); [EOL] } [EOL] public YearMonth(); [EOL] public YearMonth(DateTimeZone zone); [EOL] public YearMonth(Chronology chronology); [EOL] public YearMonth(long instant); [EOL] public YearMonth(long instant, Chronology chronology); [EOL] public YearMonth(Object instant); [EOL] public YearMonth(Object instant, Chronology chronology); [EOL] public YearMonth(int year, int monthOfYear); [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology); [EOL] YearMonth(YearMonth partial, int[] values); [EOL] YearMonth(YearMonth partial, Chronology chrono); [EOL] Property(YearMonth partial, int fieldIndex); [EOL] public static YearMonth now(); [EOL] public static YearMonth now(DateTimeZone zone); [EOL] public static YearMonth now(Chronology chronology); [EOL] public static YearMonth parse(String str); [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter); [EOL] public static YearMonth fromCalendarFields(Calendar calendar); [EOL] public static YearMonth fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonth plus(ReadablePeriod period); [EOL] public YearMonth plusYears(int years); [EOL] public YearMonth plusMonths(int months); [EOL] public YearMonth minus(ReadablePeriod period); [EOL] public YearMonth minusYears(int years); [EOL] public YearMonth minusMonths(int months); [EOL] public LocalDate toLocalDate(int dayOfMonth); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public YearMonth withYear(int year); [EOL] public YearMonth withMonthOfYear(int monthOfYear); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonth getYearMonth(); [EOL] public int get(); [EOL] public YearMonth addToCopy(int valueToAdd); [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonth setCopy(int value); [EOL] public YearMonth setCopy(String text, Locale locale); [EOL] public YearMonth setCopy(String text); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }];
public void testToStringWithNullPattern() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] String result = yearMonth.toString(null, Locale.getDefault()); [EOL] assertEquals("Default toString should be called", yearMonth.toString(), result); [EOL] }
public void testToStringWithValidPatternAndLocale() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] String pattern = "MM-yyyy"; [EOL] Locale locale = Locale.ENGLISH; [EOL] String result = yearMonth.toString(pattern, locale); [EOL] assertNotNull("Resulting string should not be null", result); [EOL] assertNotEquals("Resulting string should differ from default toString", yearMonth.toString(), result); [EOL] }
public void testAddWrapFieldToCopy_ValueZero() { [EOL] YearMonth test = new YearMonth(2000, 6); [EOL] YearMonth result = test.addWrapFieldToCopy(0); [EOL] assertEquals(new YearMonth(2000, 6), result); [EOL] }
public void testAddWrapFieldToCopy_ValuePositive() { [EOL] YearMonth test = new YearMonth(2000, 6); [EOL] YearMonth result = test.addWrapFieldToCopy(2); [EOL] assertEquals(new YearMonth(2000, 8), result); [EOL] }
public void testAddWrapFieldToCopy_ValueNegative() { [EOL] YearMonth test = new YearMonth(2000, 6); [EOL] YearMonth result = test.addWrapFieldToCopy(-2); [EOL] assertEquals(new YearMonth(2000, 4), result); [EOL] }
public void testAddWrapFieldToCopy_ValueWrap() { [EOL] YearMonth test = new YearMonth(2000, 11); [EOL] YearMonth result = test.addWrapFieldToCopy(2); [EOL] assertEquals(new YearMonth(2000, 1), result); [EOL] }
public void testAddWrapFieldToCopy_ValueNegativeWrap() { [EOL] YearMonth test = new YearMonth(2000, 2); [EOL] YearMonth result = test.addWrapFieldToCopy(-3); [EOL] assertEquals(new YearMonth(2000, 11), result); [EOL] }
public void testGetAsShortTextWithValidInstantAndLocale() { [EOL] MyClass myClass = Mockito.mock(MyClass.class); [EOL] long instant = 123456789L; [EOL] Locale locale = Locale.US; [EOL] int fieldValue = 10; // Assuming get(instant) returns 10 [EOL] String expectedShortText = "ExpectedText"; // Assuming getAsShortText(fieldValue, locale) returns "ExpectedText" [EOL] Mockito.when(myClass.get(instant)).thenReturn(fieldValue); [EOL] Mockito.when(myClass.getAsShortText(fieldValue, locale)).thenReturn(expectedShortText); [EOL] String result = myClass.getAsShortText(instant, locale); [EOL] assertEquals(expectedShortText, result); [EOL] }
public long addTestWithPositiveValue() { [EOL] DurationField mockField = Mockito.mock(DurationField.class); [EOL] long instant = 123456789L; [EOL] int valueToAdd = 10; [EOL] long expected = 123456799L; [EOL] Mockito.when(mockField.add(instant, valueToAdd)).thenReturn(expected); [EOL] Time time = new Time(mockField); [EOL] long result = time.add(instant, valueToAdd); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithNegativeValue() { [EOL] DurationField mockField = Mockito.mock(DurationField.class); [EOL] long instant = 123456789L; [EOL] int valueToAdd = -10; [EOL] long expected = 123456779L; [EOL] Mockito.when(mockField.add(instant, valueToAdd)).thenReturn(expected); [EOL] Time time = new Time(mockField); [EOL] long result = time.add(instant, valueToAdd); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithZeroValue() { [EOL] DurationField mockField = Mockito.mock(DurationField.class); [EOL] long instant = 123456789L; [EOL] int valueToAdd = 0; [EOL] long expected = instant; [EOL] Mockito.when(mockField.add(instant, valueToAdd)).thenReturn(expected); [EOL] Time time = new Time(mockField); [EOL] long result = time.add(instant, valueToAdd); [EOL] assertEquals(expected, result); [EOL] }
public int[] testAddWithValueToAddZero() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] int[] result = add(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(values, result); [EOL] }
public int[] testAddWithPositiveValueNotExceedingMax() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] when(getMaximumValue(mockInstant, values)).thenReturn(4); [EOL] int[] result = add(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(3, result[fieldIndex]); [EOL] }
public int[] testAddWithPositiveValueExceedingMax() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 5; [EOL] when(getMaximumValue(mockInstant, values)).thenReturn(4); [EOL] when(mockInstant.getField(fieldIndex - 1)).thenReturn(createMockField()); [EOL] when(getRangeDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] when(createMockField().getDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] when(createMockField().add(mockInstant, fieldIndex - 1, values, 1)).thenReturn(new int[] {1, 2, 3}); [EOL] when(getMinimumValue(mockInstant, values)).thenReturn(1); [EOL] int[] result = add(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(1, result[fieldIndex]); [EOL] }
public int[] testAddWithNegativeValueNotExceedingMin() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = -1; [EOL] when(getMinimumValue(mockInstant, values)).thenReturn(1); [EOL] int[] result = add(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(1, result[fieldIndex]); [EOL] }
public int[] testAddWithNegativeValueExceedingMin() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = -5; [EOL] when(getMinimumValue(mockInstant, values)).thenReturn(1); [EOL] when(mockInstant.getField(fieldIndex - 1)).thenReturn(createMockField()); [EOL] when(getRangeDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] when(createMockField().getDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] when(createMockField().add(mockInstant, fieldIndex - 1, values, -1)).thenReturn(new int[] {1, 2, 3}); [EOL] when(getMaximumValue(mockInstant, values)).thenReturn(3); [EOL] int[] result = add(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(3, result[fieldIndex]); [EOL] }
public int[] testAddWithFieldIndexZeroAndPositiveValueExceedingMax() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 5; [EOL] when(getMaximumValue(mockInstant, values)).thenReturn(4); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] add(mockInstant, fieldIndex, values, valueToAdd); [EOL] }); [EOL] assertEquals("Maximum value exceeded for add", exception.getMessage()); [EOL] }
public int[] testAddWithFieldIndexZeroAndNegativeValueExceedingMin() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = -5; [EOL] when(getMinimumValue(mockInstant, values)).thenReturn(1); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] add(mockInstant, fieldIndex, values, valueToAdd); [EOL] }); [EOL] assertEquals("Maximum value exceeded for add", exception.getMessage()); [EOL] }
public int[] testAddWithInvalidFieldsForAdd() { [EOL] ReadablePartial mockInstant = createMockInstant(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 5; [EOL] when(getMaximumValue(mockInstant, values)).thenReturn(4); [EOL] when(mockInstant.getField(fieldIndex - 1)).thenReturn(createMockField()); [EOL] when(getRangeDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] when(createMockField().getDurationField().getType()).thenReturn(DurationFieldType.weeks()); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] add(mockInstant, fieldIndex, values, valueToAdd); [EOL] }); [EOL] assertEquals("Fields invalid for add", exception.getMessage()); [EOL] }
public int[] testAddWrapPartial_ValueToAddIsZero() { [EOL] ReadablePartial mockInstant = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] int[] result = addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals("Values should not change when valueToAdd is zero", values, result); [EOL] } [EOL] public int[] testAddWrapPartial_ValueToAddPositiveWithoutWrap() { [EOL] ReadablePartial mockInstant = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 5, 3}; [EOL] int valueToAdd = 2; [EOL] int[] result = addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals("Value at fieldIndex should increase by valueToAdd", 7, result[fieldIndex]); [EOL] } [EOL] public int[] testAddWrapPartial_ValueToAddPositiveWithWrap() { [EOL] ReadablePartial mockInstant = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 9, 3}; [EOL] int valueToAdd = 5; [EOL] int[] result = addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals("Value at fieldIndex should wrap around", getMinimumValue(mockInstant, values), result[fieldIndex]); [EOL] } [EOL] public int[] testAddWrapPartial_ValueToAddNegativeWithoutWrap() { [EOL] ReadablePartial mockInstant = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 5, 3}; [EOL] int valueToAdd = -2; [EOL] int[] result = addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals("Value at fieldIndex should decrease by valueToAdd", 3, result[fieldIndex]); [EOL] } [EOL] public int[] testAddWrapPartial_ValueToAddNegativeWithWrap() { [EOL] ReadablePartial mockInstant = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 1, 3}; [EOL] int valueToAdd = -5; [EOL] int[] result = addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals("Value at fieldIndex should wrap around", getMaximumValue(mockInstant, values), result[fieldIndex]); [EOL] } [EOL] public int[] testAddWrapPartial_InvalidFieldForAdd() { [EOL] ReadablePartial mockInstant = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 1, 3}; [EOL] int valueToAdd = 10; [EOL] try { [EOL] addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] fail("Should throw IllegalArgumentException when fields are invalid for add"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] private ReadablePartial createMockPartial() { [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] when(mockInstant.getField(anyInt())).thenReturn(mock(DateTimeField.class)); [EOL] when(mockInstant.getField(anyInt()).getDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] when(getRangeDurationField().getType()).thenReturn(DurationFieldType.days()); [EOL] return mockInstant; [EOL] } [EOL] private int getMaximumValue(ReadablePartial instant, int[] values) { [EOL] return 10; [EOL] } [EOL] private int getMinimumValue(ReadablePartial instant, int[] values) { [EOL] return 1; [EOL] } [EOL] private DurationField getRangeDurationField() { [EOL] return mock(DurationField.class); [EOL] } [EOL] private int[] set(ReadablePartial instant, int fieldIndex, int[] values, int value) { [EOL] values[fieldIndex] = value; [EOL] return values; [EOL] }
public void testGetLeapDurationField_ReturnsNull() { [EOL] Time time = new Time(); [EOL] assertNull("Leap duration field should be null", time.getLeapDurationField()); [EOL] }
public void testGetMaximumTextLengthMaxNegative() { [EOL] Locale locale = new Locale("en", "US"); // Assuming the locale is necessary for the method [EOL] Time time = new Time() { [EOL] @Override [EOL] public int getMaximumValue() { [EOL] return -1; [EOL] } [EOL] }; [EOL] int result = time.getMaximumTextLength(locale); [EOL] assertEquals(2, result); // Assuming "-1" is the expected string representation [EOL] }
public void testGetMaximumTextLengthMaxSingleDigit() { [EOL] Locale locale = new Locale("en", "US"); [EOL] Time time = new Time() { [EOL] @Override [EOL] public int getMaximumValue() { [EOL] return 5; [EOL] } [EOL] }; [EOL] int result = time.getMaximumTextLength(locale); [EOL] assertEquals(1, result); [EOL] }
public void testGetMaximumTextLengthMaxTwoDigits() { [EOL] Locale locale = new Locale("en", "US"); [EOL] Time time = new Time() { [EOL] @Override [EOL] public int getMaximumValue() { [EOL] return 50; [EOL] } [EOL] }; [EOL] int result = time.getMaximumTextLength(locale); [EOL] assertEquals(2, result); [EOL] }
public void testGetMaximumTextLengthMaxThreeDigits() { [EOL] Locale locale = new Locale("en", "US"); [EOL] Time time = new Time() { [EOL] @Override [EOL] public int getMaximumValue() { [EOL] return 500; [EOL] } [EOL] }; [EOL] int result = time.getMaximumTextLength(locale); [EOL] assertEquals(3, result); [EOL] }
public void testGetMaximumTextLengthMaxMoreThanThreeDigits() { [EOL] Locale locale = new Locale("en", "US"); [EOL] Time time = new Time() { [EOL] @Override [EOL] public int getMaximumValue() { [EOL] return 5000; [EOL] } [EOL] }; [EOL] int result = time.getMaximumTextLength(locale); [EOL] assertEquals(4, result); [EOL] }
public void testRoundCeiling_SameAsFloor() { [EOL] long instant = SOME_INSTANT_THAT_ROUNDS_TO_ITSELF; [EOL] long expected = instant; [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundCeiling_OneMoreThanFloor() { [EOL] long instant = SOME_INSTANT_THAT_DOES_NOT_ROUND_TO_ITSELF; [EOL] long expected = SOME_INSTANT_THAT_IS_ONE_MORE_THAN_THE_FLOOR; [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfFloor_ExactFloor() { [EOL] long instant = /* provide a value where instant is exactly at floor */; [EOL] long expected = /* expected floor value */; [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testRoundHalfFloor_CloserToFloor() { [EOL] long instant = /* provide a value where instant is closer to floor than ceiling */; [EOL] long expected = /* expected floor value */; [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfFloor_ExactCeiling() { [EOL] long instant = /* provide a value where instant is exactly at ceiling */; [EOL] long expected = /* expected ceiling value */; [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testRoundHalfFloor_CloserToCeiling() { [EOL] long instant = /* provide a value where instant is closer to ceiling than floor */; [EOL] long expected = /* expected ceiling value */; [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.roundFloor(anyLong())).thenReturn(12345L); [EOL] MyClass myClass = new MyClass() { [EOL] public DateTimeField getWrappedField() { [EOL] return mockField; [EOL] } [EOL] }; [EOL] long result = myClass.roundFloor(0L); [EOL] verify(mockField).roundFloor(0L); [EOL] assertEquals(12345L, result); [EOL] }
public int getDayOfMonthTest() { [EOL] long instant = /* some valid instant representing a specific date */; [EOL] int expectedDayOfMonth = /* expected day of the month for the given instant */; [EOL] int actualDayOfMonth = iChronology.getDayOfMonth(instant); [EOL] assertEquals(expectedDayOfMonth, actualDayOfMonth); [EOL] }
public void testGetMaximumValue_SupportedMonthOfYearAndYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(DateTimeFieldType.monthOfYear())).thenReturn(true); [EOL] when(mockPartial.isSupported(DateTimeFieldType.year())).thenReturn(true); [EOL] when(mockPartial.get(DateTimeFieldType.monthOfYear())).thenReturn(5); [EOL] when(mockPartial.get(DateTimeFieldType.year())).thenReturn(2021); [EOL] when(iChronology.getDaysInYearMonth(2021, 5)).thenReturn(31); [EOL] int result = instance.getMaximumValue(mockPartial); [EOL] assertEquals(31, result); [EOL] }
public void testGetMaximumValue_SupportedMonthOfYearOnly() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(DateTimeFieldType.monthOfYear())).thenReturn(true); [EOL] when(mockPartial.isSupported(DateTimeFieldType.year())).thenReturn(false); [EOL] when(mockPartial.get(DateTimeFieldType.monthOfYear())).thenReturn(2); [EOL] when(iChronology.getDaysInMonthMax(2)).thenReturn(29); [EOL] int result = instance.getMaximumValue(mockPartial); [EOL] assertEquals(29, result); [EOL] }
public void testGetMaximumValue_UnsupportedMonthOfYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(DateTimeFieldType.monthOfYear())).thenReturn(false); [EOL] int result = instance.getMaximumValue(mockPartial); [EOL] assertEquals(getMaximumValue(), result); [EOL] }
public void testAppendPaddedInteger_NegativeValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, -1, 3); [EOL] assertEquals("-01", buf.toString()); [EOL] }
public void testAppendPaddedInteger_MinValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, Integer.MIN_VALUE, 12); [EOL] assertEquals("-02147483648", buf.toString()); [EOL] }
public void testAppendPaddedInteger_SingleDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 5, 2); [EOL] assertEquals("05", buf.toString()); [EOL] }
public void testAppendPaddedInteger_TwoDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 50, 3); [EOL] assertEquals("050", buf.toString()); [EOL] }
public void testAppendPaddedInteger_ThreeDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 123, 3); [EOL] assertEquals("123", buf.toString()); [EOL] }
public void testAppendPaddedInteger_FourDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 1234, 4); [EOL] assertEquals("1234", buf.toString()); [EOL] }
public void testAppendPaddedInteger_LargeValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 123456, 6); [EOL] assertEquals("123456", buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_NegativeValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = -1; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals("-1", buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_MinValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = Integer.MIN_VALUE; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals("-" + -(long) Integer.MIN_VALUE, buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_SingleDigit() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = 5; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals("5", buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_TwoDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = 42; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals("42", buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_ThreeDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int value = 123; [EOL] Time.appendUnpaddedInteger(buf, value); [EOL] assertEquals("123", buf.toString()); [EOL] }
public void testCalculateDigitCountNegativeValueNotMinLong() { [EOL] int result = Time.calculateDigitCount(-123); [EOL] assertEquals(4, result); [EOL] }
public void testCalculateDigitCountMinLongValue() { [EOL] int result = Time.calculateDigitCount(Long.MIN_VALUE); [EOL] assertEquals(20, result); [EOL] }
public void testCalculateDigitCountZero() { [EOL] int result = Time.calculateDigitCount(0); [EOL] assertEquals(1, result); [EOL] }
public void testCalculateDigitCountSingleDigit() { [EOL] int result = Time.calculateDigitCount(5); [EOL] assertEquals(1, result); [EOL] }
public void testCalculateDigitCountTwoDigits() { [EOL] int result = Time.calculateDigitCount(12); [EOL] assertEquals(2, result); [EOL] }
public void testCalculateDigitCountThreeDigits() { [EOL] int result = Time.calculateDigitCount(123); [EOL] assertEquals(3, result); [EOL] }
public void testCalculateDigitCountFourDigits() { [EOL] int result = Time.calculateDigitCount(1234); [EOL] assertEquals(4, result); [EOL] }
public void testCalculateDigitCountLargeNumber() { [EOL] int result = Time.calculateDigitCount(123456789); [EOL] assertEquals(9, result); [EOL] }
public void testParseTwoDigits_ValidInput() { [EOL] int result = parseTwoDigits("12345", 2); [EOL] assertEquals(34, result); [EOL] } [EOL] public void testParseTwoDigits_InvalidInput() { [EOL] try { [EOL] parseTwoDigits("12", 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testParseTwoDigits_NegativePosition() { [EOL] try { [EOL] parseTwoDigits("12345", -1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testParseTwoDigits_AtEndOfString() { [EOL] try { [EOL] parseTwoDigits("89", 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testParseTwoDigits_SingleDigit() { [EOL] try { [EOL] parseTwoDigits("5", 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWithZoneSameAsCurrent() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology and zone [EOL] DateTimeZone currentZone = chronology.getZone(); [EOL] Chronology result = chronology.withZone(currentZone); [EOL] assertSame("Should be the same chronology because zones are equal", chronology, result); [EOL] }
public void testWithZoneDifferentFromCurrent() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology and zone [EOL] DateTimeZone differentZone = ...; // Initialize with a different zone [EOL] Chronology result = chronology.withZone(differentZone); [EOL] assertNotSame("Should not be the same chronology because zones are different", chronology, result); [EOL] assertEquals("The new chronology should have the different zone", differentZone, result.getZone()); [EOL] }
public void testWithZoneNull() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology and zone [EOL] Chronology result = chronology.withZone(null); [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] assertNotSame("Should not be the same chronology because null zone implies default zone", chronology, result); [EOL] assertEquals("The new chronology should have the default zone", defaultZone, result.getZone()); [EOL] }
public class ReadableInstantConverterTest extends ReadableInstantConverter { [EOL] public ReadableInstantConverterTest() { [EOL] super(); [EOL] } [EOL] public void testReadableInstantConverter() { [EOL] ReadableInstantConverterTest instance = new ReadableInstantConverterTest(); [EOL] assertNotNull(instance); [EOL] } [EOL] }
public void testGetChronology_WithNullChronology() { [EOL] Object object = new ReadableInstant() { [EOL] public long getMillis() { return 0; } [EOL] public Chronology getChronology() { return null; } [EOL] public DateTimeZone getZone() { return null; } [EOL] }; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Chronology result = getChronology(object, zone); [EOL] assertTrue(result instanceof ISOChronology); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testGetChronology_WithNonNullChronology_SameZone() { [EOL] final DateTimeZone zone = DateTimeZone.UTC; [EOL] Object object = new ReadableInstant() { [EOL] public long getMillis() { return 0; } [EOL] public Chronology getChronology() { return ISOChronology.getInstance(zone); } [EOL] public DateTimeZone getZone() { return zone; } [EOL] }; [EOL] Chronology result = getChronology(object, zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testGetChronology_WithNonNullChronology_DifferentZone() { [EOL] final DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] final DateTimeZone newZone = DateTimeZone.UTC; [EOL] Object object = new ReadableInstant() { [EOL] public long getMillis() { return 0; } [EOL] public Chronology getChronology() { return ISOChronology.getInstance(originalZone); } [EOL] public DateTimeZone getZone() { return originalZone; } [EOL] }; [EOL] Chronology result = getChronology(object, newZone); [EOL] assertNotNull(result); [EOL] assertEquals(newZone, result.getZone()); [EOL] }
public void testGetInstantMillisWithNullChronology() { [EOL] ReadableInstant instant = new DateTime(123456789L); [EOL] long millis = getInstantMillis(instant, null); [EOL] assertEquals(123456789L, millis); [EOL] }
public void testGetInstantMillisWithNonNullChronology() { [EOL] ReadableInstant instant = new DateTime(123456789L, GregorianChronology.getInstance()); [EOL] long millis = getInstantMillis(instant, GregorianChronology.getInstance()); [EOL] assertEquals(123456789L, millis); [EOL] }
public void testGetInstanceUTC() { [EOL] BuddhistChronology instance = BuddhistChronology.getInstanceUTC(); [EOL] assertNotNull(instance); [EOL] assertSame(BuddhistChronology.INSTANCE_UTC, instance); [EOL] }
public void testReadResolve_BaseIsNull() { [EOL] Time time = new Time(); // Assuming Time is the class where readResolve is defined [EOL] time.setBase(null); // Assuming setBase is a method to set the private field 'base' [EOL] Object result = time.readResolve(); [EOL] assertTrue(result instanceof Time); [EOL] assertEquals("UTC", ((Time) result).getZone()); // Assuming getZone is a method to get the zone [EOL] }
public void testReadResolve_BaseIsNotNull() { [EOL] Time time = new Time(); [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.getZone()).thenReturn(DateTimeZone.getDefault()); [EOL] time.setBase(mockChronology); [EOL] Object result = time.readResolve(); [EOL] assertTrue(result instanceof Time); [EOL] assertEquals(DateTimeZone.getDefault(), ((Time) result).getZone()); [EOL] }
public void testAssembleWithNullParam() { [EOL] Fields fields = new Fields(); [EOL] assemble(fields); // Assuming getParam() will return null [EOL] assertNotNull(fields.eras); [EOL] assertTrue(fields.year instanceof OffsetDateTimeField); [EOL] assertTrue(fields.yearOfEra instanceof DelegatedDateTimeField); [EOL] assertTrue(fields.weekyear instanceof OffsetDateTimeField); [EOL] assertTrue(fields.centuryOfEra instanceof DividedDateTimeField); [EOL] assertTrue(fields.centuries instanceof DurationField); [EOL] assertTrue(fields.yearOfCentury instanceof OffsetDateTimeField); [EOL] assertTrue(fields.weekyearOfCentury instanceof OffsetDateTimeField); [EOL] assertEquals(ERA_FIELD, fields.era); [EOL] }
public void testAssembleWithNonNullParam() { [EOL] Fields fields = new Fields(); [EOL] setParam(new Object()); // Assuming setParam(Object param) is a method that sets the parameter which getParam() will return [EOL] assemble(fields); // Now getParam() will not return null [EOL] assertNull(fields.eras); [EOL] assertNull(fields.year); [EOL] assertNull(fields.yearOfEra); [EOL] assertNull(fields.weekyear); [EOL] assertNull(fields.centuryOfEra); [EOL] assertNull(fields.centuries); [EOL] assertNull(fields.yearOfCentury); [EOL] assertNull(fields.weekyearOfCentury); [EOL] assertNull(fields.era); [EOL] }
public void testHashCode() { [EOL] long millis = 123456789L; [EOL] DateTimeType type = new DateTimeType(); // Assuming DateTimeType is a class with a proper hashCode implementation [EOL] Time time = new Time(millis, type); // Assuming Time is the class that contains the hashCode method [EOL] int expectedHash = (int) (millis ^ (millis >>> 32)); [EOL] expectedHash += type.hashCode(); [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public int getMonthOfYearTestWithValidInstant() { [EOL] long instant = /* some valid instant value */; [EOL] int expectedMonthOfYear = /* expected month of year for the given instant */; [EOL] int actualMonthOfYear = /* your object */.get(instant); [EOL] assertEquals(expectedMonthOfYear, actualMonthOfYear); [EOL] }
public void testAddWithZeroMonths() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = 0; [EOL] long expected = instant; [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithPositiveMonthsNoYearChange() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = 5; // Assuming this does not cause a year change [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after adding 5 months [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithPositiveMonthsYearChange() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = 10; // Assuming this causes a year change [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after adding 10 months [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithNegativeMonthsNoYearChange() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = -5; // Assuming this does not cause a year change [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after subtracting 5 months [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithNegativeMonthsYearChange() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = -10; // Assuming this causes a year change [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after subtracting 10 months [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithMonthOverflow() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = 12; // Assuming this causes month overflow to next year [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after adding 12 months [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithMonthUnderflow() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = -12; // Assuming this causes month underflow to previous year [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after subtracting 12 months [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithDayOfMonthAdjustment() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int months = 1; // Assuming this causes day of month adjustment due to fewer days in the resulting month [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after adding 1 month [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public long add(long instant, long months) { [EOL] int i_months = (int) months; [EOL] if (i_months == months) { [EOL] return add(instant, i_months); [EOL] } [EOL] long timePart = iChronology.getMillisOfDay(instant); [EOL] int thisYear = iChronology.getYear(instant); [EOL] int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL] long yearToUse; [EOL] long monthToUse = thisMonth - 1 + months; [EOL] if (monthToUse >= 0) { [EOL] yearToUse = thisYear + (monthToUse / iMax); [EOL] monthToUse = (monthToUse % iMax) + 1; [EOL] } else { [EOL] yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL] monthToUse = Math.abs(monthToUse); [EOL] int remMonthToUse = (int) (monthToUse % iMax); [EOL] if (remMonthToUse == 0) { [EOL] remMonthToUse = iMax; [EOL] } [EOL] monthToUse = iMax - remMonthToUse + 1; [EOL] if (monthToUse == 1) { [EOL] yearToUse += 1; [EOL] } [EOL] } [EOL] if (yearToUse < iChronology.getMinYear() || yearToUse > iChronology.getMaxYear()) { [EOL] throw new IllegalArgumentException("Magnitude of add amount is too large: " + months); [EOL] } [EOL] int i_yearToUse = (int) yearToUse; [EOL] int i_monthToUse = (int) monthToUse; [EOL] int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL] int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse); [EOL] if (dayToUse > maxDay) { [EOL] dayToUse = maxDay; [EOL] } [EOL] long datePart = iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse); [EOL] return datePart + timePart; [EOL] }
public void testRoundFloor_AtStartOfYear() { [EOL] long startOfYearInstant = iChronology.getYearMonthMillis(2023, 1); // Assume this is the start of the year [EOL] long roundedInstant = roundFloor(startOfYearInstant); [EOL] assertEquals(startOfYearInstant, roundedInstant); [EOL] } [EOL] public void testRoundFloor_InMiddleOfMonth() { [EOL] long middleOfMonthInstant = iChronology.getYearMonthMillis(2023, 6) + 15 * DateTimeConstants.MILLIS_PER_DAY; // Assume this is the middle of June [EOL] long expectedStartOfMonthInstant = iChronology.getYearMonthMillis(2023, 6); [EOL] long roundedInstant = roundFloor(middleOfMonthInstant); [EOL] assertEquals(expectedStartOfMonthInstant, roundedInstant); [EOL] } [EOL] public void testRoundFloor_AtStartOfMonth() { [EOL] long startOfMonthInstant = iChronology.getYearMonthMillis(2023, 3); // Assume this is the start of March [EOL] long roundedInstant = roundFloor(startOfMonthInstant); [EOL] assertEquals(startOfMonthInstant, roundedInstant); [EOL] } [EOL] public void testRoundFloor_AtEndOfYear() { [EOL] long endOfYearInstant = iChronology.getYearMonthMillis(2023, 12) + (31 * DateTimeConstants.MILLIS_PER_DAY - 1); // Assume this is the end of December [EOL] long expectedStartOfMonthInstant = iChronology.getYearMonthMillis(2023, 12); [EOL] long roundedInstant = roundFloor(endOfYearInstant); [EOL] assertEquals(expectedStartOfMonthInstant, roundedInstant); [EOL] }
public void testSafeMultiplyWithNoOverflow() { [EOL] int result = safeMultiply(1000, 2000); [EOL] assertEquals(2000000, result); [EOL] }
public void testSafeMultiplyWithOverflow() { [EOL] try { [EOL] safeMultiply(Integer.MAX_VALUE, 2); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testSafeMultiplyWithUnderflow() { [EOL] try { [EOL] safeMultiply(Integer.MIN_VALUE, 2); [EOL] fail("Should have thrown ArithmeticException due to underflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testSafeMultiplyWithZero() { [EOL] int result = safeMultiply(0, 12345); [EOL] assertEquals(0, result); [EOL] }
public void testSafeMultiplyWithOne() { [EOL] int result = safeMultiply(1, Integer.MAX_VALUE); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] }
public void testSafeMultiplyWithMinusOne() { [EOL] int result = safeMultiply(-1, Integer.MIN_VALUE); [EOL] assertEquals(Integer.MIN_VALUE, result); [EOL] }
public void testSafeToIntWithMinValue() { [EOL] long value = Integer.MIN_VALUE; [EOL] int result = Time.safeToInt(value); [EOL] assertEquals(Integer.MIN_VALUE, result); [EOL] }
public void testSafeToIntWithMaxValue() { [EOL] long value = Integer.MAX_VALUE; [EOL] int result = Time.safeToInt(value); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] }
public void testSafeToIntWithTooSmallValue() { [EOL] long value = (long) Integer.MIN_VALUE - 1; [EOL] try { [EOL] Time.safeToInt(value); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Value cannot fit in an int: " + value, e.getMessage()); [EOL] } [EOL] }
public void testSafeToIntWithTooLargeValue() { [EOL] long value = (long) Integer.MAX_VALUE + 1; [EOL] try { [EOL] Time.safeToInt(value); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Value cannot fit in an int: " + value, e.getMessage()); [EOL] } [EOL] }
public void testVerifyValueBoundsWithinLimits() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 10; [EOL] int lowerBound = 1; [EOL] int upperBound = 30; [EOL] Time.verifyValueBounds(fieldType, value, lowerBound, upperBound); [EOL] }
public void testVerifyValueBoundsBelowLowerLimit() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 0; [EOL] int lowerBound = 1; [EOL] int upperBound = 30; [EOL] try { [EOL] Time.verifyValueBounds(fieldType, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsAboveUpperLimit() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 31; [EOL] int lowerBound = 1; [EOL] int upperBound = 30; [EOL] try { [EOL] Time.verifyValueBounds(fieldType, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testIsLenient_True() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.isLenient()).thenReturn(true); [EOL] DelegatedDateTimeField field = new DelegatedDateTimeField(mockField, null); [EOL] assertTrue(field.isLenient()); [EOL] }
public void testIsLenient_False() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.isLenient()).thenReturn(false); [EOL] DelegatedDateTimeField field = new DelegatedDateTimeField(mockField, null); [EOL] assertFalse(field.isLenient()); [EOL] }
public long setTestWithValidValue() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.set(anyLong(), anyInt())).thenReturn(12345L); [EOL] Time time = new Time(mockField); [EOL] long result = time.set(0L, 10); [EOL] assertEquals(12345L, result); [EOL] }
public long setTestWithInvalidValue() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.set(anyLong(), anyInt())).thenThrow(new IllegalArgumentException()); [EOL] Time time = new Time(mockField); [EOL] try { [EOL] time.set(0L, -1); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int getMinimumValue() { [EOL] return iField.getMinimumValue(); [EOL] }
public int testGetMaximumValue() { [EOL] Time time = new Time(); [EOL] int maxValue = time.getMaximumValue(); [EOL] assertEquals(9999, maxValue); [EOL] }
public void testGetInstance_WhenInstanceIsNull() { [EOL] ConverterManager result = ConverterManager.getInstance(); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_WhenInstanceIsNotNull() { [EOL] ConverterManager firstCall = ConverterManager.getInstance(); [EOL] ConverterManager secondCall = ConverterManager.getInstance(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testConverterManagerInitialization() { [EOL] ConverterManager manager = new ConverterManager(); [EOL] assertNotNull(manager.iInstantConverters); [EOL] assertEquals(6, manager.iInstantConverters.size()); [EOL] assertTrue(manager.iInstantConverters.contains(ReadableInstantConverter.INSTANCE)); [EOL] assertTrue(manager.iInstantConverters.contains(StringConverter.INSTANCE)); [EOL] assertTrue(manager.iInstantConverters.contains(CalendarConverter.INSTANCE)); [EOL] assertTrue(manager.iInstantConverters.contains(DateConverter.INSTANCE)); [EOL] assertTrue(manager.iInstantConverters.contains(LongConverter.INSTANCE)); [EOL] assertTrue(manager.iInstantConverters.contains(NullConverter.INSTANCE)); [EOL] assertNotNull(manager.iPartialConverters); [EOL] assertEquals(6, manager.iPartialConverters.size()); [EOL] assertTrue(manager.iPartialConverters.contains(ReadablePartialConverter.INSTANCE)); [EOL] assertTrue(manager.iPartialConverters.contains(ReadableInstantConverter.INSTANCE)); [EOL] assertTrue(manager.iPartialConverters.contains(StringConverter.INSTANCE)); [EOL] assertTrue(manager.iPartialConverters.contains(CalendarConverter.INSTANCE)); [EOL] assertTrue(manager.iPartialConverters.contains(DateConverter.INSTANCE)); [EOL] assertTrue(manager.iPartialConverters.contains(LongConverter.INSTANCE)); [EOL] assertTrue(manager.iPartialConverters.contains(NullConverter.INSTANCE)); [EOL] assertNotNull(manager.iDurationConverters); [EOL] assertEquals(5, manager.iDurationConverters.size()); [EOL] assertTrue(manager.iDurationConverters.contains(ReadableDurationConverter.INSTANCE)); [EOL] assertTrue(manager.iDurationConverters.contains(ReadableIntervalConverter.INSTANCE)); [EOL] assertTrue(manager.iDurationConverters.contains(StringConverter.INSTANCE)); [EOL] assertTrue(manager.iDurationConverters.contains(LongConverter.INSTANCE)); [EOL] assertTrue(manager.iDurationConverters.contains(NullConverter.INSTANCE)); [EOL] assertNotNull(manager.iPeriodConverters); [EOL] assertEquals(5, manager.iPeriodConverters.size()); [EOL] assertTrue(manager.iPeriodConverters.contains(ReadableDurationConverter.INSTANCE)); [EOL] assertTrue(manager.iPeriodConverters.contains(ReadablePeriodConverter.INSTANCE)); [EOL] assertTrue(manager.iPeriodConverters.contains(ReadableIntervalConverter.INSTANCE)); [EOL] assertTrue(manager.iPeriodConverters.contains(StringConverter.INSTANCE)); [EOL] assertTrue(manager.iPeriodConverters.contains(NullConverter.INSTANCE)); [EOL] assertNotNull(manager.iIntervalConverters); [EOL] assertEquals(3, manager.iIntervalConverters.size()); [EOL] assertTrue(manager.iIntervalConverters.contains(ReadableIntervalConverter.INSTANCE)); [EOL] assertTrue(manager.iIntervalConverters.contains(StringConverter.INSTANCE)); [EOL] assertTrue(manager.iIntervalConverters.contains(NullConverter.INSTANCE)); [EOL] }
public void testAddInstantConverterWithNull() { [EOL] InstantConverter result = timeObject.addInstantConverter(null); [EOL] assertNull(result); [EOL] }
public void testAddInstantConverterWithNonNull() throws SecurityException { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] InstantConverter result = timeObject.addInstantConverter(mockConverter); [EOL] assertNotNull(timeObject.getInstantConverters()); [EOL] assertTrue(Arrays.asList(timeObject.getInstantConverters()).contains(mockConverter)); [EOL] }
public void testAddInstantConverterThrowsSecurityException() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] doThrow(new SecurityException()).when(timeObject).checkAlterInstantConverters(); [EOL] assertThrows(SecurityException.class, () -> { [EOL] timeObject.addInstantConverter(mockConverter); [EOL] }); [EOL] }
public void testAddPartialConverter_WithNullConverter() { [EOL] PartialConverter result = time.addPartialConverter(null); [EOL] assertNull("Expected null when adding null converter", result); [EOL] } [EOL] public void testAddPartialConverter_WithNonNullConverter() throws SecurityException { [EOL] PartialConverter mockConverter = createMockPartialConverter(); [EOL] PartialConverter result = time.addPartialConverter(mockConverter); [EOL] assertNotNull("Expected non-null when adding non-null converter", result); [EOL] } [EOL] public void testAddPartialConverter_CheckSecurityException() { [EOL] try { [EOL] PartialConverter mockConverter = createMockPartialConverter(); [EOL] makeAlterPartialConvertersThrowSecurityException(); [EOL] time.addPartialConverter(mockConverter); [EOL] fail("Expected SecurityException to be thrown"); [EOL] } catch (SecurityException e) { [EOL] } [EOL] } [EOL] private PartialConverter createMockPartialConverter() { [EOL] return new PartialConverter() { [EOL] }; [EOL] } [EOL] private void makeAlterPartialConvertersThrowSecurityException() { [EOL] }
public void testGetPeriodConverterWithNull() { [EOL] try { [EOL] PeriodConverter result = getPeriodConverter(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("No period converter found for type: null", ex.getMessage()); [EOL] } [EOL] }
public void testGetPeriodConverterWithValidObject() { [EOL] Object validObject = new MockPeriodType(); [EOL] PeriodConverter expectedConverter = new MockPeriodConverter(); [EOL] iPeriodConverters.add(validObject.getClass(), expectedConverter); [EOL] PeriodConverter result = getPeriodConverter(validObject); [EOL] assertNotNull("Expected a non-null PeriodConverter", result); [EOL] assertSame("Expected the mock converter to be returned", expectedConverter, result); [EOL] }
public void testGetPeriodConverterWithInvalidObject() { [EOL] Object invalidObject = new Object(); [EOL] try { [EOL] PeriodConverter result = getPeriodConverter(invalidObject); [EOL] fail("Should have thrown IllegalArgumentException for invalid input"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("No period converter found for type: " + invalidObject.getClass().getName(), ex.getMessage()); [EOL] } [EOL] }
public void testGetPeriodConverters_WithNonEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new PeriodConverter[]{new StubPeriodConverter()}); [EOL] PeriodTypeConverter instance = new PeriodTypeConverter(set); [EOL] PeriodConverter[] result = instance.getPeriodConverters(); [EOL] assertNotNull(result); [EOL] assertEquals(set.size(), result.length); [EOL] }
public void testGetPeriodConverters_WithEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new PeriodConverter[0]); [EOL] PeriodTypeConverter instance = new PeriodTypeConverter(set); [EOL] PeriodConverter[] result = instance.getPeriodConverters(); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testAddPeriodConverterWithNullConverter() { [EOL] PeriodConverter result = addPeriodConverter(null); [EOL] assertNull(result); [EOL] }
public void testAddPeriodConverterWithNonNullConverter() throws SecurityException { [EOL] PeriodConverter mockConverter = createMockPeriodConverter(); [EOL] PeriodConverter[] originalConverters = getPeriodConvertersArray(); [EOL] int originalSize = originalConverters.length; [EOL] PeriodConverter result = addPeriodConverter(mockConverter); [EOL] PeriodConverter[] newConverters = getPeriodConvertersArray(); [EOL] assertNotNull(newConverters); [EOL] assertEquals(originalSize + 1, newConverters.length); [EOL] assertSame(mockConverter, newConverters[originalSize]); [EOL] assertNull(result); [EOL] }
public void testRemovePeriodConverter_WithNullConverter() { [EOL] PeriodConverter result = periodConverter.removePeriodConverter(null); [EOL] assertNull("Expected null when removing null converter", result); [EOL] }
public void testRemovePeriodConverter_WithValidConverter() throws SecurityException { [EOL] PeriodConverter mockConverter = createMockConverter(); [EOL] periodConverter.addPeriodConverter(mockConverter); [EOL] PeriodConverter result = periodConverter.removePeriodConverter(mockConverter); [EOL] assertNotNull("Expected non-null when removing existing converter", result); [EOL] assertEquals("Expected the removed converter to be the one we added", mockConverter, result); [EOL] }
public void testRemovePeriodConverter_WithNonExistingConverter() throws SecurityException { [EOL] PeriodConverter mockConverter = createMockConverter(); [EOL] PeriodConverter result = periodConverter.removePeriodConverter(mockConverter); [EOL] assertNull("Expected null when removing non-existing converter", result); [EOL] }
public void testRemovePeriodConverter_ThrowsSecurityException() { [EOL] PeriodConverter mockConverter = createMockConverter(); [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("alterPeriodConverters".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] periodConverter.removePeriodConverter(mockConverter); [EOL] fail("Expected SecurityException when security manager denies permission"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterPeriodConverters_WithNoSecurityManager() { [EOL] System.setSecurityManager(null); [EOL] try { [EOL] checkAlterPeriodConverters(); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterPeriodConverters_WithSecurityManager() throws Exception { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm instanceof JodaTimePermission) { [EOL] if ("ConverterManager.alterPeriodConverters".equals(perm.getName())) { [EOL] return; // Permission is granted [EOL] } [EOL] } [EOL] super.checkPermission(perm); [EOL] } [EOL] }; [EOL] System.setSecurityManager(sm); [EOL] checkAlterPeriodConverters(); [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); // Reset security manager [EOL] } [EOL] }
public void testRemoveIntervalConverter_WithNullConverter() { [EOL] IntervalConverter result = removeIntervalConverter(null); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveIntervalConverter_WithNonNullConverter_NotInList() { [EOL] IntervalConverter mockConverter = new MockIntervalConverter(); [EOL] IntervalConverter result = removeIntervalConverter(mockConverter); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveIntervalConverter_WithNonNullConverter_InList() { [EOL] IntervalConverter mockConverter = new MockIntervalConverter(); [EOL] addIntervalConverter(mockConverter); [EOL] IntervalConverter result = removeIntervalConverter(mockConverter); [EOL] assertNotNull(result); [EOL] assertEquals(mockConverter, result); [EOL] }
public void testDelegatedDateTimeFieldWithNonNullField() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DelegatedDateTimeField delegatedDateTimeField = new DelegatedDateTimeField(mockField); [EOL] assertNotNull(delegatedDateTimeField); [EOL] }
public void testDelegatedDateTimeFieldWithNullField() { [EOL] try { [EOL] new DelegatedDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeField"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDelegatedDateTimeFieldWithNonNullFieldAndType() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] DelegatedDateTimeField delegatedDateTimeField = new DelegatedDateTimeField(mockField, mockType); [EOL] assertNotNull(delegatedDateTimeField); [EOL] assertSame(mockField, delegatedDateTimeField.getWrappedField()); [EOL] assertSame(mockType, delegatedDateTimeField.getType()); [EOL] }
public void testDelegatedDateTimeFieldWithNullField() { [EOL] try { [EOL] new DelegatedDateTimeField(null, Mockito.mock(DateTimeFieldType.class)); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDelegatedDateTimeFieldWithNullType() { [EOL] try { [EOL] new DelegatedDateTimeField(Mockito.mock(DateTimeField.class), null); [EOL] fail("Should have thrown IllegalArgumentException for null type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDelegatedDateTimeFieldWithNonNullFields() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] DurationField mockRangeField = mock(DurationField.class); [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DelegatedDateTimeField delegatedDateTimeField = new DelegatedDateTimeField(mockField, mockRangeField, mockType); [EOL] assertNotNull(delegatedDateTimeField); [EOL] }
public void testDelegatedDateTimeFieldWithNullField() { [EOL] try { [EOL] new DelegatedDateTimeField(null, mock(DurationField.class), mock(DateTimeFieldType.class)); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDelegatedDateTimeFieldWithNullType() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] DurationField mockRangeField = mock(DurationField.class); [EOL] when(mockField.getType()).thenReturn(mock(DateTimeFieldType.class)); [EOL] DelegatedDateTimeField delegatedDateTimeField = new DelegatedDateTimeField(mockField, mockRangeField, null); [EOL] assertNotNull(delegatedDateTimeField); [EOL] }
public void testGetType() { [EOL] DateTimeFieldType expectedType = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeProperty property = new DateTimeProperty(null, expectedType); [EOL] DateTimeFieldType actualType = property.getType(); [EOL] assertEquals("The type should be the same as expected", expectedType, actualType); [EOL] }
public long remainder_whenCalledWithInstant_returnsRemainder() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] long expected = 10L; [EOL] when(mockField.remainder(anyLong())).thenReturn(expected); [EOL] Time time = new Time(mockField); [EOL] long actual = time.remainder(100L); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDateOnlyInstance() { [EOL] DateTimeComparator result = ClassName.getDateOnlyInstance(); [EOL] assertNotNull(result); [EOL] assertSame(ClassName.DATE_INSTANCE, result); [EOL] }
public int compare(Object lhsObj, Object rhsObj) { [EOL] InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj); [EOL] Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null); [EOL] long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono); [EOL] conv = ConverterManager.getInstance().getInstantConverter(rhsObj); [EOL] Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null); [EOL] long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono); [EOL] if (iLowerLimit != null) { [EOL] lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis); [EOL] rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis); [EOL] } [EOL] if (iUpperLimit != null) { [EOL] lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis); [EOL] rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis); [EOL] } [EOL] if (lhsMillis < rhsMillis) { [EOL] return -1; [EOL] } else if (lhsMillis > rhsMillis) { [EOL] return 1; [EOL] } else { [EOL] return 0; [EOL] } [EOL] }
public void testToString_BothLimitsNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, null); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[]", result); [EOL] }
public void testToString_LowerLimitNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, new DateTimeLimit("Upper")); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[-Upper]", result); [EOL] }
public void testToString_UpperLimitNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(new DateTimeLimit("Lower"), null); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[Lower-]", result); [EOL] }
public void testToString_NeitherLimitNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(new DateTimeLimit("Lower"), new DateTimeLimit("Upper")); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[Lower-Upper]", result); [EOL] }
public void testToString_BothLimitsSame() { [EOL] DateTimeLimit sameLimit = new DateTimeLimit("Same"); [EOL] DateTimeComparator comparator = new DateTimeComparator(sameLimit, sameLimit); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[Same]", result); [EOL] }
public void testGetValueAtIndexZero() { [EOL] Time time = new Time(); [EOL] int expected = time.getValue(); [EOL] int actual = time.getValue(0); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetValueAtNonZeroIndex() { [EOL] Time time = new Time(); [EOL] int index = 1; [EOL] try { [EOL] time.getValue(index); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("1", e.getMessage()); [EOL] } [EOL] }
public void testToMutablePeriod() { [EOL] Period period = new Period(); [EOL] MutablePeriod mutablePeriod = period.toMutablePeriod(); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(period.getYears(), mutablePeriod.getYears()); [EOL] assertEquals(period.getMonths(), mutablePeriod.getMonths()); [EOL] assertEquals(period.getWeeks(), mutablePeriod.getWeeks()); [EOL] assertEquals(period.getDays(), mutablePeriod.getDays()); [EOL] assertEquals(period.getHours(), mutablePeriod.getHours()); [EOL] assertEquals(period.getMinutes(), mutablePeriod.getMinutes()); [EOL] assertEquals(period.getSeconds(), mutablePeriod.getSeconds()); [EOL] assertEquals(period.getMillis(), mutablePeriod.getMillis()); [EOL] }
int getMonthOfYear(long millis, int year) { [EOL] int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL] return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] } [EOL] BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek); [EOL] int getMonthOfYear(long millis, int year); [EOL] int getDaysInYearMonth(int year, int month); [EOL] int getDaysInMonthMax(int month); [EOL] int getDaysInMonthMaxForSet(long instant, int value); [EOL] long getTotalMillisByYearMonth(int year, int month); [EOL] long getYearDifference(long minuendInstant, long subtrahendInstant); [EOL] long setYear(long instant, int year); [EOL] long serialVersionUID=538276888268L; [EOL] int[] MIN_DAYS_PER_MONTH_ARRAY={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; [EOL] int[] MAX_DAYS_PER_MONTH_ARRAY={ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
public void testGetDaysInYearMonth_LeapYear_February() { [EOL] int year = 2020; // Example leap year [EOL] int month = 2; // February [EOL] int expectedDays = 29; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] } [EOL] public void testGetDaysInYearMonth_NonLeapYear_February() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 2; // February [EOL] int expectedDays = 28; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] } [EOL] public void testGetDaysInYearMonth_LeapYear_April() { [EOL] int year = 2020; // Example leap year [EOL] int month = 4; // April [EOL] int expectedDays = 30; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_NonLeapYear_April() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 4; // April [EOL] int expectedDays = 30; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetTotalMillisByYearMonth_LeapYear_February() { [EOL] int year = 2020; // Example leap year [EOL] int month = 2; // February [EOL] long expectedMillis = MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetTotalMillisByYearMonth_NonLeapYear_February() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 2; // February [EOL] long expectedMillis = MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetTotalMillisByYearMonth_LeapYear_January() { [EOL] int year = 2020; // Example leap year [EOL] int month = 1; // January [EOL] long expectedMillis = MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetTotalMillisByYearMonth_NonLeapYear_January() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 1; // January [EOL] long expectedMillis = MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearDifferenceWithNonLeapYears() { [EOL] long minuendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long subtrahendInstant = 1514764800000L; // 2018-01-01T00:00:00Z [EOL] long expectedDifference = 2; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendLeapYear() { [EOL] long minuendInstant = 1583020800000L; // 2020-03-01T00:00:00Z (leap year after Feb 29) [EOL] long subtrahendInstant = 1551398400000L; // 2019-03-01T00:00:00Z (non-leap year) [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithSubtrahendLeapYear() { [EOL] long minuendInstant = 1614556800000L; // 2021-03-01T00:00:00Z (non-leap year) [EOL] long subtrahendInstant = 1583020800000L; // 2020-03-01T00:00:00Z (leap year after Feb 29) [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithBothLeapYears() { [EOL] long minuendInstant = 1646092800000L; // 2022-03-01T00:00:00Z (leap year after Feb 29) [EOL] long subtrahendInstant = 1583020800000L; // 2020-03-01T00:00:00Z (leap year after Feb 29) [EOL] long expectedDifference = 2; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendBeforeSubtrahend() { [EOL] long minuendInstant = 1514764800000L; // 2018-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expectedDifference = -2; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithSameYear() { [EOL] long minuendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expectedDifference = 0; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testSecondsZero() { [EOL] Seconds result = Time.seconds(0); [EOL] assertSame(Seconds.ZERO, result); [EOL] }
public void testSecondsOne() { [EOL] Seconds result = Time.seconds(1); [EOL] assertSame(Seconds.ONE, result); [EOL] }
public void testSecondsTwo() { [EOL] Seconds result = Time.seconds(2); [EOL] assertSame(Seconds.TWO, result); [EOL] }
public void testSecondsThree() { [EOL] Seconds result = Time.seconds(3); [EOL] assertSame(Seconds.THREE, result); [EOL] }
public void testSecondsMaxValue() { [EOL] Seconds result = Time.seconds(Integer.MAX_VALUE); [EOL] assertSame(Seconds.MAX_VALUE, result); [EOL] }
public void testSecondsMinValue() { [EOL] Seconds result = Time.seconds(Integer.MIN_VALUE); [EOL] assertSame(Seconds.MIN_VALUE, result); [EOL] }
public void testSecondsDefault() { [EOL] int arbitrarySeconds = 10; [EOL] Seconds result = Time.seconds(arbitrarySeconds); [EOL] assertNotNull(result); [EOL] assertEquals(arbitrarySeconds, result.getSeconds()); [EOL] }
public void testSecondsBetweenWithLocalTimes() { [EOL] LocalTime start = new LocalTime(10, 0); // 10:00 AM [EOL] LocalTime end = new LocalTime(10, 0, 30); // 10:00:30 AM [EOL] Seconds result = Time.secondsBetween(start, end); [EOL] assertEquals(30, result.getSeconds()); [EOL] }
public void testSecondsBetweenWithDifferentPartials() { [EOL] LocalDate startDate = new LocalDate(2020, 1, 1); [EOL] LocalDate endDate = new LocalDate(2020, 1, 2); [EOL] Seconds result = Time.secondsBetween(startDate, endDate); [EOL] assertEquals(86400, result.getSeconds()); [EOL] }
public void testParseSecondsWithNullInput() { [EOL] Seconds result = Time.parseSeconds(null); [EOL] assertEquals(Seconds.ZERO, result); [EOL] }
public void testParseSecondsWithValidInput() { [EOL] Seconds result = Time.parseSeconds("PT2S"); [EOL] assertEquals(Seconds.seconds(2), result); [EOL] }
public void testParseSecondsWithInvalidInput() { [EOL] try { [EOL] Time.parseSeconds("InvalidInput"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int getValueTestWithValidDurationAndInstant() { [EOL] long duration = 1000L; // Example duration [EOL] long instant = 2000L; // Example instant [EOL] int expectedValue = 10; // Expected value from getWrappedField().getValue(duration, instant) [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getValue(duration, instant)).thenReturn(expectedValue); [EOL] Mockito.doNothing().when(this).checkLimits(instant, null); [EOL] this.setWrappedField(mockField); // Assuming there is a method to set the wrapped field [EOL] int actualValue = this.getValue(duration, instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public int getValueTestWithLimitsCheck() { [EOL] long duration = 1000L; // Example duration [EOL] long instant = 2000L; // Example instant [EOL] int expectedValue = 10; // Expected value from getWrappedField().getValue(duration, instant) [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getValue(duration, instant)).thenReturn(expectedValue); [EOL] Mockito.doThrow(new IllegalArgumentException()).when(this).checkLimits(instant, null); [EOL] try { [EOL] this.getValue(duration, instant); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetMillisWithValidValueAndInstant() { [EOL] int value = 5; [EOL] long instant = 1000L; [EOL] long expectedMillis = getWrappedField().getMillis(value, instant); [EOL] long actualMillis = getMillis(value, instant); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMillisWithValidInstant() { [EOL] long value = 10L; [EOL] long instant = 1000L; [EOL] long expectedMillis = getWrappedField().getMillis(value, instant); [EOL] long actualMillis = getMillis(value, instant); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] } [EOL] public void testGetMillisWithLimitInstant() { [EOL] long value = 10L; [EOL] long instant = Long.MAX_VALUE; [EOL] try { [EOL] getMillis(value, instant); [EOL] fail("Should have thrown an exception due to limit instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsShortTextWithValidInstantAndLocale() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = Locale.getDefault(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("HH").getChronology()); [EOL] String expected = field.getAsShortText(instant, locale); [EOL] String actual = field.getAsShortText(instant, locale); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAsShortTextWithInvalidInstant() { [EOL] long invalidInstant = Long.MAX_VALUE; [EOL] Locale locale = Locale.getDefault(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("HH").getChronology()); [EOL] try { [EOL] field.getAsShortText(invalidInstant, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = null; [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("HH").getChronology()); [EOL] String expected = field.getAsShortText(instant, Locale.getDefault()); [EOL] String actual = field.getAsShortText(instant, locale); [EOL] assertEquals(expected, actual); [EOL] }
public void testAbstractDateTimeSubclassInstantiation() { [EOL] AbstractDateTimeSubclass instance = new AbstractDateTimeSubclass(); [EOL] assertNotNull(instance); [EOL] }
public void testGetWeekyear() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int expectedWeekyear = testDateTime.getChronology().weekyear().get(testDateTime.getMillis()); [EOL] int actualWeekyear = testDateTime.getWeekyear(); [EOL] assertEquals(expectedWeekyear, actualWeekyear); [EOL] }
public int getWeekOfWeekyear() { [EOL] return getChronology().weekOfWeekyear().get(getMillis()); [EOL] }
public int getHourOfDay() { [EOL] return getChronology().hourOfDay().get(getMillis()); [EOL] }
public int getMinuteOfDay() { [EOL] return getChronology().minuteOfDay().get(getMillis()); [EOL] }
public int getMinuteOfHour() { [EOL] return getChronology().minuteOfHour().get(getMillis()); [EOL] }
public int getSecondOfDay() { [EOL] return getChronology().secondOfDay().get(getMillis()); [EOL] }
public int getSecondOfMinute() { [EOL] return getChronology().secondOfMinute().get(getMillis()); [EOL] }
public int getMillisOfDay() { [EOL] return getChronology().millisOfDay().get(getMillis()); [EOL] }
public int getMillisOfSecond() { [EOL] return getChronology().millisOfSecond().get(getMillis()); [EOL] }
public void testToCalendarWithNullLocale() { [EOL] DateTime testDateTime = new DateTime(); // Assuming DateTime is the class containing toCalendar method [EOL] Locale nullLocale = null; [EOL] Calendar result = testDateTime.toCalendar(nullLocale); [EOL] assertNotNull(result); [EOL] assertEquals(Locale.getDefault(), result.getLocale()); [EOL] }
public void testToCalendarWithNonNullLocale() { [EOL] DateTime testDateTime = new DateTime(); // Assuming DateTime is the class containing toCalendar method [EOL] Locale nonNullLocale = new Locale("en", "US"); [EOL] Calendar result = testDateTime.toCalendar(nonNullLocale); [EOL] assertNotNull(result); [EOL] assertEquals(nonNullLocale, result.getLocale()); [EOL] }
public void testToGregorianCalendar() { [EOL] DateTime testDateTime = new DateTime(); // Assuming DateTime is the class containing the toGregorianCalendar method [EOL] GregorianCalendar cal = testDateTime.toGregorianCalendar(); [EOL] assertNotNull("GregorianCalendar should not be null", cal); [EOL] assertEquals("Time in milliseconds should be equal", testDateTime.getMillis(), cal.getTimeInMillis()); [EOL] assertEquals("TimeZone should be equal", testDateTime.getZone().getID(), cal.getTimeZone().getID()); [EOL] }
public void testGetInstanceWithNullChronology() { [EOL] try { [EOL] LenientChronology.getInstance(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testGetInstanceWithNonNullChronology() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] LenientChronology lenient = LenientChronology.getInstance(base); [EOL] assertNotNull("LenientChronology creation failed", lenient); [EOL] }
public void testLenientChronologyWithNonNullBase() { [EOL] Chronology baseChronology = ISOChronology.getInstance(); [EOL] LenientChronology lenientChronology = new LenientChronology(baseChronology); [EOL] assertNotNull("LenientChronology creation should not be null", lenientChronology); [EOL] }
public void testWithUTC_AlreadyUTC() { [EOL] Chronology chronology = new StubChronology(DateTimeZone.UTC); [EOL] Chronology withUTC = chronology.withUTC(); [EOL] assertSame(chronology, withUTC); [EOL] }
public void testWithUTC_NotUTC() { [EOL] Chronology chronology = new StubChronology(DateTimeZone.getDefault()); [EOL] Chronology withUTC = chronology.withUTC(); [EOL] assertNotNull(withUTC); [EOL] assertNotSame(chronology, withUTC); [EOL] assertEquals(DateTimeZone.UTC, withUTC.getZone()); [EOL] }
public void testWithZone_NullZone() { [EOL] Chronology chronology = ...; // Initialize with a concrete Chronology [EOL] Chronology result = chronology.withZone(null); [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] assertEquals(defaultZone, result.getZone()); [EOL] }
public void testWithZone_UTCZone() { [EOL] Chronology chronology = ...; // Initialize with a concrete Chronology [EOL] Chronology result = chronology.withZone(DateTimeZone.UTC); [EOL] assertSame(result.getClass(), UTCChronology.class); [EOL] }
public void testWithZone_SameZone() { [EOL] Chronology chronology = ...; // Initialize with a concrete Chronology [EOL] DateTimeZone zone = chronology.getZone(); [EOL] Chronology result = chronology.withZone(zone); [EOL] assertSame(chronology, result); [EOL] }
public void testWithZone_DifferentZone() { [EOL] Chronology chronology = ...; // Initialize with a concrete Chronology [EOL] DateTimeZone differentZone = ...; // Initialize with a different DateTimeZone [EOL] Chronology result = chronology.withZone(differentZone); [EOL] assertNotSame(chronology, result); [EOL] assertEquals(differentZone, result.getZone()); [EOL] }
public void testAssemble_AllFieldsNonNull() { [EOL] Fields fields = new Fields(); [EOL] fields.year = new Object(); [EOL] fields.yearOfEra = new Object(); [EOL] fields.yearOfCentury = new Object(); [EOL] fields.centuryOfEra = new Object(); [EOL] fields.era = new Object(); [EOL] fields.dayOfWeek = new Object(); [EOL] fields.dayOfMonth = new Object(); [EOL] fields.dayOfYear = new Object(); [EOL] fields.monthOfYear = new Object(); [EOL] fields.weekOfWeekyear = new Object(); [EOL] fields.weekyear = new Object(); [EOL] fields.weekyearOfCentury = new Object(); [EOL] fields.millisOfSecond = new Object(); [EOL] fields.millisOfDay = new Object(); [EOL] fields.secondOfMinute = new Object(); [EOL] fields.secondOfDay = new Object(); [EOL] fields.minuteOfHour = new Object(); [EOL] fields.minuteOfDay = new Object(); [EOL] fields.hourOfDay = new Object(); [EOL] fields.hourOfHalfday = new Object(); [EOL] fields.clockhourOfDay = new Object(); [EOL] fields.clockhourOfHalfday = new Object(); [EOL] fields.halfdayOfDay = new Object(); [EOL] assemble(fields); [EOL] assertNotNull(fields.year); [EOL] assertNotNull(fields.yearOfEra); [EOL] assertNotNull(fields.yearOfCentury); [EOL] assertNotNull(fields.centuryOfEra); [EOL] assertNotNull(fields.era); [EOL] assertNotNull(fields.dayOfWeek); [EOL] assertNotNull(fields.dayOfMonth); [EOL] assertNotNull(fields.dayOfYear); [EOL] assertNotNull(fields.monthOfYear); [EOL] assertNotNull(fields.weekOfWeekyear); [EOL] assertNotNull(fields.weekyear); [EOL] assertNotNull(fields.weekyearOfCentury); [EOL] assertNotNull(fields.millisOfSecond); [EOL] assertNotNull(fields.millisOfDay); [EOL] assertNotNull(fields.secondOfMinute); [EOL] assertNotNull(fields.secondOfDay); [EOL] assertNotNull(fields.minuteOfHour); [EOL] assertNotNull(fields.minuteOfDay); [EOL] assertNotNull(fields.hourOfDay); [EOL] assertNotNull(fields.hourOfHalfday); [EOL] assertNotNull(fields.clockhourOfDay); [EOL] assertNotNull(fields.clockhourOfHalfday); [EOL] assertNotNull(fields.halfdayOfDay); [EOL] }
public void testConvertFieldWithNonNullField() { [EOL] DateTimeField inputField = new MockDateTimeField(); [EOL] DateTimeField resultField = convertField(inputField); [EOL] assertNotNull("The result should not be null.", resultField); [EOL] assertTrue("The result should be a LenientDateTimeField.", resultField instanceof LenientDateTimeField); [EOL] }
public void testConvertFieldWithNullField() { [EOL] DateTimeField resultField = convertField(null); [EOL] assertNull("The result should be null.", resultField); [EOL] }
public int getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL] long difference = minuendInstant - subtrahendInstant; [EOL] return difference; [EOL] } [EOL] public void testGetDifferenceWithinIntRange() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expected = 500; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceOutsideIntRange() { [EOL] long minuendInstant = Long.MAX_VALUE; [EOL] long subtrahendInstant = 0L; [EOL] try { [EOL] getDifference(minuendInstant, subtrahendInstant); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public long addTestWithPositiveValue() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long instant = 0L; [EOL] int valueToAdd = 5; [EOL] long expected = field.add(instant, valueToAdd); [EOL] long result = field.add(instant, valueToAdd); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithNegativeValue() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long instant = 0L; [EOL] int valueToAdd = -5; [EOL] long expected = field.add(instant, valueToAdd); [EOL] long result = field.add(instant, valueToAdd); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithZeroValue() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long instant = 0L; [EOL] int valueToAdd = 0; [EOL] long expected = field.add(instant, valueToAdd); [EOL] long result = field.add(instant, valueToAdd); [EOL] assertEquals(expected, result); [EOL] }
public long addTestWithPositiveValue() { [EOL] long instant = 1234567890L; [EOL] long valueToAdd = 10L; [EOL] long expected = 1234567890L + 10L; [EOL] long result = add(instant, valueToAdd); [EOL] assert result == expected; [EOL] } [EOL] public long addTestWithNegativeValue() { [EOL] long instant = 1234567890L; [EOL] long valueToAdd = -10L; [EOL] long expected = 1234567890L - 10L; [EOL] long result = add(instant, valueToAdd); [EOL] assert result == expected; [EOL] } [EOL] public long addTestWithZeroValue() { [EOL] long instant = 1234567890L; [EOL] long valueToAdd = 0L; [EOL] long expected = 1234567890L; [EOL] long result = add(instant, valueToAdd); [EOL] assert result == expected; [EOL] }
public void testGetDifference() { [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(); [EOL] long minuendInstant = 1000000L; [EOL] long subtrahendInstant = 500000L; [EOL] int expectedDifference = field.getDifference(minuendInstant, subtrahendInstant); [EOL] int actualDifference = field.getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testWeeks_Zero() { [EOL] Weeks result = Time.weeks(0); [EOL] assertSame(Weeks.ZERO, result); [EOL] }
public void testWeeks_One() { [EOL] Weeks result = Time.weeks(1); [EOL] assertSame(Weeks.ONE, result); [EOL] }
public void testWeeks_Two() { [EOL] Weeks result = Time.weeks(2); [EOL] assertSame(Weeks.TWO, result); [EOL] }
public void testWeeks_Three() { [EOL] Weeks result = Time.weeks(3); [EOL] assertSame(Weeks.THREE, result); [EOL] }
public void testWeeks_MaxValue() { [EOL] Weeks result = Time.weeks(Integer.MAX_VALUE); [EOL] assertSame(Weeks.MAX_VALUE, result); [EOL] }
public void testWeeks_MinValue() { [EOL] Weeks result = Time.weeks(Integer.MIN_VALUE); [EOL] assertSame(Weeks.MIN_VALUE, result); [EOL] }
public void testWeeks_Default() { [EOL] int arbitraryWeeks = 4; // Any number not covered by the switch cases [EOL] Weeks result = Time.weeks(arbitraryWeeks); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryWeeks, result.getWeeks()); [EOL] }
public void testStandardWeeksIn_NullPeriod() { [EOL] try { [EOL] Weeks result = Time.standardWeeksIn(null); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStandardWeeksIn_ZeroWeeks() { [EOL] Period zeroWeeksPeriod = new Period(0, PeriodType.weeks()); [EOL] Weeks result = Time.standardWeeksIn(zeroWeeksPeriod); [EOL] assertEquals("Expected zero weeks", 0, result.getWeeks()); [EOL] }
public void testStandardWeeksIn_NonZeroWeeks() { [EOL] Period nonZeroWeeksPeriod = new Period(1, PeriodType.weeks()); [EOL] Weeks result = Time.standardWeeksIn(nonZeroWeeksPeriod); [EOL] assertEquals("Expected non-zero weeks", 1, result.getWeeks()); [EOL] }
public void testToStandardDays_PositiveWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(2); [EOL] Days expectedDays = Days.days(14); [EOL] assertEquals(expectedDays, testWeeks.toStandardDays()); [EOL] }
public void testToStandardDays_NegativeWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(-3); [EOL] Days expectedDays = Days.days(-21); [EOL] assertEquals(expectedDays, testWeeks.toStandardDays()); [EOL] }
public void testToStandardDays_ZeroWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(0); [EOL] Days expectedDays = Days.days(0); [EOL] assertEquals(expectedDays, testWeeks.toStandardDays()); [EOL] }
public void testNegated_Zero() { [EOL] Weeks zeroWeeks = Weeks.weeks(0); [EOL] Weeks result = zeroWeeks.negated(); [EOL] assertEquals(0, result.getWeeks()); [EOL] }
public void testNegated_Positive() { [EOL] Weeks positiveWeeks = Weeks.weeks(1); [EOL] Weeks result = positiveWeeks.negated(); [EOL] assertEquals(-1, result.getWeeks()); [EOL] }
public void testNegated_Negative() { [EOL] Weeks negativeWeeks = Weeks.weeks(-1); [EOL] Weeks result = negativeWeeks.negated(); [EOL] assertEquals(1, result.getWeeks()); [EOL] }
public void testNegated_MaxValue() { [EOL] Weeks maxWeeks = Weeks.weeks(Integer.MAX_VALUE); [EOL] Weeks result = maxWeeks.negated(); [EOL] assertEquals(Integer.MIN_VALUE + 1, result.getWeeks()); [EOL] }
public void testNegated_MinValue() { [EOL] Weeks minWeeks = Weeks.weeks(Integer.MIN_VALUE); [EOL] try { [EOL] minWeeks.negated(); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testIsGreaterThanWithNullOther() { [EOL] Weeks weeks = new Weeks(1); [EOL] boolean result = weeks.isGreaterThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsGreaterThanWithPositiveOtherGreater() { [EOL] Weeks weeks = new Weeks(1); [EOL] Weeks other = new Weeks(2); [EOL] boolean result = weeks.isGreaterThan(other); [EOL] assertFalse(result); [EOL] }
public void testIsGreaterThanWithPositiveOtherLesser() { [EOL] Weeks weeks = new Weeks(2); [EOL] Weeks other = new Weeks(1); [EOL] boolean result = weeks.isGreaterThan(other); [EOL] assertTrue(result); [EOL] }
public void testIsGreaterThanWithEqualOther() { [EOL] Weeks weeks = new Weeks(1); [EOL] Weeks other = new Weeks(1); [EOL] boolean result = weeks.isGreaterThan(other); [EOL] assertFalse(result); [EOL] }
public void testIsGreaterThanWithNegativeWeeks() { [EOL] Weeks weeks = new Weeks(-1); [EOL] Weeks other = new Weeks(0); [EOL] boolean result = weeks.isGreaterThan(other); [EOL] assertFalse(result); [EOL] }
public void testGetMaximumShortTextLengthWithNullLocale() { [EOL] int result = getMaximumShortTextLength(null); [EOL] }
public void testGetMaximumShortTextLengthWithSpecificLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] int result = getMaximumShortTextLength(locale); [EOL] }
public static DateTime now() { [EOL] return new DateTime(); [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime result = ClassName.now(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] ClassName.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Zone must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDateTimeConstructor() { [EOL] DateTime dateTime = new DateTime(); [EOL] assertNotNull(dateTime); [EOL] }
public void testDateTimeWithNullZone() { [EOL] try { [EOL] new DateTime((DateTimeZone) null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeZone"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDateTimeWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(zone); [EOL] assertNotNull("DateTime should not be null", dateTime); [EOL] assertEquals("TimeZone should match the one passed in constructor", zone, dateTime.getZone()); [EOL] }
public void testDateTimeConstructorValidDate() { [EOL] DateTime dateTime = new DateTime(2023, 3, 14, 15, 9); [EOL] assertNotNull(dateTime); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(14, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(9, dateTime.getMinuteOfHour()); [EOL] }
public void testDateTimeWithValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testWithZoneRetainFields_SameZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, zone); [EOL] DateTime result = dateTime.withZoneRetainFields(zone); [EOL] assertEquals(dateTime, result); [EOL] }
public void testWithZoneRetainFields_DifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone newZone = DateTimeZone.forID("America/New_York"); [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, originalZone); [EOL] DateTime result = dateTime.withZoneRetainFields(newZone); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.getMillis(), result.getMillis()); [EOL] assertEquals(newZone, result.getZone()); [EOL] }
public void testWithField_NullFieldType_ThrowsIllegalArgumentException() { [EOL] DateTime dateTime = new DateTime(); [EOL] try { [EOL] dateTime.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidFieldType_ReturnsNewDateTime() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 15; [EOL] DateTime updatedDateTime = dateTime.withField(fieldType, value); [EOL] assertNotNull(updatedDateTime); [EOL] assertEquals(value, updatedDateTime.get(fieldType)); [EOL] }
public void testPlus_withNullDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plus(null); [EOL] assertEquals(dateTime, result); [EOL] }
public void testPlus_withValidDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] Duration duration = new Duration(1000); [EOL] DateTime result = dateTime.plus(duration); [EOL] assertEquals(dateTime.plusMillis(1000), result); [EOL] }
public void testPlusWeeksWithZeroWeeks() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusWeeks(0); [EOL] assertSame("Should return the same DateTime object for zero weeks", dateTime, result); [EOL] }
public void testPlusWeeksWithPositiveWeeks() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusWeeks(1); [EOL] assertNotSame("Should not return the same DateTime object for positive weeks", dateTime, result); [EOL] assertEquals("The time should be one week later", dateTime.getMillis() + 604800000L, result.getMillis()); [EOL] }
public void testPlusWeeksWithNegativeWeeks() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusWeeks(-1); [EOL] assertNotSame("Should not return the same DateTime object for negative weeks", dateTime, result); [EOL] assertEquals("The time should be one week earlier", dateTime.getMillis() - 604800000L, result.getMillis()); [EOL] }
public void testPlusHours_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusHours(0); [EOL] assertSame("Expected same instance when adding zero hours", dateTime, result); [EOL] }
public void testPlusHours_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusHours(1); [EOL] assertNotSame("Expected different instance when adding hours", dateTime, result); [EOL] assertEquals("Expected time to be one hour ahead", dateTime.getMillis() + 3600000, result.getMillis()); [EOL] }
public void testPlusHours_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusHours(-1); [EOL] assertNotSame("Expected different instance when subtracting hours", dateTime, result); [EOL] assertEquals("Expected time to be one hour behind", dateTime.getMillis() - 3600000, result.getMillis()); [EOL] }
public void testPlusMinutes_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMinutes(0); [EOL] assertSame("Expected the same instance when adding zero minutes", dateTime, result); [EOL] }
public void testPlusMinutes_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMinutes(5); [EOL] assertNotSame("Expected a different instance when adding minutes", dateTime, result); [EOL] assertEquals("Expected the minutes to be added correctly", dateTime.getMinuteOfDay() + 5, result.getMinuteOfDay()); [EOL] }
public void testPlusMinutes_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMinutes(-5); [EOL] assertNotSame("Expected a different instance when subtracting minutes", dateTime, result); [EOL] assertEquals("Expected the minutes to be subtracted correctly", dateTime.getMinuteOfDay() - 5, result.getMinuteOfDay()); [EOL] }
public void testPlusSeconds_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusSeconds(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testPlusSeconds_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusSeconds(1); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.getMillis() + 1000, result.getMillis()); [EOL] }
public void testPlusSeconds_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusSeconds(-1); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.getMillis() - 1000, result.getMillis()); [EOL] }
public void testPlusMillis_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMillis(0); [EOL] assertSame("Expected the same instance when adding zero milliseconds", dateTime, result); [EOL] }
public void testPlusMillis_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMillis(1000); [EOL] assertEquals("Expected the DateTime to be 1000 milliseconds later", dateTime.getMillis() + 1000, result.getMillis()); [EOL] }
public void testPlusMillis_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMillis(-1000); [EOL] assertEquals("Expected the DateTime to be 1000 milliseconds earlier", dateTime.getMillis() - 1000, result.getMillis()); [EOL] }
public void testMinus_withNullDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minus(null); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinus_withValidDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] Duration duration = new Duration(1000); [EOL] DateTime result = dateTime.minus(duration); [EOL] DateTime expected = dateTime.minusMillis(1000); [EOL] assertEquals(expected, result); [EOL] }
public void testMinus_withNullPeriod() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minus(null); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] DateTime dateTime = new DateTime(); [EOL] Period period = new Period().withDays(1); [EOL] DateTime result = dateTime.minus(period); [EOL] DateTime expected = dateTime.minusDays(1); [EOL] assertEquals(expected, result); [EOL] }
public void testMinusYears_ZeroYears() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusYears(0); [EOL] assertSame("The result should be the same as the original DateTime object when subtracting zero years.", dateTime, result); [EOL] }
public void testMinusYears_NegativeYears() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusYears(-5); [EOL] assertNotNull("The result should not be null when subtracting negative years.", result); [EOL] assertNotSame("The result should not be the same as the original DateTime object when subtracting negative years.", dateTime, result); [EOL] assertTrue("The result should be later in time when subtracting negative years.", result.isAfter(dateTime)); [EOL] }
public void testMinusYears_PositiveYears() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusYears(5); [EOL] assertNotNull("The result should not be null when subtracting positive years.", result); [EOL] assertNotSame("The result should not be the same as the original DateTime object when subtracting positive years.", dateTime, result); [EOL] assertTrue("The result should be earlier in time when subtracting positive years.", result.isBefore(dateTime)); [EOL] }
public void testToDateMidnight() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateMidnight dateMidnight = dateTime.toDateMidnight(); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(dateTime.getMillis(), dateMidnight.getMillis()); [EOL] assertEquals(dateTime.getChronology(), dateMidnight.getChronology()); [EOL] }
public void testToLocalDate() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] LocalDate localDate = dateTime.toLocalDate(); [EOL] assertEquals(new LocalDate(2023, 4, 1), localDate); [EOL] }
public void testToLocalDateWithDifferentChronology() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0, CopticChronology.getInstance()); [EOL] LocalDate localDate = dateTime.toLocalDate(); [EOL] assertEquals(new LocalDate(2023, 4, 1, CopticChronology.getInstance()), localDate); [EOL] }
public void testWithHourOfDay_ValidHour() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validHour = 10; // Assuming 10 is within the valid range of hours [EOL] DateTime updatedDateTime = dateTime.withHourOfDay(validHour); [EOL] assertEquals(validHour, updatedDateTime.getHourOfDay()); [EOL] }
public void testWithHourOfDay_InvalidHour() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidHour = 25; // Assuming the valid range of hours is 0-23 [EOL] try { [EOL] dateTime.withHourOfDay(invalidHour); [EOL] fail("Should have thrown an exception for invalid hour"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMillisOfSecond_ValidMillis() { [EOL] DateTime dt = new DateTime(); [EOL] int validMillis = 500; [EOL] DateTime updatedDt = dt.withMillisOfSecond(validMillis); [EOL] assertEquals(validMillis, updatedDt.getMillisOfSecond()); [EOL] } [EOL] public void testWithMillisOfSecond_MinValue() { [EOL] DateTime dt = new DateTime(); [EOL] int minMillis = 0; [EOL] DateTime updatedDt = dt.withMillisOfSecond(minMillis); [EOL] assertEquals(minMillis, updatedDt.getMillisOfSecond()); [EOL] } [EOL] public void testWithMillisOfSecond_MaxValue() { [EOL] DateTime dt = new DateTime(); [EOL] int maxMillis = 999; [EOL] DateTime updatedDt = dt.withMillisOfSecond(maxMillis); [EOL] assertEquals(maxMillis, updatedDt.getMillisOfSecond()); [EOL] }
public void testEraProperty() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property eraProperty = dateTime.era(); [EOL] assertNotNull("Era property should not be null", eraProperty); [EOL] assertEquals("Era property should be equal to the era of the chronology", dateTime.getChronology().era(), eraProperty.getField()); [EOL] assertSame("Era property should be linked to the original DateTime object", dateTime, eraProperty.getReadableInstant()); [EOL] }
public void testWeekOfWeekyear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.weekOfWeekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().weekOfWeekyear(), property.getField()); [EOL] assertEquals(dateTime.getWeekOfWeekyear(), property.get()); [EOL] }
public void testMillisOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.millisOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().millisOfDay(), property.getField()); [EOL] assertEquals(dateTime.getMillis(), property.getMillis()); [EOL] }
protected Chronology getChronology() { [EOL] return iInstant.getChronology(); [EOL] }
public void testWithMinimumValue_NormalCase() { [EOL] DateTime testDateTime = new DateTime(); // Assuming this is a valid DateTime object [EOL] DateTime minimumDateTime = testDateTime.withMinimumValue(); [EOL] long expectedMillis = testDateTime.getChronology().getMinimumValue(); // Assuming getMinimumValue() returns the minimum millis [EOL] assertEquals(expectedMillis, minimumDateTime.getMillis()); [EOL] }
public void testWithMinimumValue_IllegalInstantException() { [EOL] DateTime testDateTime = new DateTime(); // Assuming this is a valid DateTime object [EOL] DateTimeZone zone = mock(DateTimeZone.class); // Mocking DateTimeZone [EOL] Chronology chronology = mock(Chronology.class); // Mocking Chronology [EOL] when(testDateTime.getChronology()).thenReturn(chronology); [EOL] when(chronology.getZone()).thenReturn(zone); [EOL] when(zone.nextTransition(anyLong())).thenReturn(1234567890L); // Mocked response for nextTransition [EOL] when(testDateTime.getMillis()).thenThrow(new IllegalInstantException()); // Mocking an IllegalInstantException [EOL] DateTime resultDateTime = testDateTime.withMinimumValue(); [EOL] assertEquals(1234567890L, resultDateTime.getMillis()); [EOL] assertEquals(chronology, resultDateTime.getChronology()); [EOL] }
public void testZoneInfoProviderWithNullFileDir() { [EOL] try { [EOL] new ZoneInfoProvider(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("No file directory provided", ex.getMessage()); [EOL] } catch (IOException ex) { [EOL] fail("Expected IllegalArgumentException, not IOException"); [EOL] } [EOL] }
public void testZoneInfoProviderWithNonExistentFileDir() { [EOL] File nonExistentFileDir = new File("nonexistentdir"); [EOL] try { [EOL] new ZoneInfoProvider(nonExistentFileDir); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException ex) { [EOL] assertTrue(ex.getMessage().contains("File directory doesn't exist")); [EOL] } [EOL] }
public void testZoneInfoProviderWithFileInsteadOfDirectory() { [EOL] File fileInsteadOfDirectory = new File("somefile.txt"); [EOL] fileInsteadOfDirectory.createNewFile(); [EOL] try { [EOL] new ZoneInfoProvider(fileInsteadOfDirectory); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException ex) { [EOL] assertTrue(ex.getMessage().contains("File doesn't refer to a directory")); [EOL] } finally { [EOL] fileInsteadOfDirectory.delete(); [EOL] } [EOL] }
public void testZoneInfoProviderWithValidDirectory() throws IOException { [EOL] File validDirectory = new File("validDir"); [EOL] validDirectory.mkdir(); [EOL] try { [EOL] ZoneInfoProvider provider = new ZoneInfoProvider(validDirectory); [EOL] assertNotNull(provider); [EOL] } finally { [EOL] validDirectory.delete(); [EOL] } [EOL] }
public void testZoneInfoProviderWithValidResourcePath() throws IOException { [EOL] String resourcePath = "valid/path/to/resource"; [EOL] ZoneInfoProvider provider = new ZoneInfoProvider(resourcePath); [EOL] assertNotNull(provider); [EOL] }
public void testZoneInfoProviderWithNullResourcePath() { [EOL] String resourcePath = null; [EOL] try { [EOL] new ZoneInfoProvider(resourcePath); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IOException e) { [EOL] fail("Should not have thrown IOException"); [EOL] } [EOL] }
public void testZoneInfoProvider_NullResourcePath() { [EOL] ClassLoader classLoader = getClass().getClassLoader(); [EOL] try { [EOL] new ZoneInfoProvider(null, classLoader, false); [EOL] fail("Should have thrown IllegalArgumentException for null resourcePath"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No resource path provided", e.getMessage()); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown for null resourcePath"); [EOL] } [EOL] }
public void testZoneInfoProvider_ValidResourcePathWithoutTrailingSlash() throws IOException { [EOL] String resourcePath = "validPath"; [EOL] ClassLoader classLoader = getClass().getClassLoader(); [EOL] ZoneInfoProvider zip = new ZoneInfoProvider(resourcePath, classLoader, false); [EOL] assertNotNull(zip); [EOL] assertEquals("validPath/", zip.getResourcePath()); [EOL] }
public void testZoneInfoProvider_ValidResourcePathWithTrailingSlash() throws IOException { [EOL] String resourcePath = "validPath/"; [EOL] ClassLoader classLoader = getClass().getClassLoader(); [EOL] ZoneInfoProvider zip = new ZoneInfoProvider(resourcePath, classLoader, false); [EOL] assertNotNull(zip); [EOL] assertEquals("validPath/", zip.getResourcePath()); [EOL] }
public void testZoneInfoProvider_NullLoaderWithoutFavorSystemLoader() throws IOException { [EOL] String resourcePath = "validPath/"; [EOL] ZoneInfoProvider zip = new ZoneInfoProvider(resourcePath, null, false); [EOL] assertNotNull(zip); [EOL] assertNotNull(zip.getLoader()); [EOL] }
public void testZoneInfoProvider_NullLoaderWithFavorSystemLoader() throws IOException { [EOL] String resourcePath = "validPath/"; [EOL] ZoneInfoProvider zip = new ZoneInfoProvider(resourcePath, null, true); [EOL] assertNotNull(zip); [EOL] assertNull(zip.getLoader()); [EOL] }
public void testGetZoneWithNullId() { [EOL] DateTimeZone result = getZone(null); [EOL] assertNull(result); [EOL] }
public void testGetZoneWithUnknownId() { [EOL] DateTimeZone result = getZone("Unknown"); [EOL] assertNull(result); [EOL] }
public void testGetZoneWithMatchingId() { [EOL] iZoneInfoMap.put("ValidId", "ValidId"); [EOL] DateTimeZone expectedZone = new DateTimeZone("ValidId"); [EOL] when(loadZoneData("ValidId")).thenReturn(expectedZone); [EOL] DateTimeZone result = getZone("ValidId"); [EOL] assertSame(expectedZone, result); [EOL] }
public void testGetZoneWithSoftReference() { [EOL] DateTimeZone expectedZone = new DateTimeZone("SoftRefId"); [EOL] SoftReference<DateTimeZone> softRef = new SoftReference<>(expectedZone); [EOL] iZoneInfoMap.put("SoftRefId", softRef); [EOL] DateTimeZone result = getZone("SoftRefId"); [EOL] assertSame(expectedZone, result); [EOL] }
public void testGetZoneWithClearedSoftReference() { [EOL] SoftReference<DateTimeZone> softRef = new SoftReference<>(null); [EOL] iZoneInfoMap.put("ClearedSoftRefId", softRef); [EOL] DateTimeZone expectedZone = new DateTimeZone("ClearedSoftRefId"); [EOL] when(loadZoneData("ClearedSoftRefId")).thenReturn(expectedZone); [EOL] DateTimeZone result = getZone("ClearedSoftRefId"); [EOL] assertSame(expectedZone, result); [EOL] }
public void testGetZoneWithRedirectId() { [EOL] iZoneInfoMap.put("RedirectId", "ActualId"); [EOL] DateTimeZone expectedZone = new DateTimeZone("ActualId"); [EOL] when(getZone("ActualId")).thenReturn(expectedZone); [EOL] DateTimeZone result = getZone("RedirectId"); [EOL] assertSame(expectedZone, result); [EOL] }
public void testGetAvailableIDs_NonEmptyMap() { [EOL] Map<String, DateTimeZone> mockZoneInfoMap = new HashMap<>(); [EOL] mockZoneInfoMap.put("America/New_York", DateTimeZone.forID("America/New_York")); [EOL] mockZoneInfoMap.put("Europe/London", DateTimeZone.forID("Europe/London")); [EOL] ReflectionTestUtils.setField(time, "iZoneInfoMap", mockZoneInfoMap); [EOL] Set<String> result = time.getAvailableIDs(); [EOL] assertNotNull("The result should not be null.", result); [EOL] assertEquals("The size of the result set should be equal to the number of entries in the map.", mockZoneInfoMap.size(), result.size()); [EOL] assertTrue("The result should contain all keys from the map.", result.containsAll(mockZoneInfoMap.keySet())); [EOL] }
public void testGetAvailableIDs_EmptyMap() { [EOL] Map<String, DateTimeZone> mockZoneInfoMap = new HashMap<>(); [EOL] ReflectionTestUtils.setField(time, "iZoneInfoMap", mockZoneInfoMap); [EOL] Set<String> result = time.getAvailableIDs(); [EOL] assertNotNull("The result should not be null.", result); [EOL] assertTrue("The result set should be empty.", result.isEmpty()); [EOL] }
public void testOpenResourceWithFileDirNotNull() throws IOException { [EOL] Time time = new Time(); [EOL] time.iFileDir = new File("path/to/directory"); [EOL] String resourceName = "testResource.txt"; [EOL] InputStream result = time.openResource(resourceName); [EOL] assertNotNull(result); [EOL] result.close(); [EOL] }
public void testOpenResourceWithFileDirNullAndLoaderNotNull() throws IOException { [EOL] Time time = new Time(); [EOL] time.iFileDir = null; [EOL] time.iLoader = this.getClass().getClassLoader(); [EOL] String resourceName = "testResource.txt"; [EOL] InputStream result = time.openResource(resourceName); [EOL] assertNotNull(result); [EOL] result.close(); [EOL] }
public void testOpenResourceWithFileDirNullAndLoaderNullResourceExists() throws IOException { [EOL] Time time = new Time(); [EOL] time.iFileDir = null; [EOL] time.iLoader = null; [EOL] time.iResourcePath = "/path/to/resources/"; [EOL] String resourceName = "testResource.txt"; [EOL] InputStream result = time.openResource(resourceName); [EOL] assertNotNull(result); [EOL] result.close(); [EOL] }
public void testOpenResourceWithFileDirNullAndLoaderNullResourceNotFound() { [EOL] Time time = new Time(); [EOL] time.iFileDir = null; [EOL] time.iLoader = null; [EOL] time.iResourcePath = "/path/to/nonexistent/"; [EOL] String resourceName = "nonexistentResource.txt"; [EOL] try { [EOL] time.openResource(resourceName); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("Resource not found: \"/path/to/nonexistent/nonexistentResource.txt\" ClassLoader: system", e.getMessage()); [EOL] } [EOL] }
public void testLoadZoneInfoMap_ValidInputStream() throws IOException { [EOL] InputStream mockInputStream = createValidMockInputStream(); [EOL] Map<String, Object> result = loadZoneInfoMap(mockInputStream); [EOL] assertNotNull("Map should not be null", result); [EOL] assertTrue("Map should contain key 'UTC'", result.containsKey("UTC")); [EOL] Object utcValue = result.get("UTC"); [EOL] assertTrue("Value for key 'UTC' should be a SoftReference", utcValue instanceof SoftReference); [EOL] SoftReference<DateTimeZone> utcRef = (SoftReference<DateTimeZone>) utcValue; [EOL] assertNotNull("SoftReference should not be null", utcRef.get()); [EOL] assertEquals("SoftReference should refer to DateTimeZone.UTC", DateTimeZone.UTC, utcRef.get()); [EOL] } [EOL] public void testLoadZoneInfoMap_IOExceptionOnClose() throws IOException { [EOL] InputStream mockInputStream = createMockInputStreamThatThrowsOnClose(); [EOL] Map<String, Object> result = null; [EOL] try { [EOL] result = loadZoneInfoMap(mockInputStream); [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown when closing the stream"); [EOL] } [EOL] assertNotNull("Map should not be null even if IOException is thrown on close", result); [EOL] } [EOL] private InputStream createValidMockInputStream() { [EOL] } [EOL] private InputStream createMockInputStreamThatThrowsOnClose() { [EOL] }
public void testReadZoneInfoMap_ValidData() throws IOException { [EOL] DataInputStream din = createDataInputStreamWithValidData(); [EOL] Map<String, Object> zimap = new HashMap<>(); [EOL] readZoneInfoMap(din, zimap); [EOL] assertEquals("Expected map size after reading valid data", expectedSize, zimap.size()); [EOL] for (String key : expectedKeys) { [EOL] assertTrue("Expected key in map", zimap.containsKey(key)); [EOL] } [EOL] } [EOL] public void testReadZoneInfoMap_EmptyData() throws IOException { [EOL] DataInputStream din = createDataInputStreamWithEmptyData(); [EOL] Map<String, Object> zimap = new HashMap<>(); [EOL] readZoneInfoMap(din, zimap); [EOL] assertTrue("Expected empty map after reading empty data", zimap.isEmpty()); [EOL] } [EOL] public void testReadZoneInfoMap_CorruptData_ThrowsIOException() { [EOL] DataInputStream din = createDataInputStreamWithCorruptData(); [EOL] Map<String, Object> zimap = new HashMap<>(); [EOL] try { [EOL] readZoneInfoMap(din, zimap); [EOL] fail("Expected IOException due to corrupt data"); [EOL] } catch (IOException e) { [EOL] assertEquals("Corrupt zone info map", e.getMessage()); [EOL] } [EOL] }

public void testPeriodFormatterConstructorWithNonNullPrinterAndParser() { [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] PeriodFormatter formatter = new PeriodFormatter(printer, parser); [EOL] assertNotNull(formatter); [EOL] assertSame(printer, formatter.getPrinter()); [EOL] assertSame(parser, formatter.getParser()); [EOL] assertNull(formatter.getLocale()); [EOL] assertNull(formatter.getParseType()); [EOL] }
public void testPeriodFormatterConstructorWithNullPrinterAndParser() { [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null); [EOL] assertNotNull(formatter); [EOL] assertNull(formatter.getPrinter()); [EOL] assertNull(formatter.getParser()); [EOL] assertNull(formatter.getLocale()); [EOL] assertNull(formatter.getParseType()); [EOL] }
public void testGetPrinter() { [EOL] PeriodPrinter expectedPrinter = new PeriodPrinter(); [EOL] Time time = new Time(expectedPrinter); [EOL] PeriodPrinter actualPrinter = time.getPrinter(); [EOL] assertEquals(expectedPrinter, actualPrinter); [EOL] }
public void testWithParseType_SameType() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, null, type); [EOL] PeriodFormatter result = formatter.withParseType(type); [EOL] assertSame(formatter, result); [EOL] }
public void testWithParseType_DifferentType() { [EOL] PeriodType type1 = PeriodType.standard(); [EOL] PeriodType type2 = PeriodType.days(); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, null, type1); [EOL] PeriodFormatter result = formatter.withParseType(type2); [EOL] assertNotNull(result); [EOL] assertNotSame(formatter, result); [EOL] assertEquals(type2, result.getParseType()); [EOL] }
public PeriodType getParseType() { [EOL] return iParseType; [EOL] }
public void testPrintToWithNullBuffer() { [EOL] try { [EOL] PeriodFormatter formatter = createFormatter(); [EOL] formatter.printTo((StringBuffer) null, new Period()); [EOL] fail("Should have thrown IllegalArgumentException for null StringBuffer"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPrintToWithNullPeriod() { [EOL] try { [EOL] PeriodFormatter formatter = createFormatter(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] formatter.printTo(buf, null); [EOL] fail("Should have thrown IllegalArgumentException for null ReadablePeriod"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPrintTo() { [EOL] PeriodFormatter formatter = createFormatter(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = new Period(); [EOL] formatter.printTo(buf, period); [EOL] assertNotNull("Buffer should not be null", buf); [EOL] assertTrue("Buffer should contain formatted period", buf.length() > 0); [EOL] } [EOL] private PeriodFormatter createFormatter() { [EOL] return new PeriodFormatter(null, null); // Replace with actual printer and locale [EOL] }
public void testPrintWithValidPeriod() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockPrinter = mock(PeriodPrinter.class); [EOL] when(mockPrinter.calculatePrintedLength(mockPeriod, iLocale)).thenReturn(10); [EOL] doNothing().when(mockPrinter).printTo(any(StringBuffer.class), eq(mockPeriod), eq(iLocale)); [EOL] setPrinter(mockPrinter); [EOL] String result = print(mockPeriod); [EOL] assertNotNull(result); [EOL] verify(mockPrinter).calculatePrintedLength(mockPeriod, iLocale); [EOL] verify(mockPrinter).printTo(any(StringBuffer.class), eq(mockPeriod), eq(iLocale)); [EOL] }
public void testPrintWithNullPeriod() { [EOL] try { [EOL] print(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintWithNoPrinter() { [EOL] setPrinter(null); [EOL] try { [EOL] print(mock(ReadablePeriod.class)); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
private void checkPrinter() { [EOL] if (iPrinter == null) { [EOL] throw new UnsupportedOperationException("Printing not supported"); [EOL] } [EOL] }
public void testCheckPeriodWithNull() { [EOL] try { [EOL] checkPeriod(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Period must not be null", e.getMessage()); [EOL] } [EOL] }
public void testCheckPeriodWithNonNull() { [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] checkPeriod(period); // Should not throw an exception [EOL] }
public void testPartialConstructor_NullTypes() { [EOL] try { [EOL] new Partial(null, new int[]{1, 2, 3}, null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_NullValues() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null values array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_InequalLengthArrays() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types and values array of different lengths"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_EmptyArrays() { [EOL] Partial partial = new Partial(new DateTimeFieldType[]{}, new int[]{}, null); [EOL] assertEquals(0, partial.size()); [EOL] } [EOL] public void testPartialConstructor_NullTypeElement() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{null}, new int[]{1}, null); [EOL] fail("Should have thrown IllegalArgumentException for null element in types array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_UnsupportedType() { [EOL] DateTimeFieldType unsupportedType = new DateTimeFieldType("unsupported") { [EOL] public DurationFieldType getDurationType() { [EOL] return DurationFieldType.days(); [EOL] } [EOL] public DurationFieldType getRangeDurationType() { [EOL] return null; [EOL] } [EOL] public DateTimeField getField(Chronology chronology) { [EOL] return UnsupportedDateTimeField.getInstance(getDurationType(), getRangeDurationType()); [EOL] } [EOL] }; [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.years(), unsupportedType}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for unsupported type following a supported one"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_TypesNotInOrder() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.hours(), DateTimeFieldType.days()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types not in order largest-smallest"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_DuplicateTypes() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.years(), DateTimeFieldType.years()}, new int[]{1, 1}, null); [EOL] fail("Should have thrown IllegalArgumentException for duplicate types"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_ValidInput() { [EOL] Partial partial = new Partial(new DateTimeFieldType[]{DateTimeFieldType.years(), DateTimeFieldType.monthOfYear()}, new int[]{1, 2}, null); [EOL] assertEquals(2, partial.size()); [EOL] assertEquals(DateTimeFieldType.years(), partial.getFieldType(0)); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), partial.getFieldType(1)); [EOL] }
public void testWithField_SameValue() { [EOL] Partial partial = createPartial(); // Assume createPartial() creates a valid Partial instance [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Assume this is a supported field type [EOL] int currentValue = partial.getValue(partial.indexOfSupported(fieldType)); [EOL] Partial result = partial.withField(fieldType, currentValue); [EOL] assertSame("Expected same instance when setting the same value", partial, result); [EOL] }
public void testWithField_DifferentValue() { [EOL] Partial partial = createPartial(); // Assume createPartial() creates a valid Partial instance [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Assume this is a supported field type [EOL] int currentValue = partial.getValue(partial.indexOfSupported(fieldType)); [EOL] int newValue = currentValue + 1; [EOL] Partial result = partial.withField(fieldType, newValue); [EOL] assertNotSame("Expected different instance when setting a new value", partial, result); [EOL] assertEquals("Expected new value to be set", newValue, result.getValue(partial.indexOfSupported(fieldType))); [EOL] }
public void testWithField_UnsupportedType() { [EOL] Partial partial = createPartial(); // Assume createPartial() creates a valid Partial instance [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assume this is an unsupported field type [EOL] try { [EOL] partial.withField(fieldType, 1); [EOL] fail("Expected exception when setting an unsupported field type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] Partial partial = new Partial(); [EOL] Partial result = partial.withPeriodAdded(null, 1); [EOL] assertSame("Method should return the same partial when period is null", partial, result); [EOL] } [EOL] public void testWithPeriodAdded_ZeroScalar() { [EOL] Partial partial = new Partial(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] Partial result = partial.withPeriodAdded(period, 0); [EOL] assertSame("Method should return the same partial when scalar is zero", partial, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriod() { [EOL] Partial partial = new Partial(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] Partial result = partial.withPeriodAdded(period, 1); [EOL] assertNotNull("Method should not return null when period is non-null", result); [EOL] assertNotSame("Method should not return the same partial when period is non-null", partial, result); [EOL] }
public void testWithPeriodAdded_ValidPeriodAndScalar() { [EOL] Partial partial = new Partial(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] int scalar = 2; [EOL] Partial result = partial.withPeriodAdded(period, scalar); [EOL] assertNotNull("Method should not return null with valid period and scalar", result); [EOL] assertNotSame("Method should not return the same partial with valid period and scalar", partial, result); [EOL] }
public void testPlus_withNullPeriod() { [EOL] Partial partial = new Partial(); [EOL] Partial result = partial.plus(null); [EOL] assertEquals(partial, result); [EOL] }
public void testPlus_withValidPeriod() { [EOL] Partial partial = new Partial(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] Partial result = partial.plus(period); [EOL] assertNotSame(partial, result); [EOL] assertEquals(partial.getChronology(), result.getChronology()); [EOL] assertTrue(result.isSupported(DateTimeFieldType.year())); [EOL] assertEquals(1, result.get(DateTimeFieldType.year())); [EOL] }
public void testMinus_withNullPeriod() { [EOL] Partial partial = new Partial(); [EOL] Partial result = partial.minus(null); [EOL] assertEquals(partial, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] Partial partial = new Partial(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] Partial result = partial.minus(period); [EOL] Partial expected = partial.withPeriodAdded(period, -1); [EOL] assertEquals(expected, result); [EOL] }
public void testIsMatch_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] boolean result = isMatch(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The partial must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testIsMatch_PartialNotMatching_ReturnsFalse() { [EOL] ReadablePartial mockPartial = createMockPartial(new int[] {1, 2}, new int[] {3, 4}); [EOL] boolean result = isMatch(mockPartial); [EOL] assertFalse(result); [EOL] }
public void testIsMatch_PartialMatching_ReturnsTrue() { [EOL] ReadablePartial mockPartial = createMockPartial(new int[] {1, 2}, new int[] {1, 2}); [EOL] boolean result = isMatch(mockPartial); [EOL] assertTrue(result); [EOL] } [EOL] private ReadablePartial createMockPartial(int[] types, int[] values) { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] for (int i = 0; i < types.length; i++) { [EOL] when(mockPartial.get(types[i])).thenReturn(values[i]); [EOL] } [EOL] return mockPartial; [EOL] }
public void testToStringWithNullFormatterArray() { [EOL] this.iFormatter = null; [EOL] String result = this.toString(); [EOL] assertEquals("ExpectedResultFromToStringList", result); [EOL] }
public void testToStringWithNonNullFormatterArrayButNullElement() { [EOL] this.iFormatter = new DateTimeFormatter[2]; [EOL] this.iFormatter[1] = null; [EOL] String result = this.toString(); [EOL] assertEquals("ExpectedResultFromToStringList", result); [EOL] }
public void testToStringWithNonNullFormatterArrayAndNonNullElement() { [EOL] this.iFormatter = new DateTimeFormatter[2]; [EOL] this.iFormatter[1] = mock(DateTimeFormatter.class); [EOL] when(this.iFormatter[1].print(this)).thenReturn("FormattedString"); [EOL] String result = this.toString(); [EOL] assertEquals("FormattedString", result); [EOL] }
public void testToStringList_Empty() { [EOL] initializeEmptyObject(); [EOL] String result = toStringList(); [EOL] assertEquals("[]", result); [EOL] }
public void testToStringList_SingleElement() { [EOL] initializeObjectWithSingleElement("Type1", 1); [EOL] String result = toStringList(); [EOL] assertEquals("[Type1=1]", result); [EOL] }
public void testToStringList_MultipleElements() { [EOL] initializeObjectWithMultipleElements(new String[]{"Type1", "Type2"}, new int[]{1, 2}); [EOL] String result = toStringList(); [EOL] assertEquals("[Type1=1, Type2=2]", result); [EOL] }
public void testToStringWithNullPattern() { [EOL] Time time = new Time(); [EOL] String defaultToString = time.toString(); [EOL] String result = time.toString(null); [EOL] assertEquals(defaultToString, result); [EOL] }
public void testToStringWithValidPattern() { [EOL] Time time = new Time(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String expected = DateTimeFormat.forPattern(pattern).print(time); [EOL] String result = time.toString(pattern); [EOL] assertEquals(expected, result); [EOL] }
public void testToStringWithNullPattern() { [EOL] Time time = new Time(); // Assuming Time is the class where toString method is defined [EOL] String pattern = null; [EOL] Locale locale = Locale.getDefault(); // Use default locale for this test [EOL] String result = time.toString(pattern, locale); [EOL] assertEquals(time.toString(), result); [EOL] }
public void testToStringWithNonNullPattern() { [EOL] Time time = new Time(); // Assuming Time is the class where toString method is defined [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; // Use a specific locale for this test [EOL] String result = time.toString(pattern, locale); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeFormat.forPattern(pattern).withLocale(locale).print(time), result); [EOL] }
public void testAddToCopy_Zero() { [EOL] Partial partial = new Partial(); // Assuming constructor and state initialization [EOL] int valueToAdd = 0; [EOL] Partial result = partial.addToCopy(valueToAdd); [EOL] assertEquals(partial, result); // Assuming a valid equals method [EOL] } [EOL] public void testAddToCopy_Positive() { [EOL] Partial partial = new Partial(); // Assuming constructor and state initialization [EOL] int valueToAdd = 1; [EOL] Partial result = partial.addToCopy(valueToAdd); [EOL] assertNotSame(partial, result); // Ensure a new object is returned [EOL] int[] expectedValues = new int[]{/* expected values after adding 1 */}; [EOL] assertTrue(Arrays.equals(expectedValues, result.getValues())); // Assuming a getValues method [EOL] } [EOL] public void testAddToCopy_Negative() { [EOL] Partial partial = new Partial(); // Assuming constructor and state initialization [EOL] int valueToAdd = -1; [EOL] Partial result = partial.addToCopy(valueToAdd); [EOL] assertNotSame(partial, result); // Ensure a new object is returned [EOL] int[] expectedValues = new int[]{/* expected values after subtracting 1 */}; [EOL] assertTrue(Arrays.equals(expectedValues, result.getValues())); // Assuming a getValues method [EOL] }

public Partial withMaximumValue() { [EOL] return setCopy(getMaximumValue()); [EOL] }
public void testBaseDurationWithPositiveDuration() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] BaseDuration duration = new BaseDuration(startInstant, endInstant); [EOL] assertEquals(1000L, duration.getMillis()); [EOL] }
public void testBaseDurationWithNegativeDuration() { [EOL] long startInstant = 2000L; [EOL] long endInstant = 1000L; [EOL] BaseDuration duration = new BaseDuration(startInstant, endInstant); [EOL] assertEquals(-1000L, duration.getMillis()); [EOL] }
public void testBaseDurationWithZeroDuration() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 1000L; [EOL] BaseDuration duration = new BaseDuration(startInstant, endInstant); [EOL] assertEquals(0L, duration.getMillis()); [EOL] }
public void testToPeriodFromWithNullStartInstant() { [EOL] try { [EOL] DateTime endInstant = new DateTime(); [EOL] endInstant.toPeriodFrom(null); [EOL] fail("Should have thrown IllegalArgumentException because startInstant is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToPeriodFromWithNonNullStartInstant() { [EOL] DateTime startInstant = new DateTime(); [EOL] DateTime endInstant = new DateTime(startInstant.getMillis() + 1000); // 1 second later [EOL] Period result = endInstant.toPeriodFrom(startInstant); [EOL] assertNotNull("Resulting Period should not be null", result); [EOL] assertEquals("Period should be 1 second", 1000, result.toDurationMillis()); [EOL] }
public void testYearsInWithNullInterval() { [EOL] Years result = Time.yearsIn(null); [EOL] assertEquals(Years.ZERO, result); [EOL] }
public void testYearsInWithValidInterval() { [EOL] ReadableInterval interval = new Interval(new DateTime(0), new DateTime().plusYears(5)); [EOL] Years result = Time.yearsIn(interval); [EOL] assertEquals(Years.years(5), result); [EOL] }
private Object readResolve() { [EOL] return Years.years(getValue()); [EOL] }
public DurationFieldType getFieldType() { [EOL] return DurationFieldType.years(); [EOL] }
public void testGetPeriodType_ReturnsYears() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] PeriodType result = timePeriod.getPeriodType(); [EOL] assertEquals(PeriodType.years(), result); [EOL] }
public void testPlus_ZeroYears() { [EOL] Years initialYears = Years.years(5); [EOL] Years result = initialYears.plus(0); [EOL] assertEquals("Adding zero should return the same Years instance", initialYears, result); [EOL] }
public void testPlus_PositiveYears() { [EOL] Years initialYears = Years.years(5); [EOL] Years result = initialYears.plus(3); [EOL] assertEquals("Adding positive years should return the correct Years instance", 8, result.getValue()); [EOL] }
public void testPlus_NegativeYears() { [EOL] Years initialYears = Years.years(5); [EOL] Years result = initialYears.plus(-3); [EOL] assertEquals("Adding negative years should return the correct Years instance", 2, result.getValue()); [EOL] }
public void testPlus_withNull() { [EOL] Years yearsBase = Years.years(5); [EOL] Years result = yearsBase.plus(null); [EOL] assertEquals(yearsBase, result); [EOL] }
public void testPlus_withNonNull() { [EOL] Years yearsBase = Years.years(5); [EOL] Years yearsToAdd = Years.years(3); [EOL] Years result = yearsBase.plus(yearsToAdd); [EOL] assertEquals(Years.years(8), result); [EOL] }
public void testWithMillis_SameMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] Instant instant = new Instant(currentMillis); [EOL] Instant result = instant.withMillis(currentMillis); [EOL] assertSame("Should be the same instance since millis are the same", instant, result); [EOL] }
public void testWithMillis_DifferentMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] Instant instant = new Instant(currentMillis); [EOL] long newMillis = currentMillis + 1000; // Assuming newMillis is different [EOL] Instant result = instant.withMillis(newMillis); [EOL] assertNotSame("Should not be the same instance since millis are different", instant, result); [EOL] assertEquals("The millis of the result should be the new millis", newMillis, result.getMillis()); [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] Instant instant = Instant.now(); [EOL] Instant result = instant.withDurationAdded(0, 1); [EOL] assertSame("Expected same instance when duration to add is zero", instant, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] Instant instant = Instant.now(); [EOL] Instant result = instant.withDurationAdded(10, 0); [EOL] assertSame("Expected same instance when scalar is zero", instant, result); [EOL] }
public void testWithDurationAdded_NonZeroDurationAndScalar() { [EOL] Instant instant = Instant.now(); [EOL] long durationToAdd = 10; [EOL] int scalar = 2; [EOL] Instant result = instant.withDurationAdded(durationToAdd, scalar); [EOL] assertNotSame("Expected different instance when duration and scalar are non-zero", instant, result); [EOL] assertEquals("Expected instant with added duration", instant.getMillis() + durationToAdd * scalar, result.getMillis()); [EOL] }
public void testWithDurationAdded_NullDuration() { [EOL] Instant instant = Instant.now(); [EOL] Instant result = instant.withDurationAdded(null, 1); [EOL] assertEquals(instant, result); [EOL] } [EOL] public void testWithDurationAdded_ZeroScalar() { [EOL] Instant instant = Instant.now(); [EOL] ReadableDuration duration = new Duration(1000); [EOL] Instant result = instant.withDurationAdded(duration, 0); [EOL] assertEquals(instant, result); [EOL] } [EOL] public void testWithDurationAdded_NonNullDurationNonZeroScalar() { [EOL] Instant instant = Instant.now(); [EOL] ReadableDuration duration = new Duration(1000); [EOL] Instant expected = instant.plus(1000L * 2); [EOL] Instant result = instant.withDurationAdded(duration, 2); [EOL] assertEquals(expected, result); [EOL] }

public Instant plus(long duration) { [EOL] return withDurationAdded(duration, 1); [EOL] }
public void testMinus_withNullDuration() { [EOL] Instant instant = Instant.now(); [EOL] try { [EOL] instant.minus(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMinus_withZeroDuration() { [EOL] Instant instant = Instant.now(); [EOL] ReadableDuration zeroDuration = Duration.ZERO; [EOL] Instant result = instant.minus(zeroDuration); [EOL] assertEquals("Subtracting zero duration should not change the instant", instant, result); [EOL] }
public void testMinus_withPositiveDuration() { [EOL] Instant instant = Instant.now(); [EOL] ReadableDuration positiveDuration = new Duration(1000); [EOL] Instant expected = instant.minusMillis(1000); [EOL] Instant result = instant.minus(positiveDuration); [EOL] assertEquals("Subtracting positive duration should decrease the instant", expected, result); [EOL] }
public void testMinus_withNegativeDuration() { [EOL] Instant instant = Instant.now(); [EOL] ReadableDuration negativeDuration = new Duration(-1000); [EOL] Instant expected = instant.plusMillis(1000); [EOL] Instant result = instant.minus(negativeDuration); [EOL] assertEquals("Subtracting negative duration should increase the instant", expected, result); [EOL] }
public void testToDateTimeISO() { [EOL] YourClass instance = new YourClass(); // Replace YourClass with the actual class name [EOL] DateTime result = instance.toDateTimeISO(); [EOL] assertNotNull("The result should not be null", result); [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] LocalDate expected = new LocalDate(zone); [EOL] LocalDate actual = Time.now(zone); [EOL] assertEquals(expected, actual); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] Time.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Zone must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] LocalDate.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] LocalDate result = LocalDate.now(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testLocalDateConstructor() { [EOL] LocalDate date = new LocalDate(); [EOL] assertNotNull(date); [EOL] assertEquals(ISOChronology.getInstance(), date.getChronology()); [EOL] assertEquals(DateTimeUtils.currentTimeMillis(), date.toDate().getTime(), 1000); [EOL] }
public void testLocalDateWithValidInstant() { [EOL] long instant = 1580515200000L; // 2020-02-01T00:00:00Z [EOL] LocalDate date = new LocalDate(instant); [EOL] assertNotNull(date); [EOL] assertEquals(2020, date.getYear()); [EOL] assertEquals(2, date.getMonthOfYear()); [EOL] assertEquals(1, date.getDayOfMonth()); [EOL] }

public void testLocalDateWithInstantAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] LocalDate date = new LocalDate(instant, zone); [EOL] assertNotNull(date); [EOL] }
public void testLocalDateWithInstantAndUTCZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] LocalDate date = new LocalDate(instant, zone); [EOL] assertNotNull(date); [EOL] assertEquals(ISOChronology.getInstanceUTC(), date.getChronology()); [EOL] }
public void testLocalDateWithNullInstant() { [EOL] Object instant = null; [EOL] try { [EOL] new LocalDate(instant); [EOL] fail("Should have thrown IllegalArgumentException for null instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithValidInstant() { [EOL] Object instant = new Date(); [EOL] LocalDate localDate = new LocalDate(instant); [EOL] assertNotNull("LocalDate should not be null with a valid instant", localDate); [EOL] }
public void testLocalDateWithValidInstantAndChronology() { [EOL] Object instant = "2023-01-01"; // Assuming the instant can be a String that is parsable [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); // Using a specific chronology for the test [EOL] LocalDate localDate = new LocalDate(instant, chronology); [EOL] assertNotNull(localDate); [EOL] assertEquals(chronology.withUTC(), localDate.getChronology()); [EOL] assertEquals(2023, localDate.getYear()); [EOL] assertEquals(1, localDate.getMonthOfYear()); [EOL] assertEquals(1, localDate.getDayOfMonth()); [EOL] }
public void testLocalDateWithNullInstantAndChronology() { [EOL] Object instant = null; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] LocalDate localDate = new LocalDate(instant, chronology); [EOL] fail("Should have thrown an exception because instant is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithInvalidInstantAndChronology() { [EOL] Object instant = new Object(); // An instant that is not a valid type [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] LocalDate localDate = new LocalDate(instant, chronology); [EOL] fail("Should have thrown an exception because instant is of an invalid type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithValidInstantAndNullChronology() { [EOL] Object instant = "2023-01-01"; [EOL] Chronology chronology = null; // Passing null to test default chronology usage [EOL] LocalDate localDate = new LocalDate(instant, chronology); [EOL] assertNotNull(localDate); [EOL] assertNotNull(localDate.getChronology()); // Should not be null, should default to ISOChronology [EOL] assertEquals(2023, localDate.getYear()); [EOL] assertEquals(1, localDate.getMonthOfYear()); [EOL] assertEquals(1, localDate.getDayOfMonth()); [EOL] }
public int size() { [EOL] return 3; [EOL] }
public void testGetFieldYear() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(YEAR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.year(), field); [EOL] }
public void testGetFieldMonthOfYear() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MONTH_OF_YEAR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.monthOfYear(), field); [EOL] }
public void testGetFieldDayOfMonth() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(DAY_OF_MONTH, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.dayOfMonth(), field); [EOL] }
public void testGetFieldInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] try { [EOL] getField(-1, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testGetValue_YEAR() { [EOL] int index = YEAR; // Assuming YEAR is a constant defined somewhere [EOL] int expectedValue = 2023; // Assuming this is the expected year value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_MONTH_OF_YEAR() { [EOL] int index = MONTH_OF_YEAR; // Assuming MONTH_OF_YEAR is a constant defined somewhere [EOL] int expectedValue = 4; // Assuming this is the expected month value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_DAY_OF_MONTH() { [EOL] int index = DAY_OF_MONTH; // Assuming DAY_OF_MONTH is a constant defined somewhere [EOL] int expectedValue = 15; // Assuming this is the expected day value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValue_InvalidIndex() { [EOL] int index = -1; // Assuming this is an invalid index [EOL] try { [EOL] getValue(index); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Invalid index: " + index, e.getMessage()); [EOL] } [EOL] }
public void testGetWithNullFieldType() { [EOL] try { [EOL] dateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithUnsupportedFieldType() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is unsupported for the sake of example [EOL] when(dateTime.isSupported(fieldType)).thenReturn(false); [EOL] try { [EOL] dateTime.get(fieldType); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field '" + fieldType + "' is not supported", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithSupportedFieldType() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Assuming this is supported for the sake of example [EOL] when(dateTime.isSupported(fieldType)).thenReturn(true); [EOL] long localMillis = dateTime.getLocalMillis(); [EOL] Chronology chronology = dateTime.getChronology(); [EOL] DateTimeField field = fieldType.getField(chronology); [EOL] when(field.get(localMillis)).thenReturn(2021); [EOL] int result = dateTime.get(fieldType); [EOL] assertEquals(2021, result); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse("Expected isSupported to return false for null type", result); [EOL] }
public void testIsSupportedWithUnsupportedDurationType() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationFieldType mockDurationType = mock(DurationFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(mockDurationType); [EOL] when(DATE_DURATION_TYPES.contains(mockDurationType)).thenReturn(false); [EOL] when(mockDurationType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.getUnitMillis()).thenReturn(1L); [EOL] when(getChronology().days().getUnitMillis()).thenReturn(2L); [EOL] when(mockType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.isSupported()).thenReturn(false); [EOL] boolean result = instance.isSupported(mockType); [EOL] assertFalse("Expected isSupported to return false for unsupported duration type", result); [EOL] }
public void testIsSupportedWithSupportedDurationType() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationFieldType mockDurationType = mock(DurationFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(mockDurationType); [EOL] when(DATE_DURATION_TYPES.contains(mockDurationType)).thenReturn(true); [EOL] when(mockType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.isSupported()).thenReturn(true); [EOL] boolean result = instance.isSupported(mockType); [EOL] assertTrue("Expected isSupported to return true for supported duration type", result); [EOL] }
public void testIsSupportedWithEqualUnitMillis() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationFieldType mockDurationType = mock(DurationFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(mockDurationType); [EOL] when(DATE_DURATION_TYPES.contains(mockDurationType)).thenReturn(false); [EOL] when(mockDurationType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.getUnitMillis()).thenReturn(1L); [EOL] when(getChronology().days().getUnitMillis()).thenReturn(1L); [EOL] when(mockType.getField(any(Chronology.class))).thenReturn(mockField); [EOL] when(mockField.isSupported()).thenReturn(true); [EOL] boolean result = instance.isSupported(mockType); [EOL] assertTrue("Expected isSupported to return true when unit millis are equal", result); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = DurationFieldType.seconds(); [EOL] when(unsupportedType.getField(getChronology())).thenReturn(someUnsupportedField); [EOL] boolean result = instance.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = DurationFieldType.days(); [EOL] when(supportedType.getField(getChronology())).thenReturn(someSupportedField); [EOL] when(someSupportedField.getUnitMillis()).thenReturn(getChronology().days().getUnitMillis()); [EOL] when(someSupportedField.isSupported()).thenReturn(true); [EOL] boolean result = instance.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testEquals_SameObject() { [EOL] LocalDate date = new LocalDate(2023, 3, 14); [EOL] assertTrue(date.equals(date)); [EOL] }
public void testEquals_DifferentClass() { [EOL] LocalDate date = new LocalDate(2023, 3, 14); [EOL] Object obj = new Object(); [EOL] assertFalse(date.equals(obj)); [EOL] }
public void testEquals_EqualLocalDate() { [EOL] LocalDate date1 = new LocalDate(2023, 3, 14); [EOL] LocalDate date2 = new LocalDate(2023, 3, 14); [EOL] assertTrue(date1.equals(date2)); [EOL] }
public void testEquals_DifferentChronology() { [EOL] LocalDate date1 = new LocalDate(2023, 3, 14, GregorianChronology.getInstance()); [EOL] LocalDate date2 = new LocalDate(2023, 3, 14, JulianChronology.getInstance()); [EOL] assertFalse(date1.equals(date2)); [EOL] }
public void testEquals_DifferentLocalMillis() { [EOL] LocalDate date1 = new LocalDate(2023, 3, 14); [EOL] LocalDate date2 = new LocalDate(2023, 3, 15); [EOL] assertFalse(date1.equals(date2)); [EOL] }
public void testHashCodeWhenHashIsZero() { [EOL] Time time = new Time(); [EOL] int expectedHash = time.hashCode(); [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testHashCodeWhenHashIsNonZero() { [EOL] Time time = new Time(); [EOL] int initialHash = time.hashCode(); [EOL] time.iHash = initialHash; [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(initialHash, actualHash); [EOL] }
public void testToLocalDateTimeWithNullTime() { [EOL] LocalDateTime dateTime = new LocalDateTime(0L, ISOChronology.getInstance()); [EOL] try { [EOL] dateTime.toLocalDateTime(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The time must not be null", e.getMessage()); [EOL] } [EOL] }
public void testToLocalDateTimeWithDifferentChronology() { [EOL] LocalDateTime dateTime = new LocalDateTime(0L, ISOChronology.getInstance()); [EOL] LocalTime time = new LocalTime(0L, GJChronology.getInstance()); [EOL] try { [EOL] dateTime.toLocalDateTime(time); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The chronology of the time does not match", e.getMessage()); [EOL] } [EOL] }
public void testToLocalDateTimeWithSameChronology() { [EOL] LocalDateTime dateTime = new LocalDateTime(0L, ISOChronology.getInstance()); [EOL] LocalTime time = new LocalTime(0L, ISOChronology.getInstance()); [EOL] LocalDateTime result = dateTime.toLocalDateTime(time); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result.getChronology()); [EOL] }
public Interval toInterval() { [EOL] return toInterval(null); [EOL] }
public void testWithField_NullField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] try { [EOL] testDate.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_UnsupportedField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is unsupported for LocalDate [EOL] try { [EOL] testDate.withField(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '" + fieldType + "' is not supported")); [EOL] } [EOL] }
public void testWithField_SupportedField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is supported for LocalDate [EOL] int newValue = 15; [EOL] LocalDate updatedDate = testDate.withField(fieldType, newValue); [EOL] assertEquals(newValue, updatedDate.getDayOfMonth()); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] LocalDate date = new LocalDate(); [EOL] date.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] try { [EOL] LocalDate date = new LocalDate(); [EOL] DurationFieldType fieldType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] date.withFieldAdded(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] LocalDate date = new LocalDate(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); // Assuming days is supported [EOL] LocalDate result = date.withFieldAdded(fieldType, 0); [EOL] assertEquals(date, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] LocalDate date = new LocalDate(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); // Assuming days is supported [EOL] int amount = 10; [EOL] LocalDate result = date.withFieldAdded(fieldType, amount); [EOL] assertNotEquals(date, result); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusDays(0); [EOL] assertEquals(date, result); [EOL] }
public void testPlusDays_PositiveDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusDays(10); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusDays(10), result); [EOL] }
public void testPlusDays_NegativeDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusDays(-10); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusDays(-10), result); [EOL] }
public void testMinus_withNullPeriod() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minus(null); [EOL] assertEquals("Minus with null period should return the same date", date, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] LocalDate date = LocalDate.now(); [EOL] Period period = Period.days(1); [EOL] LocalDate expected = date.minusDays(1); [EOL] LocalDate result = date.minus(period); [EOL] assertEquals("Minus with a valid period should return the correct date", expected, result); [EOL] }
public void testMinusDays_ZeroDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusDays(0); [EOL] assertEquals(date, result); [EOL] }
public void testMinusDays_PositiveDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusDays(10); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.minusDays(10), result); [EOL] }
public void testMinusDays_NegativeDays() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusDays(-10); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusDays(10), result); [EOL] }
public void testYearProperty() { [EOL] Time time = new Time(); [EOL] Property yearProperty = time.year(); [EOL] assertNotNull(yearProperty); [EOL] assertEquals(time.getChronology().year(), yearProperty.getField()); [EOL] }
public void testMonthOfYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.monthOfYear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().monthOfYear(), property.getField()); [EOL] assertEquals(dateTime.getMonthOfYear(), property.get()); [EOL] }
public void testGetField() { [EOL] DateTimeField expectedField = // initialize with a valid DateTimeField instance [EOL] YourClass instance = new YourClass(expectedField); [EOL] DateTimeField actualField = instance.getField(); [EOL] assertEquals(expectedField, actualField); [EOL] }
protected long getMillis() { [EOL] return iInstant.getLocalMillis(); [EOL] }
public void testAddWrapFieldToCopy_Zero() { [EOL] LocalDate testDate = new LocalDate(); [EOL] LocalDateField field = testDate.getField(); [EOL] LocalDate result = testDate.addWrapFieldToCopy(0); [EOL] assertEquals(testDate, result); [EOL] } [EOL] public void testAddWrapFieldToCopy_Positive() { [EOL] LocalDate testDate = new LocalDate(); [EOL] LocalDateField field = testDate.getField(); [EOL] int valueToAdd = 1; // Assuming the field wraps within a range that 1 is a valid non-zero value [EOL] LocalDate result = testDate.addWrapFieldToCopy(valueToAdd); [EOL] assertFalse(testDate.equals(result)); [EOL] } [EOL] public void testAddWrapFieldToCopy_Negative() { [EOL] LocalDate testDate = new LocalDate(); [EOL] LocalDateField field = testDate.getField(); [EOL] int valueToSubtract = -1; // Assuming the field wraps within a range that -1 is a valid non-zero value [EOL] LocalDate result = testDate.addWrapFieldToCopy(valueToSubtract); [EOL] assertFalse(testDate.equals(result)); [EOL] }
public void testSetCopy_ValidValue() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] int validValue = 5; // Assuming 5 is a valid value for the field [EOL] LocalDate updatedDate = testDate.setCopy(validValue); [EOL] assertNotNull("The updated date should not be null", updatedDate); [EOL] assertEquals("The field should be updated to the valid value", validValue, updatedDate.get(testDate.getField())); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] int invalidValue = Integer.MAX_VALUE; // Assuming this is an invalid value for the field [EOL] try { [EOL] testDate.setCopy(invalidValue); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public LocalDate withMaximumValue() { [EOL] return setCopy(getMaximumValue()); [EOL] }
public LocalDate withMinimumValue() { [EOL] return setCopy(getMinimumValue()); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForYearLessThanOrEqualTo1963() { [EOL] int year = 1960; [EOL] long expectedMillis = -946771200000L; // Expected millis for 1st Jan 1960 [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForYearGreaterThan1963_NonLeapYear() { [EOL] int year = 1965; [EOL] long expectedMillis = 63072000000L; // Expected millis for 1st Jan 1965 [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForYearGreaterThan1963_LeapYear() { [EOL] int year = 1964; [EOL] long expectedMillis = 31536000000L; // Expected millis for 1st Jan 1964 [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMinYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MIN_YEAR; [EOL] int actual = time.getMinYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaxYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MAX_YEAR; [EOL] int actual = time.getMaxYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithYearBeforeEra() { [EOL] long instant = -62167219200000L; // Represents a time instant before Common Era [EOL] int result = get(instant); [EOL] assertEquals(DateTimeConstants.BCE, result); [EOL] }
public void testGetWithYearInCommonEra() { [EOL] long instant = 62167219200000L; // Represents a time instant in Common Era [EOL] int result = get(instant); [EOL] assertEquals(DateTimeConstants.CE, result); [EOL] }
public void testGetAsTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 1; // Assuming 1 is a valid era value [EOL] Locale locale = Locale.US; [EOL] String result = getAsText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetAsTextWithInvalidFieldValue() { [EOL] int fieldValue = -1; // Assuming -1 is an invalid era value [EOL] Locale locale = Locale.US; [EOL] try { [EOL] getAsText(fieldValue, locale); [EOL] fail("Should have thrown an exception for invalid field value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsTextWithNullLocale() { [EOL] int fieldValue = 1; // Assuming 1 is a valid era value [EOL] Locale locale = null; [EOL] try { [EOL] getAsText(fieldValue, locale); [EOL] fail("Should have thrown an exception for null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetWithBCE() { [EOL] long instant = /* some instant representing a date in BCE */; [EOL] int era = DateTimeConstants.BCE; [EOL] long updatedInstant = set(instant, era); [EOL] int updatedEra = get(updatedInstant); [EOL] assertEquals("Setting BCE era should not change the era if it's already BCE", era, updatedEra); [EOL] } [EOL] public void testSetWithCE() { [EOL] long instant = /* some instant representing a date in CE */; [EOL] int era = DateTimeConstants.CE; [EOL] long updatedInstant = set(instant, era); [EOL] int updatedEra = get(updatedInstant); [EOL] assertEquals("Setting CE era should not change the era if it's already CE", era, updatedEra); [EOL] }
public void testSetChangingEraFromBCEToCE() { [EOL] long instant = /* some instant representing a date in BCE */; [EOL] int era = DateTimeConstants.CE; [EOL] long updatedInstant = set(instant, era); [EOL] int updatedEra = get(updatedInstant); [EOL] assertEquals("Changing era from BCE to CE should update the era", era, updatedEra); [EOL] }
public void testSetChangingEraFromCEToBCE() { [EOL] long instant = /* some instant representing a date in CE */; [EOL] int era = DateTimeConstants.BCE; [EOL] long updatedInstant = set(instant, era); [EOL] int updatedEra = get(updatedInstant); [EOL] assertEquals("Changing era from CE to BCE should update the era", era, updatedEra); [EOL] }
public void testRoundFloorAtCE() { [EOL] long instantAtCE = /* value representing a time instant in the Common Era */; [EOL] long expected = iChronology.setYear(0, 1); [EOL] long actual = roundFloor(instantAtCE); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloorBeforeCE() { [EOL] long instantBeforeCE = /* value representing a time instant before the Common Era */; [EOL] long expected = Long.MIN_VALUE; [EOL] long actual = roundFloor(instantBeforeCE); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaximumTextLengthWithNullLocale() { [EOL] try { [EOL] int result = getMaximumTextLength(null); [EOL] fail("Expected an exception to be thrown when the locale is null"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetMaximumTextLengthWithNonNullLocale() { [EOL] Locale locale = new Locale("en"); [EOL] int result = getMaximumTextLength(locale); [EOL] assertTrue("The result should be a positive integer", result > 0); [EOL] }
public void testYearWeekDayTime_WhenTypeIsNull() { [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYWDTime", null); [EOL] PeriodType result = PeriodType.yearWeekDayTime(); [EOL] assertNotNull(result); [EOL] assertEquals("YearWeekDayTime", result.getName()); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.years())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.weeks())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.days())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.hours())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.minutes())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.seconds())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testYearWeekDayTime_WhenTypeIsNotNull() { [EOL] PeriodType expected = new PeriodType("YearWeekDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 }); [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYWDTime", expected); [EOL] PeriodType result = PeriodType.yearWeekDayTime(); [EOL] assertSame(expected, result); [EOL] }
public void testDayTime_WhenCDTimeIsNull() { [EOL] PeriodType result = Time.dayTime(); [EOL] assertNotNull(result); [EOL] assertEquals("DayTime", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertTrue(result.isSupported(DurationFieldType.hours())); [EOL] assertTrue(result.isSupported(DurationFieldType.minutes())); [EOL] assertTrue(result.isSupported(DurationFieldType.seconds())); [EOL] assertTrue(result.isSupported(DurationFieldType.millis())); [EOL] }
public void testDayTime_WhenCDTimeIsNotNull() { [EOL] PeriodType preSetCDTime = new PeriodType("PreSetCDTime", new DurationFieldType[] {}, new int[] {}); [EOL] Time.cDTime = preSetCDTime; [EOL] PeriodType result = Time.dayTime(); [EOL] assertSame(preSetCDTime, result); [EOL] }
public void testWeeks_Initialization() { [EOL] PeriodType type = PeriodType.weeks(); [EOL] assertNotNull("Weeks type should not be null", type); [EOL] assertEquals("Type name should be 'Weeks'", "Weeks", type.getName()); [EOL] assertTrue("Weeks should be supported", type.isSupported(DurationFieldType.weeks())); [EOL] assertFalse("Days should not be supported", type.isSupported(DurationFieldType.days())); [EOL] }
public void testForFields_NullOrEmptyTypesArray_ThrowsIllegalArgumentException() { [EOL] try { [EOL] PeriodType.forFields(null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null or empty", e.getMessage()); [EOL] } [EOL] try { [EOL] PeriodType.forFields(new DurationFieldType[0]); [EOL] fail("Should have thrown IllegalArgumentException for empty types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFields_TypesArrayContainsNull_ThrowsIllegalArgumentException() { [EOL] DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.years(), null }; [EOL] try { [EOL] PeriodType.forFields(types); [EOL] fail("Should have thrown IllegalArgumentException for types array containing null"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not contain null", e.getMessage()); [EOL] } [EOL] }
public void testForFields_ValidTypesArray_ReturnsPeriodType() { [EOL] DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months() }; [EOL] PeriodType type = PeriodType.forFields(types); [EOL] assertNotNull(type); [EOL] }
public void testForFields_UnsupportedFields_ThrowsIllegalArgumentException() { [EOL] DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.years(), new MockDurationFieldType("unsupported") }; [EOL] try { [EOL] PeriodType.forFields(types); [EOL] fail("Should have thrown IllegalArgumentException for unsupported fields"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("PeriodType does not support fields")); [EOL] } [EOL] }
public void testForFields_CachedType_ReturnsSameInstance() { [EOL] DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months() }; [EOL] PeriodType type1 = PeriodType.forFields(types); [EOL] PeriodType type2 = PeriodType.forFields(types); [EOL] assertSame(type1, type2); [EOL] }
public void testAddIndexedField_ValueToAddIsZero() { [EOL] ReadablePeriod period = null; // Assuming a mock or concrete implementation is available [EOL] int index = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] boolean result = addIndexedField(period, index, values, valueToAdd); [EOL] assertFalse(result); [EOL] }
public void testAddIndexedField_UnsupportedField() { [EOL] ReadablePeriod period = null; // Assuming a mock or concrete implementation is available [EOL] int index = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] int[] iIndices = new int[] {-1}; // Assuming iIndices is accessible and modifiable [EOL] try { [EOL] addIndexedField(period, index, values, valueToAdd); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Field is not supported", e.getMessage()); [EOL] } [EOL] }
public void testAddIndexedField_ValidField() { [EOL] ReadablePeriod period = null; // Assuming a mock or concrete implementation is available [EOL] int index = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] int[] iIndices = new int[] {0}; // Assuming iIndices is accessible and modifiable [EOL] boolean result = addIndexedField(period, index, values, valueToAdd); [EOL] assertTrue(result); [EOL] assertEquals(2, values[0]); // Assuming that FieldUtils.safeAdd() adds the values correctly [EOL] }
public void testEquals_sameObject() { [EOL] PeriodType periodType = new PeriodType(); [EOL] boolean result = periodType.equals(periodType); [EOL] assert result; [EOL] } [EOL] public void testEquals_differentClass() { [EOL] PeriodType periodType = new PeriodType(); [EOL] Object obj = new Object(); [EOL] boolean result = periodType.equals(obj); [EOL] assert !result; [EOL] } [EOL] public void testEquals_null() { [EOL] PeriodType periodType = new PeriodType(); [EOL] Object obj = null; [EOL] boolean result = periodType.equals(obj); [EOL] assert !result; [EOL] } [EOL] public void testEquals_differentPeriodType() { [EOL] PeriodType periodType1 = new PeriodType(new String[]{"hours", "minutes"}); [EOL] PeriodType periodType2 = new PeriodType(new String[]{"seconds", "minutes"}); [EOL] boolean result = periodType1.equals(periodType2); [EOL] assert !result; [EOL] } [EOL] public void testEquals_samePeriodType() { [EOL] PeriodType periodType1 = new PeriodType(new String[]{"hours", "minutes"}); [EOL] PeriodType periodType2 = new PeriodType(new String[]{"hours", "minutes"}); [EOL] boolean result = periodType1.equals(periodType2); [EOL] assert result; [EOL] }

public void testSetCurrentMillisFixed_ValidInput() { [EOL] long expectedMillis = 1000L; [EOL] Time.setCurrentMillisFixed(expectedMillis); [EOL] long actualMillis = Time.currentTimeMillis(); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSetCurrentMillisFixed_SecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("setCurrentMillis".equals(perm.getName())) { [EOL] throw new SecurityException("Permission denied"); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] Time.setCurrentMillisFixed(1000L); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testGetInstantMillisWithNull() { [EOL] long expected = DateTimeUtils.currentTimeMillis(); [EOL] long actual = Time.getInstantMillis(null); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetInstantMillisWithNonNull() { [EOL] ReadableInstant instant = new Instant(); [EOL] long expected = instant.getMillis(); [EOL] long actual = Time.getInstantMillis(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testFixedMillisProviderWithZero() { [EOL] long fixedMillis = 0L; [EOL] FixedMillisProvider provider = new FixedMillisProvider(fixedMillis); [EOL] assertEquals("Expected millis to be zero", 0L, provider.iMillis); [EOL] }
public void testFixedMillisProviderWithPositiveMillis() { [EOL] long fixedMillis = 12345L; [EOL] FixedMillisProvider provider = new FixedMillisProvider(fixedMillis); [EOL] assertEquals("Expected millis to match input", 12345L, provider.iMillis); [EOL] }
public void testFixedMillisProviderWithNegativeMillis() { [EOL] long fixedMillis = -12345L; [EOL] FixedMillisProvider provider = new FixedMillisProvider(fixedMillis); [EOL] assertEquals("Expected millis to match input", -12345L, provider.iMillis); [EOL] }
public long getMillis() { [EOL] return iMillis; [EOL] }
protected NullConverter() { [EOL] super(); [EOL] }
public long getDurationMillis(Object object) { [EOL] return 0L; [EOL] }
public void testSetInto_NullDuration() { [EOL] ReadWritablePeriod mockDuration = mock(ReadWritablePeriod.class); [EOL] Object object = new Object(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] setInto(mockDuration, object, chrono); [EOL] verify(mockDuration).setPeriod((Period) null); [EOL] }
public void testBaseIntervalWithBothNullStartAndEnd() { [EOL] BaseInterval interval = new BaseInterval(null, null); [EOL] long currentMillis = DateTimeUtils.currentTimeMillis(); [EOL] assertEquals(currentMillis, interval.getStartMillis()); [EOL] assertEquals(currentMillis, interval.getEndMillis()); [EOL] assertTrue(interval.getChronology() instanceof ISOChronology); [EOL] }
public void testBaseIntervalWithNonNullStartAndEnd() { [EOL] ReadableInstant start = new Instant(0L); [EOL] ReadableInstant end = new Instant(1000L); [EOL] BaseInterval interval = new BaseInterval(start, end); [EOL] assertEquals(0L, interval.getStartMillis()); [EOL] assertEquals(1000L, interval.getEndMillis()); [EOL] assertTrue(interval.getChronology() instanceof ISOChronology); [EOL] }
public void testBaseIntervalWithStartAfterEnd() { [EOL] ReadableInstant start = new Instant(1000L); [EOL] ReadableInstant end = new Instant(0L); [EOL] try { [EOL] new BaseInterval(start, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBaseIntervalWithNullPeriod() { [EOL] ReadableInstant start = new DateTime(2023, 4, 1, 12, 0); [EOL] BaseInterval interval = new BaseInterval(start, null); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.getMillis(), interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithNonNullPeriod() { [EOL] ReadableInstant start = new DateTime(2023, 4, 1, 12, 0); [EOL] ReadablePeriod period = new Period(1, 0, 0, 0); [EOL] BaseInterval interval = new BaseInterval(start, period); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertNotEquals(start.getMillis(), interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithReadableIntervalAndNonNullChronology() { [EOL] ReadableInterval readableInterval = mock(ReadableInterval.class); [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(readableInterval.getChronology()).thenReturn(chronology); [EOL] when(readableInterval.getStartMillis()).thenReturn(123L); [EOL] when(readableInterval.getEndMillis()).thenReturn(456L); [EOL] IntervalConverter converter = mock(IntervalConverter.class); [EOL] when(converter.isReadableInterval(readableInterval, chronology)).thenReturn(true); [EOL] ConverterManager converterManager = mock(ConverterManager.class); [EOL] when(converterManager.getIntervalConverter(readableInterval)).thenReturn(converter); [EOL] setStaticField(ConverterManager.class, "INSTANCE", converterManager); [EOL] BaseInterval interval = new BaseInterval(readableInterval, chronology); [EOL] assertEquals(chronology, interval.getChronology()); [EOL] assertEquals(123L, interval.getStartMillis()); [EOL] assertEquals(456L, interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithReadableIntervalAndNullChronology() { [EOL] ReadableInterval readableInterval = mock(ReadableInterval.class); [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(readableInterval.getChronology()).thenReturn(chronology); [EOL] when(readableInterval.getStartMillis()).thenReturn(123L); [EOL] when(readableInterval.getEndMillis()).thenReturn(456L); [EOL] IntervalConverter converter = mock(IntervalConverter.class); [EOL] when(converter.isReadableInterval(readableInterval, null)).thenReturn(true); [EOL] ConverterManager converterManager = mock(ConverterManager.class); [EOL] when(converterManager.getIntervalConverter(readableInterval)).thenReturn(converter); [EOL] setStaticField(ConverterManager.class, "INSTANCE", converterManager); [EOL] BaseInterval interval = new BaseInterval(readableInterval, null); [EOL] assertEquals(chronology, interval.getChronology()); [EOL] assertEquals(123L, interval.getStartMillis()); [EOL] assertEquals(456L, interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithNonReadableIntervalAndReadWritableInterval() { [EOL] Object nonReadableInterval = new Object(); [EOL] ReadWritableInterval readWritableInterval = mock(ReadWritableInterval.class); [EOL] Chronology chronology = mock(Chronology.class); [EOL] IntervalConverter converter = mock(IntervalConverter.class); [EOL] when(converter.isReadableInterval(nonReadableInterval, chronology)).thenReturn(false); [EOL] ConverterManager converterManager = mock(ConverterManager.class); [EOL] when(converterManager.getIntervalConverter(nonReadableInterval)).thenReturn(converter); [EOL] setStaticField(ConverterManager.class, "INSTANCE", converterManager); [EOL] BaseInterval interval = new BaseInterval(nonReadableInterval, chronology) { [EOL] @Override [EOL] public boolean instanceofReadWritableInterval() { [EOL] return true; [EOL] } [EOL] }; [EOL] verify(converter).setInto(readWritableInterval, nonReadableInterval, chronology); [EOL] }
public void testBaseIntervalWithNonReadableIntervalAndNotReadWritableInterval() { [EOL] Object nonReadableInterval = new Object(); [EOL] Chronology chronology = mock(Chronology.class); [EOL] IntervalConverter converter = mock(IntervalConverter.class); [EOL] when(converter.isReadableInterval(nonReadableInterval, chronology)).thenReturn(false); [EOL] ConverterManager converterManager = mock(ConverterManager.class); [EOL] when(converterManager.getIntervalConverter(nonReadableInterval)).thenReturn(converter); [EOL] setStaticField(ConverterManager.class, "INSTANCE", converterManager); [EOL] BaseInterval interval = new BaseInterval(nonReadableInterval, chronology) { [EOL] @Override [EOL] public boolean instanceofReadWritableInterval() { [EOL] return false; [EOL] } [EOL] }; [EOL] MutableInterval mi = new MutableInterval(); [EOL] verify(converter).setInto(mi, nonReadableInterval, chronology); [EOL] assertEquals(mi.getChronology(), interval.getChronology()); [EOL] assertEquals(mi.getStartMillis(), interval.getStartMillis()); [EOL] assertEquals(mi.getEndMillis(), interval.getEndMillis()); [EOL] }
public void testGetDefault_WithSystemPropertySet() { [EOL] System.setProperty("user.timezone", "America/New_York"); [EOL] DateTimeZone result = DateTimeZone.getDefault(); [EOL] assertNotNull(result); [EOL] assertEquals("America/New_York", result.getID()); [EOL] }
public void testGetDefault_WithSystemPropertyNotSet() { [EOL] System.clearProperty("user.timezone"); [EOL] DateTimeZone result = DateTimeZone.getDefault(); [EOL] assertNotNull(result); [EOL] assertNotEquals("UTC", result.getID()); [EOL] }
public void testGetDefault_WithInvalidSystemProperty() { [EOL] System.setProperty("user.timezone", "Invalid/Timezone"); [EOL] DateTimeZone result = DateTimeZone.getDefault(); [EOL] assertNotNull(result); [EOL] assertNotEquals("Invalid/Timezone", result.getID()); [EOL] assertEquals(DateTimeZone.UTC.getID(), result.getID()); [EOL] }
public void testForOffsetHoursMinutes_UTC() { [EOL] DateTimeZone result = Time.forOffsetHoursMinutes(0, 0); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForOffsetHoursMinutes_HoursOutOfRange() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(24, 0); [EOL] fail("Should have thrown IllegalArgumentException for hours out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Hours out of range: 24", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetHoursMinutes_MinutesOutOfRange() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, 60); [EOL] fail("Should have thrown IllegalArgumentException for minutes out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Minutes out of range: 60", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetHoursMinutes_PositiveHoursNegativeMinutes() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, -1); [EOL] fail("Should have thrown IllegalArgumentException for positive hours with negative minutes"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Positive hours must not have negative minutes: -1", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetHoursMinutes_ValidOffset() { [EOL] DateTimeZone result = Time.forOffsetHoursMinutes(1, 30); [EOL] assertNotNull(result); [EOL] }
public void testForOffsetHoursMinutes_OffsetTooLarge() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(Integer.MAX_VALUE / 60, 0); [EOL] fail("Should have thrown IllegalArgumentException for offset too large"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Offset is too large", e.getMessage()); [EOL] } [EOL] }
public void testGetAvailableIDs() { [EOL] Set<String> result = Time.getAvailableIDs(); [EOL] assertNotNull(result); [EOL] Set<String> expectedIDs = new HashSet<>(Arrays.asList("ID1", "ID2", "ID3")); // Replace with actual initial values [EOL] assertEquals(expectedIDs, result); [EOL] }
public void testGetDefaultProviderWithSystemPropertySet() { [EOL] System.setProperty("org.joda.time.DateTimeZone.Provider", "com.example.CustomProvider"); [EOL] try { [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof com.example.CustomProvider); [EOL] } finally { [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] } [EOL] }
public void testGetDefaultProviderWithSecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("org.joda.time.DateTimeZone.Provider".equals(perm.getName())) { [EOL] throw new SecurityException("Access denied!"); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof ZoneInfoProvider || provider instanceof UTCProvider); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testGetDefaultProviderWithZoneInfoProviderException() { [EOL] System.setProperty("org.joda.time.DateTimeZone.Provider", "com.example.NonExistentProvider"); [EOL] try { [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof UTCProvider); [EOL] } finally { [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] } [EOL] }
public void testDateTimeZoneWithNullId() { [EOL] try { [EOL] new DateTimeZone(null); [EOL] fail("Should have thrown IllegalArgumentException for null id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Id must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDateTimeZoneWithValidId() { [EOL] String validId = "UTC"; [EOL] DateTimeZone zone = new DateTimeZone(validId); [EOL] assertEquals(validId, zone.getID()); [EOL] }
public void testGetID() { [EOL] Time time = new Time("12345"); [EOL] String id = time.getID(); [EOL] assertEquals("12345", id); [EOL] }
public void testIsStandardOffset_WhenOffsetEqualsStandardOffset() { [EOL] Time time = new Time(); [EOL] long instant = SOME_INSTANT_WHEN_OFFSET_EQUALS_STANDARD; [EOL] boolean result = time.isStandardOffset(instant); [EOL] assertTrue(result); [EOL] }
public void testIsStandardOffset_WhenOffsetDoesNotEqualStandardOffset() { [EOL] Time time = new Time(); [EOL] long instant = SOME_INSTANT_WHEN_OFFSET_DOES_NOT_EQUAL_STANDARD; [EOL] boolean result = time.isStandardOffset(instant); [EOL] assertFalse(result); [EOL] }
public void testConvertUTCToLocal_WithNoOverflow() { [EOL] long instantUTC = 0L; // Assuming getOffset() returns a non-overflowing offset [EOL] long expected = instantUTC + getOffset(instantUTC); [EOL] long result = convertUTCToLocal(instantUTC); [EOL] assertEquals(expected, result); [EOL] }
public void testConvertUTCToLocal_WithOverflow() { [EOL] long instantUTC = Long.MAX_VALUE; // Assuming getOffset() returns a value that causes overflow [EOL] try { [EOL] convertUTCToLocal(instantUTC); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testConvertLocalToUTC_SameOffset() { [EOL] long instantLocal = SOME_INSTANT_LOCAL; [EOL] boolean strict = true; // or false, doesn't impact this path [EOL] long originalInstantUTC = SOME_ORIGINAL_INSTANT_UTC; [EOL] when(this.getOffset(originalInstantUTC)).thenReturn(SOME_OFFSET); [EOL] when(this.getOffset(instantLocal - SOME_OFFSET)).thenReturn(SOME_OFFSET); [EOL] long result = convertLocalToUTC(instantLocal, strict, originalInstantUTC); [EOL] assertEquals(instantLocal - SOME_OFFSET, result); [EOL] }
public void testConvertLocalToUTC_DifferentOffset() { [EOL] long instantLocal = SOME_INSTANT_LOCAL; [EOL] boolean strict = true; // or false, doesn't impact this path [EOL] long originalInstantUTC = SOME_ORIGINAL_INSTANT_UTC; [EOL] when(this.getOffset(originalInstantUTC)).thenReturn(SOME_OFFSET); [EOL] when(this.getOffset(instantLocal - SOME_OFFSET)).thenReturn(ANOTHER_OFFSET); [EOL] long expected = convertLocalToUTC(instantLocal, strict); [EOL] long result = convertLocalToUTC(instantLocal, strict, originalInstantUTC); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillisKeepLocal_WithNullZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] long oldInstant = System.currentTimeMillis(); [EOL] long expectedMillis = originalZone.getMillisKeepLocal(null, oldInstant); [EOL] assertEquals(expectedMillis, oldInstant); [EOL] }
public void testGetMillisKeepLocal_WithSameZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] long oldInstant = System.currentTimeMillis(); [EOL] long expectedMillis = originalZone.getMillisKeepLocal(originalZone, oldInstant); [EOL] assertEquals(expectedMillis, oldInstant); [EOL] }
public void testGetMillisKeepLocal_WithDifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone newZone = DateTimeZone.forID("America/New_York"); [EOL] long oldInstant = System.currentTimeMillis(); [EOL] long instantLocal = originalZone.convertUTCToLocal(oldInstant); [EOL] long expectedMillis = newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] long actualMillis = originalZone.getMillisKeepLocal(newZone, oldInstant); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testToTimeZoneWithValidID() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] java.util.TimeZone expected = java.util.TimeZone.getTimeZone("Europe/London"); [EOL] java.util.TimeZone actual = zone.toTimeZone(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToTimeZoneWithInvalidID() { [EOL] DateTimeZone zone = DateTimeZone.forID("Invalid/ID"); [EOL] java.util.TimeZone expected = java.util.TimeZone.getTimeZone("Invalid/ID"); [EOL] java.util.TimeZone actual = zone.toTimeZone(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToTimeZoneWithUTC() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] java.util.TimeZone expected = java.util.TimeZone.getTimeZone("UTC"); [EOL] java.util.TimeZone actual = zone.toTimeZone(); [EOL] assertEquals(expected, actual); [EOL] }
public int hashCode() { [EOL] return 57 + getID().hashCode(); [EOL] }
public void testBasicChronologyValidMinDays() { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] int validMinDays = 4; [EOL] BasicChronology chronology = new BasicChronology(baseChronology, new Object(), validMinDays); [EOL] assertEquals(validMinDays, chronology.getMinDaysInFirstWeek()); [EOL] }
public void testBasicChronologyInvalidMinDaysLessThanOne() { [EOL] try { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] int invalidMinDays = 0; [EOL] new BasicChronology(baseChronology, new Object(), invalidMinDays); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBasicChronologyInvalidMinDaysMoreThanSeven() { [EOL] try { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] int invalidMinDays = 8; [EOL] new BasicChronology(baseChronology, new Object(), invalidMinDays); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetZone_BaseChronologyNotNull() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeZone expectedZone = DateTimeZone.forID("Europe/London"); [EOL] Mockito.when(mockChronology.getZone()).thenReturn(expectedZone); [EOL] DateTime dateTime = new DateTime(mockChronology); [EOL] DateTimeZone actualZone = dateTime.getZone(); [EOL] assertEquals("Expected zone should be returned when base chronology is not null", expectedZone, actualZone); [EOL] }
public void testGetZone_BaseChronologyNull() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockChronology.getZone()).thenReturn(null); [EOL] DateTime dateTime = new DateTime(mockChronology); [EOL] DateTimeZone actualZone = dateTime.getZone(); [EOL] assertEquals("UTC should be returned when base chronology is null", DateTimeZone.UTC, actualZone); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNotNull() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public Chronology getBase() { [EOL] return new Chronology() { [EOL] @Override [EOL] public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL] return 123456789L; // Mocked return value [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] long result = time.getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(123456789L, result); [EOL] }
public void testGetDateTimeMillis_ValidValues() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public Chronology getBase() { [EOL] return null; [EOL] } [EOL] }; [EOL] long result = time.getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] long expected = 1609459200000L + 12 * DateTimeConstants.MILLIS_PER_HOUR; [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_HourOfDayOutOfBounds() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public Chronology getBase() { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] time.getDateTimeMillis(2021, 1, 1, 24, 0, 0, 0); [EOL] fail("IllegalArgumentException expected for hourOfDay out of bounds"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_MinuteOfHourOutOfBounds() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public Chronology getBase() { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] time.getDateTimeMillis(2021, 1, 1, 12, 60, 0, 0); [EOL] fail("IllegalArgumentException expected for minuteOfHour out of bounds"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_SecondOfMinuteOutOfBounds() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public Chronology getBase() { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] time.getDateTimeMillis(2021, 1, 1, 12, 0, 60, 0); [EOL] fail("IllegalArgumentException expected for secondOfMinute out of bounds"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_MillisOfSecondOutOfBounds() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public Chronology getBase() { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] time.getDateTimeMillis(2021, 1, 1, 12, 0, 0, 1000); [EOL] fail("IllegalArgumentException expected for millisOfSecond out of bounds"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEquals_Reflexive() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] assertTrue(chrono1.equals(chrono1)); [EOL] }
public void testEquals_Null() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] assertFalse(chrono1.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] Object obj = new Object(); [EOL] assertFalse(chrono1.equals(obj)); [EOL] }
public void testEquals_EqualChronology() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] BasicChronology chrono2 = new BasicChronology(); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentMinimumDays() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] BasicChronology chrono2 = new BasicChronology(); [EOL] chrono2.setMinimumDaysInFirstWeek(chrono1.getMinimumDaysInFirstWeek() + 1); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentZone() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] BasicChronology chrono2 = new BasicChronology(); [EOL] chrono2.setZone(DifferentZone); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public long getYearMillis(int year) { [EOL] return getYearInfo(year).iFirstDayMillis; [EOL] }
public void testGetYearMonthDayMillis_ValidDate() { [EOL] int year = 2020; [EOL] int month = 5; [EOL] int dayOfMonth = 15; [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] long actualMillis = getYearMonthDayMillis(year, month, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearMonthDayMillis_LeapYear() { [EOL] int year = 2020; [EOL] int month = 2; [EOL] int dayOfMonth = 29; [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value for a leap year [EOL] long actualMillis = getYearMonthDayMillis(year, month, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearMonthDayMillis_NonLeapYear() { [EOL] int year = 2019; [EOL] int month = 2; [EOL] int dayOfMonth = 28; [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value for a non-leap year [EOL] long actualMillis = getYearMonthDayMillis(year, month, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearMonthDayMillis_BeginningOfYear() { [EOL] int year = 2020; [EOL] int month = 1; [EOL] int dayOfMonth = 1; [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value for the beginning of the year [EOL] long actualMillis = getYearMonthDayMillis(year, month, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearMonthDayMillis_EndOfYear() { [EOL] int year = 2020; [EOL] int month = 12; [EOL] int dayOfMonth = 31; [EOL] long expectedMillis = SOME_EXPECTED_VALUE; // Replace with the actual expected value for the end of the year [EOL] long actualMillis = getYearMonthDayMillis(year, month, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYear_NegativeInstant() { [EOL] long instant = -1; // some negative instant [EOL] int expectedYear = -1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_StartOfEpoch() { [EOL] long instant = 0; // start of the epoch [EOL] int expectedYear = 1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_JustBeforeLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 365 - 1); // just before a leap year [EOL] int expectedYear = 1973; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_StartOfLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 365); // start of a leap year [EOL] int expectedYear = 1974; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_WithinLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 365 + 1); // within a leap year [EOL] int expectedYear = 1974; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_EndOfLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (366L * 4 - 1); // end of a leap year [EOL] int expectedYear = 1974; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_AfterLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (366L * 4); // after a leap year [EOL] int expectedYear = 1975; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
int getMonthOfYear(long millis) { [EOL] return getMonthOfYear(millis, getYear(millis)); [EOL] }
public void testGetDayOfMonth_JanuaryFirst() { [EOL] long millis = new GregorianCalendar(2021, Calendar.JANUARY, 1).getTimeInMillis(); [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(1, result); [EOL] }
public void testGetDayOfMonth_FebruaryFirst() { [EOL] long millis = new GregorianCalendar(2021, Calendar.FEBRUARY, 1).getTimeInMillis(); [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(1, result); [EOL] }
public void testGetDayOfMonth_DecemberThirtyFirst() { [EOL] long millis = new GregorianCalendar(2021, Calendar.DECEMBER, 31).getTimeInMillis(); [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(31, result); [EOL] }
public void testGetDayOfMonthForStartOfYear() { [EOL] long millis = DateTimeConstants.MILLIS_PER_DAY * 31; // January 31st [EOL] int year = 2020; [EOL] int month = 1; [EOL] int expectedDayOfMonth = 31; [EOL] int actualDayOfMonth = getDayOfMonth(millis, year, month); [EOL] assertEquals(expectedDayOfMonth, actualDayOfMonth); [EOL] }
public void testGetDayOfMonthForLeapYearFebruary() { [EOL] long millis = DateTimeConstants.MILLIS_PER_DAY * 60; // Leap year February 29th [EOL] int year = 2020; [EOL] int month = 2; [EOL] int expectedDayOfMonth = 29; [EOL] int actualDayOfMonth = getDayOfMonth(millis, year, month); [EOL] assertEquals(expectedDayOfMonth, actualDayOfMonth); [EOL] }
public void testGetDayOfMonthForNonLeapYearFebruary() { [EOL] long millis = DateTimeConstants.MILLIS_PER_DAY * 59; // Non-leap year February 28th [EOL] int year = 2021; [EOL] int month = 2; [EOL] int expectedDayOfMonth = 28; [EOL] int actualDayOfMonth = getDayOfMonth(millis, year, month); [EOL] assertEquals(expectedDayOfMonth, actualDayOfMonth); [EOL] }
public void testGetDayOfMonthForEndOfYear() { [EOL] long millis = DateTimeConstants.MILLIS_PER_DAY * 365; // December 31st on a non-leap year [EOL] int year = 2021; [EOL] int month = 12; [EOL] int expectedDayOfMonth = 31; [EOL] int actualDayOfMonth = getDayOfMonth(millis, year, month); [EOL] assertEquals(expectedDayOfMonth, actualDayOfMonth); [EOL] }
public void testGetMillisOfDayWithPositiveInstant() { [EOL] long instant = 1000; // Any positive value within the range of millis per day [EOL] int expected = 1000; // Expected result is the same as instant since it's less than MILLIS_PER_DAY [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetMillisOfDayWithNegativeInstant() { [EOL] long instant = -1000; // Any negative value [EOL] int expected = DateTimeConstants.MILLIS_PER_DAY - 1; // Expected result is MILLIS_PER_DAY - 1 since (instant + 1) % MILLIS_PER_DAY is 0 [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetMillisOfDayWithInstantAtDayBoundary() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY; // Exactly at the boundary of a day [EOL] int expected = 0; // Expected result is 0 since instant % MILLIS_PER_DAY is 0 [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetMillisOfDayWithInstantJustBeforeDayBoundary() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY - 1; // Just before the boundary of a day [EOL] int expected = DateTimeConstants.MILLIS_PER_DAY - 1; // Expected result is instant since it's less than MILLIS_PER_DAY [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetMillisOfDayWithLargeNegativeInstant() { [EOL] long instant = -DateTimeConstants.MILLIS_PER_DAY * 2; // A large negative value that is a multiple of MILLIS_PER_DAY [EOL] int expected = DateTimeConstants.MILLIS_PER_DAY - 1; // Expected result is MILLIS_PER_DAY - 1 since (instant + 1) % MILLIS_PER_DAY is 0 [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDateMidnightMillis_ValidDate() { [EOL] int year = 2020; [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] long expectedMillis = getYearMonthDayMillis(year, monthOfYear, dayOfMonth); [EOL] long actualMillis = getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetDateMidnightMillis_YearBelowMin() { [EOL] int year = getMinYear() - 1; [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException for year below min value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateMidnightMillis_YearAboveMax() { [EOL] int year = getMaxYear() + 1; [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException for year above max value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateMidnightMillis_MonthBelowMin() { [EOL] int year = 2020; [EOL] int monthOfYear = 0; [EOL] int dayOfMonth = 15; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException for month below min value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateMidnightMillis_MonthAboveMax() { [EOL] int year = 2020; [EOL] int monthOfYear = getMaxMonth(year) + 1; [EOL] int dayOfMonth = 15; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException for month above max value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateMidnightMillis_DayBelowMin() { [EOL] int year = 2020; [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 0; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException for day below min value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateMidnightMillis_DayAboveMax() { [EOL] int year = 2020; [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = getDaysInYearMonth(year, monthOfYear) + 1; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException for day above max value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetMaxMonth() { [EOL] int year = 2021; // Any year would work since the method does not use the year parameter [EOL] int expectedMaxMonth = 12; // Assuming getMaxMonth() returns 12 [EOL] int actualMaxMonth = getMaxMonth(year); [EOL] assertEquals(expectedMaxMonth, actualMaxMonth); [EOL] }
public void testGetMaxMonth() { [EOL] Time time = new Time(); [EOL] int maxMonth = time.getMaxMonth(); [EOL] assertEquals(12, maxMonth); [EOL] }
public void testGetYearInfo_CacheHit() { [EOL] int year = 2020; // Assuming CACHE_MASK is set up such that this year is cached [EOL] YearInfo expectedInfo = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL] iYearInfoCache[year & CACHE_MASK] = expectedInfo; [EOL] YearInfo result = getYearInfo(year); [EOL] assertSame("Cache hit should return the same YearInfo object", expectedInfo, result); [EOL] }
public void testGetYearInfo_CacheMiss_NewYearInfo() { [EOL] int year = 2021; // Assuming CACHE_MASK is set up such that this year is not cached [EOL] YearInfo expectedInfo = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL] YearInfo result = getYearInfo(year); [EOL] assertEquals("Cache miss should calculate and return new YearInfo", expectedInfo.iYear, result.iYear); [EOL] assertEquals("Cache miss should calculate and return new YearInfo", expectedInfo.getFirstDayOfYearMillis(), result.getFirstDayOfYearMillis()); [EOL] }
public void testGetYearInfo_CacheMiss_YearInfoWithDifferentYear() { [EOL] int cachedYear = 2020; // Assuming CACHE_MASK is set up such that this year is cached [EOL] int requestYear = 2022; // Different year, same cache slot [EOL] YearInfo cachedInfo = new YearInfo(cachedYear, calculateFirstDayOfYearMillis(cachedYear)); [EOL] iYearInfoCache[cachedYear & CACHE_MASK] = cachedInfo; [EOL] YearInfo result = getYearInfo(requestYear); [EOL] assertNotSame("Cache hit with different year should not return the same YearInfo object", cachedInfo, result); [EOL] assertEquals("Cache hit with different year should return new YearInfo with requested year", requestYear, result.iYear); [EOL] }
public void testGetMaximumTextLength_NullLocale() { [EOL] int result = getMaximumTextLength(null); [EOL] assertTrue(result >= 0); [EOL] }
public void testGetMaximumTextLength_ExistingLocale() { [EOL] int result = getMaximumTextLength(Locale.US); [EOL] assertTrue(result >= 0); [EOL] }
It seems there might be a misunderstanding. As an AI language model, I can help you generate unit test case methods for Java code, but I do not have the capability to process or manipulate actual Java code files directly. However, I can provide you with Java code snippets that you can use as unit test cases based on the provided method signature. [EOL] If you want me to generate unit test case methods for the `BasePeriod` constructor in your Java project, please provide the necessary context, such as the behavior of the methods called within the constructor (e.g., `checkPeriodType`, `setPeriodInternal`), and any relevant class properties. With that information, I can create meaningful assertions for the test cases.
protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL] super(); [EOL] type = checkPeriodType(type); [EOL] chrono = DateTimeUtils.getChronology(chrono); [EOL] iType = type; [EOL] iValues = chrono.get(this, startInstant, endInstant); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }]
protected void testBasePeriodWithNullStartAndEndInstant() { [EOL] PeriodType type = PeriodType.standard(); [EOL] BasePeriod period = new BasePeriod((ReadableInstant) null, (ReadableInstant) null, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] for (int i = 0; i < period.getPeriodType().size(); i++) { [EOL] assertEquals(0, period.getValue(i)); [EOL] } [EOL] } [EOL] protected void testBasePeriodWithNonNullStartAndEndInstant() { [EOL] DateTime startInstant = new DateTime(0); [EOL] DateTime endInstant = new DateTime(1000); [EOL] PeriodType type = PeriodType.standard(); [EOL] BasePeriod period = new BasePeriod(startInstant, endInstant, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertTrue(period.getValue(0) != 0 || period.getValue(1) != 0 || period.getValue(2) != 0); [EOL] } [EOL] protected void testBasePeriodWithDifferentChronology() { [EOL] DateTime startInstant = new DateTime(0, GregorianChronology.getInstance()); [EOL] DateTime endInstant = new DateTime(1000, JulianChronology.getInstance()); [EOL] PeriodType type = PeriodType.standard(); [EOL] BasePeriod period = new BasePeriod(startInstant, endInstant, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertTrue(period.getValue(0) != 0 || period.getValue(1) != 0 || period.getValue(2) != 0); [EOL] } [EOL] protected void testBasePeriodWithNullType() { [EOL] DateTime startInstant = new DateTime(0); [EOL] DateTime endInstant = new DateTime(1000); [EOL] BasePeriod period = new BasePeriod(startInstant, endInstant, null); [EOL] assertNotNull(period); [EOL] assertEquals(PeriodType.standard(), period.getPeriodType()); [EOL] assertTrue(period.getValue(0) != 0 || period.getValue(1) != 0 || period.getValue(2) != 0); [EOL] }
public void testBasePeriod_WithNullStartReadablePartial() { [EOL] try { [EOL] new BasePeriod(null, new MockReadablePartial(), PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for null start partial"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBasePeriod_WithNullEndReadablePartial() { [EOL] try { [EOL] new BasePeriod(new MockReadablePartial(), null, PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for null end partial"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBasePeriod_WithDifferentSizeReadablePartials() { [EOL] try { [EOL] new BasePeriod(new MockReadablePartial(3), new MockReadablePartial(4), PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for different size partials"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBasePeriod_WithNonContiguousReadablePartials() { [EOL] try { [EOL] new BasePeriod(new MockNonContiguousReadablePartial(), new MockNonContiguousReadablePartial(), PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for non-contiguous partials"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBasePeriod_WithSameTypeAndContiguousReadablePartials() { [EOL] MockContiguousReadablePartial start = new MockContiguousReadablePartial(); [EOL] MockContiguousReadablePartial end = new MockContiguousReadablePartial(); [EOL] BasePeriod period = new BasePeriod(start, end, PeriodType.standard()); [EOL] assertNotNull("The period should be created successfully", period); [EOL] }
public void testBasePeriod_WithSameTypeAndNonContiguousReadablePartials() { [EOL] try { [EOL] new BasePeriod(new MockContiguousReadablePartial(), new MockNonContiguousReadablePartial(), PeriodType.standard()); [EOL] fail("Should have thrown IllegalArgumentException for partials with different types"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
protected void testBasePeriod_WithReadableDurationAndEndInstant() { [EOL] ReadableDuration duration = new Duration(1234L); [EOL] ReadableInstant endInstant = new Instant(5678L); [EOL] PeriodType type = PeriodType.standard(); [EOL] BasePeriod period = new BasePeriod(duration, endInstant, type); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(1, period.getValue(0)); // Assuming this is the correct value [EOL] }
protected void testBasePeriod_WithNullDuration() { [EOL] ReadableDuration duration = null; [EOL] ReadableInstant endInstant = new Instant(5678L); [EOL] PeriodType type = PeriodType.standard(); [EOL] BasePeriod period = new BasePeriod(duration, endInstant, type); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(0, period.getValue(0)); // Assuming null duration is treated as 0 [EOL] }
protected void testBasePeriod_WithNullEndInstant() { [EOL] ReadableDuration duration = new Duration(1234L); [EOL] ReadableInstant endInstant = null; [EOL] PeriodType type = PeriodType.standard(); [EOL] BasePeriod period = new BasePeriod(duration, endInstant, type); [EOL] assertEquals(type, period.getPeriodType()); [EOL] }
protected void testBasePeriod_WithNullType() { [EOL] ReadableDuration duration = new Duration(1234L); [EOL] ReadableInstant endInstant = new Instant(5678L); [EOL] PeriodType type = null; [EOL] BasePeriod period = new BasePeriod(duration, endInstant, type); [EOL] assertNotNull(period.getPeriodType()); // checkPeriodType should return a non-null type [EOL] assertEquals(1, period.getValue(0)); // Assuming this is the correct value [EOL] }
public Duration toDurationTo(ReadableInstant endInstant) { [EOL] long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL] Chronology chrono = DateTimeUtils.getInstantChronology(endInstant); [EOL] long startMillis = chrono.add(this, endMillis, -1); [EOL] return new Duration(startMillis, endMillis); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }]
private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) { [EOL] int index = indexOf(type); [EOL] if (index == -1) { [EOL] if (newValue != 0) { [EOL] throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL] } [EOL] } else { [EOL] values[index] = newValue; [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
public void testSetPeriodInternal_AllFields() { [EOL] int[] result = setPeriodInternal(1, 1, 1, 1, 1, 1, 1, 1); [EOL] assertEquals(1, result[DurationFieldType.years().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.months().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.weeks().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.days().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.hours().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.minutes().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.seconds().getIndex()]); [EOL] assertEquals(1, result[DurationFieldType.millis().getIndex()]); [EOL] }
public void testSetPeriodInternal_ZeroFields() { [EOL] int[] result = setPeriodInternal(0, 0, 0, 0, 0, 0, 0, 0); [EOL] assertEquals(0, result[DurationFieldType.years().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.months().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.weeks().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.days().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.hours().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.minutes().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.seconds().getIndex()]); [EOL] assertEquals(0, result[DurationFieldType.millis().getIndex()]); [EOL] }
public void testSetPeriodInternal_NegativeFields() { [EOL] int[] result = setPeriodInternal(-1, -1, -1, -1, -1, -1, -1, -1); [EOL] assertEquals(-1, result[DurationFieldType.years().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.months().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.weeks().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.days().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.hours().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.minutes().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.seconds().getIndex()]); [EOL] assertEquals(-1, result[DurationFieldType.millis().getIndex()]); [EOL] }
protected void setField(DurationFieldType field, int value) { [EOL] setFieldInto(iValues, field, value); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void setFieldInto(int[] values, DurationFieldType field, int value) { [EOL] int index = indexOf(field); [EOL] if (index == -1) { [EOL] if (value != 0 || field == null) { [EOL] throw new IllegalArgumentException("Period does not support field '" + field + "'"); [EOL] } [EOL] } else { [EOL] values[index] = value; [EOL] } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }]
public void testForFieldsWithNullFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(null, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithEmptyFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(Collections.emptyList(), true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithMonthOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekOfWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfMonth() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfWeek() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithUnsupportedOperationException() { [EOL] Set<DateTimeFieldType> fields = new HashSet<DateTimeFieldType>() { [EOL] @Override [EOL] public boolean retainAll(Collection<?> c) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithNoValidFormat() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.halfdayOfDay()); [EOL] try { [EOL] DateTimeFormatter.forFields(fields, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("No valid format for fields")); [EOL] } [EOL] }
public void testDateByMonthWithYearMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearMonth() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithYearDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithMonthOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithDayOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testTimeWithNoFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("HH", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourMinuteSecond() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("HH:mm:ss", bld.toFormatter().toString()); [EOL] }
public void testTimeWithStrictISOAndReducedPrecision() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] try { [EOL] time(bld, fields, false, true, true, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOAndDatePresent() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] try { [EOL] time(bld, fields, false, true, false, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOWithoutHour() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] try { [EOL] time(bld, fields, false, true, false, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithExtendedFormat() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("HH:mm", bld.toFormatter().toString()); [EOL] }
public void testTimeWithMilli() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.millisOfSecond()); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("-.SSS", bld.toFormatter().toString()); [EOL] }
public void testAppendSeparatorWithExtendedTrue() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] appendSeparator(bld, true); [EOL] assertEquals("-", bld.toFormatter().toString()); [EOL] }
public void testAppendSeparatorWithExtendedFalse() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] appendSeparator(bld, false); [EOL] assertEquals("", bld.toFormatter().toString()); [EOL] }
public void testDateParser() { [EOL] DateTimeFormatter result = ClassName.dateParser(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.dp, result); [EOL] }
public void testLocalTimeParser() { [EOL] DateTimeFormatter result = ClassName.localTimeParser(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.ltp, result); [EOL] }
public void testTimeElementParser() { [EOL] DateTimeFormatter result = ClassName.timeElementParser(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.tpe, result); [EOL] }
public void testDateOptionalTimeParser() { [EOL] DateTimeFormatter formatter = ClassName.dateOptionalTimeParser(); [EOL] assertNotNull(formatter); [EOL] }
public void testTTime() { [EOL] DateTimeFormatter result = YourClass.tTime(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.tt, result); [EOL] }
public void testOrdinalDate() { [EOL] DateTimeFormatter result = Time.ordinalDate(); [EOL] assertNotNull("DateTimeFormatter should not be null", result); [EOL] }
public void testBasicTimeNoMillis() { [EOL] DateTimeFormatter formatter = TimeUtils.basicTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testBasicDateTimeNoMillis() { [EOL] DateTimeFormatter formatter = ClassName.basicDateTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] assertEquals("BasicDateTimeNoMillis formatter pattern", "yyyyMMdd'T'HHmmssZ", formatter.getPattern()); [EOL] }
public void testBasicOrdinalDate() { [EOL] DateTimeFormatter formatter = Time.basicOrdinalDate(); [EOL] assertNotNull(formatter); [EOL] }
public void testBasicWeekDateTimeNoMillis() { [EOL] DateTimeFormatter formatter = Time.basicWeekDateTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testYearFormatter() { [EOL] DateTimeFormatter formatter = ClassName.year(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Year formatter should match the predefined constant", Constants.ye, formatter); [EOL] }
public void testYearMonth() { [EOL] DateTimeFormatter formatter = Time.yearMonth(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter to match the constant ym", Constants.ym, formatter); [EOL] }
public void testMinutes_Zero() { [EOL] Minutes result = Time.minutes(0); [EOL] assertSame(Minutes.ZERO, result); [EOL] }
public void testMinutes_One() { [EOL] Minutes result = Time.minutes(1); [EOL] assertSame(Minutes.ONE, result); [EOL] }
public void testMinutes_Two() { [EOL] Minutes result = Time.minutes(2); [EOL] assertSame(Minutes.TWO, result); [EOL] }
public void testMinutes_Three() { [EOL] Minutes result = Time.minutes(3); [EOL] assertSame(Minutes.THREE, result); [EOL] }
public void testMinutes_MaxValue() { [EOL] Minutes result = Time.minutes(Integer.MAX_VALUE); [EOL] assertSame(Minutes.MAX_VALUE, result); [EOL] }
public void testMinutes_MinValue() { [EOL] Minutes result = Time.minutes(Integer.MIN_VALUE); [EOL] assertSame(Minutes.MIN_VALUE, result); [EOL] }
public void testMinutes_Default() { [EOL] int arbitraryMinutes = 10; [EOL] Minutes result = Time.minutes(arbitraryMinutes); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryMinutes, result.getMinutes()); [EOL] }
public void testMinutesBetween_SameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Minutes result = Time.minutesBetween(start, end); [EOL] assertEquals(0, result.getMinutes()); [EOL] }
public void testMinutesBetween_DifferentInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusMinutes(30); [EOL] Minutes result = Time.minutesBetween(start, end); [EOL] assertEquals(30, result.getMinutes()); [EOL] }
public void testMinutesConstructor_ValidValue() { [EOL] int minutesValue = 10; [EOL] Minutes minutes = new Minutes(minutesValue); [EOL] assertEquals(minutesValue, minutes.getMinutes()); [EOL] }
public void testToStandardSeconds_Positive() { [EOL] Minutes minutes = Minutes.minutes(2); [EOL] Seconds seconds = minutes.toStandardSeconds(); [EOL] assertEquals(120, seconds.getSeconds()); [EOL] }
public void testToStandardSeconds_Negative() { [EOL] Minutes minutes = Minutes.minutes(-3); [EOL] Seconds seconds = minutes.toStandardSeconds(); [EOL] assertEquals(-180, seconds.getSeconds()); [EOL] }
public void testToStandardSeconds_Zero() { [EOL] Minutes minutes = Minutes.minutes(0); [EOL] Seconds seconds = minutes.toStandardSeconds(); [EOL] assertEquals(0, seconds.getSeconds()); [EOL] }
public void testIsLessThanWithNullOther() { [EOL] Minutes minutes = new Minutes(-1); [EOL] boolean result = minutes.isLessThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNullOtherAndPositiveMinutes() { [EOL] Minutes minutes = new Minutes(1); [EOL] boolean result = minutes.isLessThan(null); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithNonNullOtherAndLessMinutes() { [EOL] Minutes minutes1 = new Minutes(5); [EOL] Minutes minutes2 = new Minutes(10); [EOL] boolean result = minutes1.isLessThan(minutes2); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNonNullOtherAndEqualMinutes() { [EOL] Minutes minutes1 = new Minutes(10); [EOL] Minutes minutes2 = new Minutes(10); [EOL] boolean result = minutes1.isLessThan(minutes2); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithNonNullOtherAndMoreMinutes() { [EOL] Minutes minutes1 = new Minutes(15); [EOL] Minutes minutes2 = new Minutes(10); [EOL] boolean result = minutes1.isLessThan(minutes2); [EOL] assertFalse(result); [EOL] }
public static void main(String[] args) throws Exception { [EOL] if (args.length == 0) { [EOL] printUsage(); [EOL] return; [EOL] } [EOL] File inputDir = null; [EOL] File outputDir = null; [EOL] boolean verbose = false; [EOL] int i; [EOL] for (i = 0; i < args.length; i++) { [EOL] try { [EOL] if ("-src".equals(args[i])) { [EOL] inputDir = new File(args[++i]); [EOL] } else if ("-dst".equals(args[i])) { [EOL] outputDir = new File(args[++i]); [EOL] } else if ("-verbose".equals(args[i])) { [EOL] verbose = true; [EOL] } else if ("-?".equals(args[i])) { [EOL] printUsage(); [EOL] return; [EOL] } else { [EOL] break; [EOL] } [EOL] } catch (IndexOutOfBoundsException e) { [EOL] printUsage(); [EOL] return; [EOL] } [EOL] } [EOL] if (i >= args.length) { [EOL] printUsage(); [EOL] return; [EOL] } [EOL] File[] sources = new File[args.length - i]; [EOL] for (int j = 0; i < args.length; i++, j++) { [EOL] sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]); [EOL] } [EOL] cVerbose.set(verbose); [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] zic.compile(outputDir, sources); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] } [EOL] };
static DateTimeOfYear getStartOfYear() { [EOL] if (cStartOfYear == null) { [EOL] cStartOfYear = new DateTimeOfYear(); [EOL] } [EOL] return cStartOfYear; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }]
static Chronology getLenientISOChronology() { [EOL] if (cLenientISO == null) { [EOL] cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); [EOL] } [EOL] return cLenientISO; [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; [EOL] }]
static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException { [EOL] Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size()); [EOL] TreeMap<Short, String> indexToId = new TreeMap<Short, String>(); [EOL] short count = 0; [EOL] for (Entry<String, DateTimeZone> entry : zimap.entrySet()) { [EOL] String id = (String) entry.getKey(); [EOL] if (!idToIndex.containsKey(id)) { [EOL] Short index = Short.valueOf(count); [EOL] idToIndex.put(id, index); [EOL] indexToId.put(index, id); [EOL] if (++count == 0) { [EOL] throw new InternalError("Too many time zone ids"); [EOL] } [EOL] } [EOL] id = ((DateTimeZone) entry.getValue()).getID(); [EOL] if (!idToIndex.containsKey(id)) { [EOL] Short index = Short.valueOf(count); [EOL] idToIndex.put(id, index); [EOL] indexToId.put(index, id); [EOL] if (++count == 0) { [EOL] throw new InternalError("Too many time zone ids"); [EOL] } [EOL] } [EOL] } [EOL] dout.writeShort(indexToId.size()); [EOL] for (String id : indexToId.values()) { [EOL] dout.writeUTF(id); [EOL] } [EOL] dout.writeShort(zimap.size()); [EOL] for (Entry<String, DateTimeZone> entry : zimap.entrySet()) { [EOL] String id = entry.getKey(); [EOL] dout.writeShort(idToIndex.get(id).shortValue()); [EOL] id = entry.getValue().getID(); [EOL] dout.writeShort(idToIndex.get(id).shortValue()); [EOL] } [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; }]
public void testParseYearWithMinimum() { [EOL] int result = ZoneInfoCompiler.parseYear("minimum", 0); [EOL] assertEquals(Integer.MIN_VALUE, result); [EOL] } [EOL] public void testParseYearWithMin() { [EOL] int result = ZoneInfoCompiler.parseYear("min", 0); [EOL] assertEquals(Integer.MIN_VALUE, result); [EOL] } [EOL] public void testParseYearWithMaximum() { [EOL] int result = ZoneInfoCompiler.parseYear("maximum", 0); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] } [EOL] public void testParseYearWithMax() { [EOL] int result = ZoneInfoCompiler.parseYear("max", 0); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] } [EOL] public void testParseYearWithOnly() { [EOL] int defaultValue = 2023; [EOL] int result = ZoneInfoCompiler.parseYear("only", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] } [EOL] public void testParseYearWithNumber() { [EOL] int result = ZoneInfoCompiler.parseYear("1987", 0); [EOL] assertEquals(1987, result); [EOL] } [EOL] public void testParseYearWithInvalidString() { [EOL] try { [EOL] ZoneInfoCompiler.parseYear("invalid", 0); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException expected) { [EOL] } [EOL] }
static String parseOptional(String str) { [EOL] return (str.equals("-")) ? null : str; [EOL] }
static int parseTime(String str) { [EOL] DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction(); [EOL] MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology()); [EOL] int pos = 0; [EOL] if (str.startsWith("-")) { [EOL] pos = 1; [EOL] } [EOL] int newPos = p.parseInto(mdt, str, pos); [EOL] if (newPos == ~pos) { [EOL] throw new IllegalArgumentException(str); [EOL] } [EOL] int millis = (int) mdt.getMillis(); [EOL] if (pos == 1) { [EOL] millis = -millis; [EOL] } [EOL] return millis; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }]
static char parseZoneChar(char c) { [EOL] switch(c) { [EOL] case 's': [EOL] case 'S': [EOL] return 's'; [EOL] case 'u': [EOL] case 'U': [EOL] case 'g': [EOL] case 'G': [EOL] case 'z': [EOL] case 'Z': [EOL] return 'u'; [EOL] case 'w': [EOL] case 'W': [EOL] default: [EOL] return 'w'; [EOL] } [EOL] }
public void testIdNotEqualsTimeZoneId() { [EOL] String id = "UTC"; [EOL] DateTimeZone tz = DateTimeZone.forID("Europe/London"); [EOL] boolean result = test(id, tz); [EOL] assertTrue(result); [EOL] }
public void testIdEqualsTimeZoneIdWithNoTransitions() { [EOL] String id = "Europe/London"; [EOL] DateTimeZone tz = DateTimeZone.forID(id); [EOL] boolean result = test(id, tz); [EOL] assertTrue(result); [EOL] }
public void testIdEqualsTimeZoneIdWithTransitionErrors() { [EOL] String id = "Europe/London"; [EOL] DateTimeZone tz = new DateTimeZone(id) { [EOL] @Override [EOL] public String getNameKey(long instant) { [EOL] return instant == ISOChronology.getInstanceUTC().year().set(0, 1850) ? "???" : super.getNameKey(instant); [EOL] } [EOL] @Override [EOL] public long nextTransition(long instant) { [EOL] return instant + DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public long previousTransition(long instant) { [EOL] return instant - DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public boolean isFixed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public long getOffset(long instant) { [EOL] return instant < ISOChronology.getInstanceUTC().year().set(0, 1850) ? 0 : DateTimeConstants.MILLIS_PER_HOUR; // Change offset after 1850 [EOL] } [EOL] @Override [EOL] public int getStandardOffset(long instant) { [EOL] return 0; [EOL] } [EOL] }; [EOL] boolean result = test(id, tz); [EOL] assertFalse(result); [EOL] }
public void testIdEqualsTimeZoneIdWithNullNameKey() { [EOL] String id = "Europe/London"; [EOL] DateTimeZone tz = new DateTimeZone(id) { [EOL] @Override [EOL] public String getNameKey(long instant) { [EOL] return null; // Force a null name key [EOL] } [EOL] @Override [EOL] public long nextTransition(long instant) { [EOL] return instant + DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public long previousTransition(long instant) { [EOL] return instant - DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public boolean isFixed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public long getOffset(long instant) { [EOL] return DateTimeConstants.MILLIS_PER_HOUR; // Constant offset [EOL] } [EOL] @Override [EOL] public int getStandardOffset(long instant) { [EOL] return 0; [EOL] } [EOL] }; [EOL] boolean result = test(id, tz); [EOL] assertFalse(result); [EOL] }
public void testIdEqualsTimeZoneIdWithShortNameKey() { [EOL] String id = "Europe/London"; [EOL] DateTimeZone tz = new DateTimeZone(id) { [EOL] @Override [EOL] public String getNameKey(long instant) { [EOL] return "AB"; // Force a short name key [EOL] } [EOL] @Override [EOL] public long nextTransition(long instant) { [EOL] return instant + DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public long previousTransition(long instant) { [EOL] return instant - DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public boolean isFixed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public long getOffset(long instant) { [EOL] return DateTimeConstants.MILLIS_PER_HOUR; // Constant offset [EOL] } [EOL] @Override [EOL] public int getStandardOffset(long instant) { [EOL] return 0; [EOL] } [EOL] }; [EOL] boolean result = test(id, tz); [EOL] assertFalse(result); [EOL] }
public void testIdEqualsTimeZoneIdWithReverseTransitionErrors() { [EOL] String id = "Europe/London"; [EOL] DateTimeZone tz = new DateTimeZone(id) { [EOL] @Override [EOL] public long nextTransition(long instant) { [EOL] return instant + DateTimeConstants.MILLIS_PER_DAY; // Force a transition every day [EOL] } [EOL] @Override [EOL] public long previousTransition(long instant) { [EOL] return instant - DateTimeConstants.MILLIS_PER_DAY * 2; // Force a wrong previous transition [EOL] } [EOL] @Override [EOL] public boolean isFixed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public long getOffset(long instant) { [EOL] return DateTimeConstants.MILLIS_PER_HOUR; // Constant offset [EOL] } [EOL] @Override [EOL] public int getStandardOffset(long instant) { [EOL] return 0; [EOL] } [EOL] }; [EOL] boolean result = test(id, tz); [EOL] assertFalse(result); [EOL] }
public ZoneInfoCompiler() { [EOL] iRuleSets = new HashMap<String, RuleSet>(); [EOL] iZones = new ArrayList<Zone>(); [EOL] iLinks = new ArrayList<String>(); [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; }]
public void testCompileWithNullSourcesAndOutputDir() throws IOException { [EOL] File outputDir = null; [EOL] File[] sources = null; [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] Map<String, DateTimeZone> result = zic.compile(outputDir, sources); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testCompileWithEmptySourcesAndValidOutputDir() throws IOException { [EOL] File outputDir = createTempDir(); [EOL] File[] sources = new File[0]; [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] Map<String, DateTimeZone> result = zic.compile(outputDir, sources); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] assertTrue(outputDir.exists()); [EOL] assertTrue(outputDir.isDirectory()); [EOL] deleteTempDir(outputDir); [EOL] }
public void testCompileWithValidSourcesAndOutputDir() throws IOException { [EOL] File outputDir = createTempDir(); [EOL] File[] sources = new File[] {createTempFileWithData()}; [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] Map<String, DateTimeZone> result = zic.compile(outputDir, sources); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue(outputDir.exists()); [EOL] assertTrue(outputDir.isDirectory()); [EOL] deleteTempDir(outputDir); [EOL] }
public void testCompileWithValidSourcesAndNonExistentOutputDir() throws IOException { [EOL] File outputDir = new File("nonexistent_dir"); [EOL] File[] sources = new File[] {createTempFileWithData()}; [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] try { [EOL] zic.compile(outputDir, sources); [EOL] fail("Should have thrown IOException because output directory cannot be created"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCompileWithValidSourcesAndOutputDirIsNotDirectory() throws IOException { [EOL] File outputDir = createTempFile(); [EOL] File[] sources = new File[] {createTempFileWithData()}; [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] try { [EOL] zic.compile(outputDir, sources); [EOL] fail("Should have thrown IOException because output directory is not a directory"); [EOL] } catch (IOException e) { [EOL] } finally { [EOL] deleteTempFile(outputDir); [EOL] } [EOL] }
public void testCompileWithValidSourcesAndOutputDirCannotBeCreated() throws IOException { [EOL] File outputDir = createTempFile(); [EOL] outputDir.setReadOnly(); [EOL] File[] sources = new File[] {createTempFileWithData()}; [EOL] ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL] try { [EOL] zic.compile(outputDir, sources); [EOL] fail("Should have thrown IOException because output directory cannot be created"); [EOL] } catch (IOException e) { [EOL] } finally { [EOL] deleteTempFile(outputDir); [EOL] } [EOL] }
public void testParseDataFile_EmptyLinesAndComments() throws IOException { [EOL] BufferedReader in = new BufferedReader(new StringReader("\n#comment\n   # another comment\n")); [EOL] parseDataFile(in); [EOL] }
public void testParseDataFile_ValidZoneLine() throws IOException { [EOL] BufferedReader in = new BufferedReader(new StringReader("Zone Europe/London  0:00 EU GMT/BST")); [EOL] parseDataFile(in); [EOL] }
public void testParseDataFile_ValidRuleLine() throws IOException { [EOL] BufferedReader in = new BufferedReader(new StringReader("Rule EU 1981 1995 - Mar lastSun  1:00u 1:00 S")); [EOL] parseDataFile(in); [EOL] }
public void testParseDataFile_ValidLinkLine() throws IOException { [EOL] BufferedReader in = new BufferedReader(new StringReader("Link Europe/Istanbul Asia/Istanbul")); [EOL] parseDataFile(in); [EOL] }
public void testParseDataFile_UnknownLine() throws IOException { [EOL] ByteArrayOutputStream outContent = new ByteArrayOutputStream(); [EOL] System.setOut(new PrintStream(outContent)); [EOL] BufferedReader in = new BufferedReader(new StringReader("Unknown line content")); [EOL] parseDataFile(in); [EOL] assertTrue(outContent.toString().contains("Unknown line: Unknown line content")); [EOL] System.setOut(System.out); [EOL] }
public void testParseDataFile_WhitespaceBeforeToken() throws IOException { [EOL] BufferedReader in = new BufferedReader(new StringReader(" Zone Europe/London  0:00 EU GMT/BST")); [EOL] parseDataFile(in); [EOL] }
public void testParseDataFile_EndOfFileWithZone() throws IOException { [EOL] BufferedReader in = new BufferedReader(new StringReader("Zone Europe/London  0:00 EU GMT/BST\n")); [EOL] parseDataFile(in); [EOL] }
DateTimeOfYear() { [EOL] iMonthOfYear = 1; [EOL] iDayOfMonth = 1; [EOL] iDayOfWeek = 0; [EOL] iAdvanceDayOfWeek = false; [EOL] iMillisOfDay = 0; [EOL] iZoneChar = 'w'; [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] }; [EOL] }]
DateTimeOfYear(StringTokenizer st) { [EOL] int month = 1; [EOL] int day = 1; [EOL] int dayOfWeek = 0; [EOL] int millis = 0; [EOL] boolean advance = false; [EOL] char zoneChar = 'w'; [EOL] if (st.hasMoreTokens()) { [EOL] month = parseMonth(st.nextToken()); [EOL] if (st.hasMoreTokens()) { [EOL] String str = st.nextToken(); [EOL] if (str.startsWith("last")) { [EOL] day = -1; [EOL] dayOfWeek = parseDayOfWeek(str.substring(4)); [EOL] advance = false; [EOL] } else { [EOL] try { [EOL] day = Integer.parseInt(str); [EOL] dayOfWeek = 0; [EOL] advance = false; [EOL] } catch (NumberFormatException e) { [EOL] int index = str.indexOf(">="); [EOL] if (index > 0) { [EOL] day = Integer.parseInt(str.substring(index + 2)); [EOL] dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL] advance = true; [EOL] } else { [EOL] index = str.indexOf("<="); [EOL] if (index > 0) { [EOL] day = Integer.parseInt(str.substring(index + 2)); [EOL] dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL] advance = false; [EOL] } else { [EOL] throw new IllegalArgumentException(str); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (st.hasMoreTokens()) { [EOL] str = st.nextToken(); [EOL] zoneChar = parseZoneChar(str.charAt(str.length() - 1)); [EOL] if (str.equals("24:00")) { [EOL] LocalDate date = (day == -1 ? new LocalDate(2001, month, 1).plusMonths(1) : new LocalDate(2001, month, day).plusDays(1)); [EOL] advance = (day != -1); [EOL] month = date.getMonthOfYear(); [EOL] day = date.getDayOfMonth(); [EOL] dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1; [EOL] } else { [EOL] millis = parseTime(str); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] iMonthOfYear = month; [EOL] iDayOfMonth = day; [EOL] iDayOfWeek = dayOfWeek; [EOL] iAdvanceDayOfWeek = advance; [EOL] iMillisOfDay = millis; [EOL] iZoneChar = zoneChar; [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; }]
public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear) { [EOL] builder.addRecurringSavings(nameKey, saveMillis, fromYear, toYear, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay); [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] }; [EOL] }]
public void addCutover(DateTimeZoneBuilder builder, int year) { [EOL] builder.addCutover(year, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay); [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] }; [EOL] }]
Rule(StringTokenizer st) { [EOL] iName = st.nextToken().intern(); [EOL] iFromYear = parseYear(st.nextToken(), 0); [EOL] iToYear = parseYear(st.nextToken(), iFromYear); [EOL] if (iToYear < iFromYear) { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] iType = parseOptional(st.nextToken()); [EOL] iDateTimeOfYear = new DateTimeOfYear(st); [EOL] iSaveMillis = parseTime(st.nextToken()); [EOL] iLetterS = parseOptional(st.nextToken()); [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] }; [EOL] }]
public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) { [EOL] String nameKey = formatName(nameFormat); [EOL] iDateTimeOfYear.addRecurring(builder, nameKey, iSaveMillis, iFromYear, iToYear); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }]
private String formatName(String nameFormat) { [EOL] int index = nameFormat.indexOf('/'); [EOL] if (index > 0) { [EOL] if (iSaveMillis == 0) { [EOL] return nameFormat.substring(0, index).intern(); [EOL] } else { [EOL] return nameFormat.substring(index + 1).intern(); [EOL] } [EOL] } [EOL] index = nameFormat.indexOf("%s"); [EOL] if (index < 0) { [EOL] return nameFormat; [EOL] } [EOL] String left = nameFormat.substring(0, index); [EOL] String right = nameFormat.substring(index + 2); [EOL] String name; [EOL] if (iLetterS == null) { [EOL] name = left.concat(right); [EOL] } else { [EOL] name = left + iLetterS + right; [EOL] } [EOL] return name.intern(); [EOL] }
RuleSet(Rule rule) { [EOL] iRules = new ArrayList<Rule>(); [EOL] iRules.add(rule); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] } [EOL] }
void addRule(Rule rule) { [EOL] if (!(rule.iName.equals(iRules.get(0).iName))) { [EOL] throw new IllegalArgumentException("Rule name mismatch"); [EOL] } [EOL] iRules.add(rule); [EOL] }
public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) { [EOL] for (int i = 0; i < iRules.size(); i++) { [EOL] Rule rule = iRules.get(i); [EOL] rule.addRecurring(builder, nameFormat); [EOL] } [EOL] }
public void testZoneWithValidStringTokenizer() { [EOL] StringTokenizer st = new StringTokenizer("ZoneName"); [EOL] Zone zone = new Zone(st); [EOL] assertNotNull(zone); [EOL] } [EOL] public void testZoneWithEmptyStringTokenizer() { [EOL] StringTokenizer st = new StringTokenizer(""); [EOL] try { [EOL] Zone zone = new Zone(st); [EOL] fail("Should have thrown NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testZoneWithNullStringTokenizer() { [EOL] try { [EOL] Zone zone = new Zone(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
private Zone(String name, StringTokenizer st) { [EOL] iName = name.intern(); [EOL] iOffsetMillis = parseTime(st.nextToken()); [EOL] iRules = parseOptional(st.nextToken()); [EOL] iFormat = st.nextToken().intern(); [EOL] int year = Integer.MAX_VALUE; [EOL] DateTimeOfYear dtOfYear = getStartOfYear(); [EOL] if (st.hasMoreTokens()) { [EOL] year = Integer.parseInt(st.nextToken()); [EOL] if (st.hasMoreTokens()) { [EOL] dtOfYear = new DateTimeOfYear(st); [EOL] } [EOL] } [EOL] iUntilYear = year; [EOL] iUntilDateTimeOfYear = dtOfYear; [EOL] }
void chain(StringTokenizer st) { [EOL] if (iNext != null) { [EOL] iNext.chain(st); [EOL] } else { [EOL] iNext = new Zone(iName, st); [EOL] } [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() { [EOL] protected Boolean initialValue() { [EOL] return Boolean.FALSE; [EOL] }; [EOL] }]
public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) { [EOL] addToBuilder(this, builder, ruleSets); [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; [EOL] }]
private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) { [EOL] for (; zone != null; zone = zone.iNext) { [EOL] builder.setStandardOffset(zone.iOffsetMillis); [EOL] if (zone.iRules == null) { [EOL] builder.setFixedSavings(zone.iFormat, 0); [EOL] } else { [EOL] try { [EOL] int saveMillis = parseTime(zone.iRules); [EOL] builder.setFixedSavings(zone.iFormat, saveMillis); [EOL] } catch (Exception e) { [EOL] RuleSet rs = ruleSets.get(zone.iRules); [EOL] if (rs == null) { [EOL] throw new IllegalArgumentException("Rules not found: " + zone.iRules); [EOL] } [EOL] rs.addRecurring(builder, zone.iFormat); [EOL] } [EOL] } [EOL] if (zone.iUntilYear == Integer.MAX_VALUE) { [EOL] break; [EOL] } [EOL] zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear); [EOL] } [EOL] } [EOL] public ZoneInfoCompiler(); [EOL] DateTimeOfYear(); [EOL] DateTimeOfYear(StringTokenizer st); [EOL] Rule(StringTokenizer st); [EOL] RuleSet(Rule rule); [EOL] Zone(StringTokenizer st); [EOL] private Zone(String name, StringTokenizer st); [EOL] protected Boolean initialValue(); [EOL] public static boolean verbose(); [EOL] public static void main(String[] args) throws Exception; [EOL] private static void printUsage(); [EOL] static DateTimeOfYear getStartOfYear(); [EOL] static Chronology getLenientISOChronology(); [EOL] static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException; [EOL] static int parseYear(String str, int def); [EOL] static int parseMonth(String str); [EOL] static int parseDayOfWeek(String str); [EOL] static String parseOptional(String str); [EOL] static int parseTime(String str); [EOL] static char parseZoneChar(char c); [EOL] static boolean test(String id, DateTimeZone tz); [EOL] public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; [EOL] public void parseDataFile(BufferedReader in) throws IOException; [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); [EOL] public void addCutover(DateTimeZoneBuilder builder, int year); [EOL] public String toString(); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] private String formatName(String nameFormat); [EOL] public String toString(); [EOL] void addRule(Rule rule); [EOL] public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); [EOL] void chain(StringTokenizer st); [EOL] public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); [EOL] public String toString(); [EOL] DateTimeOfYear cStartOfYear; [EOL] Chronology cLenientISO; [EOL] ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ; [EOL] protected Boolean initialValue() {; [EOL] return Boolean.FALSE;; [EOL] }; }]
public void testGetInstanceWithNullZoneAndValidMinDays() { [EOL] GregorianChronology chrono = GregorianChronology.getInstance(null, 4); [EOL] assertNotNull(chrono); [EOL] }
public void testGetInstanceWithNonNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, 4); [EOL] assertNotNull(chrono); [EOL] }
public void testGetInstanceWithUTCZoneAndValidMinDays() { [EOL] GregorianChronology chrono = GregorianChronology.getInstance(DateTimeZone.UTC, 4); [EOL] assertNotNull(chrono); [EOL] }
public void testGetInstanceWithInvalidMinDays() { [EOL] try { [EOL] GregorianChronology.getInstance(DateTimeZone.UTC, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGregorianChronologyConstructor() { [EOL] Chronology base = null; // Assuming Chronology is an abstract class or interface [EOL] Object param = new Object(); [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology chronology = new GregorianChronology(base, param, minDaysInFirstWeek); [EOL] assertNotNull(chronology); [EOL] }
public void testReadResolve_BaseIsNull() { [EOL] setBase(null); [EOL] setMinimumDaysInFirstWeek(0); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(DateTimeZone.UTC, ((YourExpectedType) result).getZone()); [EOL] assertEquals(4, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] }
public void testReadResolve_BaseIsNotNull() { [EOL] Chronology mockBase = createMockChronology(); [EOL] setBase(mockBase); [EOL] setMinimumDaysInFirstWeek(3); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(mockBase.getZone(), ((YourExpectedType) result).getZone()); [EOL] assertEquals(3, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] }
public void testReadResolve_MinimumDaysIsZero() { [EOL] Chronology mockBase = createMockChronology(); [EOL] setBase(mockBase); [EOL] setMinimumDaysInFirstWeek(0); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(mockBase.getZone(), ((YourExpectedType) result).getZone()); [EOL] assertEquals(4, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] }
protected void assemble(Fields fields) { [EOL] if (getBase() == null) { [EOL] super.assemble(fields); [EOL] } [EOL] }
public void testGetAverageMillisPerYear() { [EOL] long expected = MILLIS_PER_YEAR; [EOL] long actual = getAverageMillisPerYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAverageMillisPerMonth() { [EOL] Time time = new Time(); [EOL] long expected = Time.MILLIS_PER_MONTH; [EOL] long actual = time.getAverageMillisPerMonth(); [EOL] assertEquals(expected, actual); [EOL] }
public void testBaseDateTimeConstructor() { [EOL] BaseDateTime baseDateTime = new BaseDateTime(); [EOL] assertNotNull("The BaseDateTime object should not be null", baseDateTime); [EOL] assertEquals("The chronology should be ISOChronology", ISOChronology.getInstance(), baseDateTime.getChronology()); [EOL] assertEquals("The milliseconds should be the current time", DateTimeUtils.currentTimeMillis(), baseDateTime.getMillis(), 1000); [EOL] }
public void testBaseDateTimeWithCurrentTime() { [EOL] long currentInstant = System.currentTimeMillis(); [EOL] BaseDateTime dateTime = new BaseDateTime(currentInstant); [EOL] assertNotNull(dateTime); [EOL] assertEquals(currentInstant, dateTime.getMillis()); [EOL] }
public void testBaseDateTimeWithSpecificTime() { [EOL] long specificInstant = 1000L; // 1 second past the epoch [EOL] BaseDateTime dateTime = new BaseDateTime(specificInstant); [EOL] assertNotNull(dateTime); [EOL] assertEquals(specificInstant, dateTime.getMillis()); [EOL] }
public void testBaseDateTimeWithValidInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] BaseDateTime dateTime = new BaseDateTime(instant, chronology); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithValidInstantAndNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] BaseDateTime dateTime = new BaseDateTime(instant, null); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertNotNull(dateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithNegativeInstantAndChronology() { [EOL] long instant = -1234567890L; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] BaseDateTime dateTime = new BaseDateTime(instant, chronology); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
protected Chronology checkChronology(Chronology chronology) { [EOL] return DateTimeUtils.getChronology(chronology); [EOL] }
public Chronology getChronology() { [EOL] return iChronology; [EOL] }
public int getOffsetTest() { [EOL] DateTimeZone zone = DateTimeZone.forOffsetHours(3); [EOL] long instant = System.currentTimeMillis(); [EOL] int expectedOffset = zone.getOffset(instant); [EOL] int actualOffset = zone.getOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testToTimeZoneWithGMTId() { [EOL] String gmtId = "+0200"; [EOL] when(getID()).thenReturn(gmtId); [EOL] java.util.TimeZone result = toTimeZone(); [EOL] assertEquals("GMT+0200", result.getID()); [EOL] }
public void testToTimeZoneWithNonGMTId() { [EOL] String nonGmtId = "NonGMTID"; [EOL] int wallOffset = 3600000; // 1 hour in milliseconds [EOL] when(getID()).thenReturn(nonGmtId); [EOL] when(iWallOffset).thenReturn(wallOffset); [EOL] java.util.TimeZone result = toTimeZone(); [EOL] assertTrue(result instanceof java.util.SimpleTimeZone); [EOL] assertEquals(nonGmtId, result.getID()); [EOL] assertEquals(wallOffset, ((java.util.SimpleTimeZone) result).getRawOffset()); [EOL] }
public void testEquals_Reflexive() { [EOL] FixedDateTimeZone zone = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] assertTrue(zone.equals(zone)); [EOL] }
public void testEquals_SameIDAndOffsets() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] assertTrue(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentID() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("GMT", "GMT", 0, 0); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentStandardOffset() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("UTC", "UTC", 3600000, 0); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentWallOffset() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("UTC", "UTC", 0, 3600000); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_Null() { [EOL] FixedDateTimeZone zone = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] assertFalse(zone.equals(null)); [EOL] }
public void testEquals_NonFixedDateTimeZone() { [EOL] FixedDateTimeZone zone = new FixedDateTimeZone("UTC", "UTC", 0, 0); [EOL] Object other = new Object(); [EOL] assertFalse(zone.equals(other)); [EOL] }
protected ReadableDurationConverter() { [EOL] super(); [EOL] }
public void testGetFieldType() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeFieldType mockFieldType = Mockito.mock(DateTimeFieldType.class); [EOL] Mockito.when(mockField.getType()).thenReturn(mockFieldType); [EOL] DateTimeProperty property = new DateTimeProperty(mockField); [EOL] DateTimeFieldType result = property.getFieldType(); [EOL] assertNotNull(result); [EOL] assertSame(mockFieldType, result); [EOL] }
public void testGetDifferenceWithNullInstant() { [EOL] DateTimeField field = mock(DateTimeField.class); [EOL] long currentMillis = DateTimeUtils.currentTimeMillis(); [EOL] long fieldMillis = 123456789L; [EOL] int expectedDifference = 10; [EOL] when(field.getDifference(fieldMillis, currentMillis)).thenReturn(expectedDifference); [EOL] Time time = new Time(field, fieldMillis); [EOL] int actualDifference = time.getDifference(null); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceWithNonNullInstant() { [EOL] DateTimeField field = mock(DateTimeField.class); [EOL] long fieldMillis = 123456789L; [EOL] ReadableInstant instant = mock(ReadableInstant.class); [EOL] long instantMillis = 987654321L; [EOL] int expectedDifference = 5; [EOL] when(field.getDifference(fieldMillis, instantMillis)).thenReturn(expectedDifference); [EOL] when(instant.getMillis()).thenReturn(instantMillis); [EOL] Time time = new Time(field, fieldMillis); [EOL] int actualDifference = time.getDifference(instant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLongWithNullInstant() { [EOL] MyTimeClass myTimeInstance = new MyTimeClass(); // Replace with actual constructor and state setup [EOL] long expected = 0L; // Replace with the expected value based on the current time and the internal state of myTimeInstance [EOL] long result = myTimeInstance.getDifferenceAsLong(null); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLongWithNonNullInstant() { [EOL] MyTimeClass myTimeInstance = new MyTimeClass(); // Replace with actual constructor and state setup [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); // Replace with actual instantiation or mocking [EOL] when(mockInstant.getMillis()).thenReturn(1234567890L); // Replace with a specific stubbed return value [EOL] long expected = 0L; // Replace with the expected value based on the stubbed instant and the internal state of myTimeInstance [EOL] long result = myTimeInstance.getDifferenceAsLong(mockInstant); [EOL] assertEquals(expected, result); [EOL] }
public void testToInterval() { [EOL] MyObject obj = new MyObject(mockedField, millis); [EOL] when(mockedField.roundFloor(anyLong())).thenReturn(someStartTime); [EOL] when(mockedField.add(anyLong(), anyInt())).thenReturn(someEndTime); [EOL] Interval result = obj.toInterval(); [EOL] assertNotNull(result); [EOL] assertEquals(someStartTime, result.getStartMillis()); [EOL] assertEquals(someEndTime, result.getEndMillis()); [EOL] }
public void testCompareTo_ThrowsIllegalArgumentException_WhenInstantIsNull() { [EOL] YourClass instance = new YourClass(); [EOL] try { [EOL] instance.compareTo(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The instant must not be null", e.getMessage()); [EOL] } [EOL] }
public void testCompareTo_ReturnsNegative_WhenThisValueIsLessThanOtherValue() { [EOL] YourClass instance = new YourClass(); // Assume get() returns a value less than otherValue [EOL] ReadableInstant other = createMockReadableInstantWithFieldValueGreaterThan(instance.get()); [EOL] int result = instance.compareTo(other); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_ReturnsPositive_WhenThisValueIsGreaterThanOtherValue() { [EOL] YourClass instance = new YourClass(); // Assume get() returns a value greater than otherValue [EOL] ReadableInstant other = createMockReadableInstantWithFieldValueLessThan(instance.get()); [EOL] int result = instance.compareTo(other); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_ReturnsZero_WhenValuesAreEqual() { [EOL] YourClass instance = new YourClass(); // Assume get() returns a value equal to otherValue [EOL] ReadableInstant other = createMockReadableInstantWithFieldValueEqualTo(instance.get()); [EOL] int result = instance.compareTo(other); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] ReadablePartial partial = null; [EOL] int result = compareTo(partial); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCompareTo_LessThan() { [EOL] ReadablePartial partial = createPartialWithFixedValue(5); // Assuming createPartialWithFixedValue sets the value for the field type [EOL] setInternalValue(3); // Assuming setInternalValue sets the internal value to compare [EOL] int result = compareTo(partial); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] ReadablePartial partial = createPartialWithFixedValue(2); // Assuming createPartialWithFixedValue sets the value for the field type [EOL] setInternalValue(4); // Assuming setInternalValue sets the internal value to compare [EOL] int result = compareTo(partial); [EOL] assertEquals(1, result); [EOL] }
public void testCompareTo_Equal() { [EOL] ReadablePartial partial = createPartialWithFixedValue(3); // Assuming createPartialWithFixedValue sets the value for the field type [EOL] setInternalValue(3); // Assuming setInternalValue sets the internal value to compare [EOL] int result = compareTo(partial); [EOL] assertEquals(0, result); [EOL] }
public void testEquals_SameObject() { [EOL] AbstractReadableInstantFieldProperty property = new ConcreteReadableInstantFieldProperty(); [EOL] assertTrue(property.equals(property)); [EOL] }
public void testEquals_Null() { [EOL] AbstractReadableInstantFieldProperty property = new ConcreteReadableInstantFieldProperty(); [EOL] assertFalse(property.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] AbstractReadableInstantFieldProperty property = new ConcreteReadableInstantFieldProperty(); [EOL] assertFalse(property.equals(new Object())); [EOL] }
public void testEquals_DifferentValue() { [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(1); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(2); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_DifferentFieldType() { [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(DateTimeFieldType.secondOfMinute()); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(DateTimeFieldType.minuteOfHour()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_DifferentChronology() { [EOL] Chronology chrono1 = ISOChronology.getInstanceUTC(); [EOL] Chronology chrono2 = GregorianChronology.getInstanceUTC(); [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(chrono1); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(chrono2); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_AllFieldsEqual() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(chrono, DateTimeFieldType.secondOfMinute(), 30); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(chrono, DateTimeFieldType.secondOfMinute(), 30); [EOL] assertTrue(property1.equals(property2)); [EOL] }
public int get(long instant) { [EOL] throw unsupported(); [EOL] }
public String getAsText(long instant, Locale locale) { [EOL] throw unsupported(); [EOL] }
public String getAsText(long instant) { [EOL] throw unsupported(); [EOL] }
public void testGetAsTextWithReadablePartial() { [EOL] try { [EOL] getAsText(null, 0, Locale.ENGLISH); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public String getAsText(ReadablePartial partial, Locale locale) { [EOL] throw unsupported(); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL] throw unsupported(); [EOL] }
public void testGetAsShortText_UnsupportedOperationException() { [EOL] try { [EOL] getAsShortText(0L, Locale.ENGLISH); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public String getAsShortText(long instant) { [EOL] throw unsupported(); [EOL] }
public void testGetAsShortText_WithUnsupportedOperationException() { [EOL] try { [EOL] getAsShortText(null, 0, null); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testGetAsShortTextWithNullPartial() { [EOL] try { [EOL] getAsShortText(null, Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] try { [EOL] getAsShortText(mockPartial, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testGetAsShortTextUnsupportedOperationException() { [EOL] try { [EOL] getAsShortText(0, Locale.ENGLISH); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testAdd_ThrowsUnsupportedOperationException() { [EOL] TimePeriodAdder adder = new TimePeriodAdder(); [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 5; [EOL] try { [EOL] adder.add(mockInstant, fieldIndex, values, valueToAdd); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testAddWrapPartialUnsupportedOperationException() { [EOL] try { [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] addWrapPartial(mockInstant, fieldIndex, values, valueToAdd); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public long addWrapField(long instant, int value) { [EOL] throw unsupported(); [EOL] }
public void testAddWrapFieldThrowsException() { [EOL] try { [EOL] int[] values = new int[]{1, 2, 3}; [EOL] int fieldIndex = 0; [EOL] int valueToAdd = 1; [EOL] ReadablePartial instant = null; // Assuming ReadablePartial is an interface or class available in the context [EOL] addWrapField(instant, fieldIndex, values, valueToAdd); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public long set(long instant, int value) { [EOL] throw unsupported(); [EOL] }
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) { [EOL] throw unsupported(); [EOL] }
public void testSet_ThrowsUnsupportedOperationException() { [EOL] try { [EOL] long instant = System.currentTimeMillis(); [EOL] String text = "anyText"; [EOL] Locale locale = Locale.getDefault(); [EOL] set(instant, text, locale); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public long set(long instant, String text) { [EOL] throw unsupported(); [EOL] }
public void testSetThrowsUnsupportedOperationException() { [EOL] Time time = new Time(); [EOL] ReadablePartial instant = null; // Assuming ReadablePartial is an interface or class available in the context [EOL] int fieldIndex = 0; [EOL] int[] values = new int[0]; [EOL] String text = ""; [EOL] Locale locale = Locale.getDefault(); [EOL] try { [EOL] time.set(instant, fieldIndex, values, text, locale); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertNotNull("Exception should not be null", e); [EOL] } [EOL] }
public void testGetRangeDurationField_ReturnsNull() { [EOL] Time time = new Time(); [EOL] assertNull("Range duration field should be null", time.getRangeDurationField()); [EOL] }
public boolean isLeap(long instant) { [EOL] throw unsupported(); [EOL] }
public int getLeapAmount(long instant) { [EOL] throw unsupported(); [EOL] }
public int getMinimumValue() { [EOL] throw unsupported(); [EOL] }
public int getMinimumValue(long instant) { [EOL] throw unsupported(); [EOL] }
public int getMinimumValueTest_ThrowsUnsupportedOperationException() { [EOL] try { [EOL] getMinimumValue(null); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testGetMinimumValue_WithUnsupportedOperation() { [EOL] Time time = new Time(); [EOL] try { [EOL] time.getMinimumValue(null, null); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testGetMaximumValueThrowsException() { [EOL] Time time = new Time(); [EOL] try { [EOL] time.getMaximumValue(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public int getMaximumValue(long instant) { [EOL] throw unsupported(); [EOL] }
public int getMaximumValue(ReadablePartial instant) { [EOL] throw unsupported(); [EOL] }
public int getMaximumValueTest_ThrowsUnsupportedOperationException() { [EOL] ReadablePartial instant = null; // Assuming ReadablePartial is an interface or class available in the context [EOL] int[] values = null; [EOL] try { [EOL] getMaximumValue(instant, values); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL] throw unsupported(); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL] throw unsupported(); [EOL] }
public long roundFloor(long instant) { [EOL] throw unsupported(); [EOL] }
public void testRoundCeiling_UnsupportedOperationException() { [EOL] try { [EOL] roundCeiling(0L); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public long roundHalfFloor(long instant) { [EOL] throw unsupported(); [EOL] }
public void testRoundHalfCeiling_UnsupportedOperationException() { [EOL] try { [EOL] roundHalfCeiling(0L); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public long roundHalfEven(long instant) { [EOL] throw unsupported(); [EOL] }
public long remainder(long instant) { [EOL] throw unsupported(); [EOL] }
public String testToString() { [EOL] UnsupportedDateTimeField field = new UnsupportedDateTimeField(); [EOL] String result = field.toString(); [EOL] assert "UnsupportedDateTimeField".equals(result); [EOL] }
private UnsupportedOperationException unsupported() { [EOL] return new UnsupportedOperationException(iType + " field is unsupported"); [EOL] }
public void testGetWithPositiveInstant() { [EOL] long instant = 1000; // Assume this is a positive instant [EOL] int expected = (int) ((instant / getUnitMillis()) % iRange); // Replace getUnitMillis() and iRange with actual values [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithNegativeInstant() { [EOL] long instant = -1000; // Assume this is a negative instant [EOL] int expected = iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange); // Replace getUnitMillis() and iRange with actual values [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMinimumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int minimumValue = getMinimumValue(); [EOL] long expected = instant + (minimumValue - get(instant)) * iUnitMillis; [EOL] long result = set(instant, minimumValue); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithMaximumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int maximumValue = getMaximumValue(); [EOL] long expected = instant + (maximumValue - get(instant)) * iUnitMillis; [EOL] long result = set(instant, maximumValue); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithMidRangeValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int midRangeValue = (getMinimumValue() + getMaximumValue()) / 2; [EOL] long expected = instant + (midRangeValue - get(instant)) * iUnitMillis; [EOL] long result = set(instant, midRangeValue); [EOL] assertEquals(expected, result); [EOL] }
public void testGetZoneReturnsCorrectDateTimeZone() { [EOL] DateTimeZone expectedZone = DateTimeZone.UTC; // Example timezone [EOL] MyClass myObject = new MyClass(expectedZone); // MyClass is a placeholder for the actual class name [EOL] DateTimeZone actualZone = myObject.getZone(); [EOL] assertEquals("The returned DateTimeZone should be the same as the one set.", expectedZone, actualZone); [EOL] }
public void testAddWithTimeFieldTrue() { [EOL] long instant = 0L; // Example initial instant [EOL] int value = 5; // Example value to add [EOL] int offset = 10; // Example offset [EOL] long expected = 15L; // Expected result after adding value and adjusting for offset [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithTimeFieldFalse() { [EOL] long instant = 0L; // Example initial instant [EOL] int value = 5; // Example value to add [EOL] long localInstant = 10L; // Example local instant after conversion from UTC [EOL] long expected = 15L; // Expected result after adding value and converting back to UTC [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithValidValue() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int value = SOME_VALID_VALUE; // Replace with a valid value that does not throw an exception [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after setting the value [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] assertEquals(value, get(result)); [EOL] }
public void testSetWithInvalidValue() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant [EOL] int invalidValue = SOME_INVALID_VALUE; // Replace with an invalid value that will throw an exception [EOL] try { [EOL] set(instant, invalidValue); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] assertEquals(Integer.valueOf(invalidValue), ex.getIllegalValue()); [EOL] assertNotNull(ex.getCause()); [EOL] assertTrue(ex.getCause() instanceof IllegalInstantException); [EOL] } [EOL] }
public void testGetDifference_WithPositiveOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expectedDifference = 1; // Assuming iField.getDifference() would return 1 for these parameters [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] } [EOL] public void testGetDifference_WithNegativeOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1500L; [EOL] int expectedDifference = -1; // Assuming iField.getDifference() would return -1 for these parameters [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] } [EOL] public void testGetDifference_WithZeroOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1000L; [EOL] int expectedDifference = 0; // Assuming iField.getDifference() would return 0 for these parameters [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] } [EOL] public void testGetDifference_WithDifferentOffsets() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expectedDifference = 2; // Assuming iField.getDifference() would return 2 when offsets are different [EOL] when(getOffsetToAdd(minuendInstant)).thenReturn(100); [EOL] when(getOffsetToAdd(subtrahendInstant)).thenReturn(200); [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong_WithPositiveOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] long expectedDifference = 1L; // Assuming the difference calculation and offsets lead to this result [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong_WithNegativeOffset() { [EOL] long minuendInstant = 500L; [EOL] long subtrahendInstant = 1000L; [EOL] long expectedDifference = -1L; // Assuming the difference calculation and offsets lead to this result [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong_WithZeroOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1000L; [EOL] long expectedDifference = 0L; // Assuming the difference calculation and offsets lead to this result [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testRoundFloorWithTimeFieldTrue() { [EOL] long instant = 1234567890L; [EOL] int offset = 5; // Assuming getOffsetToAdd(instant) would return 5 [EOL] long expected = instant - offset; // Assuming iField.roundFloor(instant + offset) returns instant [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloorWithTimeFieldFalse() { [EOL] long instant = 1234567890L; [EOL] long localInstant = 1234567895L; // Assuming iZone.convertUTCToLocal(instant) would return localInstant [EOL] long expected = 1234567890L; // Assuming iZone.convertLocalToUTC(localInstant, false, instant) returns expected [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAsTextWithAnyFieldValueAndLocale() { [EOL] Time time = new Time(); [EOL] String expected = time.iEraText; [EOL] String actual = time.getAsText(0, Locale.ENGLISH); [EOL] assertEquals(expected, actual); [EOL] }
public void testBaseLocalConstructor() { [EOL] BaseLocal baseLocal = new BaseLocal(); [EOL] assertNotNull(baseLocal); [EOL] }
public void testIllegalInstantExceptionWithValidInput() { [EOL] long instantLocal = 1582605042000L; // Example timestamp [EOL] String zoneId = "Europe/London"; [EOL] IllegalInstantException exception = new IllegalInstantException(instantLocal, zoneId); [EOL] assertNotNull("Exception should not be null", exception); [EOL] assertTrue("Exception message should contain the zone ID", exception.getMessage().contains(zoneId)); [EOL] }
public void testCreateMessageWithNonNullZoneId() { [EOL] long instantLocal = 1583667000000L; // Example timestamp [EOL] String zoneId = "Europe/London"; [EOL] String expectedMessage = "Illegal instant due to time zone offset transition (daylight savings time 'gap'): 2020-03-08T01:30:00.000 (Europe/London)"; [EOL] String actualMessage = createMessage(instantLocal, zoneId); [EOL] assertEquals(expectedMessage, actualMessage); [EOL] }
public void testCreateMessageWithNullZoneId() { [EOL] long instantLocal = 1583667000000L; // Example timestamp [EOL] String zoneId = null; [EOL] String expectedMessage = "Illegal instant due to time zone offset transition (daylight savings time 'gap'): 2020-03-08T01:30:00.000"; [EOL] String actualMessage = createMessage(instantLocal, zoneId); [EOL] assertEquals(expectedMessage, actualMessage); [EOL] }
public void testIsIllegalInstantWithIllegalInstantException() { [EOL] Throwable ex = new IllegalInstantException(); [EOL] boolean result = Time.isIllegalInstant(ex); [EOL] assertTrue(result); [EOL] }
public void testIsIllegalInstantWithOtherException() { [EOL] Throwable ex = new Exception(); [EOL] boolean result = Time.isIllegalInstant(ex); [EOL] assertFalse(result); [EOL] }
public void testIsIllegalInstantWithNestedIllegalInstantException() { [EOL] Throwable cause = new IllegalInstantException(); [EOL] Throwable ex = new Exception(cause); [EOL] boolean result = Time.isIllegalInstant(ex); [EOL] assertTrue(result); [EOL] }
public void testIsIllegalInstantWithNestedOtherException() { [EOL] Throwable cause = new Exception(); [EOL] Throwable ex = new Exception(cause); [EOL] boolean result = Time.isIllegalInstant(ex); [EOL] assertFalse(result); [EOL] }
public void testIsIllegalInstantWithSelfCausingException() { [EOL] Throwable ex = new Exception(); [EOL] ex.initCause(ex); [EOL] boolean result = Time.isIllegalInstant(ex); [EOL] assertFalse(result); [EOL] }
public void testCreateMessage_AllNull() { [EOL] String result = createMessage(null, null, null, null, null); [EOL] assertEquals("Value null for null is not supported", result); [EOL] } [EOL] public void testCreateMessage_ValueAndFieldOnly() { [EOL] String result = createMessage("field", 10, null, null, null); [EOL] assertEquals("Value 10 for field is not supported", result); [EOL] } [EOL] public void testCreateMessage_UpperBoundOnly() { [EOL] String result = createMessage("field", 10, null, 20, null); [EOL] assertEquals("Value 10 for field must not be larger than 20", result); [EOL] } [EOL] public void testCreateMessage_LowerBoundOnly() { [EOL] String result = createMessage("field", 10, 5, null, null); [EOL] assertEquals("Value 10 for field must not be smaller than 5", result); [EOL] } [EOL] public void testCreateMessage_BothBounds() { [EOL] String result = createMessage("field", 10, 5, 20, null); [EOL] assertEquals("Value 10 for field must be in the range [5,20]", result); [EOL] } [EOL] public void testCreateMessage_WithExplanation() { [EOL] String result = createMessage("field", 10, 5, 20, "Explanation text"); [EOL] assertEquals("Value 10 for field must be in the range [5,20]: Explanation text", result); [EOL] }
public void testIllegalFieldValueExceptionWithAllFields() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] Number value = 32; [EOL] Number lowerBound = 1; [EOL] Number upperBound = 31; [EOL] IllegalFieldValueException ex = new IllegalFieldValueException(fieldType, value, lowerBound, upperBound); [EOL] assertEquals("dayOfMonth", ex.getFieldType().getName()); [EOL] assertEquals(value, ex.getNumberValue()); [EOL] assertEquals(null, ex.getStringValue()); [EOL] assertEquals(lowerBound, ex.getLowerBound()); [EOL] assertEquals(upperBound, ex.getUpperBound()); [EOL] assertNotNull(ex.getMessage()); [EOL] }
public void testGetDateTimeFieldType() { [EOL] DateTimeFieldType fieldType = new DateTimeFieldType(); [EOL] DateTimeFieldType result = fieldType.getDateTimeFieldType(); [EOL] assertNotNull(result); [EOL] assertEquals(fieldType, result); [EOL] }
public void testGetDurationFieldType() { [EOL] DurationFieldType expectedType = DurationFieldType.hours(); [EOL] MyClass myClassInstance = new MyClass(expectedType); [EOL] DurationFieldType actualType = myClassInstance.getDurationFieldType(); [EOL] assertEquals("The duration field type should be the same as the one set in constructor", expectedType, actualType); [EOL] }
public void testGetFieldName() { [EOL] YourClass instance = new YourClass(); [EOL] instance.iFieldName = "expectedFieldName"; [EOL] String result = instance.getFieldName(); [EOL] assertEquals("expectedFieldName", result); [EOL] }
public void testGetIllegalNumberValue() { [EOL] Time time = new Time(); [EOL] Number result = time.getIllegalNumberValue(); [EOL] assertNotNull(result); [EOL] }
public void testGetIllegalStringValue() { [EOL] Time time = new Time(); [EOL] String result = time.getIllegalStringValue(); [EOL] assertNull("iStringValue should be null", result); [EOL] }
public void testGetIllegalValueAsStringWithValueNotNull() { [EOL] Time time = new Time(); [EOL] time.iStringValue = "TestString"; [EOL] time.iNumberValue = 123; [EOL] String result = time.getIllegalValueAsString(); [EOL] assertEquals("TestString", result); [EOL] }
public void testGetIllegalValueAsStringWithValueNull() { [EOL] Time time = new Time(); [EOL] time.iStringValue = null; [EOL] time.iNumberValue = 123; [EOL] String result = time.getIllegalValueAsString(); [EOL] assertEquals("123", result); [EOL] }
public void testGetLowerBound_PositiveValue() { [EOL] Time time = new Time(10); [EOL] Number result = time.getLowerBound(); [EOL] assertEquals(10, result.intValue()); [EOL] }
public void testGetLowerBound_NegativeValue() { [EOL] Time time = new Time(-10); [EOL] Number result = time.getLowerBound(); [EOL] assertEquals(-10, result.intValue()); [EOL] }
public void testGetLowerBound_ZeroValue() { [EOL] Time time = new Time(0); [EOL] Number result = time.getLowerBound(); [EOL] assertEquals(0, result.intValue()); [EOL] }
public Number getUpperBound() { [EOL] return iUpperBound; [EOL] }
public void testNow() { [EOL] LocalTime result = LocalTime.now(); [EOL] assertNotNull(result); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] LocalTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalTime result = LocalTime.now(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testParseWithValidString() { [EOL] String validTimeString = "10:15:30"; [EOL] LocalTime result = LocalTime.parse(validTimeString); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(15, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] } [EOL] public void testParseWithInvalidString() { [EOL] String invalidTimeString = "invalid"; [EOL] try { [EOL] LocalTime.parse(invalidTimeString); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseValidTime() { [EOL] String timeStr = "10:15"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm"); [EOL] LocalTime result = Time.parse(timeStr, formatter); [EOL] assertEquals(LocalTime.of(10, 15), result); [EOL] }
public void testParseInvalidTime() { [EOL] String timeStr = "invalid"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm"); [EOL] try { [EOL] Time.parse(timeStr, formatter); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalTime.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The date must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testFromDateFieldsWithNonNullDate() { [EOL] Date date = new Date(); // This uses the current time. [EOL] date.setHours(13); [EOL] date.setMinutes(45); [EOL] date.setSeconds(30); [EOL] date.setTime(date.getTime() / 1000 * 1000); // Truncate milliseconds to ensure consistency in the test. [EOL] LocalTime result = LocalTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(13, result.getHourOfDay()); [EOL] assertEquals(45, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(date.getTime() % 1000, result.getMillisOfSecond()); [EOL] }
public void testLocalTimeWithNullChronology() { [EOL] try { [EOL] new LocalTime(null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalTimeWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalTime localTime = new LocalTime(chronology); [EOL] assertNotNull("LocalTime should not be null with non-null chronology", localTime); [EOL] assertEquals("Chronology should match the one passed in constructor", chronology, localTime.getChronology()); [EOL] }
public void testLocalTimeConstructorValidHourAndMinute() { [EOL] LocalTime time = new LocalTime(11, 30); [EOL] assertEquals(11, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(0, time.getSecondOfMinute()); [EOL] assertEquals(0, time.getMillisOfSecond()); [EOL] }
public void testLocalTimeConstructorLowerBoundaryHour() { [EOL] LocalTime time = new LocalTime(0, 30); [EOL] assertEquals(0, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] }
public void testLocalTimeConstructorUpperBoundaryHour() { [EOL] LocalTime time = new LocalTime(23, 30); [EOL] assertEquals(23, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] }
public void testLocalTimeConstructorLowerBoundaryMinute() { [EOL] LocalTime time = new LocalTime(11, 0); [EOL] assertEquals(11, time.getHourOfDay()); [EOL] assertEquals(0, time.getMinuteOfHour()); [EOL] }
public void testLocalTimeConstructorUpperBoundaryMinute() { [EOL] LocalTime time = new LocalTime(11, 59); [EOL] assertEquals(11, time.getHourOfDay()); [EOL] assertEquals(59, time.getMinuteOfHour()); [EOL] }
public void testLocalTimeConstructorValidValues() { [EOL] LocalTime time = new LocalTime(12, 30, 45); [EOL] assertEquals(12, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(45, time.getSecondOfMinute()); [EOL] assertEquals(0, time.getMillisOfSecond()); [EOL] }
public void testLocalTimeConstructorBoundaryValues() { [EOL] LocalTime timeStartOfDay = new LocalTime(0, 0, 0); [EOL] assertEquals(0, timeStartOfDay.getHourOfDay()); [EOL] assertEquals(0, timeStartOfDay.getMinuteOfHour()); [EOL] assertEquals(0, timeStartOfDay.getSecondOfMinute()); [EOL] assertEquals(0, timeStartOfDay.getMillisOfSecond()); [EOL] LocalTime timeEndOfDay = new LocalTime(23, 59, 59); [EOL] assertEquals(23, timeEndOfDay.getHourOfDay()); [EOL] assertEquals(59, timeEndOfDay.getMinuteOfHour()); [EOL] assertEquals(59, timeEndOfDay.getSecondOfMinute()); [EOL] assertEquals(0, timeEndOfDay.getMillisOfSecond()); [EOL] }
public void testGetValueWithHourOfDay() { [EOL] int index = HOUR_OF_DAY; [EOL] int expectedValue = // expected value for HOUR_OF_DAY [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithMinuteOfHour() { [EOL] int index = MINUTE_OF_HOUR; [EOL] int expectedValue = // expected value for MINUTE_OF_HOUR [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithSecondOfMinute() { [EOL] int index = SECOND_OF_MINUTE; [EOL] int expectedValue = // expected value for SECOND_OF_MINUTE [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithMillisOfSecond() { [EOL] int index = MILLIS_OF_SECOND; [EOL] int expectedValue = // expected value for MILLIS_OF_SECOND [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithInvalidIndex() { [EOL] int index = INVALID_INDEX; // INVALID_INDEX should be a constant that is not a valid case [EOL] try { [EOL] instance.getValue(index); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Invalid index: " + index, e.getMessage()); [EOL] } [EOL] }
public void testWithField_NullFieldType() { [EOL] LocalTime time = new LocalTime(); [EOL] try { [EOL] time.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_UnsupportedFieldType() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is unsupported for LocalTime [EOL] try { [EOL] time.withField(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_SupportedFieldType() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is supported for LocalTime [EOL] int newValue = 10; [EOL] LocalTime updatedTime = time.withField(fieldType, newValue); [EOL] assertEquals(newValue, updatedTime.get(fieldType)); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] LocalTime time = LocalTime.now(); [EOL] time.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] try { [EOL] LocalTime time = LocalTime.now(); [EOL] DurationFieldType fieldType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] time.withFieldAdded(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] LocalTime time = LocalTime.now(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assuming minutes is supported [EOL] LocalTime result = time.withFieldAdded(fieldType, 0); [EOL] assertEquals(time, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] LocalTime time = LocalTime.now(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assuming minutes is supported [EOL] int amount = 30; [EOL] LocalTime result = time.withFieldAdded(fieldType, amount); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.plusMinutes(amount), result); [EOL] }
public void testMinus_withNullPeriod() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minus(null); [EOL] assertEquals(time, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] LocalTime time = LocalTime.of(10, 0); [EOL] Period period = Period.ofHours(1); [EOL] LocalTime result = time.minus(period); [EOL] assertEquals(LocalTime.of(9, 0), result); [EOL] }
public void testToStringWithNullPattern() { [EOL] Time time = new Time(); [EOL] String result = time.toString(null, Locale.ENGLISH); [EOL] assertNotNull(result); [EOL] assertEquals(time.toString(), result); [EOL] }
public void testToStringWithValidPatternAndLocale() { [EOL] Time time = new Time(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String result = time.toString(pattern, Locale.ENGLISH); [EOL] assertNotNull(result); [EOL] String expected = manuallyFormatTime(time, pattern, Locale.ENGLISH); [EOL] assertEquals(expected, result); [EOL] }
public LocalTime getLocalTime() { [EOL] return iInstant; [EOL] }
public void testAddWrapFieldToCopy_WithPositiveValue() { [EOL] LocalTime initialTime = new LocalTime(3, 0); // Assuming LocalTime is a valid class and has this constructor [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); // Assuming usage of Mockito for mocking [EOL] LocalTime expectedTime = new LocalTime(4, 0); // Expected time after adding [EOL] when(mockField.addWrapField(anyLong(), anyInt())).thenReturn(expectedTime.getLocalMillis()); [EOL] LocalTime result = initialTime.addWrapFieldToCopy(1); [EOL] assertEquals(expectedTime, result); [EOL] }
public void testAddWrapFieldToCopy_WithNegativeValue() { [EOL] LocalTime initialTime = new LocalTime(3, 0); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] LocalTime expectedTime = new LocalTime(2, 0); // Expected time after subtracting [EOL] when(mockField.addWrapField(anyLong(), anyInt())).thenReturn(expectedTime.getLocalMillis()); [EOL] LocalTime result = initialTime.addWrapFieldToCopy(-1); [EOL] assertEquals(expectedTime, result); [EOL] }
public void testAddWrapFieldToCopy_WithZeroValue() { [EOL] LocalTime initialTime = new LocalTime(3, 0); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] when(mockField.addWrapField(anyLong(), eq(0))).thenReturn(initialTime.getLocalMillis()); [EOL] LocalTime result = initialTime.addWrapFieldToCopy(0); [EOL] assertEquals(initialTime, result); [EOL] }
public void testRoundFloorCopy() { [EOL] LocalTime time = new LocalTime(12, 30, 40, 500); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] RoundingField field = new RoundingField(fieldType.getField(time.getChronology())); [EOL] TimeRoundingTestInstant instant = new TimeRoundingTestInstant(time, field); [EOL] LocalTime roundedTime = instant.roundFloorCopy(); [EOL] assertEquals(new LocalTime(12, 30), roundedTime); [EOL] }
public void testRoundFloorCopyAtFieldBoundary() { [EOL] LocalTime time = new LocalTime(12, 0, 0, 0); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] RoundingField field = new RoundingField(fieldType.getField(time.getChronology())); [EOL] TimeRoundingTestInstant instant = new TimeRoundingTestInstant(time, field); [EOL] LocalTime roundedTime = instant.roundFloorCopy(); [EOL] assertEquals(new LocalTime(12, 0), roundedTime); [EOL] }
public void testRoundCeilingCopy() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] LocalTime localTime = new LocalTime(10, 30, 40, 500); [EOL] LocalTime roundedTime = localTime.roundCeilingCopy(); [EOL] assertEquals(new LocalTime(10, 31), roundedTime); [EOL] }
public void testRoundCeilingCopyAtFieldBoundary() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] LocalTime localTime = new LocalTime(23, 59, 59, 999); [EOL] LocalTime roundedTime = localTime.roundCeilingCopy(); [EOL] assertEquals(new LocalTime(0, 0), roundedTime); [EOL] }
public void testRoundHalfFloorCopy() { [EOL] LocalTime time = new LocalTime(3, 30); [EOL] LocalTime roundedTime = time.roundHalfFloorCopy(); [EOL] assertEquals(new LocalTime(3, 30), roundedTime); [EOL] }
public void testRoundHalfFloorCopyBeforeHalf() { [EOL] LocalTime time = new LocalTime(3, 29); [EOL] LocalTime roundedTime = time.roundHalfFloorCopy(); [EOL] assertEquals(new LocalTime(3, 0), roundedTime); [EOL] }
public void testRoundHalfFloorCopyAfterHalf() { [EOL] LocalTime time = new LocalTime(3, 31); [EOL] LocalTime roundedTime = time.roundHalfFloorCopy(); [EOL] assertEquals(new LocalTime(3, 30), roundedTime); [EOL] }
public void testRoundHalfCeilingCopy() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] LocalTime localTime = new LocalTime(10, 30, 40, 500); [EOL] DateTimeField field = fieldType.getField(localTime.getChronology()); [EOL] LocalTime.Property property = new LocalTime.Property(localTime, field); [EOL] LocalTime roundedTime = property.roundHalfCeilingCopy(); [EOL] assertEquals(new LocalTime(10, 31), roundedTime); [EOL] }
public void testRoundHalfCeilingCopyAtMidpoint() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] LocalTime localTime = new LocalTime(10, 30, 30, 0); // exactly at the midpoint [EOL] DateTimeField field = fieldType.getField(localTime.getChronology()); [EOL] LocalTime.Property property = new LocalTime.Property(localTime, field); [EOL] LocalTime roundedTime = property.roundHalfCeilingCopy(); [EOL] assertEquals(new LocalTime(10, 31), roundedTime); // should round up [EOL] }
public void testRoundHalfCeilingCopyBeforeMidpoint() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] LocalTime localTime = new LocalTime(10, 30, 29, 999); // just before the midpoint [EOL] DateTimeField field = fieldType.getField(localTime.getChronology()); [EOL] LocalTime.Property property = new LocalTime.Property(localTime, field); [EOL] LocalTime roundedTime = property.roundHalfCeilingCopy(); [EOL] assertEquals(new LocalTime(10, 31), roundedTime); // should round up [EOL] }
public void testRoundHalfCeilingCopyAfterMidpoint() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] LocalTime localTime = new LocalTime(10, 30, 30, 1); // just after the midpoint [EOL] DateTimeField field = fieldType.getField(localTime.getChronology()); [EOL] LocalTime.Property property = new LocalTime.Property(localTime, field); [EOL] LocalTime roundedTime = property.roundHalfCeilingCopy(); [EOL] assertEquals(new LocalTime(10, 31), roundedTime); // should round up [EOL] }
public void testRoundHalfEvenCopy() { [EOL] iInstant = new LocalTime(10, 0); // Assuming LocalTime is the type of iInstant [EOL] iField = DateTimeFieldType.minuteOfHour().getField(DateTimeZone.UTC); // Assuming this is how we get iField [EOL] LocalTime result1 = iInstant.roundHalfEvenCopy(); [EOL] assertEquals(new LocalTime(10, 0), result1); // Assuming the time does not change
iInstant = new LocalTime(10, 29); // Close to 10:30 but should round down to 10:00 [EOL] LocalTime result2 = iInstant.roundHalfEvenCopy(); [EOL] assertEquals(new LocalTime(10, 0), result2);
iInstant = new LocalTime(10, 31); // Close to 10:30 but should round up to 11:00 [EOL] LocalTime result3 = iInstant.roundHalfEvenCopy(); [EOL] assertEquals(new LocalTime(11, 0), result3);
iInstant = new LocalTime(10, 30); // Exactly half, should round to the nearest even hour, which is 10:00 [EOL] LocalTime result4 = iInstant.roundHalfEvenCopy(); [EOL] assertEquals(new LocalTime(10, 0), result4);
iInstant = new LocalTime(11, 30); // Exactly half, should round to the nearest even hour, which is 12:00 [EOL] LocalTime result5 = iInstant.roundHalfEvenCopy(); [EOL] assertEquals(new LocalTime(12, 0), result5); [EOL] }
public void testSkipDateTimeField_MinLessThanSkip() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(3); [EOL] int skip = 5; [EOL] SkipDateTimeField skipDateTimeField = new SkipDateTimeField(mockChronology, mockField, skip); [EOL] assertEquals(2, skipDateTimeField.getMinimumValue()); [EOL] }
public void testSkipDateTimeField_MinEqualToSkip() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(5); [EOL] int skip = 5; [EOL] SkipDateTimeField skipDateTimeField = new SkipDateTimeField(mockChronology, mockField, skip); [EOL] assertEquals(6, skipDateTimeField.getMinimumValue()); [EOL] }
public void testSkipDateTimeField_MinGreaterThanSkip() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(7); [EOL] int skip = 5; [EOL] SkipDateTimeField skipDateTimeField = new SkipDateTimeField(mockChronology, mockField, skip); [EOL] assertEquals(7, skipDateTimeField.getMinimumValue()); [EOL] }
public int getTestWithMillisLessThanOrEqualToSkip() { [EOL] Time time = new Time(5); // Assuming 'iSkip' is 5 and Time extends a class with get(long millis) method [EOL] int result = time.get(4); [EOL] assertEquals(3, result); [EOL] }
public int getTestWithMillisGreaterThanSkip() { [EOL] Time time = new Time(5); // Assuming 'iSkip' is 5 and Time extends a class with get(long millis) method [EOL] int result = time.get(6); [EOL] assertEquals(6, result); [EOL] }
public void testSet_ValueWithinBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue + 1; // Assuming iMinValue is the minimum allowed value for the field [EOL] if (value == iSkip) { // Adjust value if it's equal to iSkip [EOL] value++; [EOL] } [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSet_ValueAtMinBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue; [EOL] if (value == iSkip) { // Adjust value if it's equal to iSkip [EOL] value++; [EOL] } [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSet_ValueAtMaxBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = getMaximumValue(); // Assuming getMaximumValue() returns the maximum allowed value for the field [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSet_ValueBelowMinBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue - 1; [EOL] try { [EOL] set(millis, value); [EOL] fail("Should have thrown an exception for value below min boundary"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSet_ValueEqualsSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip; [EOL] try { [EOL] set(millis, value); [EOL] fail("Should have thrown an exception for value equal to iSkip"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testSet_ValueJustAboveSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip + 1; [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testDays() { [EOL] DurationFieldType daysType = DurationFieldType.days(); [EOL] assertNotNull(daysType); [EOL] assertEquals("days", daysType.getName()); [EOL] }
public static DurationFieldType weekyears() { [EOL] return WEEKYEARS_TYPE; [EOL] }
public void testMonths() { [EOL] DurationFieldType fieldType = ClassName.months(); [EOL] assertNotNull(fieldType); [EOL] assertEquals("months", fieldType.getName()); [EOL] }
public void testEras() { [EOL] DurationFieldType result = Time.eras(); [EOL] assertNotNull("Eras type should not be null", result); [EOL] assertEquals("Eras type should match the expected ERAS_TYPE", Time.ERAS_TYPE, result); [EOL] }
public void testGetField_Eras() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.eras()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.eras(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).eras(); [EOL] }
public void testGetField_Centuries() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.centuries()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.centuries(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).centuries(); [EOL] }
public void testGetField_Weekyears() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.weekyears()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.weekyears(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).weekyears(); [EOL] }
public void testGetField_Years() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.years()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.years(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).years(); [EOL] }
public void testGetField_Months() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.months()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.months(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).months(); [EOL] }
public void testGetField_Weeks() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.weeks()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.weeks(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).weeks(); [EOL] }
public void testGetField_Days() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.days()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.days(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).days(); [EOL] }
public void testGetField_Halfdays() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.halfdays()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.halfdays(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).halfdays(); [EOL] }
public void testGetField_Hours() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.hours()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.hours(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).hours(); [EOL] }
public void testGetField_Minutes() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.minutes()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.minutes(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).minutes(); [EOL] }
public void testGetField_Seconds() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.seconds()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.seconds(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).seconds(); [EOL] }
public void testGetField_Millis() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.millis()).thenReturn(mock(DurationField.class)); [EOL] DateTimeFieldType type = DateTimeFieldType.millis(); [EOL] DurationField field = type.getField(chronology); [EOL] assertNotNull(field); [EOL] verify(chronology).millis(); [EOL] }
public void testGetField_Invalid() { [EOL] Chronology chronology = mock(Chronology.class); [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] when(type.ordinal()).thenReturn(-1); [EOL] assertThrows(InternalError.class, () -> type.getField(chronology)); [EOL] }
public void testReadResolveForEras() { [EOL] MyClass instance = new MyClass(MyClass.ERAS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.ERAS_TYPE, result); [EOL] }
public void testReadResolveForCenturies() { [EOL] MyClass instance = new MyClass(MyClass.CENTURIES); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.CENTURIES_TYPE, result); [EOL] }
public void testReadResolveForWeekyears() { [EOL] MyClass instance = new MyClass(MyClass.WEEKYEARS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.WEEKYEARS_TYPE, result); [EOL] }
public void testReadResolveForYears() { [EOL] MyClass instance = new MyClass(MyClass.YEARS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.YEARS_TYPE, result); [EOL] }
public void testReadResolveForMonths() { [EOL] MyClass instance = new MyClass(MyClass.MONTHS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.MONTHS_TYPE, result); [EOL] }
public void testReadResolveForWeeks() { [EOL] MyClass instance = new MyClass(MyClass.WEEKS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.WEEKS_TYPE, result); [EOL] }
public void testReadResolveForDays() { [EOL] MyClass instance = new MyClass(MyClass.DAYS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.DAYS_TYPE, result); [EOL] }
public void testReadResolveForHalfdays() { [EOL] MyClass instance = new MyClass(MyClass.HALFDAYS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.HALFDAYS_TYPE, result); [EOL] }
public void testReadResolveForHours() { [EOL] MyClass instance = new MyClass(MyClass.HOURS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.HOURS_TYPE, result); [EOL] }
public void testReadResolveForMinutes() { [EOL] MyClass instance = new MyClass(MyClass.MINUTES); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.MINUTES_TYPE, result); [EOL] }
public void testReadResolveForSeconds() { [EOL] MyClass instance = new MyClass(MyClass.SECONDS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.SECONDS_TYPE, result); [EOL] }
public void testReadResolveForMillis() { [EOL] MyClass instance = new MyClass(MyClass.MILLIS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.MILLIS_TYPE, result); [EOL] }
public void testReadResolveForDefault() { [EOL] MyClass instance = new MyClass(-1); // Assuming -1 is not a valid ordinal [EOL] Object result = instance.readResolve(); [EOL] assertSame(instance, result); [EOL] }
public void testEquals_Reflexive() { [EOL] UnsupportedDurationField field = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertTrue(field.equals(field)); [EOL] }
public void testEquals_SameContent() { [EOL] UnsupportedDurationField field1 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDurationField field2 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_DifferentContent() { [EOL] UnsupportedDurationField field1 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDurationField field2 = UnsupportedDurationField.getInstance(DurationFieldType.minutes()); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testEquals_Null() { [EOL] UnsupportedDurationField field = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertFalse(field.equals(null)); [EOL] }
public void testEquals_OtherObject() { [EOL] UnsupportedDurationField field = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] Object other = new Object(); [EOL] assertFalse(field.equals(other)); [EOL] }
public void testEquals_NullName() { [EOL] UnsupportedDurationField field1 = new UnsupportedDurationField(null); [EOL] UnsupportedDurationField field2 = new UnsupportedDurationField(null); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_NullAndNonNullName() { [EOL] UnsupportedDurationField field1 = new UnsupportedDurationField(null); [EOL] UnsupportedDurationField field2 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] MutableDateTime dateTime = MutableDateTime.now(zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] MutableDateTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Zone must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testSetMillisWithRoundNone() { [EOL] initializeRoundingMode(ROUND_NONE); [EOL] long expected = SOME_INSTANT; [EOL] setMillis(expected); [EOL] long result = getMillis(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetMillisWithRoundFloor() { [EOL] initializeRoundingMode(ROUND_FLOOR); [EOL] long instant = SOME_INSTANT; [EOL] long expected = mockRoundingFieldRoundFloor(instant); [EOL] setMillis(instant); [EOL] long result = getMillis(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetMillisWithRoundCeiling() { [EOL] initializeRoundingMode(ROUND_CEILING); [EOL] long instant = SOME_INSTANT; [EOL] long expected = mockRoundingFieldRoundCeiling(instant); [EOL] setMillis(instant); [EOL] long result = getMillis(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetMillisWithRoundHalfFloor() { [EOL] initializeRoundingMode(ROUND_HALF_FLOOR); [EOL] long instant = SOME_INSTANT; [EOL] long expected = mockRoundingFieldRoundHalfFloor(instant); [EOL] setMillis(instant); [EOL] long result = getMillis(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetMillisWithRoundHalfCeiling() { [EOL] initializeRoundingMode(ROUND_HALF_CEILING); [EOL] long instant = SOME_INSTANT; [EOL] long expected = mockRoundingFieldRoundHalfCeiling(instant); [EOL] setMillis(instant); [EOL] long result = getMillis(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetMillisWithRoundHalfEven() { [EOL] initializeRoundingMode(ROUND_HALF_EVEN); [EOL] long instant = SOME_INSTANT; [EOL] long expected = mockRoundingFieldRoundHalfEven(instant); [EOL] setMillis(instant); [EOL] long result = getMillis(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetMillisWithNullInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] long initialMillis = testDateTime.getMillis(); [EOL] testDateTime.setMillis((ReadableInstant) null); [EOL] long updatedMillis = testDateTime.getMillis(); [EOL] assertNotEquals(initialMillis, updatedMillis); [EOL] }
public void testSetMillisWithNonNullInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant instant = new Instant(); [EOL] testDateTime.setMillis(instant); [EOL] assertEquals(instant.getMillis(), testDateTime.getMillis()); [EOL] }
public void testSetZoneWithDifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] TestDateTime testDateTime = new TestDateTime(originalZone); [EOL] testDateTime.setZone(newZone); [EOL] assertEquals(newZone, testDateTime.getZone()); [EOL] } [EOL] public void testSetZoneWithSameZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] TestDateTime testDateTime = new TestDateTime(originalZone); [EOL] testDateTime.setZone(originalZone); [EOL] assertEquals(originalZone, testDateTime.getZone()); [EOL] } [EOL] public void testSetZoneWithNull() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] TestDateTime testDateTime = new TestDateTime(originalZone); [EOL] testDateTime.setZone(null); [EOL] DateTimeZone defaultZone = DateTimeUtils.getDefault(); [EOL] assertEquals(defaultZone, testDateTime.getZone()); [EOL] }
public void testSetZoneRetainFields_SameZone() { [EOL] DateTime testDateTime = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] DateTimeZone sameZone = DateTimeZone.UTC; [EOL] testDateTime.setZoneRetainFields(sameZone); [EOL] assertEquals(DateTimeZone.UTC, testDateTime.getZone()); [EOL] }
public void testSetZoneRetainFields_DifferentZone() { [EOL] DateTime testDateTime = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] DateTimeZone differentZone = DateTimeZone.forID("Europe/Paris"); [EOL] testDateTime.setZoneRetainFields(differentZone); [EOL] assertNotEquals(DateTimeZone.UTC, testDateTime.getZone()); [EOL] assertEquals(differentZone, testDateTime.getZone()); [EOL] }
public void testAddWithNullType() { [EOL] try { [EOL] time.add(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testAddWithZeroAmount() { [EOL] long initialMillis = time.getMillis(); [EOL] time.add(DurationFieldType.seconds(), 0); [EOL] assertEquals("Time should not change when amount is zero", initialMillis, time.getMillis()); [EOL] }
public void testAddWithNonZeroAmount() { [EOL] long initialMillis = time.getMillis(); [EOL] time.add(DurationFieldType.seconds(), 1); [EOL] assertNotEquals("Time should change when amount is non-zero", initialMillis, time.getMillis()); [EOL] }
public void testSetMonthOfYear_ValidMonth() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validMonth = 5; // May [EOL] dateTime.setMonthOfYear(validMonth); [EOL] assertEquals(validMonth, dateTime.getMonthOfYear()); [EOL] }
public void testSetMonthOfYear_InvalidMonthLow() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidMonth = 0; // Invalid month [EOL] try { [EOL] dateTime.setMonthOfYear(invalidMonth); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetMonthOfYear_InvalidMonthHigh() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidMonth = 13; // Invalid month [EOL] try { [EOL] dateTime.setMonthOfYear(invalidMonth); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void setDayOfWeekTest_ValidDayOfWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validDayOfWeek = 3; // Assuming 3 is a valid day of the week [EOL] dateTime.setDayOfWeek(validDayOfWeek); [EOL] assertEquals(validDayOfWeek, dateTime.getDayOfWeek()); [EOL] }
public void setDayOfWeekTest_InvalidDayOfWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidDayOfWeek = 8; // Assuming the valid range is 1-7 [EOL] try { [EOL] dateTime.setDayOfWeek(invalidDayOfWeek); [EOL] fail("Should have thrown an exception for invalid day of the week"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddHours_Zero() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addHours(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void testAddHours_Positive() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] int hoursToAdd = 5; // Positive number of hours [EOL] time.addHours(hoursToAdd); [EOL] assertEquals(initialMillis + hoursToAdd * 3600000, time.getMillis()); [EOL] }
public void testAddHours_Negative() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] int hoursToSubtract = -5; // Negative number of hours [EOL] time.addHours(hoursToSubtract); [EOL] assertEquals(initialMillis + hoursToSubtract * 3600000, time.getMillis()); [EOL] }
public void testSetMinuteOfHour_ValidValue() { [EOL] Time time = new Time(); [EOL] int validMinuteOfHour = 30; [EOL] time.setMinuteOfHour(validMinuteOfHour); [EOL] assertEquals(validMinuteOfHour, time.getMinuteOfHour()); [EOL] }
public void testSetMinuteOfHour_LowerBoundary() { [EOL] Time time = new Time(); [EOL] int lowerBoundaryMinuteOfHour = 0; [EOL] time.setMinuteOfHour(lowerBoundaryMinuteOfHour); [EOL] assertEquals(lowerBoundaryMinuteOfHour, time.getMinuteOfHour()); [EOL] }
public void testSetMinuteOfHour_UpperBoundary() { [EOL] Time time = new Time(); [EOL] int upperBoundaryMinuteOfHour = 59; [EOL] time.setMinuteOfHour(upperBoundaryMinuteOfHour); [EOL] assertEquals(upperBoundaryMinuteOfHour, time.getMinuteOfHour()); [EOL] }
public void testSetSecondOfMinute_ValidSecond() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validSecond = 30; [EOL] dateTime.setSecondOfMinute(validSecond); [EOL] assertEquals(validSecond, dateTime.getSecondOfMinute()); [EOL] } [EOL] public void testSetSecondOfMinute_InvalidSecondLow() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidSecond = -1; [EOL] try { [EOL] dateTime.setSecondOfMinute(invalidSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetSecondOfMinute_InvalidSecondHigh() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidSecond = 60; [EOL] try { [EOL] dateTime.setSecondOfMinute(invalidSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void addSeconds_ZeroSeconds_NoChange() { [EOL] int initialSeconds = 0; [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addSeconds(initialSeconds); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addSeconds_PositiveSeconds_ChangesMillis() { [EOL] int secondsToAdd = 10; [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().seconds().add(initialMillis, secondsToAdd); [EOL] time.addSeconds(secondsToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void addSeconds_NegativeSeconds_ChangesMillis() { [EOL] int secondsToSubtract = -10; [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().seconds().add(initialMillis, secondsToSubtract); [EOL] time.addSeconds(secondsToSubtract); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void setDateTime_validArguments() { [EOL] Time time = new Time(); [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] Chronology chronology = mock(Chronology.class); [EOL] when(chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)).thenReturn(1621513530500L); [EOL] time.setChronology(chronology); [EOL] time.setDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] verify(time).setMillis(1621513530500L); [EOL] }
public void testAddPositiveValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = 10; [EOL] MutableDateTime result = dateTime.add(valueToAdd); [EOL] long expectedMillis = getField().add(initialMillis, valueToAdd); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] }
public void testAddNegativeValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = -10; [EOL] MutableDateTime result = dateTime.add(valueToAdd); [EOL] long expectedMillis = getField().add(initialMillis, valueToAdd); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] }
public void testAddZeroValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int valueToAdd = 0; [EOL] MutableDateTime result = dateTime.add(valueToAdd); [EOL] long expectedMillis = getField().add(initialMillis, valueToAdd); [EOL] assertEquals(expectedMillis, result.getMillis()); [EOL] }
public void testRoundHalfCeiling_MidpointUp() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 3, 15, 10, 30, 25, 500); // Midpoint [EOL] MutableDateTime rounded = dateTime.roundHalfCeiling(); [EOL] assertEquals(new MutableDateTime(2023, 3, 15, 10, 30, 26, 0), rounded); [EOL] }
public void testRoundHalfCeiling_NotMidpoint() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 3, 15, 10, 30, 25, 499); // Not a midpoint [EOL] MutableDateTime rounded = dateTime.roundHalfCeiling(); [EOL] assertEquals(new MutableDateTime(2023, 3, 15, 10, 30, 25, 0), rounded); [EOL] }
public void testHoursBetween_SameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Hours result = Time.hoursBetween(start, end); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testHoursBetween_DifferentInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusHours(5); [EOL] Hours result = Time.hoursBetween(start, end); [EOL] assertEquals(5, result.getHours()); [EOL] }
public void testHoursInWithNullInterval() { [EOL] Hours result = Time.hoursIn(null); [EOL] assertEquals(Hours.ZERO, result); [EOL] }
public void testHoursInWithValidInterval() { [EOL] ReadableInterval interval = new Interval(0, 3600000); // 1 hour interval [EOL] Hours result = Time.hoursIn(interval); [EOL] assertEquals(Hours.hours(1), result); [EOL] }
public void testParseHoursWithNullInput() { [EOL] Hours result = Time.parseHours(null); [EOL] assertEquals(Hours.ZERO, result); [EOL] }
public void testParseHoursWithValidInput() { [EOL] Hours result = Time.parseHours("PT2H"); [EOL] assertEquals(Hours.hours(2), result); [EOL] }
public void testParseHoursWithInvalidInput() { [EOL] try { [EOL] Time.parseHours("invalid"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToStandardMinutes() { [EOL] Hours hours = Hours.hours(1); [EOL] Minutes minutes = hours.toStandardMinutes(); [EOL] assertEquals(60, minutes.getMinutes()); [EOL] }
public void testToStandardMinutes_ZeroHours() { [EOL] Hours hours = Hours.hours(0); [EOL] Minutes minutes = hours.toStandardMinutes(); [EOL] assertEquals(0, minutes.getMinutes()); [EOL] }
public void testToStandardMinutes_NegativeHours() { [EOL] Hours hours = Hours.hours(-1); [EOL] Minutes minutes = hours.toStandardMinutes(); [EOL] assertEquals(-60, minutes.getMinutes()); [EOL] }
public void testMinusWithNullHours() { [EOL] Hours originalHours = Hours.hours(5); [EOL] Hours result = originalHours.minus(null); [EOL] assertEquals("Minus with null should return the same Hours object", originalHours, result); [EOL] }
public void testMinusWithNonNullHours() { [EOL] Hours originalHours = Hours.hours(5); [EOL] Hours hoursToSubtract = Hours.hours(3); [EOL] Hours result = originalHours.minus(hoursToSubtract); [EOL] assertEquals("Minus with non-null Hours should subtract the value", Hours.hours(2), result); [EOL] }
public void testToString_PositiveValue() { [EOL] Time time = new Time(5); [EOL] String result = time.toString(); [EOL] assertEquals("PT5H", result); [EOL] }
public void testToString_NegativeValue() { [EOL] Time time = new Time(-5); [EOL] String result = time.toString(); [EOL] assertEquals("PT-5H", result); [EOL] }
public void testToString_ZeroValue() { [EOL] Time time = new Time(0); [EOL] String result = time.toString(); [EOL] assertEquals("PT0H", result); [EOL] }
public void testAddWithEqualConverterAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter1, removed); [EOL] assertNull(removed[0]); [EOL] assertSame(set, result); [EOL] }
public void testAddWithEqualConverterAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] ConverterSet result = set.add(converter1, null); [EOL] assertSame(set, result); [EOL] }
public void testAddWithSupportedTypeMatchAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter2, removed); [EOL] assertSame(converter1, removed[0]); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter2)); [EOL] assertFalse(result.contains(converter1)); [EOL] }
public void testAddWithSupportedTypeMatchAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] ConverterSet result = set.add(converter2, null); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter2)); [EOL] assertFalse(result.contains(converter1)); [EOL] }
public void testAddWithNoMatchAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter3, removed); [EOL] assertNull(removed[0]); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter3)); [EOL] }
public void testAddWithNoMatchAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] ConverterSet result = set.add(converter3, null); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter3)); [EOL] }
public void testRemove_IndexOutOfBounds() { [EOL] try { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new ConverterA(), new ConverterB()}); [EOL] set.remove(2, new Converter[1]); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException expected) { [EOL] } [EOL] }
public void testRemove_NullRemovedArray() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new ConverterA(), new ConverterB()}); [EOL] ConverterSet result = set.remove(0, null); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] }
public void testRemove_ValidIndexWithRemovedArray() { [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet set = new ConverterSet(new Converter[]{new ConverterA(), new ConverterB()}); [EOL] ConverterSet result = set.remove(0, removed); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertNotNull(removed[0]); [EOL] assertTrue(removed[0] instanceof ConverterA); [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenFieldTypeIsNull() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendDecimal(null, 1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenMinDigitsNegative() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendDecimal(DateTimeFieldType.dayOfMonth(), -1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenMaxDigitsLessThanMinDigits() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendDecimal(DateTimeFieldType.dayOfMonth(), 3, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenMaxDigitsNonPositive() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendDecimal(DateTimeFieldType.dayOfMonth(), 1, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ReturnsUnpaddedNumber_WhenMinDigitsLessThanOrEqualToOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendDecimal(DateTimeFieldType.dayOfMonth(), 1, 2); [EOL] assertNotNull(result); [EOL] }
public void testAppendDecimal_ReturnsPaddedNumber_WhenMinDigitsGreaterThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendDecimal(DateTimeFieldType.dayOfMonth(), 2, 3); [EOL] assertNotNull(result); [EOL] }
public void testAppendFixedDecimal_WithNullFieldType_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFixedDecimal(null, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field type must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendFixedDecimal_WithNegativeNumDigits_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFixedDecimal(DateTimeFieldType.year(), -1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Illegal number of digits: -1", e.getMessage()); [EOL] } [EOL] }
public void testAppendFixedDecimal_WithZeroNumDigits_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFixedDecimal(DateTimeFieldType.year(), 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Illegal number of digits: 0", e.getMessage()); [EOL] } [EOL] }
public void testAppendFixedDecimal_WithValidArguments_ReturnsFormatterBuilder() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendFixedDecimal(DateTimeFieldType.year(), 2); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendFixedSignedDecimal_WithNullFieldType_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFixedSignedDecimal(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field type must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendFixedSignedDecimal_WithNegativeNumDigits_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFixedSignedDecimal(DateTimeFieldType.year(), -1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Illegal number of digits: -1")); [EOL] } [EOL] }
public void testAppendFixedSignedDecimal_WithZeroNumDigits_ThrowsIllegalArgumentException() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFixedSignedDecimal(DateTimeFieldType.year(), 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Illegal number of digits: 0")); [EOL] } [EOL] }
public void testAppendFixedSignedDecimal_WithValidArguments_ReturnsBuilder() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendFixedSignedDecimal(DateTimeFieldType.year(), 4); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendDayOfWeekText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendDayOfWeekText(); [EOL] assertNotNull(result); [EOL] }
public void testParseInto_PositionBeyondTextLength() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Test"; [EOL] int position = 5; // position is beyond text length [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_FirstCharacterMismatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 'X'); [EOL] String text = "Test"; [EOL] int position = 0; // position is at the start [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_FirstCharacterMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 'T'); [EOL] String text = "Test"; [EOL] int position = 0; // position is at the start [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] }
public void testParseInto_MismatchAfterCaseChange() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 't'); [EOL] String text = "Test"; [EOL] int position = 0; // position is at the start [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_MatchAfterCaseChange() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 't'); [EOL] String text = "tEst"; [EOL] int position = 0; // position is at the start [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] }
public void testParseInto_PositiveNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12345"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(5, result); [EOL] assertEquals(12345, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_NegativeNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "-123"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(4, result); [EOL] assertEquals(-123, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_InvalidPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12345"; [EOL] int position = 6; // position out of bounds [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_InvalidCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12a45"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_EmptyString() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_SignedWithNoDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "-"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_LongNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "1234567890"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(10, result); [EOL] assertEquals(1234567890, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_SignedLongNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+1234567890"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(11, result); [EOL] assertEquals(1234567890, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_MaxParsedDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] iMaxParsedDigits = 5; // Assuming iMaxParsedDigits is a modifiable field [EOL] String text = "1234567890"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(5, result); [EOL] assertEquals(12345, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_SignedMaxParsedDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] iMaxParsedDigits = 5; // Assuming iMaxParsedDigits is a modifiable field [EOL] String text = "-1234567890"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(6, result); [EOL] assertEquals(-12345, bucket.getFieldValue(iFieldType)); [EOL] }
public void testUnpaddedNumberConstructor() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int maxParsedDigits = 4; [EOL] boolean signed = true; [EOL] UnpaddedNumber unpaddedNumber = new UnpaddedNumber(fieldType, maxParsedDigits, signed); [EOL] assertNotNull(unpaddedNumber); [EOL] assertEquals(fieldType, unpaddedNumber.getFieldType()); [EOL] assertEquals(maxParsedDigits, unpaddedNumber.getMaxParsedDigits()); [EOL] assertEquals(signed, unpaddedNumber.isSigned()); [EOL] }
public void testPrintTo_SupportedFieldType() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = mock(ReadablePartial.class); [EOL] when(partial.isSupported(iFieldType)).thenReturn(true); [EOL] when(partial.get(iFieldType)).thenReturn(123); [EOL] printTo(buf, partial, Locale.ENGLISH); [EOL] assertEquals("123", buf.toString()); [EOL] }
public void testPrintTo_UnsupportedFieldType() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = mock(ReadablePartial.class); [EOL] when(partial.isSupported(iFieldType)).thenReturn(false); [EOL] printTo(buf, partial, Locale.ENGLISH); [EOL] assertEquals("\ufffd", buf.toString()); [EOL] }
public void testPrintTo_ThrowsRuntimeException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = mock(ReadablePartial.class); [EOL] when(partial.isSupported(iFieldType)).thenReturn(true); [EOL] when(partial.get(iFieldType)).thenThrow(new RuntimeException()); [EOL] printTo(buf, partial, Locale.ENGLISH); [EOL] assertEquals("\ufffd", buf.toString()); [EOL] }
It seems there is a misunderstanding. The provided input text is a constructor for a class, presumably named `FixedNumber`, which takes three parameters: `DateTimeFieldType fieldType`, `int numDigits`, and `boolean signed`. However, without additional context or the body of the class, generating meaningful unit test cases is not possible. Unit tests typically require knowledge of the expected behavior of the method or constructor to assert correct functionality. [EOL] If you can provide the expected behavior or additional methods within the `FixedNumber` class, I could then generate unit test cases that assert this behavior. Otherwise, the only test that could be generated would be to instantiate the class with various inputs, which would not provide meaningful assertions beyond checking for successful object creation.
public void testParseInto_Success() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "12345"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 5; // Assuming this is a field in the class [EOL] boolean iSigned = false; // Assuming this is a field in the class [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + iMaxParsedDigits, result); [EOL] }
public void testParseInto_NegativePosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "12345"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 5; // Assuming this is a field in the class [EOL] boolean iSigned = false; // Assuming this is a field in the class [EOL] int result = parseInto(bucket, text, -1); [EOL] assertTrue(result < 0); [EOL] }
public void testParseInto_SignedWithPositiveSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+12345"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 5; // Assuming this is a field in the class [EOL] boolean iSigned = true; // Assuming this is a field in the class [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + iMaxParsedDigits + 1, ~result); [EOL] }
public void testParseInto_SignedWithNegativeSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "-12345"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 5; // Assuming this is a field in the class [EOL] boolean iSigned = true; // Assuming this is a field in the class [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + iMaxParsedDigits + 1, ~result); [EOL] }
public void testParseInto_PositionGreaterThanExpected() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "123456"; // 6 digits instead of 5 [EOL] int position = 0; [EOL] int iMaxParsedDigits = 5; // Assuming this is a field in the class [EOL] boolean iSigned = false; // Assuming this is a field in the class [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~(position + iMaxParsedDigits + 1), result); [EOL] }
public void testParseInto_PositionLessThanExpected() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "1234"; // 4 digits instead of 5 [EOL] int position = 0; [EOL] int iMaxParsedDigits = 5; // Assuming this is a field in the class [EOL] boolean iSigned = false; // Assuming this is a field in the class [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~(position + text.length()), result); [EOL] }
public void testEstimateParsedLength_Lenient() { [EOL] Time time = new Time(true); [EOL] int estimatedLength = time.estimateParsedLength(); [EOL] assertEquals(4, estimatedLength); [EOL] }
public void testEstimateParsedLength_Strict() { [EOL] Time time = new Time(false); [EOL] int estimatedLength = time.estimateParsedLength(); [EOL] assertEquals(2, estimatedLength); [EOL] }
public void testParseInto_LenientParseFalse_ShortInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseFalse_ExactLength() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_LenientParseTrue_SignChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+34"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + text.length(), result); [EOL] }
public void testParseInto_LenientParseTrue_NegativeSignChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "-34"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + text.length(), result); [EOL] }
public void testParseInto_LenientParseTrue_NonDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "a1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_LongInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "123456789"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + text.length(), result); [EOL] }
public void testParseInto_LenientParseTrue_EmptyInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_InputWithPivot() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] bucket.setPivotYear(Integer.valueOf(2000)); [EOL] String text = "99"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_LenientParseTrue_InputWithPivotAndOffset() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] bucket.setPivotYear(Integer.valueOf(2000)); [EOL] String text = "12345"; [EOL] int position = 2; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_LenientParseTrue_StringIndexOutOfBoundsException() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_CacheMissAndMaxDifferenceGreaterThan32() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "SomeText"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_CacheMissAndMaxDifferenceLessThan32() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "SomeText"; [EOL] int position = 0; [EOL] bucket.setLocale(Locale.ENGLISH); [EOL] int result = parseInto(bucket, text, position); [EOL] assertTrue(result < 0); [EOL] }
public void testParseInto_CacheHit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "SomeText"; [EOL] int position = 0; [EOL] bucket.setLocale(Locale.ENGLISH); [EOL] parseInto(bucket, text, position); [EOL] int result = parseInto(bucket, text, position); [EOL] assertTrue(result < 0); [EOL] }
public void testParseInto_ValidValueInText() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "ValidValue"; [EOL] int position = 0; [EOL] bucket.setLocale(Locale.ENGLISH); [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(text.length(), result); [EOL] }
public void testParseInto_SpecialCaseForEnglishEra() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "BCE"; [EOL] int position = 0; [EOL] bucket.setLocale(Locale.ENGLISH); [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(3, result); [EOL] }
public void testPrintToWithNullAppendable() throws IOException { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(buf, instant, chrono, 0, displayZone, locale); [EOL] assertTrue(buf.length() > 0); [EOL] }
public void testPrintToWithIOException() throws IOException { [EOL] Appendable buf = new Appendable() { [EOL] @Override [EOL] public Appendable append(CharSequence csq) throws IOException { [EOL] throw new IOException(); [EOL] } [EOL] @Override [EOL] public Appendable append(CharSequence csq, int start, int end) throws IOException { [EOL] throw new IOException(); [EOL] } [EOL] @Override [EOL] public Appendable append(char c) throws IOException { [EOL] throw new IOException(); [EOL] } [EOL] }; [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] try { [EOL] printTo(buf, instant, chrono, 0, displayZone, locale); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testPrintToWithValidInput() throws IOException { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockPartial.getChronology()).thenReturn(mockChronology); [EOL] Mockito.when(mockChronology.set(Mockito.any(ReadablePartial.class), Mockito.eq(0L))).thenReturn(12345L); [EOL] Mockito.doNothing().when(mockChronology).printTo(Mockito.any(StringBuffer.class), Mockito.any(DateTimeFormatter.class), Mockito.eq(12345L), Mockito.eq(mockChronology)); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] printTo(buf, mockPartial, mockLocale); [EOL] Mockito.verify(mockChronology).set(mockPartial, 0L); [EOL] Mockito.verify(mockChronology).printTo(buf, null, 12345L, mockChronology); [EOL] }
public void testPrintToWithIOException() throws IOException { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockPartial.getChronology()).thenReturn(mockChronology); [EOL] Mockito.when(mockChronology.set(Mockito.any(ReadablePartial.class), Mockito.eq(0L))).thenReturn(12345L); [EOL] Mockito.doThrow(new IOException()).when(mockChronology).printTo(Mockito.any(StringBuffer.class), Mockito.any(DateTimeFormatter.class), Mockito.eq(12345L), Mockito.eq(mockChronology)); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] printTo(buf, mockPartial, mockLocale); [EOL] Mockito.verify(mockChronology).set(mockPartial, 0L); [EOL] Mockito.verify(mockChronology).printTo(buf, null, 12345L, mockChronology); [EOL] }
protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException { [EOL] DateTimeField field = iFieldType.getField(chrono); [EOL] int minDigits = iMinDigits; [EOL] long fraction; [EOL] try { [EOL] fraction = field.remainder(instant); [EOL] } catch (RuntimeException e) { [EOL] if (buf != null) { [EOL] appendUnknownString(buf, minDigits); [EOL] } else { [EOL] printUnknownString(out, minDigits); [EOL] } [EOL] return; [EOL] } [EOL] if (fraction == 0) { [EOL] if (buf != null) { [EOL] while (--minDigits >= 0) { [EOL] buf.append('0'); [EOL] } [EOL] } else { [EOL] while (--minDigits >= 0) { [EOL] out.write('0'); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] String str; [EOL] long[] fractionData = getFractionData(fraction, field); [EOL] long scaled = fractionData[0]; [EOL] int maxDigits = (int) fractionData[1]; [EOL] if ((scaled & 0x7fffffff) == scaled) { [EOL] str = Integer.toString((int) scaled); [EOL] } else { [EOL] str = Long.toString(scaled); [EOL] } [EOL] int length = str.length(); [EOL] int digits = maxDigits; [EOL] while (length < digits) { [EOL] if (buf != null) { [EOL] buf.append('0'); [EOL] } else { [EOL] out.write('0'); [EOL] } [EOL] minDigits--; [EOL] digits--; [EOL] } [EOL] if (minDigits < digits) { [EOL] while (minDigits < digits) { [EOL] if (length <= 1 || str.charAt(length - 1) != '0') { [EOL] break; [EOL] } [EOL] digits--; [EOL] length--; [EOL] } [EOL] if (length < str.length()) { [EOL] if (buf != null) { [EOL] for (int i = 0; i < length; i++) { [EOL] buf.append(str.charAt(i)); [EOL] } [EOL] } else { [EOL] for (int i = 0; i < length; i++) { [EOL] out.write(str.charAt(i)); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] if (buf != null) { [EOL] buf.append(str); [EOL] } else { [EOL] out.write(str); [EOL] } [EOL] }
public void testGetFractionData_DefaultCase() { [EOL] DateTimeField field = createMockedDateTimeField(1L); // Assuming createMockedDateTimeField is a helper method [EOL] long fraction = 1L; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals(1L, result[0]); [EOL] assertEquals(0, result[1]); // Assuming iMaxDigits is initialized to 0 [EOL] } [EOL] public void testGetFractionData_Case1() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 1; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals(10L, result[0]); [EOL] assertEquals(1, result[1]); [EOL] } [EOL] public void testGetFractionData_Case2() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 2; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals(100L, result[0]); [EOL] assertEquals(2, result[1]); [EOL] }
public void testGetFractionData_Case3() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 3; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals(1000L, result[0]); [EOL] assertEquals(3, result[1]); [EOL] }
public void testGetFractionData_Case18() { [EOL] DateTimeField field = createMockedDateTimeField(1L); [EOL] long fraction = 1L; [EOL] iMaxDigits = 18; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals(1000000000000000000L, result[0]); [EOL] assertEquals(18, result[1]); [EOL] }
public void testGetFractionData_LoopBreakCondition() { [EOL] DateTimeField field = createMockedDateTimeField(Long.MAX_VALUE / 1000); [EOL] long fraction = 1L; [EOL] iMaxDigits = 4; [EOL] long[] result = getFractionData(fraction, field); [EOL] assertEquals(10000L, result[0]); [EOL] assertEquals(4, result[1]); [EOL] }
public void testPrintToWithNullDisplayZone() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = null; [EOL] Locale locale = null; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithZeroOffsetAndNonNullText() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iZeroOffsetPrintText = "GMT"; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("GMT", buf.toString()); [EOL] }
public void testPrintToWithPositiveOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR; // 1 hour [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01:00", buf.toString()); [EOL] }
public void testPrintToWithNegativeOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = -DateTimeConstants.MILLIS_PER_HOUR; // -1 hour [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("-01:00", buf.toString()); [EOL] }
public void testPrintToWithMaxFields() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; // 1 hour 1 minute [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 1; [EOL] iMinFields = 0; [EOL] iShowSeparators = false; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01", buf.toString()); [EOL] }
public void testPrintToWithMinFields() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; // 1 hour 1 minute [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 3; [EOL] iMinFields = 2; [EOL] iShowSeparators = false; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+0101", buf.toString()); [EOL] }
public void testPrintToWithShowSeparators() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE + DateTimeConstants.MILLIS_PER_SECOND; // 1 hour 1 minute 1 second [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 4; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01:01:01.000", buf.toString()); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] int limit = text.length() - position; [EOL] zeroOffset: if (iZeroOffsetParseText != null) { [EOL] if (iZeroOffsetParseText.length() == 0) { [EOL] if (limit > 0) { [EOL] char c = text.charAt(position); [EOL] if (c == '-' || c == '+') { [EOL] break zeroOffset; [EOL] } [EOL] } [EOL] bucket.setOffset(Integer.valueOf(0)); [EOL] return position; [EOL] } [EOL] if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL] bucket.setOffset(Integer.valueOf(0)); [EOL] return position + iZeroOffsetParseText.length(); [EOL] } [EOL] } [EOL] if (limit <= 1) { [EOL] return ~position; [EOL] } [EOL] boolean negative; [EOL] char c = text.charAt(position); [EOL] if (c == '-') { [EOL] negative = true; [EOL] } else if (c == '+') { [EOL] negative = false; [EOL] } else { [EOL] return ~position; [EOL] } [EOL] limit--; [EOL] position++; [EOL] if (digitCount(text, position, 2) < 2) { [EOL] return ~position; [EOL] } [EOL] int offset; [EOL] int hours = FormatUtils.parseTwoDigits(text, position); [EOL] if (hours > 23) { [EOL] return ~position; [EOL] } [EOL] offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL] limit -= 2; [EOL] position += 2; [EOL] parse: { [EOL] if (limit <= 0) { [EOL] break parse; [EOL] } [EOL] boolean expectSeparators; [EOL] c = text.charAt(position); [EOL] if (c == ':') { [EOL] expectSeparators = true; [EOL] limit--; [EOL] position++; [EOL] } else if (c >= '0' && c <= '9') { [EOL] expectSeparators = false; [EOL] } else { [EOL] break parse; [EOL] } [EOL] int count = digitCount(text, position, 2); [EOL] if (count == 0 && !expectSeparators) { [EOL] break parse; [EOL] } else if (count < 2) { [EOL] return ~position; [EOL] } [EOL] int minutes = FormatUtils.parseTwoDigits(text, position); [EOL] if (minutes > 59) { [EOL] return ~position; [EOL] } [EOL] offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL] limit -= 2; [EOL] position += 2; [EOL] if (limit <= 0) { [EOL] break parse; [EOL] } [EOL] if (expectSeparators) { [EOL] if (text.charAt(position) != ':') { [EOL] break parse; [EOL] } [EOL] limit--; [EOL] position++; [EOL] } [EOL] count = digitCount(text, position, 2); [EOL] if (count == 0 && !expectSeparators) { [EOL] break parse; [EOL] } else if (count < 2) { [EOL] return ~position; [EOL] } [EOL] int seconds = FormatUtils.parseTwoDigits(text, position); [EOL] if (seconds > 59) { [EOL] return ~position; [EOL] } [EOL] offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL] limit -= 2; [EOL] position += 2; [EOL] if (limit <= 0) { [EOL] break parse; [EOL] } [EOL] if (expectSeparators) { [EOL] if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL] break parse; [EOL] } [EOL] limit--; [EOL] position++; [EOL] } [EOL] count = digitCount(text, position, 3); [EOL] if (count == 0 && !expectSeparators) { [EOL] break parse; [EOL] } else if (count < 1) { [EOL] return ~position; [EOL] } [EOL] offset += (text.charAt(position++) - '0') * 100; [EOL] if (count > 1) { [EOL] offset += (text.charAt(position++) - '0') * 10; [EOL] if (count > 2) { [EOL] offset += text.charAt(position++) - '0'; [EOL] } [EOL] } [EOL] } [EOL] bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL] return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] DateTimeParser[] parsers = iParsers; [EOL] int length = parsers.length; [EOL] final Object originalState = bucket.saveState(); [EOL] boolean isOptional = false; [EOL] int bestValidPos = position; [EOL] Object bestValidState = null; [EOL] int bestInvalidPos = position; [EOL] for (int i = 0; i < length; i++) { [EOL] DateTimeParser parser = parsers[i]; [EOL] if (parser == null) { [EOL] if (bestValidPos <= position) { [EOL] return position; [EOL] } [EOL] isOptional = true; [EOL] break; [EOL] } [EOL] int parsePos = parser.parseInto(bucket, text, position); [EOL] if (parsePos >= position) { [EOL] if (parsePos > bestValidPos) { [EOL] if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL] return parsePos; [EOL] } [EOL] bestValidPos = parsePos; [EOL] bestValidState = bucket.saveState(); [EOL] } [EOL] } else { [EOL] if (parsePos < 0) { [EOL] parsePos = ~parsePos; [EOL] if (parsePos > bestInvalidPos) { [EOL] bestInvalidPos = parsePos; [EOL] } [EOL] } [EOL] } [EOL] bucket.restoreState(originalState); [EOL] } [EOL] if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL] if (bestValidState != null) { [EOL] bucket.restoreState(bestValidState); [EOL] } [EOL] return bestValidPos; [EOL] } [EOL] return ~bestInvalidPos; [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay time = new TimeOfDay(); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayLongConstructor() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] TimeOfDay time = new TimeOfDay(currentTimeMillis); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayLongChronologyConstructor() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(currentTimeMillis, chronology); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay time = new TimeOfDay(instant); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(instant, chronology); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayHourAndMinuteConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] TimeOfDay time = new TimeOfDay(hourOfDay, minuteOfHour); [EOL] assertEquals(hourOfDay, time.getHourOfDay()); [EOL] assertEquals(minuteOfHour, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteChronologyConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(hourOfDay, minuteOfHour, chronology); [EOL] assertEquals(hourOfDay, time.getHourOfDay()); [EOL] assertEquals(minuteOfHour, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteSecondConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] TimeOfDay time = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute); [EOL] assertEquals(hourOfDay, time.getHourOfDay()); [EOL] assertEquals(minuteOfHour, time.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, time.getSecondOfMinute()); [EOL] }
public void testTimeOfDayHourMinuteSecondChronologyConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, chronology); [EOL] assertEquals(hourOfDay, time.getHourOfDay()); [EOL] assertEquals(minuteOfHour, time.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, time.getSecondOfMinute()); [EOL] }
public void testTimeOfDayFullConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] TimeOfDay time = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(hourOfDay, time.getHourOfDay()); [EOL] assertEquals(minuteOfHour, time.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, time.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayFullChronologyConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertEquals(hourOfDay, time.getHourOfDay()); [EOL] assertEquals(minuteOfHour, time.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, time.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, time.getMillisOfSecond()); [EOL] }
public TimeOfDay(long instant, Chronology chronology) { [EOL] super(instant, chronology); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testPlusSeconds() { [EOL] TimeOfDay time = new TimeOfDay(10, 30, 0); [EOL] TimeOfDay newTime = time.plusSeconds(30); [EOL] assertEquals(10, newTime.getHourOfDay()); [EOL] assertEquals(30, newTime.getMinuteOfHour()); [EOL] assertEquals(30, newTime.getSecondOfMinute()); [EOL] }
public void testPlusSecondsWithHourOverflow() { [EOL] TimeOfDay time = new TimeOfDay(23, 59, 30); [EOL] TimeOfDay newTime = time.plusSeconds(30); [EOL] assertEquals(0, newTime.getHourOfDay()); [EOL] assertEquals(0, newTime.getMinuteOfHour()); [EOL] assertEquals(0, newTime.getSecondOfMinute()); [EOL] }
public void testPlusSecondsWithNegativeInput() { [EOL] TimeOfDay time = new TimeOfDay(10, 30, 30); [EOL] TimeOfDay newTime = time.plusSeconds(-60); [EOL] assertEquals(10, newTime.getHourOfDay()); [EOL] assertEquals(29, newTime.getMinuteOfHour()); [EOL] assertEquals(30, newTime.getSecondOfMinute()); [EOL] }
public void testMinusMillis_CoverNewLines() { [EOL] TimeOfDay time = new TimeOfDay(10, 0, 0, 0); // 10:00:00.000 [EOL] TimeOfDay result = time.minusMillis(1000); // Subtract 1 second [EOL] assertEquals(new TimeOfDay(9, 59, 59, 0), result); // Expect 09:59:59.000 [EOL] }
public void testMinusMillis_WithNegativeInput() { [EOL] TimeOfDay time = new TimeOfDay(10, 0, 0, 0); // 10:00:00.000 [EOL] TimeOfDay result = time.minusMillis(-1000); // Add 1 second [EOL] assertEquals(new TimeOfDay(10, 0, 1, 0), result); // Expect 10:00:01.000 [EOL] }
public void testMinusMillis_WithZeroInput() { [EOL] TimeOfDay time = new TimeOfDay(10, 0, 0, 0); // 10:00:00.000 [EOL] TimeOfDay result = time.minusMillis(0); // No change [EOL] assertEquals(new TimeOfDay(10, 0, 0, 0), result); // Expect 10:00:00.000 [EOL] }
public void testMinusMillis_WithMaxIntInput() { [EOL] TimeOfDay time = new TimeOfDay(10, 0, 0, 0); // 10:00:00.000 [EOL] TimeOfDay result = time.minusMillis(Integer.MAX_VALUE); [EOL] }
public void testMinusMillis_WithMinIntInput() { [EOL] TimeOfDay time = new TimeOfDay(10, 0, 0, 0); // 10:00:00.000 [EOL] TimeOfDay result = time.minusMillis(Integer.MIN_VALUE); [EOL] }
public TimeOfDay addWrapFieldToCopy(int valueToAdd) { [EOL] int[] newValues = iTimeOfDay.getValues(); [EOL] newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL] return new TimeOfDay(iTimeOfDay, newValues); [EOL] } [EOL] public TimeOfDay() { } [EOL] public TimeOfDay(DateTimeZone zone) { } [EOL] public TimeOfDay(Chronology chronology) { } [EOL] public TimeOfDay(long instant) { } [EOL] public TimeOfDay(long instant, Chronology chronology) { } [EOL] public TimeOfDay(Object instant) { } [EOL] public TimeOfDay(Object instant, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { } [EOL] TimeOfDay(TimeOfDay partial, int[] values) { } [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) { } [EOL] Property(TimeOfDay partial, int fieldIndex) { } [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) { } [EOL] public static TimeOfDay fromDateFields(Date date) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public TimeOfDay plus(ReadablePeriod period) { } [EOL] public TimeOfDay plusHours(int hours) { } [EOL] public TimeOfDay plusMinutes(int minutes) { } [EOL] public TimeOfDay plusSeconds(int seconds) { } [EOL] public TimeOfDay plusMillis(int millis) { } [EOL] public TimeOfDay minus(ReadablePeriod period) { } [EOL] public TimeOfDay minusHours(int hours) { } [EOL] public TimeOfDay minusMinutes(int minutes) { } [EOL] public TimeOfDay minusSeconds(int seconds) { } [EOL] public TimeOfDay minusMillis(int millis) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalTime toLocalTime() { } [EOL] public DateTime toDateTimeToday() { } [EOL] public DateTime toDateTimeToday(DateTimeZone zone) { } [EOL] public int getHourOfDay() { } [EOL] public int getMinuteOfHour() { } [EOL] public int getSecondOfMinute() { } [EOL] public int getMillisOfSecond() { } [EOL] public TimeOfDay withHourOfDay(int hour) { } [EOL] public TimeOfDay withMinuteOfHour(int minute) { } [EOL] public TimeOfDay withSecondOfMinute(int second) { } [EOL] public TimeOfDay withMillisOfSecond(int millis) { } [EOL] public Property hourOfDay() { } [EOL] public Property minuteOfHour() { } [EOL] public Property secondOfMinute() { } [EOL] public Property millisOfSecond() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public TimeOfDay getTimeOfDay() { } [EOL] public int get() { } [EOL] public TimeOfDay addToCopy(int valueToAdd) { } [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) { } [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public TimeOfDay setCopy(int value) { } [EOL] public TimeOfDay setCopy(String text, Locale locale) { } [EOL] public TimeOfDay setCopy(String text) { } [EOL] public TimeOfDay withMaximumValue() { } [EOL] public TimeOfDay withMinimumValue() { } [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testWithMinimumValue() { [EOL] TimeOfDay time = new TimeOfDay(); [EOL] TimeOfDay minTime = time.withMinimumValue(); [EOL] assertNotNull(minTime); [EOL] assertEquals(0, minTime.getHourOfDay()); [EOL] assertEquals(0, minTime.getMinuteOfHour()); [EOL] assertEquals(0, minTime.getSecondOfMinute()); [EOL] assertEquals(0, minTime.getMillisOfSecond()); [EOL] }
public void testGetStart() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTime dateTime = new DateTime(startMillis, chronology); [EOL] DateTime start = dateTime.getStart(); [EOL] assertEquals(startMillis, start.getMillis()); [EOL] assertEquals(chronology, start.getChronology()); [EOL] }
public void testGetEnd() { [EOL] long endMillis = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTime dateTime = new DateTime(endMillis, chronology); [EOL] DateTime.Property endProperty = new DateTime.Property(dateTime, endMillis); [EOL] DateTime end = endProperty.getEnd(); [EOL] assertNotNull(end); [EOL] assertEquals(endMillis, end.getMillis()); [EOL] assertEquals(chronology, end.getChronology()); [EOL] }
public void testContains_NullInterval() { [EOL] YourIntervalClass interval = new YourIntervalClass(); // Replace with actual interval class [EOL] boolean result = interval.contains(null); [EOL] assert result == true; // Replace with actual assertion library [EOL] } [EOL] public void testContains_IntervalWithin() { [EOL] YourIntervalClass interval = new YourIntervalClass(); // Replace with actual interval class [EOL] ReadableInterval innerInterval = new ReadableInterval() { // Replace with actual interval implementation [EOL] public long getStartMillis() { return interval.getStartMillis() + 1; } [EOL] public long getEndMillis() { return interval.getEndMillis() - 1; } [EOL] }; [EOL] boolean result = interval.contains(innerInterval); [EOL] assert result == true; // Replace with actual assertion library [EOL] }
public void testContains_IntervalStartsBefore() { [EOL] YourIntervalClass interval = new YourIntervalClass(); // Replace with actual interval class [EOL] ReadableInterval startingBefore = new ReadableInterval() { // Replace with actual interval implementation [EOL] public long getStartMillis() { return interval.getStartMillis() - 1; } [EOL] public long getEndMillis() { return interval.getEndMillis() - 1; } [EOL] }; [EOL] boolean result = interval.contains(startingBefore); [EOL] assert result == false; // Replace with actual assertion library [EOL] }
public void testContains_IntervalEndsAfter() { [EOL] YourIntervalClass interval = new YourIntervalClass(); // Replace with actual interval class [EOL] ReadableInterval endingAfter = new ReadableInterval() { // Replace with actual interval implementation [EOL] public long getStartMillis() { return interval.getStartMillis() + 1; } [EOL] public long getEndMillis() { return interval.getEndMillis() + 1; } [EOL] }; [EOL] boolean result = interval.contains(endingAfter); [EOL] assert result == false; // Replace with actual assertion library [EOL] }
public void testContains_IntervalCompletelyOutside() { [EOL] YourIntervalClass interval = new YourIntervalClass(); // Replace with actual interval class [EOL] ReadableInterval outsideInterval = new ReadableInterval() { // Replace with actual interval implementation [EOL] public long getStartMillis() { return interval.getEndMillis() + 1; } [EOL] public long getEndMillis() { return interval.getEndMillis() + 2; } [EOL] }; [EOL] boolean result = interval.contains(outsideInterval); [EOL] assert result == false; // Replace with actual assertion library [EOL] }
public void testIsAfter_WithNullInterval() { [EOL] long fixedStartMillis = DateTimeUtils.currentTimeMillis(); [EOL] TestInterval testInterval = new TestInterval(fixedStartMillis, fixedStartMillis + 1000); [EOL] boolean result = testInterval.isAfter(null); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_WithIntervalBefore() { [EOL] long fixedStartMillis = DateTimeUtils.currentTimeMillis(); [EOL] TestInterval testInterval = new TestInterval(fixedStartMillis, fixedStartMillis + 1000); [EOL] ReadableInterval beforeInterval = new TestInterval(fixedStartMillis - 2000, fixedStartMillis - 1000); [EOL] boolean result = testInterval.isAfter(beforeInterval); [EOL] assertTrue(result); [EOL] }
public void testIsAfter_WithIntervalAfter() { [EOL] long fixedStartMillis = DateTimeUtils.currentTimeMillis(); [EOL] TestInterval testInterval = new TestInterval(fixedStartMillis, fixedStartMillis + 1000); [EOL] ReadableInterval afterInterval = new TestInterval(fixedStartMillis + 2000, fixedStartMillis + 3000); [EOL] boolean result = testInterval.isAfter(afterInterval); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_WithIntervalDuring() { [EOL] long fixedStartMillis = DateTimeUtils.currentTimeMillis(); [EOL] TestInterval testInterval = new TestInterval(fixedStartMillis, fixedStartMillis + 1000); [EOL] ReadableInterval duringInterval = new TestInterval(fixedStartMillis + 500, fixedStartMillis + 1500); [EOL] boolean result = testInterval.isAfter(duringInterval); [EOL] assertFalse(result); [EOL] }
public void testToDuration_ZeroMillis() { [EOL] Time time = new Time() { [EOL] @Override [EOL] public long toDurationMillis() { [EOL] return 0; [EOL] } [EOL] }; [EOL] Duration result = time.toDuration(); [EOL] assertEquals(Duration.ZERO, result); [EOL] }
public void testToDuration_NonZeroMillis() { [EOL] final long nonZeroMillis = 12345L; [EOL] Time time = new Time() { [EOL] @Override [EOL] public long toDurationMillis() { [EOL] return nonZeroMillis; [EOL] } [EOL] }; [EOL] Duration result = time.toDuration(); [EOL] assertEquals(new Duration(nonZeroMillis), result); [EOL] }
public void testGetWithInvalidType() { [EOL] DurationFieldType invalidType = null; // Assuming null is not a valid type [EOL] int expected = 0; [EOL] int actual = instance.get(invalidType); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithValidType() { [EOL] DurationFieldType validType = DurationFieldType.seconds(); // Assuming seconds is a valid type [EOL] int expectedIndex = 1; // Assuming index of seconds is 1 [EOL] int expectedValue = 10; // Assuming the value at index 1 is 10 [EOL] instance.setValue(expectedIndex, expectedValue); [EOL] int actual = instance.get(validType); [EOL] assertEquals(expectedValue, actual); [EOL] }
public int indexOfTestWithValidType() { [EOL] DurationFieldType validType = DurationFieldType.seconds(); [EOL] PeriodType periodType = PeriodType.standard(); [EOL] Period period = new Period(periodType); [EOL] int index = period.indexOf(validType); [EOL] assertEquals(periodType.indexOf(validType), index); [EOL] } [EOL] public int indexOfTestWithInvalidType() { [EOL] DurationFieldType invalidType = DurationFieldType.years(); [EOL] PeriodType periodType = PeriodType.time(); [EOL] Period period = new Period(periodType); [EOL] int index = period.indexOf(invalidType); [EOL] assertEquals(-1, index); [EOL] }
public void testToMutablePeriod() { [EOL] Period period = new Period(); [EOL] MutablePeriod mutablePeriod = period.toMutablePeriod(); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(period.getYears(), mutablePeriod.getYears()); [EOL] assertEquals(period.getMonths(), mutablePeriod.getMonths()); [EOL] assertEquals(period.getWeeks(), mutablePeriod.getWeeks()); [EOL] assertEquals(period.getDays(), mutablePeriod.getDays()); [EOL] assertEquals(period.getHours(), mutablePeriod.getHours()); [EOL] assertEquals(period.getMinutes(), mutablePeriod.getMinutes()); [EOL] assertEquals(period.getSeconds(), mutablePeriod.getSeconds()); [EOL] assertEquals(period.getMillis(), mutablePeriod.getMillis()); [EOL] }
public void testParseWithNullString() { [EOL] try { [EOL] MutablePeriod.parse(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithEmptyString() { [EOL] try { [EOL] MutablePeriod.parse(""); [EOL] fail("Should have thrown IllegalArgumentException for empty input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithValidString() { [EOL] String validPeriodString = "PT1H2M3S"; [EOL] MutablePeriod result = MutablePeriod.parse(validPeriodString); [EOL] assertNotNull("Parsed period should not be null", result); [EOL] assertEquals("Hours should be 1", 1, result.getHours()); [EOL] assertEquals("Minutes should be 2", 2, result.getMinutes()); [EOL] assertEquals("Seconds should be 3", 3, result.getSeconds()); [EOL] }
public void testParseWithValidFormatterAndString() { [EOL] String str = "P1Y2M3D"; [EOL] PeriodFormatter formatter = ISOPeriodFormat.standard(); [EOL] MutablePeriod result = Time.parse(str, formatter); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getYears()); [EOL] assertEquals(2, result.getMonths()); [EOL] assertEquals(3, result.getDays()); [EOL] }
public void testParseWithNullFormatter() { [EOL] String str = "P1Y2M3D"; [EOL] try { [EOL] Time.parse(str, null); [EOL] fail("Should have thrown IllegalArgumentException for null formatter"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithInvalidString() { [EOL] String str = "Invalid Format"; [EOL] PeriodFormatter formatter = ISOPeriodFormat.standard(); [EOL] try { [EOL] Time.parse(str, formatter); [EOL] fail("Should have thrown IllegalArgumentException for invalid format string"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMutablePeriodConstructor() { [EOL] MutablePeriod mp = new MutablePeriod(); [EOL] assertNotNull(mp); [EOL] assertEquals(0L, mp.getStartMillis()); [EOL] assertNull(mp.getPeriodType()); [EOL] assertNull(mp.getChronology()); [EOL] }
public void testMutablePeriodWithValidRange() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant); [EOL] assertNotNull(period); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] }
public void testMutablePeriodWithEqualStartAndEnd() { [EOL] long instant = 1000L; [EOL] MutablePeriod period = new MutablePeriod(instant, instant); [EOL] assertNotNull(period); [EOL] assertEquals(instant, period.getStartMillis()); [EOL] assertEquals(instant, period.getEndMillis()); [EOL] }
public void testMutablePeriodWithStartAfterEnd() { [EOL] long startInstant = 2000L; [EOL] long endInstant = 1000L; [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant); [EOL] assertNotNull(period); [EOL] assertEquals(endInstant, period.getStartMillis()); [EOL] assertEquals(startInstant, period.getEndMillis()); [EOL] }
public void testSetPeriodWithPositiveDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.setPeriod(1000L); [EOL] assertEquals(1000L, timePeriod.getDuration()); [EOL] assertNull(timePeriod.getChronoUnit()); [EOL] }
public void testSetPeriodWithZeroDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.setPeriod(0L); [EOL] assertEquals(0L, timePeriod.getDuration()); [EOL] assertNull(timePeriod.getChronoUnit()); [EOL] }
public void testSetPeriodWithNegativeDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.setPeriod(-1000L); [EOL] assertEquals(-1000L, timePeriod.getDuration()); [EOL] assertNull(timePeriod.getChronoUnit()); [EOL] }
public void setPeriod_WithValidDurationAndChronology_ShouldSetValues() { [EOL] long duration = 123456L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] BasePeriod period = new BasePeriod(0L, chrono); [EOL] period.setPeriod(duration, chrono); [EOL] long[] expectedValues = chrono.get(period, duration); [EOL] for (int i = 0; i < expectedValues.length; i++) { [EOL] assertEquals(expectedValues[i], period.getValues()[i]); [EOL] } [EOL] }
public void setPeriod_WithNullChronology_ShouldUseISOChronologyAndSetValues() { [EOL] long duration = 123456L; [EOL] Chronology chrono = null; [EOL] BasePeriod period = new BasePeriod(0L); [EOL] period.setPeriod(duration, chrono); [EOL] Chronology usedChrono = ISOChronology.getInstance(); [EOL] long[] expectedValues = usedChrono.get(period, duration); [EOL] for (int i = 0; i < expectedValues.length; i++) { [EOL] assertEquals(expectedValues[i], period.getValues()[i]); [EOL] } [EOL] }
public void testAdd() { [EOL] TimePeriod time = new TimePeriod(1, 1, 1, 1, 1, 1, 1, 1); [EOL] time.add(1, 1, 1, 1, 1, 1, 1, 1); [EOL] assertEquals(2, time.getYears()); [EOL] assertEquals(2, time.getMonths()); [EOL] assertEquals(2, time.getWeeks()); [EOL] assertEquals(2, time.getDays()); [EOL] assertEquals(2, time.getHours()); [EOL] assertEquals(2, time.getMinutes()); [EOL] assertEquals(2, time.getSeconds()); [EOL] assertEquals(2, time.getMillis()); [EOL] }
public void testAddWithDuration() { [EOL] long initialDuration = 1000; [EOL] TimePeriod timePeriod = new TimePeriod(initialDuration, timePeriod.getPeriodType()); [EOL] long additionalDuration = 500; [EOL] timePeriod.add(additionalDuration); [EOL] long expectedDuration = initialDuration + additionalDuration; [EOL] assertEquals(expectedDuration, timePeriod.getTotalDuration()); [EOL] }
public void testAddWithDurationAndChronology_NullChronology() { [EOL] long duration = 1000L; [EOL] Chronology chrono = null; [EOL] add(duration, chrono); [EOL] } [EOL] public void testAddWithDurationAndChronology_ValidChronology() { [EOL] long duration = 1000L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] add(duration, chrono); [EOL] }
public int getWeeks() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX); [EOL] }
public void setWeeksTestWithValidWeeks() { [EOL] Duration testDuration = new Duration(); [EOL] int weeks = 5; [EOL] testDuration.setWeeks(weeks); [EOL] assertEquals(weeks, testDuration.getWeeks()); [EOL] }
public void setWeeksTestWithZeroWeeks() { [EOL] Duration testDuration = new Duration(); [EOL] int weeks = 0; [EOL] testDuration.setWeeks(weeks); [EOL] assertEquals(weeks, testDuration.getWeeks()); [EOL] }
public void setWeeksTestWithNegativeWeeks() { [EOL] Duration testDuration = new Duration(); [EOL] int weeks = -1; [EOL] testDuration.setWeeks(weeks); [EOL] assertEquals(weeks, testDuration.getWeeks()); [EOL] }
public void addHours_positiveHours() { [EOL] Time time = new Time(); [EOL] int hoursToAdd = 5; [EOL] time.addHours(hoursToAdd); [EOL] }
public void addHours_negativeHours() { [EOL] Time time = new Time(); [EOL] int hoursToAdd = -3; [EOL] time.addHours(hoursToAdd); [EOL] }
public void addHours_zeroHours() { [EOL] Time time = new Time(); [EOL] int hoursToAdd = 0; [EOL] time.addHours(hoursToAdd); [EOL] }
public int getYearTestWithValidInstant() { [EOL] long instant = 1234567890L; // Replace with a valid instant value [EOL] int expectedYear = 1970; // Replace with the expected year for the given instant [EOL] int actualYear = iChronology.getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public int getYearTestWithNegativeInstant() { [EOL] long instant = -1234567890L; // Replace with a valid negative instant value [EOL] int expectedYear = 1960; // Replace with the expected year for the given negative instant [EOL] int actualYear = iChronology.getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public long add(long instant, long years) { [EOL] return add(instant, FieldUtils.safeToInt(years)); [EOL] }
public void testSaveField_WhenSavedFieldsIsFull() { [EOL] initializeFullSavedFields(); [EOL] SavedField testField = new SavedField(); [EOL] int expectedSavedFieldsCount = iSavedFieldsCount + 1; [EOL] saveField(testField); [EOL] assertEquals(expectedSavedFieldsCount, iSavedFieldsCount); [EOL] assertSame(testField, iSavedFields[iSavedFieldsCount - 1]); [EOL] assertFalse(iSavedFieldsShared); [EOL] }
public void testSaveField_WhenSavedFieldsIsNotFullAndNotShared() { [EOL] initializeNonFullNonSharedSavedFields(); [EOL] SavedField testField = new SavedField(); [EOL] int expectedSavedFieldsCount = iSavedFieldsCount + 1; [EOL] saveField(testField); [EOL] assertEquals(expectedSavedFieldsCount, iSavedFieldsCount); [EOL] assertSame(testField, iSavedFields[iSavedFieldsCount - 1]); [EOL] assertFalse(iSavedFieldsShared); [EOL] }
public void testSaveField_WhenSavedFieldsIsShared() { [EOL] initializeSharedSavedFields(); [EOL] SavedField testField = new SavedField(); [EOL] int expectedSavedFieldsCount = iSavedFieldsCount + 1; [EOL] saveField(testField); [EOL] assertEquals(expectedSavedFieldsCount, iSavedFieldsCount); [EOL] assertSame(testField, iSavedFields[iSavedFieldsCount - 1]); [EOL] assertFalse(iSavedFieldsShared); [EOL] }
public void testRestoreStateWithDifferentBucket() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] DateTimeParserBucket otherBucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] boolean result = bucket.restoreState(otherBucket); [EOL] assertFalse(result); [EOL] }
public void testRestoreStateWithSameBucket() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] boolean result = bucket.restoreState(bucket); [EOL] assertTrue(result); [EOL] }
public void testRestoreStateWithSavedFieldsCountLess() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] bucket.iSavedFieldsCount = 2; [EOL] DateTimeParserBucket otherBucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] otherBucket.iSavedFieldsCount = 3; [EOL] boolean result = otherBucket.restoreState(bucket); [EOL] assertTrue(result); [EOL] assertTrue(otherBucket.iSavedFieldsShared); [EOL] }
public void testRestoreStateWithSavedFieldsCountGreaterOrEqual() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] bucket.iSavedFieldsCount = 3; [EOL] DateTimeParserBucket otherBucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] otherBucket.iSavedFieldsCount = 2; [EOL] boolean result = otherBucket.restoreState(bucket); [EOL] assertTrue(result); [EOL] assertFalse(otherBucket.iSavedFieldsShared); [EOL] }
public long roundCeiling(long instant) { [EOL] return getWrappedField().roundCeiling(instant); [EOL] }
public void testSetYearOnNonLeapYear() { [EOL] long instant = /* some instant representing a non-leap year date */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting the year */; [EOL] long result = setYear(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public void testSetYearOnLeapYear() { [EOL] long instant = /* some instant representing a leap year date */; [EOL] int year = /* a leap year */; [EOL] long expected = /* expected instant after setting the year */; [EOL] long result = setYear(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public void testSetYearDecreasingDayOfYear() { [EOL] long instant = /* some instant representing Feb 29 in a leap year */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting the year, with dayOfYear decremented */; [EOL] long result = setYear(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public void testIsLeapYear_Leap() { [EOL] boolean result = isLeapYear(2023); [EOL] assertFalse(result); [EOL] }
public void testIsLeapYear_NotLeap() { [EOL] boolean result = isLeapYear(2024); [EOL] assertTrue(result); [EOL] }
public void testGetDaysInMonthMax() { [EOL] Time time = new Time(); [EOL] int expected = Time.MONTH_LENGTH; [EOL] int actual = time.getDaysInMonthMax(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMonthOfYear_January() { [EOL] long millis = getMillisForDate(2023, 1, 1); // Assuming this method returns the millis for January 1st, 2023 [EOL] int year = 2023; [EOL] int expectedMonth = 1; [EOL] int actualMonth = getMonthOfYear(millis, year); [EOL] assertEquals(expectedMonth, actualMonth); [EOL] } [EOL] public void testGetMonthOfYear_December() { [EOL] long millis = getMillisForDate(2023, 12, 1); // Assuming this method returns the millis for December 1st, 2023 [EOL] int year = 2023; [EOL] int expectedMonth = 12; [EOL] int actualMonth = getMonthOfYear(millis, year); [EOL] assertEquals(expectedMonth, actualMonth); [EOL] }
public void testGetMaximumValue_WithValidInstant() { [EOL] long instant = /* valid instant representing a specific time */; [EOL] int expectedWeeksInYear = /* expected number of weeks in that year */; [EOL] int actualWeeksInYear = instance.getMaximumValue(instant); [EOL] assertEquals(expectedWeeksInYear, actualWeeksInYear); [EOL] }
public void testGetMaximumValue_WithInstantAtYearStart() { [EOL] long instant = /* instant representing the start of a year */; [EOL] int expectedWeeksInYear = /* expected number of weeks in that year, typically 52 or 53 */; [EOL] int actualWeeksInYear = instance.getMaximumValue(instant); [EOL] assertEquals(expectedWeeksInYear, actualWeeksInYear); [EOL] }
public void testGetMaximumValue_WithInstantAtYearEnd() { [EOL] long instant = /* instant representing the end of a year */; [EOL] int expectedWeeksInYear = /* expected number of weeks in that year, typically 52 or 53 */; [EOL] int actualWeeksInYear = instance.getMaximumValue(instant); [EOL] assertEquals(expectedWeeksInYear, actualWeeksInYear); [EOL] }
public void testAssembledChronologyWithNonNullBase() { [EOL] Chronology base = new GregorianChronology(); [EOL] Object param = new Object(); [EOL] AssembledChronology chronology = new AssembledChronology(base, param); [EOL] assertNotNull(chronology.iBase); [EOL] assertNotNull(chronology.iParam); [EOL] }
public void testAssembledChronologyWithNullBase() { [EOL] Object param = new Object(); [EOL] AssembledChronology chronology = new AssembledChronology(null, param); [EOL] assertNull(chronology.iBase); [EOL] assertNotNull(chronology.iParam); [EOL] }
public void testAssembledChronologyWithNullParam() { [EOL] Chronology base = new GregorianChronology(); [EOL] AssembledChronology chronology = new AssembledChronology(base, null); [EOL] assertNotNull(chronology.iBase); [EOL] assertNull(chronology.iParam); [EOL] }
public void testAssembledChronologyWithNullBaseAndParam() { [EOL] AssembledChronology chronology = new AssembledChronology(null, null); [EOL] assertNull(chronology.iBase); [EOL] assertNull(chronology.iParam); [EOL] }
public void testGetZone_BaseChronologyNotNull() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeZone mockDateTimeZone = Mockito.mock(DateTimeZone.class); [EOL] Mockito.when(mockChronology.getZone()).thenReturn(mockDateTimeZone); [EOL] MyClass myClass = new MyClass(mockChronology); [EOL] DateTimeZone result = myClass.getZone(); [EOL] assertNotNull(result); [EOL] assertEquals(mockDateTimeZone, result); [EOL] }
public void testGetZone_BaseChronologyNull() { [EOL] MyClass myClass = new MyClass(null); [EOL] DateTimeZone result = myClass.getZone(); [EOL] assertNull(result); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagsMatch() { [EOL] Chronology mockBase = Mockito.mock(Chronology.class); [EOL] iBase = mockBase; [EOL] iBaseFlags = 6; // Assuming iBaseFlags is a field that can be set in the test environment [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expected = 162149760012345L; // Assuming this is the expected result from the mock [EOL] Mockito.when(mockBase.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)).thenReturn(expected); [EOL] long actual = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagsDoNotMatch() { [EOL] Chronology mockBase = Mockito.mock(Chronology.class); [EOL] iBase = mockBase; [EOL] iBaseFlags = 2; // Flags do not match the condition (iBaseFlags & 6) == 6 [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expected = 162149760012345L; // Assuming this is the expected result from the super method [EOL] long actual = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDateTimeMillis_BaseNull() { [EOL] iBase = null; // Base is set to null [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expected = 162149760012345L; // Assuming this is the expected result from the super method [EOL] long actual = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagsSet() { [EOL] iBase = mock(Chronology.class); [EOL] iBaseFlags = 5; // Setting the flags so that the condition (iBaseFlags & 5) == 5 is true [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] long expectedMillis = 1621513845123L; // Example expected value [EOL] when(iBase.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)).thenReturn(expectedMillis); [EOL] long actualMillis = getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetDateTimeMillis_BaseNull() { [EOL] iBase = null; [EOL] iBaseFlags = 0; // Any value that does not satisfy the condition (iBaseFlags & 5) == 5 [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] long expectedMillis = 1621513845123L; // Example expected value [EOL] when(super.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)).thenReturn(expectedMillis); [EOL] long actualMillis = getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagsNotSet() { [EOL] iBase = mock(Chronology.class); [EOL] iBaseFlags = 4; // Any value that does not satisfy the condition (iBaseFlags & 5) == 5 [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] long expectedMillis = 1621513845123L; // Example expected value [EOL] when(super.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)).thenReturn(expectedMillis); [EOL] long actualMillis = getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testMillisField() { [EOL] DurationFieldType type = DurationFieldType.millis(); [EOL] DurationField field = type.getField(ISOChronology.getInstanceUTC()); [EOL] assertEquals("millis", field.getName()); [EOL] assertEquals(DurationFieldType.millis(), field.getType()); [EOL] assertTrue(field.isSupported()); [EOL] assertEquals(1, field.getUnitMillis()); [EOL] assertEquals(0, field.getValue(12345L)); [EOL] assertEquals(12345L, field.getValueAsLong(12345L)); [EOL] assertEquals(0, field.getDifference(0L, 12345L)); [EOL] assertEquals(12345L, field.getDifferenceAsLong(0L, 12345L)); [EOL] assertEquals(12345L, field.add(0L, 12345)); [EOL] assertEquals(12345L, field.add(0L, 12345L)); [EOL] assertEquals(24690L, field.add(12345L, 12345)); [EOL] assertEquals(24690L, field.add(12345L, 12345L)); [EOL] assertEquals(-12345L, field.subtract(0L, 12345)); [EOL] assertEquals(-12345L, field.subtract(0L, 12345L)); [EOL] assertEquals(0L, field.subtract(12345L, 12345)); [EOL] assertEquals(0L, field.subtract(12345L, 12345L)); [EOL] assertEquals(12345L, field.roundFloor(12345L)); [EOL] assertEquals(12345L, field.roundCeiling(12345L)); [EOL] assertEquals(12345L, field.roundHalfFloor(12345L)); [EOL] assertEquals(12345L, field.roundHalfCeiling(12345L)); [EOL] assertEquals(12345L, field.roundHalfEven(12345L)); [EOL] assertEquals(12345L, field.remainder(12345L)); [EOL] assertEquals(0, field.compareTo(field)); [EOL] try { [EOL] field.compareTo(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMillisOfSecond() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField millisField = testDateTime.millisOfSecond(); [EOL] assertNotNull(millisField); [EOL] assertEquals(millisField, testDateTime.getChronology().millisOfSecond()); [EOL] }
public void testSecondsFieldNotNull() { [EOL] Time time = new Time(); [EOL] DurationField secondsField = time.seconds(); [EOL] assertNotNull(secondsField); [EOL] }
public void testSecondOfMinute() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField secondOfMinuteField = testDateTime.secondOfMinute(); [EOL] assertNotNull("Second of minute field should not be null", secondOfMinuteField); [EOL] assertEquals("Field type should be secondOfMinute", testDateTime.getChronology().secondOfMinute(), secondOfMinuteField); [EOL] }
public void testSecondOfDay() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField secondOfDayField = testDateTime.secondOfDay(); [EOL] assertNotNull(secondOfDayField); [EOL] assertEquals("secondOfDay", secondOfDayField.getName()); [EOL] assertTrue(secondOfDayField.isSupported()); [EOL] assertEquals(testDateTime.getSecondOfDay(), secondOfDayField.get()); [EOL] }
public void testMinuteOfHour() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField minuteOfHourField = testDateTime.minuteOfHour(); [EOL] assertNotNull(minuteOfHourField); [EOL] assertEquals("minuteOfHour", minuteOfHourField.getName()); [EOL] }
public void testMinuteOfDay() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField minuteOfDayField = testDateTime.minuteOfDay(); [EOL] assertNotNull(minuteOfDayField); [EOL] assertEquals("minuteOfDay", minuteOfDayField.getName()); [EOL] assertEquals(testDateTime.getMinuteOfDay(), minuteOfDayField.get()); [EOL] }
public void testHourOfDay() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField hourField = testDateTime.hourOfDay(); [EOL] assertNotNull(hourField); [EOL] assertEquals("hourOfDay", hourField.getName()); [EOL] assertEquals(testDateTime.getChronology().hours(), hourField.getDurationField()); [EOL] assertEquals(testDateTime.getChronology().days(), hourField.getRangeDurationField()); [EOL] assertTrue(hourField.isSupported()); [EOL] assertEquals(testDateTime.getHourOfDay(), hourField.get()); [EOL] }
public void testClockhourOfDay() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField clockhourField = testDateTime.clockhourOfDay(); [EOL] assertNotNull("ClockhourOfDay field should not be null", clockhourField); [EOL] }
public void testHalfdays() { [EOL] Time time = new Time(); [EOL] DurationField result = time.halfdays(); [EOL] assertNotNull(result); [EOL] assertEquals(time.iHalfdays, result); [EOL] }
public final DateTimeField hourOfHalfday() { [EOL] return iHourOfHalfday; [EOL] }
public void testClockhourOfHalfday() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField clockhourOfHalfdayField = testDateTime.clockhourOfHalfday(); [EOL] assertNotNull(clockhourOfHalfdayField); [EOL] assertTrue(clockhourOfHalfdayField instanceof ClockhourOfHalfdayDateTimeField); [EOL] }
public void testHalfdayOfDay() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField halfdayField = testDateTime.halfdayOfDay(); [EOL] assertNotNull("HalfdayOfDay field should not be null", halfdayField); [EOL] }
public void testDays() { [EOL] Time time = new Time(); // Assuming Time is the class where days() is defined [EOL] DurationField result = time.days(); [EOL] assertNotNull("DurationField should not be null", result); [EOL] }
public void testDayOfMonth() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField dayOfMonthField = testDateTime.dayOfMonth(); [EOL] assertNotNull(dayOfMonthField); [EOL] assertEquals(testDateTime.getChronology().dayOfMonth(), dayOfMonthField); [EOL] }
public final DateTimeField dayOfYear() { [EOL] return iDayOfYear; [EOL] }
public void testWeeksField() { [EOL] DurationField weeksField = time.weeks(); [EOL] assertNotNull(weeksField); [EOL] }
public void testWeekOfWeekyear() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField weekField = testDateTime.weekOfWeekyear(); [EOL] assertNotNull(weekField); [EOL] }
public void testWeekyears() { [EOL] DurationField expected = time.iWeekyears; [EOL] DurationField actual = time.weekyears(); [EOL] assertEquals(expected, actual); [EOL] }
public void testWeekyear() { [EOL] DateTimeField weekyearField = new DateTime().weekyear(); [EOL] assertNotNull("Weekyear field should not be null", weekyearField); [EOL] }
public void testWeekyearOfCentury() { [EOL] DateTimeField field = new DateTime().weekyearOfCentury(); [EOL] assertNotNull(field); [EOL] }
public void testMonthsField() { [EOL] DurationField monthsField = timeObj.months(); [EOL] assertNotNull(monthsField); [EOL] }
public void testMonthOfYear() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField monthOfYearField = testDateTime.monthOfYear(); [EOL] assertNotNull(monthOfYearField); [EOL] assertEquals(testDateTime.getChronology().monthOfYear(), monthOfYearField); [EOL] }
public final DurationField years() { [EOL] return iYears; [EOL] }
public void testYearField() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField yearField = testDateTime.year(); [EOL] assertNotNull(yearField); [EOL] assertEquals("year", yearField.getName()); [EOL] }
public void testYearOfEra() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField yearOfEraField = testDateTime.yearOfEra(); [EOL] assertNotNull(yearOfEraField); [EOL] assertEquals("yearOfEra", yearOfEraField.getName()); [EOL] }
public void testYearOfCentury() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField yearOfCenturyField = testDateTime.yearOfCentury(); [EOL] assertNotNull(yearOfCenturyField); [EOL] }
public void testCenturiesField() { [EOL] DurationField centuriesField = time.centuries(); [EOL] assertNotNull(centuriesField); [EOL] }
public void testCenturyOfEra() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField centuryOfEraField = testDateTime.centuryOfEra(); [EOL] assertNotNull(centuryOfEraField); [EOL] }
public void testEras() { [EOL] DateTimeFieldType type = DateTimeFieldType.eras(); [EOL] DurationField field = type.eras(); [EOL] assertNotNull(field); [EOL] }
public void testEraField() { [EOL] DateTimeField eraField = dateTime.era(); [EOL] assertNotNull("Era field should not be null", eraField); [EOL] }
public void testGetBase() { [EOL] MyClass myClassInstance = new MyClass(); // Replace MyClass with the actual class name [EOL] Chronology result = myClassInstance.getBase(); [EOL] assertNotNull("The base Chronology should not be null", result); [EOL] }
protected final Object getParam() { [EOL] return iParam; [EOL] }
private void setFields() { [EOL] Fields fields = new Fields(); [EOL] if (iBase != null) { [EOL] fields.copyFieldsFrom(iBase); [EOL] } [EOL] assemble(fields); [EOL] { [EOL] DurationField f; [EOL] iMillis = (f = fields.millis) != null ? f : super.millis(); [EOL] iSeconds = (f = fields.seconds) != null ? f : super.seconds(); [EOL] iMinutes = (f = fields.minutes) != null ? f : super.minutes(); [EOL] iHours = (f = fields.hours) != null ? f : super.hours(); [EOL] iHalfdays = (f = fields.halfdays) != null ? f : super.halfdays(); [EOL] iDays = (f = fields.days) != null ? f : super.days(); [EOL] iWeeks = (f = fields.weeks) != null ? f : super.weeks(); [EOL] iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears(); [EOL] iMonths = (f = fields.months) != null ? f : super.months(); [EOL] iYears = (f = fields.years) != null ? f : super.years(); [EOL] iCenturies = (f = fields.centuries) != null ? f : super.centuries(); [EOL] iEras = (f = fields.eras) != null ? f : super.eras(); [EOL] } [EOL] { [EOL] DateTimeField f; [EOL] iMillisOfSecond = (f = fields.millisOfSecond) != null ? f : super.millisOfSecond(); [EOL] iMillisOfDay = (f = fields.millisOfDay) != null ? f : super.millisOfDay(); [EOL] iSecondOfMinute = (f = fields.secondOfMinute) != null ? f : super.secondOfMinute(); [EOL] iSecondOfDay = (f = fields.secondOfDay) != null ? f : super.secondOfDay(); [EOL] iMinuteOfHour = (f = fields.minuteOfHour) != null ? f : super.minuteOfHour(); [EOL] iMinuteOfDay = (f = fields.minuteOfDay) != null ? f : super.minuteOfDay(); [EOL] iHourOfDay = (f = fields.hourOfDay) != null ? f : super.hourOfDay(); [EOL] iClockhourOfDay = (f = fields.clockhourOfDay) != null ? f : super.clockhourOfDay(); [EOL] iHourOfHalfday = (f = fields.hourOfHalfday) != null ? f : super.hourOfHalfday(); [EOL] iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday(); [EOL] iHalfdayOfDay = (f = fields.halfdayOfDay) != null ? f : super.halfdayOfDay(); [EOL] iDayOfWeek = (f = fields.dayOfWeek) != null ? f : super.dayOfWeek(); [EOL] iDayOfMonth = (f = fields.dayOfMonth) != null ? f : super.dayOfMonth(); [EOL] iDayOfYear = (f = fields.dayOfYear) != null ? f : super.dayOfYear(); [EOL] iWeekOfWeekyear = (f = fields.weekOfWeekyear) != null ? f : super.weekOfWeekyear(); [EOL] iWeekyear = (f = fields.weekyear) != null ? f : super.weekyear(); [EOL] iWeekyearOfCentury = (f = fields.weekyearOfCentury) != null ? f : super.weekyearOfCentury(); [EOL] iMonthOfYear = (f = fields.monthOfYear) != null ? f : super.monthOfYear(); [EOL] iYear = (f = fields.year) != null ? f : super.year(); [EOL] iYearOfEra = (f = fields.yearOfEra) != null ? f : super.yearOfEra(); [EOL] iYearOfCentury = (f = fields.yearOfCentury) != null ? f : super.yearOfCentury(); [EOL] iCenturyOfEra = (f = fields.centuryOfEra) != null ? f : super.centuryOfEra(); [EOL] iEra = (f = fields.era) != null ? f : super.era(); [EOL] } [EOL] int flags; [EOL] if (iBase == null) { [EOL] flags = 0; [EOL] } else { [EOL] flags = ((iHourOfDay == iBase.hourOfDay() && iMinuteOfHour == iBase.minuteOfHour() && iSecondOfMinute == iBase.secondOfMinute() && iMillisOfSecond == iBase.millisOfSecond()) ? 1 : 0) | ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) | ((iYear == iBase.year() && iMonthOfYear == iBase.monthOfYear() && iDayOfMonth == iBase.dayOfMonth()) ? 4 : 0); [EOL] } [EOL] iBaseFlags = flags; [EOL] }
It appears that the provided input text does not contain any actual code within the method body for the `Fields` method. The method body is empty, as indicated by `{ [EOL] }`. Without any code to test, I cannot generate meaningful unit test cases. If you provide a method with a concrete implementation, I can then generate the corresponding unit test cases.
public void testCopyFieldsFrom_AllFieldsSupported() { [EOL] Chronology mockChrono = createMockChronology(true); [EOL] copyFieldsFrom(mockChrono); [EOL] assertNotNull(millis); [EOL] assertNotNull(seconds); [EOL] assertNotNull(minutes); [EOL] assertNotNull(hours); [EOL] assertNotNull(halfdays); [EOL] assertNotNull(days); [EOL] assertNotNull(weeks); [EOL] assertNotNull(weekyears); [EOL] assertNotNull(months); [EOL] assertNotNull(years); [EOL] assertNotNull(centuries); [EOL] assertNotNull(eras); [EOL] assertNotNull(millisOfSecond); [EOL] assertNotNull(millisOfDay); [EOL] assertNotNull(secondOfMinute); [EOL] assertNotNull(secondOfDay); [EOL] assertNotNull(minuteOfHour); [EOL] assertNotNull(minuteOfDay); [EOL] assertNotNull(hourOfDay); [EOL] assertNotNull(clockhourOfDay); [EOL] assertNotNull(hourOfHalfday); [EOL] assertNotNull(clockhourOfHalfday); [EOL] assertNotNull(halfdayOfDay); [EOL] assertNotNull(dayOfWeek); [EOL] assertNotNull(dayOfMonth); [EOL] assertNotNull(dayOfYear); [EOL] assertNotNull(weekOfWeekyear); [EOL] assertNotNull(weekyear); [EOL] assertNotNull(weekyearOfCentury); [EOL] assertNotNull(monthOfYear); [EOL] assertNotNull(year); [EOL] assertNotNull(yearOfEra); [EOL] assertNotNull(yearOfCentury); [EOL] assertNotNull(centuryOfEra); [EOL] assertNotNull(era); [EOL] }
public void testCopyFieldsFrom_NoFieldsSupported() { [EOL] Chronology mockChrono = createMockChronology(false); [EOL] copyFieldsFrom(mockChrono); [EOL] assertNull(millis); [EOL] assertNull(seconds); [EOL] assertNull(minutes); [EOL] assertNull(hours); [EOL] assertNull(halfdays); [EOL] assertNull(days); [EOL] assertNull(weeks); [EOL] assertNull(weekyears); [EOL] assertNull(months); [EOL] assertNull(years); [EOL] assertNull(centuries); [EOL] assertNull(eras); [EOL] assertNull(millisOfSecond); [EOL] assertNull(millisOfDay); [EOL] assertNull(secondOfMinute); [EOL] assertNull(secondOfDay); [EOL] assertNull(minuteOfHour); [EOL] assertNull(minuteOfDay); [EOL] assertNull(hourOfDay); [EOL] assertNull(clockhourOfDay); [EOL] assertNull(hourOfHalfday); [EOL] assertNull(clockhourOfHalfday); [EOL] assertNull(halfdayOfDay); [EOL] assertNull(dayOfWeek); [EOL] assertNull(dayOfMonth); [EOL] assertNull(dayOfYear); [EOL] assertNull(weekOfWeekyear); [EOL] assertNull(weekyear); [EOL] assertNull(weekyearOfCentury); [EOL] assertNull(monthOfYear); [EOL] assertNull(year); [EOL] assertNull(yearOfEra); [EOL] assertNull(yearOfCentury); [EOL] assertNull(centuryOfEra); [EOL] assertNull(era); [EOL] } [EOL] private Chronology createMockChronology(boolean supported) { [EOL] Chronology chrono = mock(Chronology.class); [EOL] DurationField mockField = supported ? mock(DurationField.class) : null; [EOL] DateTimeField mockDateTimeField = supported ? mock(DateTimeField.class) : null; [EOL] when(chrono.millis()).thenReturn(mockField); [EOL] when(chrono.seconds()).thenReturn(mockField); [EOL] return chrono; [EOL] }
public void testIsSupportedWithNullField() { [EOL] boolean result = Time.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedField() { [EOL] DurationField unsupportedField = new DurationField() { [EOL] @Override [EOL] public boolean isSupported() { [EOL] return false; [EOL] } [EOL] }; [EOL] boolean result = Time.isSupported(unsupportedField); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedField() { [EOL] DurationField supportedField = new DurationField() { [EOL] @Override [EOL] public boolean isSupported() { [EOL] return true; [EOL] } [EOL] }; [EOL] boolean result = Time.isSupported(supportedField); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithNullField() { [EOL] boolean result = ClassName.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedField() { [EOL] DateTimeField field = new UnsupportedDateTimeField(); [EOL] boolean result = ClassName.isSupported(field); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedField() { [EOL] DateTimeField field = new SupportedDateTimeField(); [EOL] boolean result = ClassName.isSupported(field); [EOL] assertTrue(result); [EOL] }
public void testStandardDaysIn_NullPeriod() { [EOL] try { [EOL] Days.standardDaysIn(null); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStandardDaysIn_ZeroDays() { [EOL] ReadablePeriod period = new Period(0, PeriodType.days()); [EOL] Days result = Days.standardDaysIn(period); [EOL] assertEquals("Expected zero days", Days.ZERO, result); [EOL] }
public void testStandardDaysIn_NonZeroDays() { [EOL] ReadablePeriod period = new Period(1, PeriodType.days()); [EOL] Days result = Days.standardDaysIn(period); [EOL] assertEquals("Expected one day", Days.ONE, result); [EOL] }
public void testStandardDaysIn_MultipleDays() { [EOL] ReadablePeriod period = new Period(7, PeriodType.days()); [EOL] Days result = Days.standardDaysIn(period); [EOL] assertEquals("Expected seven days", Days.days(7), result); [EOL] }
public void testParseDaysWithNullInput() { [EOL] Days result = parseDays(null); [EOL] assertEquals(Days.ZERO, result); [EOL] }
public void testParseDaysWithValidInput() { [EOL] Days expected = Days.days(5); [EOL] Days result = parseDays("P5D"); [EOL] assertEquals(expected, result); [EOL] }
public void testParseDaysWithInvalidInput() { [EOL] try { [EOL] parseDays("InvalidInput"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPeriodType() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] PeriodType expected = PeriodType.days(); [EOL] PeriodType actual = timePeriod.getPeriodType(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDuration_PositiveDays() { [EOL] Period period = new Period().withDays(1); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(1 * DateTimeConstants.MILLIS_PER_DAY, duration.getMillis()); [EOL] } [EOL] public void testToStandardDuration_ZeroDays() { [EOL] Period period = new Period().withDays(0); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(0, duration.getMillis()); [EOL] } [EOL] public void testToStandardDuration_NegativeDays() { [EOL] Period period = new Period().withDays(-1); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(-1 * DateTimeConstants.MILLIS_PER_DAY, duration.getMillis()); [EOL] }
public void testMultipliedBy_Positive() { [EOL] Days days = Days.days(2); [EOL] Days result = days.multipliedBy(3); [EOL] assertEquals(6, result.getDays()); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Days days = Days.days(2); [EOL] Days result = days.multipliedBy(-3); [EOL] assertEquals(-6, result.getDays()); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Days days = Days.days(2); [EOL] Days result = days.multipliedBy(0); [EOL] assertEquals(0, result.getDays()); [EOL] }
public void testMultipliedBy_One() { [EOL] Days days = Days.days(2); [EOL] Days result = days.multipliedBy(1); [EOL] assertEquals(2, result.getDays()); [EOL] }
public void testNegated_Zero() { [EOL] Days daysZero = Days.days(0); [EOL] Days result = daysZero.negated(); [EOL] assertEquals(0, result.getDays()); [EOL] }
public void testNegated_Positive() { [EOL] Days daysPositive = Days.days(5); [EOL] Days result = daysPositive.negated(); [EOL] assertEquals(-5, result.getDays()); [EOL] }
public void testNegated_Negative() { [EOL] Days daysNegative = Days.days(-3); [EOL] Days result = daysNegative.negated(); [EOL] assertEquals(3, result.getDays()); [EOL] }
public void testNegated_MaxValue() { [EOL] Days daysMax = Days.days(Integer.MAX_VALUE); [EOL] Days result = daysMax.negated(); [EOL] assertEquals(-Integer.MAX_VALUE, result.getDays()); [EOL] }
public void testNegated_MinValue() { [EOL] try { [EOL] Days daysMin = Days.days(Integer.MIN_VALUE); [EOL] daysMin.negated(); [EOL] fail("Should have thrown an ArithmeticException due to integer overflow"); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testSetWithYearWithinBounds() { [EOL] long instant = /* some instant */; [EOL] int year = /* a year within bounds */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithYearBelowBounds() { [EOL] long instant = /* some instant */; [EOL] int year = 0; // below lower bound [EOL] try { [EOL] set(instant, year); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetWithYearAboveBounds() { [EOL] long instant = /* some instant */; [EOL] int year = /* a year above upper bound */; [EOL] try { [EOL] set(instant, year); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetWithNegativeYearInBC() { [EOL] long instant = /* some instant in BC */; [EOL] int year = /* a negative year */; [EOL] long expected = /* expected instant after setting negative year */; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] MonthDay.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The date must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNonNullDate() { [EOL] Date date = new Date(2023 - 1900, 3 - 1, 14); // April 14, 2023 [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertNotNull(monthDay); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(14, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_Object() { [EOL] Object instant = new LocalDate(2023, 4, 15).toDate(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] } [EOL] public void testMonthDay_DefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] } [EOL] public void testMonthDay_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] } [EOL] public void testMonthDay_Long() { [EOL] long instant = new LocalDate(2023, 4, 15).toDateTimeAtStartOfDay().getMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] } [EOL] public void testMonthDay_LongChronology() { [EOL] long instant = new LocalDate(2023, 4, 15).toDateTimeAtStartOfDay().getMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] } [EOL] public void testMonthDay_ObjectChronology() { [EOL] Object instant = new LocalDate(2023, 4, 15).toDate(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] } [EOL] public void testMonthDay_IntInt() { [EOL] MonthDay monthDay = new MonthDay(4, 15); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] } [EOL] public void testMonthDay_IntIntChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(4, 15, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDay_Now() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] } [EOL] public void testMonthDay_NowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] assertEquals(zone, monthDay.getChronology().getZone()); [EOL] } [EOL] public void testMonthDay_NowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDay_ParseString() { [EOL] String str = "04-15"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] } [EOL] public void testMonthDay_ParseStringFormatter() { [EOL] String str = "04-15"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("MM-dd"); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_FromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.APRIL); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 15); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] } [EOL] public void testMonthDay_FromDateFields() { [EOL] Date date = new GregorianCalendar(2023, Calendar.APRIL, 15).getTime(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayIntInt() { [EOL] MonthDay monthDay = new MonthDay(1, 1); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayLong() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(currentTimeMillis); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTimeInMillis(currentTimeMillis); [EOL] int month = cal.get(Calendar.MONTH) + 1; [EOL] int day = cal.get(Calendar.DAY_OF_MONTH); [EOL] assertEquals(month, monthDay.getMonthOfYear()); [EOL] assertEquals(day, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayLongChronology() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(currentTimeMillis, chronology); [EOL] Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); [EOL] cal.setTimeInMillis(currentTimeMillis); [EOL] int month = cal.get(Calendar.MONTH) + 1; [EOL] int day = cal.get(Calendar.DAY_OF_MONTH); [EOL] assertEquals(month, monthDay.getMonthOfYear()); [EOL] assertEquals(day, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayObject() { [EOL] LocalDate localDate = new LocalDate(); [EOL] MonthDay monthDay = new MonthDay(localDate); [EOL] assertEquals(localDate.getMonthOfYear(), monthDay.getMonthOfYear()); [EOL] assertEquals(localDate.getDayOfMonth(), monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayObjectChronology() { [EOL] LocalDate localDate = new LocalDate(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(localDate, chronology); [EOL] assertEquals(localDate.getMonthOfYear(), monthDay.getMonthOfYear()); [EOL] assertEquals(localDate.getDayOfMonth(), monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayNow() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] LocalDate localDate = new LocalDate(); [EOL] assertEquals(localDate.getMonthOfYear(), monthDay.getMonthOfYear()); [EOL] assertEquals(localDate.getDayOfMonth(), monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayNowDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] LocalDate localDate = new LocalDate(zone); [EOL] assertEquals(localDate.getMonthOfYear(), monthDay.getMonthOfYear()); [EOL] assertEquals(localDate.getDayOfMonth(), monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] LocalDate localDate = new LocalDate(chronology); [EOL] assertEquals(localDate.getMonthOfYear(), monthDay.getMonthOfYear()); [EOL] assertEquals(localDate.getDayOfMonth(), monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayParseString() { [EOL] String str = "--12-03"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertEquals(12, monthDay.getMonthOfYear()); [EOL] assertEquals(3, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayParseStringDateTimeFormatter() { [EOL] String str = "--12-03"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("--MM-dd"); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertEquals(12, monthDay.getMonthOfYear()); [EOL] assertEquals(3, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDay() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertEquals(zone, monthDay.getChronology().getZone()); [EOL] }
public void testMonthDayChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(new MonthDay(), monthDay); [EOL] }
public void testMonthDayLongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(new MonthDay(chronology), monthDay); [EOL] }
public void testMonthDayObject() { [EOL] Object instant = new Date(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(new MonthDay(), monthDay); [EOL] }
public void testMonthDayObjectChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(new MonthDay(chronology), monthDay); [EOL] }
public void testMonthDayIntInt() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayNow() { [EOL] MonthDay expected = new MonthDay(); [EOL] MonthDay actual = MonthDay.now(); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthDayNowDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay expected = new MonthDay(zone); [EOL] MonthDay actual = MonthDay.now(zone); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthDayNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay expected = new MonthDay(chronology); [EOL] MonthDay actual = MonthDay.now(chronology); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthDayParseString() { [EOL] String str = "--06-15"; [EOL] MonthDay expected = new MonthDay(6, 15); [EOL] MonthDay actual = MonthDay.parse(str); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthDayParseStringDateTimeFormatter() { [EOL] String str = "--06-15"; [EOL] DateTimeFormatter formatter = ISODateTimeFormat.monthDay(); [EOL] MonthDay expected = new MonthDay(6, 15); [EOL] MonthDay actual = MonthDay.parse(str, formatter); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, 5); // June is 5 (0-based) [EOL] calendar.set(Calendar.DAY_OF_MONTH, 15); [EOL] MonthDay expected = new MonthDay(6, 15); [EOL] MonthDay actual = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthDayFromDateFields() { [EOL] Date date = new Date(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] int month = calendar.get(Calendar.MONTH) + 1; // Convert to 1-based [EOL] int day = calendar.get(Calendar.DAY_OF_MONTH); [EOL] MonthDay expected = new MonthDay(month, day); [EOL] MonthDay actual = MonthDay.fromDateFields(date); [EOL] assertEquals(expected, actual); [EOL] }
public int size() { [EOL] return 2; [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case MONTH_OF_YEAR: [EOL] return chrono.monthOfYear(); [EOL] case DAY_OF_MONTH: [EOL] return chrono.dayOfMonth(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testGetFieldType_ValidIndex() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] DateTimeFieldType fieldType = monthDay.getFieldType(0); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), fieldType); [EOL] }
public void testGetFieldType_InvalidIndex() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] try { [EOL] monthDay.getFieldType(2); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testMonthDay_DefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_ZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_ChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_InstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_InstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_ObjectConstructor() { [EOL] Object instant = new LocalDate(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_ObjectChronologyConstructor() { [EOL] Object instant = new LocalDate(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_IntIntConstructor() { [EOL] MonthDay monthDay = new MonthDay(1, 1); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_IntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(1, 1, chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Now() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_NowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_NowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_ParseString() { [EOL] String str = "--12-03"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_ParseStringFormatter() { [EOL] String str = "--12-03"; [EOL] DateTimeFormatter formatter = ISODateTimeFormat.monthDay(); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_FromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.DECEMBER); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 3); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_FromDateFields() { [EOL] Date date = new GregorianCalendar(2020, Calendar.DECEMBER, 3).getTime(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertNotNull(monthDay); [EOL] }
public void testSize() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertEquals(2, monthDay.size()); [EOL] }
public void testGetField_ValidIndex() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = monthDay.getField(0, chronology); [EOL] assertNotNull(field); [EOL] }
public void testGetField_InvalidIndex() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] monthDay.getField(2, chronology); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetFieldTypes() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] DateTimeFieldType[] fieldTypes = monthDay.getFieldTypes(); [EOL] assertNotNull(fieldTypes); [EOL] assertEquals(2, fieldTypes.length); [EOL] }
public void testWithChronologyRetainFields() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.withChronologyRetainFields(chronology); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testWithField() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.withField(DateTimeFieldType.dayOfMonth(), 1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testWithFieldAdded() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testWithPeriodAdded() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Period period = new Period().withDays(1); [EOL] MonthDay newMonthDay = monthDay.withPeriodAdded(period, 1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testPlus_ReadablePeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Period period = new Period().withMonths(1); [EOL] MonthDay newMonthDay = monthDay.plus(period); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testPlusMonths() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.plusMonths(1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testPlusDays() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.plusDays(1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testMinus_ReadablePeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] Period period = new Period().withMonths(1); [EOL] MonthDay newMonthDay = monthDay.minus(period); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testMinusMonths() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.minusMonths(1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testMinusDays() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.minusDays(1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testToLocalDate() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] LocalDate localDate = monthDay.toLocalDate(2020); [EOL] assertNotNull(localDate); [EOL] }
public void testGetMonthOfYear() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int monthOfYear = monthDay.getMonthOfYear(); [EOL] assertTrue(monthOfYear >= 1 && monthOfYear <= 12); [EOL] }
public void testGetDayOfMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int dayOfMonth = monthDay.getDayOfMonth(); [EOL] assertTrue(dayOfMonth >= 1 && dayOfMonth <= 31); [EOL] }
public void testWithMonthOfYear() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.withMonthOfYear(1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testWithDayOfMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.withDayOfMonth(1); [EOL] assertNotNull(newMonthDay); [EOL] }
public void testProperty() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay.Property property = monthDay.property(DateTimeFieldType.dayOfMonth()); [EOL] assertNotNull(property); [EOL] }
public void testMonthOfYear() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay.Property property = monthDay.monthOfYear(); [EOL] assertNotNull(property); [EOL] }
public void testDayOfMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay.Property property = monthDay.dayOfMonth(); [EOL] assertNotNull(property); [EOL] }
public void testToString_Default() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String str = monthDay.toString(); [EOL] assertNotNull(str); [EOL] }
public void testToString_Pattern() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String pattern = "--MM-dd"; [EOL] String str = monthDay.toString(pattern); [EOL] assertNotNull(str); [EOL] }
public void testToString_PatternLocale() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String pattern = "--MM-dd"; [EOL] Locale locale = Locale.US; [EOL] String str = monthDay.toString(pattern, locale); [EOL] assertNotNull(str); [EOL] }
public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (amount == 0) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).add(this, index, newValues, amount); [EOL] return new MonthDay(this, newValues); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testPlusDays_Normal() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay expected = new MonthDay(5, 2); // May 2nd [EOL] MonthDay actual = original.plusDays(1); [EOL] assertEquals(expected, actual); [EOL] }
public void testPlusDays_Overflow() { [EOL] MonthDay original = new MonthDay(5, 31); // May 31st [EOL] MonthDay expected = new MonthDay(6, 1); // June 1st [EOL] MonthDay actual = original.plusDays(1); [EOL] assertEquals(expected, actual); [EOL] }
public void testPlusDays_Underflow() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay expected = new MonthDay(4, 30); // April 30th [EOL] MonthDay actual = original.plusDays(-1); [EOL] assertEquals(expected, actual); [EOL] }
public void testPlusDays_YearBoundary() { [EOL] MonthDay original = new MonthDay(12, 31); // December 31st [EOL] MonthDay expected = new MonthDay(1, 1); // January 1st [EOL] MonthDay actual = original.plusDays(1); [EOL] assertEquals(expected, actual); [EOL] }
public void testPlusDays_LeapYear() { [EOL] MonthDay original = new MonthDay(2, 28); // February 28th [EOL] MonthDay expected = new MonthDay(2, 29); // February 29th [EOL] MonthDay actual = original.plusDays(1); [EOL] assertEquals(expected, actual); [EOL] }
public void testPlusDays_InvalidInput() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] try { [EOL] original.plusDays(Integer.MAX_VALUE); [EOL] fail("Should have thrown an exception due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testNow() { [EOL] LocalDateTime result = Time.now(); [EOL] assertNotNull(result); [EOL] }
public void testFromCalendarFieldsWithNullCalendar() { [EOL] try { [EOL] LocalDateTime.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFieldsWithGregorianCalendarAD() { [EOL] Calendar calendar = new GregorianCalendar(2023, Calendar.MARCH, 25, 15, 40, 30); [EOL] calendar.set(Calendar.MILLISECOND, 123); [EOL] LocalDateTime dateTime = LocalDateTime.fromCalendarFields(calendar); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(25, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(40, dateTime.getMinuteOfHour()); [EOL] assertEquals(30, dateTime.getSecondOfMinute()); [EOL] assertEquals(123, dateTime.getMillisOfSecond()); [EOL] }
public void testFromCalendarFieldsWithGregorianCalendarBC() { [EOL] Calendar calendar = new GregorianCalendar(); [EOL] calendar.set(Calendar.ERA, GregorianCalendar.BC); [EOL] calendar.set(Calendar.YEAR, 2023); [EOL] calendar.set(Calendar.MONTH, Calendar.MARCH); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 25); [EOL] calendar.set(Calendar.HOUR_OF_DAY, 15); [EOL] calendar.set(Calendar.MINUTE, 40); [EOL] calendar.set(Calendar.SECOND, 30); [EOL] calendar.set(Calendar.MILLISECOND, 123); [EOL] LocalDateTime dateTime = LocalDateTime.fromCalendarFields(calendar); [EOL] assertEquals(1 - 2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(25, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(40, dateTime.getMinuteOfHour()); [EOL] assertEquals(30, dateTime.getSecondOfMinute()); [EOL] assertEquals(123, dateTime.getMillisOfSecond()); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalDateTime.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNegativeTime() { [EOL] Date date = new Date(-1); [EOL] LocalDateTime result = LocalDateTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] }
public void testFromDateFieldsWithPositiveTime() { [EOL] Date date = new Date(1000000000L); // Use a positive time [EOL] LocalDateTime result = LocalDateTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(2001, result.getYear()); [EOL] assertEquals(9, result.getMonthOfYear()); [EOL] assertEquals(9, result.getDayOfMonth()); [EOL] assertEquals(1, result.getHourOfDay()); [EOL] assertEquals(46, result.getMinuteOfHour()); [EOL] assertEquals(40, result.getSecondOfMinute()); [EOL] assertEquals(0, result.getMillisOfSecond()); // Assuming date.getTime() % 1000 is 0 for this timestamp [EOL] }
public void testLocalDateTimeConstructor() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] }
public void testLocalDateTimeWithNullChronology() { [EOL] try { [EOL] new LocalDateTime((Chronology) null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateTimeWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalDateTime localDateTime = new LocalDateTime(chronology); [EOL] assertNotNull("LocalDateTime should not be null with non-null chronology", localDateTime); [EOL] assertEquals("Chronology should match the one passed in constructor", chronology, localDateTime.getChronology()); [EOL] }
public void testLocalDateTimeWithValidInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] LocalDateTime dateTime = new LocalDateTime(instant); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.toDate().getTime()); [EOL] }

public void testLocalDateTimeWithValidParameters() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] assertNotNull(dateTime); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(4, dateTime.getMonthOfYear()); [EOL] assertEquals(1, dateTime.getDayOfMonth()); [EOL] assertEquals(12, dateTime.getHourOfDay()); [EOL] assertEquals(0, dateTime.getMinuteOfHour()); [EOL] assertEquals(0, dateTime.getSecondOfMinute()); [EOL] assertEquals(0, dateTime.getMillisOfSecond()); [EOL] }
public void testLocalDateTimeWithExtremeValues() { [EOL] LocalDateTime dateTime = new LocalDateTime(Integer.MAX_VALUE, 12, 31, 23, 59, 59, 999); [EOL] assertNotNull(dateTime); [EOL] assertEquals(Integer.MAX_VALUE, dateTime.getYear()); [EOL] assertEquals(12, dateTime.getMonthOfYear()); [EOL] assertEquals(31, dateTime.getDayOfMonth()); [EOL] assertEquals(23, dateTime.getHourOfDay()); [EOL] assertEquals(59, dateTime.getMinuteOfHour()); [EOL] assertEquals(59, dateTime.getSecondOfMinute()); [EOL] assertEquals(999, dateTime.getMillisOfSecond()); [EOL] }
public void testLocalDateTimeWithValidInput() { [EOL] int year = 2020; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalDateTime dateTime = new LocalDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] assertEquals(chronology.withUTC(), dateTime.getChronology()); [EOL] }
public void testLocalDateTimeWithNullChronology() { [EOL] int year = 2020; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] Chronology chronology = null; [EOL] LocalDateTime dateTime = new LocalDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] assertNotNull(dateTime.getChronology()); [EOL] assertTrue(dateTime.getChronology() instanceof ISOChronology); [EOL] }
public void testGetLocalMillis() { [EOL] Time time = new Time(123456789L); // Assuming there is a constructor that sets iLocalMillis [EOL] long expected = 123456789L; [EOL] long actual = time.getLocalMillis(); [EOL] assertEquals(expected, actual); [EOL] }
public void testEquals_SameObject() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] boolean result = dateTime.equals(dateTime); [EOL] assertTrue(result); [EOL] }
public void testEquals_DifferentObjectSameValues() { [EOL] LocalDateTime dateTime1 = new LocalDateTime(0L, new ChronologyStub(true)); [EOL] LocalDateTime dateTime2 = new LocalDateTime(0L, new ChronologyStub(true)); [EOL] boolean result = dateTime1.equals(dateTime2); [EOL] assertTrue(result); [EOL] }
public void testEquals_DifferentObjectDifferentChronology() { [EOL] LocalDateTime dateTime1 = new LocalDateTime(0L, new ChronologyStub(true)); [EOL] LocalDateTime dateTime2 = new LocalDateTime(0L, new ChronologyStub(false)); [EOL] boolean result = dateTime1.equals(dateTime2); [EOL] assertFalse(result); [EOL] }
public void testEquals_DifferentObjectDifferentMillis() { [EOL] LocalDateTime dateTime1 = new LocalDateTime(0L, new ChronologyStub(true)); [EOL] LocalDateTime dateTime2 = new LocalDateTime(1L, new ChronologyStub(true)); [EOL] boolean result = dateTime1.equals(dateTime2); [EOL] assertFalse(result); [EOL] }
public void testEquals_NonLocalDateTime() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] Object nonDateTime = new Object(); [EOL] boolean result = dateTime.equals(nonDateTime); [EOL] assertFalse(result); [EOL] }
public void testEquals_Null() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] boolean result = dateTime.equals(null); [EOL] assertFalse(result); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial sameInstance = createLocalDateTime(); [EOL] int result = sameInstance.compareTo(sameInstance); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeEqualChronology() { [EOL] LocalDateTime first = createLocalDateTime(); [EOL] LocalDateTime second = createLocalDateTime(); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeDifferentChronology() { [EOL] LocalDateTime first = createLocalDateTime(); [EOL] LocalDateTime second = createLocalDateTimeWithDifferentChronology(); [EOL] int result = first.compareTo(second); [EOL] assertNotEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeLess() { [EOL] LocalDateTime first = createLocalDateTime(); [EOL] LocalDateTime second = createLocalDateTimeLater(); [EOL] int result = first.compareTo(second); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeGreater() { [EOL] LocalDateTime first = createLocalDateTimeLater(); [EOL] LocalDateTime second = createLocalDateTime(); [EOL] int result = first.compareTo(second); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCompareTo_NonLocalDateTime() { [EOL] LocalDateTime localDateTime = createLocalDateTime(); [EOL] ReadablePartial nonLocalDateTime = createNonLocalDateTime(); [EOL] int result = localDateTime.compareTo(nonLocalDateTime); [EOL] }
private LocalDateTime createLocalDateTime() { [EOL] } [EOL] private LocalDateTime createLocalDateTimeLater() { [EOL] } [EOL] private LocalDateTime createLocalDateTimeWithDifferentChronology() { [EOL] } [EOL] private ReadablePartial createNonLocalDateTime() { [EOL] }
public void testToDate() { [EOL] MyTimeClass myTime = new MyTimeClass(2023, 3, 14, 15, 30, 45, 500); // Year, Month, Day, Hour, Minute, Second, Millis [EOL] Date result = myTime.toDate(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 14, 15, 30, 45); // Calendar month is 0-based [EOL] calendar.set(Calendar.MILLISECOND, 500); [EOL] Date expected = calendar.getTime(); [EOL] assertEquals(expected, result); [EOL] }
public void testToDateWithDstTransition() { [EOL] MyTimeClass myTime = new MyTimeClass(2023, 10, 1, 2, 30, 0, 0); // Year, Month, Day, Hour, Minute, Second, Millis [EOL] Date result = myTime.toDate(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.NOVEMBER, 1, 2, 30, 0); // Calendar month is 0-based [EOL] calendar.set(Calendar.MILLISECOND, 0); [EOL] if (!calendar.getTimeZone().inDaylightTime(result)) { [EOL] calendar.add(Calendar.HOUR_OF_DAY, -1); [EOL] } [EOL] Date expected = calendar.getTime(); [EOL] assertEquals(expected, result); [EOL] }
public void testCorrectDstTransitionBefore() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("America/New_York"); [EOL] LocalDateTime localDateTime = LocalDateTime.now(); [EOL] Date date = Date.from(localDateTime.minusDays(1).atZone(ZoneId.systemDefault()).toInstant()); [EOL] Date result = correctDstTransition(date, timeZone); [EOL] Calendar calendar = Calendar.getInstance(timeZone); [EOL] calendar.setTime(result); [EOL] LocalDateTime resultCheck = LocalDateTime.fromCalendarFields(calendar); [EOL] assertTrue(resultCheck.isAfter(localDateTime)); [EOL] }
public void testCorrectDstTransitionEquals() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("America/New_York"); [EOL] LocalDateTime localDateTime = LocalDateTime.now(); [EOL] Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); [EOL] Date result = correctDstTransition(date, timeZone); [EOL] Calendar calendar = Calendar.getInstance(timeZone); [EOL] calendar.setTime(result); [EOL] LocalDateTime resultCheck = LocalDateTime.fromCalendarFields(calendar); [EOL] assertTrue(resultCheck.equals(localDateTime) || resultCheck.isAfter(localDateTime)); [EOL] }
public void testCorrectDstTransitionDuring() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("America/New_York"); [EOL] LocalDateTime localDateTime = LocalDateTime.now(); [EOL] Date date = Date.from(localDateTime.plusHours(1).atZone(ZoneId.systemDefault()).toInstant()); [EOL] Date result = correctDstTransition(date, timeZone); [EOL] Calendar calendar = Calendar.getInstance(timeZone); [EOL] calendar.setTime(result); [EOL] LocalDateTime resultCheck = LocalDateTime.fromCalendarFields(calendar); [EOL] assertTrue(resultCheck.isBefore(localDateTime.plusHours(1))); [EOL] }
public void testWithField_NullFieldType() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] try { [EOL] dateTime.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_ValidField() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] int value = 2023; [EOL] LocalDateTime updatedDateTime = dateTime.withField(fieldType, value); [EOL] assertEquals(value, updatedDateTime.getYear()); [EOL] }
public void testWithFieldAdded_NullFieldType_ThrowsIllegalArgumentException() { [EOL] LocalDateTime testDateTime = LocalDateTime.now(); [EOL] try { [EOL] testDateTime.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount_ReturnsSame() { [EOL] LocalDateTime testDateTime = LocalDateTime.now(); [EOL] LocalDateTime resultDateTime = testDateTime.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("Expected same instance of LocalDateTime when amount is 0", testDateTime, resultDateTime); [EOL] }
public void testWithFieldAdded_NonZeroAmount_ReturnsNew() { [EOL] LocalDateTime testDateTime = LocalDateTime.now(); [EOL] LocalDateTime resultDateTime = testDateTime.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("Expected different instance of LocalDateTime when amount is non-zero", testDateTime, resultDateTime); [EOL] assertTrue("Expected the time to be after the original time", resultDateTime.isAfter(testDateTime)); [EOL] }
public void testPlusHours_ZeroHours() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusHours(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testPlusHours_PositiveHours() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusHours(5); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.plusHours(5), result); [EOL] }
public void testPlusHours_NegativeHours() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusHours(-5); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.plusHours(-5), result); [EOL] }
public void testPlusMillis_Zero() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime sameDateTime = dateTime.plusMillis(0); [EOL] assertEquals(dateTime, sameDateTime); [EOL] }
public void testPlusMillis_Positive() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime newDateTime = dateTime.plusMillis(500); [EOL] assertNotEquals(dateTime, newDateTime); [EOL] assertEquals(dateTime.plus(Duration.ofMillis(500)), newDateTime); [EOL] }
public void testPlusMillis_Negative() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime newDateTime = dateTime.plusMillis(-500); [EOL] assertNotEquals(dateTime, newDateTime); [EOL] assertEquals(dateTime.minus(Duration.ofMillis(500)), newDateTime); [EOL] }
public void testMinusMonths_ZeroMonths() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMonths(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusMonths_NegativeMonths() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMonths(-1); [EOL] assertNotEquals(dateTime, result); [EOL] }
public void testMinusMonths_PositiveMonths() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMonths(1); [EOL] assertNotEquals(dateTime, result); [EOL] }
public void testMinusWeeks_ZeroWeeks() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusWeeks(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusWeeks_PositiveWeeks() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusWeeks(1); [EOL] assertNotEquals(dateTime, result); [EOL] assertTrue(result.isBefore(dateTime)); [EOL] }
public void testMinusWeeks_NegativeWeeks() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusWeeks(-1); [EOL] assertNotEquals(dateTime, result); [EOL] assertTrue(result.isAfter(dateTime)); [EOL] }
public void testMinusHours_Zero() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusHours(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusHours_Positive() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusHours(5); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.minusHours(1).minusHours(4), result); [EOL] }
public void testMinusHours_Negative() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusHours(-5); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.plusHours(5), result); [EOL] }
public int getYear() { [EOL] return getChronology().year().get(getLocalMillis()); [EOL] }
public int getMonthOfYear() { [EOL] return getChronology().monthOfYear().get(getLocalMillis()); [EOL] }
public int getDayOfMonth() { [EOL] return getChronology().dayOfMonth().get(getLocalMillis()); [EOL] }
public int getHourOfDay() { [EOL] return getChronology().hourOfDay().get(getLocalMillis()); [EOL] }
public void testGetMinuteOfHour() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockDateTimeField = Mockito.mock(DateTimeField.class); [EOL] long localMillis = System.currentTimeMillis(); [EOL] int expectedMinute = new DateTime(localMillis).getMinuteOfHour(); [EOL] Mockito.when(mockChronology.minuteOfHour()).thenReturn(mockDateTimeField); [EOL] Mockito.when(mockDateTimeField.get(localMillis)).thenReturn(expectedMinute); [EOL] Time time = new Time(mockChronology, localMillis); [EOL] int actualMinute = time.getMinuteOfHour(); [EOL] assertEquals(expectedMinute, actualMinute); [EOL] }
public void testGetSecondOfMinute() { [EOL] long localMillis = System.currentTimeMillis(); [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockDateTimeField = Mockito.mock(DateTimeField.class); [EOL] when(mockChronology.secondOfMinute()).thenReturn(mockDateTimeField); [EOL] when(mockDateTimeField.get(localMillis)).thenReturn(30); // Assuming 30 is the second of the minute [EOL] Time time = new Time(mockChronology, localMillis); [EOL] int secondOfMinute = time.getSecondOfMinute(); [EOL] assertEquals(30, secondOfMinute); [EOL] }
public void testGetMillisOfSecond() { [EOL] long localMillis = 123456789L; // Example timestamp [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Time time = new Time(chronology, localMillis); [EOL] int millisOfSecond = time.getMillisOfSecond(); [EOL] int expectedMillisOfSecond = chronology.millisOfSecond().get(localMillis); [EOL] assertEquals(expectedMillisOfSecond, millisOfSecond); [EOL] }
public void testDayOfMonth() { [EOL] LocalDate date = new LocalDate(); [EOL] Property property = date.dayOfMonth(); [EOL] assertNotNull(property); [EOL] assertEquals(date.getChronology().dayOfMonth(), property.getField()); [EOL] assertEquals(date, property.getLocalDate()); [EOL] }
public void testMinuteOfHour() { [EOL] Time time = new Time(); [EOL] Property property = time.minuteOfHour(); [EOL] assertNotNull(property); [EOL] assertEquals(property.getField(), time.getChronology().minuteOfHour()); [EOL] }
public void testSecondOfMinute() { [EOL] Time time = new Time(); [EOL] Property property = time.secondOfMinute(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().secondOfMinute(), property.getField()); [EOL] }
public void testGetLocalDateTime() { [EOL] LocalDateTime expected = LocalDateTime.now(); [EOL] Time time = new Time(expected); [EOL] LocalDateTime actual = time.getLocalDateTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] LocalDateTime initialDateTime = LocalDateTime.now(); [EOL] DateTimeField field = initialDateTime.getField(); // Assuming getField() is a method to get a field relevant for set operation [EOL] String validText = "someValidText"; // Replace with actual text that can be set on the field [EOL] Locale locale = Locale.ENGLISH; // Assuming English locale is relevant for the text [EOL] LocalDateTime updatedDateTime = initialDateTime.setCopy(validText, locale); [EOL] String expectedValue = field.getAsString(updatedDateTime.getLocalMillis(), locale); [EOL] assertEquals("Field should be updated with the provided text", expectedValue, validText); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] LocalDateTime initialDateTime = LocalDateTime.now(); [EOL] DateTimeField field = initialDateTime.getField(); // Assuming getField() is a method to get a field relevant for set operation [EOL] String invalidText = "invalidText"; // Replace with text that is invalid for the field [EOL] Locale locale = Locale.ENGLISH; // Assuming English locale is relevant for the text [EOL] try { [EOL] initialDateTime.setCopy(invalidText, locale); [EOL] fail("Should have thrown IllegalArgumentException for invalid text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullText() { [EOL] LocalDateTime initialDateTime = LocalDateTime.now(); [EOL] Locale locale = Locale.ENGLISH; [EOL] try { [EOL] initialDateTime.setCopy(null, locale); [EOL] fail("Should have thrown IllegalArgumentException for null text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] LocalDateTime initialDateTime = LocalDateTime.now(); [EOL] DateTimeField field = initialDateTime.getField(); // Assuming getField() is a method to get a field relevant for set operation [EOL] String validText = "someValidText"; // Replace with actual text that can be set on the field [EOL] try { [EOL] initialDateTime.setCopy(validText, null); [EOL] fail("Should have thrown IllegalArgumentException for null locale"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNonNullText() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] String newText = "2023-01-01T10:15:30"; [EOL] LocalDateTime updatedDateTime = dateTime.setCopy(newText); [EOL] assertNotNull(updatedDateTime); [EOL] assertNotEquals(dateTime, updatedDateTime); [EOL] }
public void testSetCopyWithNullText() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime updatedDateTime = dateTime.setCopy(null); [EOL] assertNotNull(updatedDateTime); [EOL] assertEquals(dateTime, updatedDateTime); [EOL] }
public void testCalendarConverterConstructor() { [EOL] CalendarConverter converter = new CalendarConverter(); [EOL] assertNotNull(converter); [EOL] }
public void testDecoratedDurationFieldWithNullField() { [EOL] try { [EOL] new DecoratedDurationField(null, DurationFieldType.seconds()); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testDecoratedDurationFieldWithUnsupportedField() { [EOL] DurationField field = new UnsupportedDurationField(DurationFieldType.seconds()); [EOL] try { [EOL] new DecoratedDurationField(field, DurationFieldType.seconds()); [EOL] fail("Should have thrown IllegalArgumentException for unsupported field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The field must be supported", ex.getMessage()); [EOL] } [EOL] }
public void testDecoratedDurationFieldWithSupportedField() { [EOL] DurationField field = new PreciseDurationField(DurationFieldType.seconds(), 1000); [EOL] DecoratedDurationField decoratedField = new DecoratedDurationField(field, DurationFieldType.seconds()); [EOL] assertNotNull(decoratedField); [EOL] assertEquals(field, decoratedField.getField()); [EOL] }
public void testGetZoneWithUTC() { [EOL] DateTimeZone result = getZone("UTC"); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testGetZoneWithLowerCaseUtc() { [EOL] DateTimeZone result = getZone("utc"); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testGetZoneWithNonUTC() { [EOL] DateTimeZone result = getZone("PST"); [EOL] assertNull(result); [EOL] }
public void testDateTimeFormatterWithAllParameters() { [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean offsetParsed = true; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone zone = DateTimeZone.forID("UTC"); [EOL] Integer pivotYear = 2000; [EOL] int defaultYear = 1990; [EOL] DateTimeFormatter formatter = new DateTimeFormatter(printer, parser, locale, offsetParsed, chrono, zone, pivotYear, defaultYear); [EOL] assertNotNull(formatter); [EOL] assertSame(printer, formatter.getPrinter()); [EOL] assertSame(parser, formatter.getParser()); [EOL] assertEquals(locale, formatter.getLocale()); [EOL] assertEquals(offsetParsed, formatter.isOffsetParsed()); [EOL] assertSame(chrono, formatter.getChronolgy()); [EOL] assertSame(zone, formatter.getZone()); [EOL] assertEquals(pivotYear, formatter.getPivotYear()); [EOL] assertEquals(defaultYear, formatter.getDefaultYear()); [EOL] }
public void testDateTimeFormatterWithNullParameters() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, null, 1970); [EOL] assertNotNull(formatter); [EOL] assertNull(formatter.getPrinter()); [EOL] assertNull(formatter.getParser()); [EOL] assertNull(formatter.getLocale()); [EOL] assertFalse(formatter.isOffsetParsed()); [EOL] assertNull(formatter.getChronolgy()); [EOL] assertNull(formatter.getZone()); [EOL] assertNull(formatter.getPivotYear()); [EOL] assertEquals(1970, formatter.getDefaultYear()); [EOL] }
public void testWithOffsetParsed_WhenOffsetParsedIsTrue_ShouldReturnSameInstance() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, true, null, null, null, 0); [EOL] DateTimeFormatter result = formatter.withOffsetParsed(); [EOL] assertSame(formatter, result); [EOL] }
public void testWithOffsetParsed_WhenOffsetParsedIsFalse_ShouldReturnNewInstance() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, null, 0); [EOL] DateTimeFormatter result = formatter.withOffsetParsed(); [EOL] assertNotNull(result); [EOL] assertNotSame(formatter, result); [EOL] }
public void testIsOffsetParsedTrue() { [EOL] Time time = new Time(); [EOL] time.iOffsetParsed = true; [EOL] assertTrue(time.isOffsetParsed()); [EOL] }
public void testIsOffsetParsedFalse() { [EOL] Time time = new Time(); [EOL] time.iOffsetParsed = false; [EOL] assertFalse(time.isOffsetParsed()); [EOL] }
public void testWithChronology_SameChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, chrono, null, null, 2000); [EOL] DateTimeFormatter result = formatter.withChronology(chrono); [EOL] assertSame(formatter, result); [EOL] }
public void testWithChronology_DifferentChronology() { [EOL] Chronology initialChrono = ISOChronology.getInstance(); [EOL] Chronology newChrono = GregorianChronology.getInstance(); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, initialChrono, null, null, 2000); [EOL] DateTimeFormatter result = formatter.withChronology(newChrono); [EOL] assertNotSame(formatter, result); [EOL] assertSame(newChrono, result.getChronolgy()); [EOL] }
public void testWithZone_SameZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, null, zone, null, 0); [EOL] DateTimeFormatter result = formatter.withZone(zone); [EOL] assertSame(formatter, result); [EOL] }
public void testWithZone_DifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.UTC; [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, null, originalZone, null, 0); [EOL] DateTimeFormatter result = formatter.withZone(newZone); [EOL] assertNotNull(result); [EOL] assertNotSame(formatter, result); [EOL] assertEquals(newZone, result.getZone()); [EOL] }
public DateTimeZone getZone() { [EOL] return iZone; [EOL] }
public void testWithPivotYearSameAsCurrent() { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null, null, false, null, null, 2000, 2000); [EOL] DateTimeFormatter result = dtf.withPivotYear(2000); [EOL] assertSame(dtf, result); [EOL] }
public void testWithPivotYearDifferentThanCurrent() { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null, null, false, null, null, 2000, 2000); [EOL] DateTimeFormatter result = dtf.withPivotYear(2021); [EOL] assertNotSame(dtf, result); [EOL] assertEquals(2021, result.getPivotYear().intValue()); [EOL] }
public void testWithPivotYearNullWhenCurrentIsNull() { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null, null, false, null, null, null, 2000); [EOL] DateTimeFormatter result = dtf.withPivotYear(null); [EOL] assertSame(dtf, result); [EOL] }
public void testWithPivotYearNonNullWhenCurrentIsNull() { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null, null, false, null, null, null, 2000); [EOL] DateTimeFormatter result = dtf.withPivotYear(2021); [EOL] assertNotSame(dtf, result); [EOL] assertEquals(2021, result.getPivotYear().intValue()); [EOL] }
public void testWithPivotYear_ValidYear() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); [EOL] DateTimeFormatter updatedFormatter = formatter.withPivotYear(2000); [EOL] assertNotNull(updatedFormatter); [EOL] assertEquals(Integer.valueOf(2000), updatedFormatter.getPivotYear()); [EOL] }
public void testWithPivotYear_NullYear() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); [EOL] DateTimeFormatter updatedFormatter = formatter.withPivotYear(null); [EOL] assertNotNull(updatedFormatter); [EOL] assertNull(updatedFormatter.getPivotYear()); [EOL] }
public void testPrintToWithNonNullValues() throws IOException { [EOL] StringBuilder sb = new StringBuilder(); [EOL] ReadableInstant instant = new DateTime(); [EOL] printTo(sb, instant); [EOL] assertEquals(sb.toString(), print(instant)); [EOL] }
public void testPrintToWithNullAppendable() throws IOException { [EOL] ReadableInstant instant = new DateTime(); [EOL] try { [EOL] printTo(null, instant); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintToWithNullInstant() throws IOException { [EOL] StringBuilder sb = new StringBuilder(); [EOL] try { [EOL] printTo(sb, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintToWithValidInstantAndAppendable() throws IOException { [EOL] Time time = new Time(); [EOL] StringBuilder sb = new StringBuilder(); [EOL] long instant = System.currentTimeMillis(); [EOL] time.printTo(sb, instant); [EOL] String expected = time.print(instant); [EOL] assertEquals(expected, sb.toString()); [EOL] }
public void testPrintToWithNullAppendable() { [EOL] Time time = new Time(); [EOL] long instant = System.currentTimeMillis(); [EOL] try { [EOL] time.printTo(null, instant); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPrintToWithNullPartial() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = null; [EOL] try { [EOL] printTo(buf, partial); [EOL] fail("Should have thrown IllegalArgumentException for null partial"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullPartial() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial partial = new MockReadablePartial(); [EOL] printTo(buf, partial); [EOL] assertNotNull("Buffer should not be null", buf.toString()); [EOL] assertFalse("Buffer should not be empty", buf.toString().isEmpty()); [EOL] }
public void testPrintToWithNonNullValues() throws IOException { [EOL] StringBuilder sb = new StringBuilder(); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Mockito.when(mockPartial.toString()).thenReturn("MockPartialString"); [EOL] new Time().printTo(sb, mockPartial); [EOL] assertEquals("MockPartialString", sb.toString()); [EOL] }
public void testPrintToWithNullAppendable() throws IOException { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] try { [EOL] new Time().printTo(null, mockPartial); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPrintToWithNullPartial() throws IOException { [EOL] StringBuilder sb = new StringBuilder(); [EOL] try { [EOL] new Time().printTo(sb, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPrintWithNullPartial() { [EOL] try { [EOL] print(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testPrintWithValidPartial() { [EOL] ReadablePartial mockPartial = createMockPartial(); [EOL] String result = print(mockPartial); [EOL] assertNotNull("The print result should not be null", result); [EOL] assertFalse("The print result should not be empty", result.isEmpty()); [EOL] assertEquals("The print result should match the expected value", mockPartial.toString(), result); [EOL] } [EOL] private ReadablePartial createMockPartial() { [EOL] return new ReadablePartial() { [EOL] @Override [EOL] public int size() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public DateTimeFieldType getFieldType(int index) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public DateTimeField getField(int index) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public int getValue(int index) { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public Chronology getChronology() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public int get(DateTimeFieldType type) { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public boolean isSupported(DateTimeFieldType type) { [EOL] return false; [EOL] } [EOL] @Override [EOL] public DateTime toDateTime(ReadableInstant baseInstant) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String toString() { [EOL] return "MockPartial"; [EOL] } [EOL] }; [EOL] }
public void testParseInto_NullInstant_ThrowsIllegalArgumentException() { [EOL] try { [EOL] parseInto(null, "2023-04-01T00:00:00Z", 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Instant must not be null", e.getMessage()); [EOL] } [EOL] }
public void testParseInto_ValidInstantAndText_ParsesCorrectly() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithOffsetParsed_UpdatesInstantWithParsedOffset() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00+02:00"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithZone_UpdatesInstantWithZone() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithPresetZone_UpdatesInstantWithPresetZone() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseMillis_Success() { [EOL] String text = "2023-04-02T12:34:56"; // Assuming this is a valid date-time format for the parser [EOL] long expectedMillis = /* some expected millis value, e.g., the result of parsing the above text */; [EOL] long actualMillis = parseMillis(text); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testParseMillis_FailureDueToIncompleteParsing() { [EOL] String text = "2023-04-02T12"; // Assuming this is an incomplete date-time format for the parser [EOL] try { [EOL] parseMillis(text); [EOL] fail("Should have thrown IllegalArgumentException due to incomplete parsing"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMillis_FailureDueToInvalidFormat() { [EOL] String text = "invalid-date-time"; // Assuming this is an invalid date-time format for the parser [EOL] try { [EOL] parseMillis(text); [EOL] fail("Should have thrown IllegalArgumentException due to invalid format"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public LocalTime parseLocalTime(String text) { [EOL] return parseLocalDateTime(text).toLocalTime(); [EOL] }
public void testParseDateTimeWithValidInput() { [EOL] String validInput = "2023-03-20T10:15:30"; // Assuming this is a valid input for the parser [EOL] DateTime result = parseDateTime(validInput); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(20, result.getDayOfMonth()); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(15, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] }
public void testParseDateTimeWithInvalidInput() { [EOL] String invalidInput = "invalid-date-time"; [EOL] try { [EOL] parseDateTime(invalidInput); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Invalid format")); [EOL] } [EOL] }
public void testParseDateTimeWithPartialInput() { [EOL] String partialInput = "2023-03-20T10"; // Assuming this is a partial input that the parser can handle [EOL] DateTime result = parseDateTime(partialInput); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(20, result.getDayOfMonth()); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] }
public void testParseDateTimeWithOffsetParsed() { [EOL] String inputWithOffset = "2023-03-20T10:15:30+02:00"; // Assuming the parser can handle offsets [EOL] DateTime result = parseDateTime(inputWithOffset); [EOL] assertNotNull(result); [EOL] assertEquals(2 * 60 * 60 * 1000, result.getZone().getOffset(result)); [EOL] }
public void testParseDateTimeWithZone() { [EOL] String inputWithZone = "2023-03-20T10:15:30Z"; // Assuming 'Z' is a valid zone for the parser [EOL] DateTime result = parseDateTime(inputWithZone); [EOL] assertNotNull(result); [EOL] assertEquals("UTC", result.getZone().getID()); [EOL] }
public void testParseMutableDateTime_ValidInput() { [EOL] String validInput = "2023-04-01T00:00:00.000Z"; // Assuming this is a valid input for the parser [EOL] MutableDateTime result = parseMutableDateTime(validInput); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(0, result.getMillisOfSecond()); [EOL] }
public void testParseMutableDateTime_InvalidInput() { [EOL] String invalidInput = "invalid-date-time"; // Assuming this is an invalid input for the parser [EOL] try { [EOL] parseMutableDateTime(invalidInput); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMutableDateTime_ValidInputWithOffsetParsed() { [EOL] String validInputWithOffset = "2023-04-01T00:00:00.000+02:00"; // Assuming this is a valid input and offset is parsed [EOL] MutableDateTime result = parseMutableDateTime(validInputWithOffset); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(DateTimeZone.forOffsetHours(2), result.getZone()); [EOL] }
public void testParseMutableDateTime_ValidInputWithZone() { [EOL] String validInputWithZone = "2023-04-01T00:00:00.000Z[Europe/Paris]"; // Assuming this is a valid input and zone is provided [EOL] MutableDateTime result = parseMutableDateTime(validInputWithZone); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(DateTimeZone.forID("Europe/Paris"), result.getZone()); [EOL] }
public void testParseMutableDateTime_ValidInputWithDefaultZone() { [EOL] String validInputWithDefaultZone = "2023-04-01T00:00:00.000"; // Assuming this is a valid input and default zone should be used [EOL] MutableDateTime result = parseMutableDateTime(validInputWithDefaultZone); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(iZone, result.getZone()); // Assuming iZone is the default zone set in the context [EOL] }
public void testRequireParser_WhenParserIsNotNull() { [EOL] DateTimeParser parser = new DateTimeParser(); [EOL] MyClass myClassInstance = new MyClass(parser); [EOL] DateTimeParser result = myClassInstance.requireParser(); [EOL] assertNotNull(result); [EOL] assertEquals(parser, result); [EOL] }
public void testRequireParser_WhenParserIsNull_ShouldThrow() { [EOL] MyClass myClassInstance = new MyClass(null); [EOL] try { [EOL] myClassInstance.requireParser(); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Parsing not supported", e.getMessage()); [EOL] } [EOL] }
public void testSelectChronology_WithNullChronoAndNullZone() { [EOL] Chronology result = selectChronology(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testSelectChronology_WithNonNullChronoAndNullZone() { [EOL] Chronology inputChrono = ISOChronology.getInstanceUTC(); [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertSame(inputChrono, result); [EOL] }
public void testSelectChronology_WithNonNullChronoAndNonNullZone() { [EOL] Chronology inputChrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] this.iZone = zone; // Assuming this is a field in the test class [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertNotSame(inputChrono, result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testSelectChronology_WithNullChronoAndNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] this.iZone = zone; // Assuming this is a field in the test class [EOL] Chronology result = selectChronology(null); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testSelectChronology_WithNonNullChronoAndNonNullIChrono() { [EOL] Chronology inputChrono = ISOChronology.getInstanceUTC(); [EOL] Chronology expectedChrono = ISOChronology.getInstance(); [EOL] this.iChrono = expectedChrono; // Assuming this is a field in the test class [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertSame(expectedChrono, result); [EOL] }
public void testSelectChronology_WithNullChronoAndNonNullIChrono() { [EOL] Chronology expectedChrono = ISOChronology.getInstance(); [EOL] this.iChrono = expectedChrono; // Assuming this is a field in the test class [EOL] Chronology result = selectChronology(null); [EOL] assertSame(expectedChrono, result); [EOL] }
public class BaseChronologySubclass extends BaseChronology { [EOL] public BaseChronologySubclass() { [EOL] super(); [EOL] } [EOL] } [EOL] public class BaseChronologyTest { [EOL] public void testBaseChronologySubclassConstructor() { [EOL] BaseChronologySubclass instance = new BaseChronologySubclass(); [EOL] assertNotNull(instance); [EOL] } [EOL] }
public void testGetDateTimeMillis_ValidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expectedMillis = /* expected milliseconds value for the given date and time */; [EOL] long actualMillis = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetDateTimeMillis_InvalidMonth() { [EOL] int year = 2021; [EOL] int invalidMonthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] try { [EOL] getDateTimeMillis(year, invalidMonthOfYear, dayOfMonth, millisOfDay); [EOL] fail("IllegalArgumentException expected for invalid monthOfYear"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidDay() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int invalidDayOfMonth = 32; // Invalid day [EOL] int millisOfDay = 12345; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, invalidDayOfMonth, millisOfDay); [EOL] fail("IllegalArgumentException expected for invalid dayOfMonth"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidMillis() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int invalidMillisOfDay = -1; // Invalid millisOfDay [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, invalidMillisOfDay); [EOL] fail("IllegalArgumentException expected for invalid millisOfDay"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_ValidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] long expected = SOME_EXPECTED_VALUE; // Replace with the expected value [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_InvalidMonth() { [EOL] int year = 2021; [EOL] int monthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidDay() { [EOL] int year = 2021; [EOL] int monthOfYear = 2; // February [EOL] int dayOfMonth = 30; // Invalid day for February [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidHour() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 24; // Invalid hour [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidMinute() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 60; // Invalid minute [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidSecond() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 60; // Invalid second [EOL] int millisOfSecond = 123; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidMillis() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 1000; // Invalid millisecond [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_ValidInput() { [EOL] long expected = SOME_EXPECTED_VALUE; [EOL] long instant = SOME_INSTANT; [EOL] int hourOfDay = SOME_VALID_HOUR; [EOL] int minuteOfHour = SOME_VALID_MINUTE; [EOL] int secondOfMinute = SOME_VALID_SECOND; [EOL] int millisOfSecond = SOME_VALID_MILLISECOND; [EOL] long actual = getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdd_WithScalarZeroAndNullPeriod() { [EOL] long instant = 1234567890L; [EOL] long result = add(null, instant, 0); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_WithScalarZeroAndNonNullPeriod() { [EOL] long instant = 1234567890L; [EOL] ReadablePeriod period = new MockPeriod(); [EOL] long result = add(period, instant, 0); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_WithNonZeroScalarAndNullPeriod() { [EOL] long instant = 1234567890L; [EOL] long result = add(null, instant, 1); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_WithNonZeroScalarAndNonNullPeriod() { [EOL] long instant = 1234567890L; [EOL] ReadablePeriod period = new MockPeriod(new long[]{1, 2, 3}, new FieldType[]{FieldType.seconds(), FieldType.minutes(), FieldType.hours()}); [EOL] long result = add(period, instant, 1); [EOL] assertNotEquals(instant, result); // Assuming MockPeriod and FieldType are properly implemented and add to the instant [EOL] }
public void testAdd_WithNonZeroScalarNonNullPeriodAndZeroValues() { [EOL] long instant = 1234567890L; [EOL] ReadablePeriod period = new MockPeriod(new long[]{0, 0, 0}, new FieldType[]{FieldType.seconds(), FieldType.minutes(), FieldType.hours()}); [EOL] long result = add(period, instant, 1); [EOL] assertEquals(instant, result); [EOL] }
public void testEras() { [EOL] DurationField field = new Time().eras(); [EOL] assertNotNull(field); [EOL] assertFalse(field.isSupported()); [EOL] }
public long getMillisTestWithValueZero() { [EOL] Time time = new Time(); [EOL] int value = 0; [EOL] long instant = System.currentTimeMillis(); [EOL] long result = time.getMillis(value, instant); [EOL] assertEquals(0L, result); [EOL] }
public long getMillisTestWithPositiveValue() { [EOL] Time time = new Time(); [EOL] int value = 1; [EOL] long instant = System.currentTimeMillis(); [EOL] long result = time.getMillis(value, instant); [EOL] assertEquals(1L, result); [EOL] }
public long getMillisTestWithNegativeValue() { [EOL] Time time = new Time(); [EOL] int value = -1; [EOL] long instant = System.currentTimeMillis(); [EOL] long result = time.getMillis(value, instant); [EOL] assertEquals(-1L, result); [EOL] }
public void testReadResolveWithERA() { [EOL] TimeType testObject = new TimeType(ERA); // ERA is a constant representing the ordinal for ERA [EOL] Object result = testObject.readResolve(); [EOL] assertEquals(ERA_TYPE, result); [EOL] }
public void testReadResolveWithYEAR_OF_ERA() { [EOL] TimeType testObject = new TimeType(YEAR_OF_ERA); // YEAR_OF_ERA is a constant representing the ordinal for YEAR_OF_ERA [EOL] Object result = testObject.readResolve(); [EOL] assertEquals(YEAR_OF_ERA_TYPE, result); [EOL] }
public void testReadResolveWithCENTURY_OF_ERA() { [EOL] TimeType testObject = new TimeType(CENTURY_OF_ERA); // CENTURY_OF_ERA is a constant representing the ordinal for CENTURY_OF_ERA [EOL] Object result = testObject.readResolve(); [EOL] assertEquals(CENTURY_OF_ERA_TYPE, result); [EOL] }
public void testReadResolveWithDefault() { [EOL] TimeType testObject = new TimeType(INVALID_ORDINAL); // INVALID_ORDINAL is a constant representing an invalid ordinal [EOL] Object result = testObject.readResolve(); [EOL] assertSame(testObject, result); [EOL] }
public void testEquals_SameObject() { [EOL] ReadableDuration duration = new MockDuration(); [EOL] assertTrue(duration.equals(duration)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadableDuration duration = new MockDuration(); [EOL] assertFalse(duration.equals(null)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadableDuration duration = new MockDuration(); [EOL] assertFalse(duration.equals(new Object())); [EOL] } [EOL] public void testEquals_DifferentDuration() { [EOL] ReadableDuration duration1 = new MockDuration(123L); [EOL] ReadableDuration duration2 = new MockDuration(456L); [EOL] assertFalse(duration1.equals(duration2)); [EOL] } [EOL] public void testEquals_SameDuration() { [EOL] ReadableDuration duration1 = new MockDuration(123L); [EOL] ReadableDuration duration2 = new MockDuration(123L); [EOL] assertTrue(duration1.equals(duration2)); [EOL] }

public void testReadableIntervalConverterSubclassCreation() { [EOL] class ReadableIntervalConverterSubclass extends ReadableIntervalConverter { [EOL] public ReadableIntervalConverterSubclass() { [EOL] super(); [EOL] } [EOL] } [EOL] ReadableIntervalConverterSubclass instance = new ReadableIntervalConverterSubclass(); [EOL] assertNotNull(instance); [EOL] }
public void testSetIntoWithNonNullChronology() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] ReadableInterval input = mock(ReadableInterval.class); [EOL] Chronology chrono = mock(Chronology.class); [EOL] setInto(writableInterval, input, chrono); [EOL] verify(writableInterval).setInterval(input); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithNullChronology() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] ReadableInterval input = mock(ReadableInterval.class); [EOL] when(input.getChronology()).thenReturn(mock(Chronology.class)); [EOL] setInto(writableInterval, input, null); [EOL] verify(writableInterval).setInterval(input); [EOL] verify(writableInterval).setChronology(input.getChronology()); [EOL] }
public void testForLocaleWithNullLocale() { [EOL] GJLocaleSymbols result = GJLocaleSymbols.forLocale(null); [EOL] assertNotNull(result); [EOL] assertEquals(Locale.getDefault(), result.getLocale()); [EOL] }
public void testForLocaleWithNonNullLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] GJLocaleSymbols result = GJLocaleSymbols.forLocale(locale); [EOL] assertNotNull(result); [EOL] assertEquals(locale, result.getLocale()); [EOL] }
public void testForLocaleWithCachedLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] GJLocaleSymbols cachedSymbols = new GJLocaleSymbols(locale); [EOL] GJLocaleSymbols.setInCache(locale, cachedSymbols); [EOL] GJLocaleSymbols result = GJLocaleSymbols.forLocale(locale); [EOL] assertNotNull(result); [EOL] assertSame(cachedSymbols, result); [EOL] }
public void testEraValueToText_ValidValue() { [EOL] String[] iEras = new String[]{"BC", "AD"}; [EOL] MyClass myClass = new MyClass(iEras); [EOL] String result = myClass.eraValueToText(0); [EOL] assertEquals("BC", result); [EOL] }
public void testEraValueToText_InvalidValue() { [EOL] String[] iEras = new String[]{"BC", "AD"}; [EOL] MyClass myClass = new MyClass(iEras); [EOL] try { [EOL] myClass.eraValueToText(-1); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetEraMaxTextLength() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] int expectedMaxEraLength = 0; // Replace with the actual expected max era length [EOL] int actualMaxEraLength = time.getEraMaxTextLength(); [EOL] assertEquals(expectedMaxEraLength, actualMaxEraLength); [EOL] }
public void testGetMonthMaxShortTextLength() { [EOL] Time time = new Time(); // Assuming Time is the class where getMonthMaxShortTextLength is defined [EOL] int expected = 0; // Replace with the expected value of iMaxShortMonthLength [EOL] int actual = time.getMonthMaxShortTextLength(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAbstractInstantSubclassConstructor() { [EOL] AbstractInstantSubclass instance = new AbstractInstantSubclass(); [EOL] assertNotNull(instance); [EOL] } [EOL] private static class AbstractInstantSubclass extends AbstractInstant { [EOL] public AbstractInstantSubclass() { [EOL] super(); [EOL] } [EOL] }
public void testGetZone_NullChronology() { [EOL] DateTime dateTime = new DateTime((Chronology) null); [EOL] try { [EOL] dateTime.getZone(); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetZone_NonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateTime dateTime = new DateTime(chronology); [EOL] DateTimeZone zone = dateTime.getZone(); [EOL] assertNotNull("Zone should not be null", zone); [EOL] assertEquals("Zone should be the same as the chronology's zone", chronology.getZone(), zone); [EOL] }
public void testIsSupportedWithNullType() { [EOL] DateTime dateTime = new DateTime(); [EOL] boolean result = dateTime.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DateTimeFieldType unsupportedType = mock(DateTimeFieldType.class); [EOL] when(unsupportedType.getField(any(Chronology.class))).thenReturn(mock(DateTimeField.class)); [EOL] when(unsupportedType.getField(any(Chronology.class)).isSupported()).thenReturn(false); [EOL] DateTime dateTime = new DateTime(); [EOL] boolean result = dateTime.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DateTimeFieldType supportedType = mock(DateTimeFieldType.class); [EOL] when(supportedType.getField(any(Chronology.class))).thenReturn(mock(DateTimeField.class)); [EOL] when(supportedType.getField(any(Chronology.class)).isSupported()).thenReturn(true); [EOL] DateTime dateTime = new DateTime(); [EOL] boolean result = dateTime.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testGetWithNullField() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeField must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithValidField() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField field = DateTimeFieldType.dayOfMonth(); [EOL] int expected = field.get(testDateTime.getMillis()); [EOL] int actual = testDateTime.get(field); [EOL] assertEquals(expected, actual); [EOL] }
public void testToDateTime() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] long currentMillis = System.currentTimeMillis(); [EOL] DateTime expected = new DateTime(currentMillis, zone); [EOL] DateTime actual = new DateTime(currentMillis, zone).toDateTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToMutableDateTimeISO_WithDefaultZone() { [EOL] DateTime dateTime = new DateTime(); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTimeISO(); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] assertEquals(ISOChronology.getInstance(), mutableDateTime.getChronology()); [EOL] }
public void testToMutableDateTimeISO_WithSpecificZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime dateTime = new DateTime(zone); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTimeISO(); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] assertEquals(ISOChronology.getInstance(zone), mutableDateTime.getChronology()); [EOL] }
public void testIsAfter_WhenMillisIsGreaterThanInstant_ShouldReturnTrue() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] long pastInstant = currentMillis - 1000; // 1 second before currentMillis [EOL] Time time = new Time(currentMillis); [EOL] boolean result = time.isAfter(pastInstant); [EOL] assertTrue(result); [EOL] }
public void testIsAfter_WhenMillisIsEqualToInstant_ShouldReturnFalse() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] Time time = new Time(currentMillis); [EOL] boolean result = time.isAfter(currentMillis); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_WhenMillisIsLessThanInstant_ShouldReturnFalse() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] long futureInstant = currentMillis + 1000; // 1 second after currentMillis [EOL] Time time = new Time(currentMillis); [EOL] boolean result = time.isAfter(futureInstant); [EOL] assertFalse(result); [EOL] }
public boolean isAfterNow() { [EOL] return isAfter(DateTimeUtils.currentTimeMillis()); [EOL] }
public void testIsAfterWithNullInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] try { [EOL] testDateTime.isAfter((ReadableInstant) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIsAfterWithInstantBefore() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant earlierInstant = new DateTime(testDateTime.getMillis() - 1); [EOL] assertFalse(testDateTime.isAfter(earlierInstant)); [EOL] }
public void testIsAfterWithInstantAfter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant laterInstant = new DateTime(testDateTime.getMillis() + 1); [EOL] assertTrue(testDateTime.isAfter(laterInstant)); [EOL] }
public void testIsAfterWithSameInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant sameInstant = new DateTime(testDateTime.getMillis()); [EOL] assertFalse(testDateTime.isAfter(sameInstant)); [EOL] }
public void testToString() { [EOL] Time time = new Time(); [EOL] String expectedPattern = "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z"; [EOL] assertTrue(time.toString().matches(expectedPattern)); [EOL] }
public void testMutableInterval_WithInstantAndPeriod() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0, 0); [EOL] Period period = new Period(1, 2, 3, 4); [EOL] MutableInterval interval = new MutableInterval(start, period); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.plus(period).getMillis(), interval.getEndMillis()); [EOL] }
public void testMutableInterval_WithInstantAndNullPeriod() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0, 0); [EOL] MutableInterval interval = new MutableInterval(start, null); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.getMillis(), interval.getEndMillis()); [EOL] }
public void testSetInterval_Normal() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] long startInstant = 1000L; [EOL] long endInstant = 5000L; [EOL] timePeriod.setInterval(startInstant, endInstant); [EOL] assertEquals(startInstant, timePeriod.getStartMillis()); [EOL] assertEquals(endInstant, timePeriod.getEndMillis()); [EOL] assertNotNull(timePeriod.getChronology()); [EOL] }

public void testSetChronologyWithNullChronology() { [EOL] Interval interval = new Interval(0, 10); [EOL] interval.setChronology(null); [EOL] assertNull(interval.getChronology()); [EOL] }
public void testSetChronologyWithNonNullChronology() { [EOL] Interval interval = new Interval(0, 10); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] interval.setChronology(chrono); [EOL] assertEquals(chrono, interval.getChronology()); [EOL] }
public void testSetDurationBeforeEnd_PositiveDuration() { [EOL] long endMillis = 10000; [EOL] long duration = 5000; [EOL] MyTimePeriod instance = new MyTimePeriod(endMillis); [EOL] instance.setDurationBeforeEnd(duration); [EOL] long expectedStartMillis = endMillis - duration; [EOL] assertEquals(expectedStartMillis, instance.getStartMillis()); [EOL] }
public void testSetDurationBeforeEnd_NegativeDuration() { [EOL] long endMillis = 10000; [EOL] long duration = -5000; [EOL] MyTimePeriod instance = new MyTimePeriod(endMillis); [EOL] instance.setDurationBeforeEnd(duration); [EOL] long expectedStartMillis = endMillis - duration; [EOL] assertEquals(expectedStartMillis, instance.getStartMillis()); [EOL] }
public void testSetDurationBeforeEnd_ZeroDuration() { [EOL] long endMillis = 10000; [EOL] long duration = 0; [EOL] MyTimePeriod instance = new MyTimePeriod(endMillis); [EOL] instance.setDurationBeforeEnd(duration); [EOL] long expectedStartMillis = endMillis; [EOL] assertEquals(expectedStartMillis, instance.getStartMillis()); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] Time.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateMidnight result = Time.now(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testParseWithNullString() { [EOL] try { [EOL] DateMidnight result = DateMidnight.parse(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithEmptyString() { [EOL] try { [EOL] DateMidnight result = DateMidnight.parse(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithValidString() { [EOL] String validDateString = "2023-01-01T00:00:00.000Z"; [EOL] DateMidnight result = DateMidnight.parse(validDateString); [EOL] assertNotNull("Resulting DateMidnight should not be null", result); [EOL] assertEquals("The year should be 2023", 2023, result.getYear()); [EOL] assertEquals("The month should be January", 1, result.getMonthOfYear()); [EOL] assertEquals("The day should be the first", 1, result.getDayOfMonth()); [EOL] }
public void testDateMidnightWithCurrentTimeMillis() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(currentTimeMillis); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(currentTimeMillis, dateMidnight.getMillis()); [EOL] }
public void testDateMidnightWithInstantAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateMidnight dateMidnight = new DateMidnight(instant, zone); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(instant, dateMidnight.getMillis()); [EOL] assertEquals(zone, dateMidnight.getZone()); [EOL] }
public void testDateMidnightWithInstantAndNullZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(instant, dateMidnight.getMillis()); [EOL] assertEquals(DateTimeZone.getDefault(), dateMidnight.getZone()); [EOL] }
public void testDateMidnightWithValidInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, chronology); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(instant, dateMidnight.getMillis()); [EOL] assertEquals(chronology, dateMidnight.getChronology()); [EOL] }
public void testDateMidnightWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(instant, dateMidnight.getMillis()); [EOL] assertNotNull(dateMidnight.getChronology()); [EOL] assertTrue(dateMidnight.getChronology() instanceof ISOChronology); [EOL] }
public void testDateMidnightWithNullInstantAndNullChronology() { [EOL] DateMidnight dateMidnight = new DateMidnight((Object) null, (Chronology) null); [EOL] assertNotNull(dateMidnight); [EOL] }
public void testDateMidnightWithNonNullInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, (Chronology) null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(instant.getMillis(), dateMidnight.getMillis()); [EOL] }
public void testDateMidnightWithNullInstantAndNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateMidnight dateMidnight = new DateMidnight((Object) null, chronology); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(chronology, dateMidnight.getChronology()); [EOL] }
public void testDateMidnightWithNonNullInstantAndNonNullChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, chronology); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(instant.getMillis(), dateMidnight.getMillis()); [EOL] assertEquals(chronology, dateMidnight.getChronology()); [EOL] }
public void testDateMidnight_ValidDateWithTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 4, 1, zone); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(2023, dateMidnight.getYear()); [EOL] assertEquals(4, dateMidnight.getMonthOfYear()); [EOL] assertEquals(1, dateMidnight.getDayOfMonth()); [EOL] assertEquals(zone, dateMidnight.getZone()); [EOL] }
public void testDateMidnight_ValidDateWithUTC() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 4, 1, zone); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(DateTimeZone.UTC, dateMidnight.getZone()); [EOL] }
protected long checkInstant(long instant, Chronology chronology) { [EOL] return chronology.dayOfMonth().roundFloor(instant); [EOL] }
public void testWithZoneRetainFields_SameZone() { [EOL] DateTimeZone originalZone = DateTimeZone.UTC; [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 4, 1, originalZone); [EOL] DateMidnight result = dateMidnight.withZoneRetainFields(originalZone); [EOL] assertSame("The object should be the same as the original zone is the same", dateMidnight, result); [EOL] }
public void testWithZoneRetainFields_DifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.UTC; [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 4, 1, originalZone); [EOL] DateMidnight result = dateMidnight.withZoneRetainFields(newZone); [EOL] assertNotSame("The object should not be the same as the zone is different", dateMidnight, result); [EOL] assertEquals("The new zone should be set correctly", newZone, result.getZone()); [EOL] }
public void testWithFields_NullPartial() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFields(null); [EOL] assertSame("Expected the same instance when passing null", dateMidnight, result); [EOL] }
public void testWithFields_NonNullPartial() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadablePartial partial = new LocalDate(); [EOL] DateMidnight result = dateMidnight.withFields(partial); [EOL] assertNotSame("Expected a different instance when passing a non-null partial", dateMidnight, result); [EOL] assertEquals("Expected the result to have the same millis as set by the partial", dateMidnight.getChronology().set(partial, dateMidnight.getMillis()), result.getMillis()); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] try { [EOL] dateMidnight.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("The same dateMidnight should be returned", dateMidnight, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("A different dateMidnight should be returned", dateMidnight, result); [EOL] assertEquals("The dateMidnight should be one day ahead", dateMidnight.plusDays(1), result); [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(0, 1); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(1000, 0); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testWithDurationAdded_NonZeroDurationAndScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(1000, 2); [EOL] assertNotEquals(dateMidnight, result); [EOL] assertEquals(dateMidnight.getMillis() + 2000, result.getMillis()); [EOL] }
public void testPlusMonths_ZeroMonths() { [EOL] DateMidnight original = new DateMidnight(2023, 1, 1); [EOL] DateMidnight result = original.plusMonths(0); [EOL] assertEquals("Adding zero months should return the same date", original, result); [EOL] }
public void testPlusMonths_PositiveMonths() { [EOL] DateMidnight original = new DateMidnight(2023, 1, 1); [EOL] DateMidnight result = original.plusMonths(5); [EOL] DateMidnight expected = new DateMidnight(2023, 6, 1); [EOL] assertEquals("Adding five months should return the correct date", expected, result); [EOL] }
public void testPlusMonths_NegativeMonths() { [EOL] DateMidnight original = new DateMidnight(2023, 6, 1); [EOL] DateMidnight result = original.plusMonths(-5); [EOL] DateMidnight expected = new DateMidnight(2023, 1, 1); [EOL] assertEquals("Subtracting five months should return the correct date", expected, result); [EOL] }
public void testMinus_withPositiveDuration() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] long positiveDuration = 1000L; // 1 second in milliseconds [EOL] DateMidnight resultDateMidnight = initialDateMidnight.minus(positiveDuration); [EOL] long expectedMillis = initialDateMidnight.getMillis() - positiveDuration; [EOL] assertEquals(new DateMidnight(expectedMillis), resultDateMidnight); [EOL] }
public void testMinus_withNegativeDuration() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] long negativeDuration = -1000L; // -1 second in milliseconds [EOL] DateMidnight resultDateMidnight = initialDateMidnight.minus(negativeDuration); [EOL] long expectedMillis = initialDateMidnight.getMillis() - negativeDuration; [EOL] assertEquals(new DateMidnight(expectedMillis), resultDateMidnight); [EOL] }
public void testMinus_withZeroDuration() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] long zeroDuration = 0L; [EOL] DateMidnight resultDateMidnight = initialDateMidnight.minus(zeroDuration); [EOL] assertEquals(initialDateMidnight, resultDateMidnight); [EOL] }
public void testMinusMonths_ZeroMonths() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minusMonths(0); [EOL] assertSame("Should be the same object as no months are subtracted", dateMidnight, result); [EOL] }
public void testMinusMonths_NegativeMonths() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minusMonths(-1); [EOL] assertNotSame("Should not be the same object as months are subtracted", dateMidnight, result); [EOL] assertTrue("Resulting date should be after the original date", result.isAfter(dateMidnight)); [EOL] }
public void testMinusMonths_PositiveMonths() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minusMonths(1); [EOL] assertNotSame("Should not be the same object as months are subtracted", dateMidnight, result); [EOL] assertTrue("Resulting date should be before the original date", result.isBefore(dateMidnight)); [EOL] }
public void testMinusWeeks_ZeroWeeks() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minusWeeks(0); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testMinusWeeks_NegativeWeeks() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minusWeeks(-1); [EOL] assertNotSame(dateMidnight, result); [EOL] assertTrue(result.isBefore(dateMidnight)); [EOL] }
public void testMinusWeeks_PositiveWeeks() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.minusWeeks(1); [EOL] assertNotSame(dateMidnight, result); [EOL] assertTrue(result.isAfter(dateMidnight)); [EOL] }
public void testToYearMonthDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] YearMonthDay result = dateTime.toYearMonthDay(); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime.getYear(), result.getYear()); [EOL] assertEquals(dateTime.getMonthOfYear(), result.getMonthOfYear()); [EOL] assertEquals(dateTime.getDayOfMonth(), result.getDayOfMonth()); [EOL] }
public void testWithEra_ValidEra() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] int validEra = DateTimeConstants.BC; // Assuming BC is a valid era constant [EOL] DateMidnight newDateMidnight = dateMidnight.withEra(validEra); [EOL] assertEquals(validEra, newDateMidnight.getEra()); [EOL] }
public void testWithEra_InvalidEra() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] int invalidEra = Integer.MAX_VALUE; // Assuming this is an invalid era [EOL] try { [EOL] dateMidnight.withEra(invalidEra); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithCenturyOfEra_ValidCentury() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 14); [EOL] int newCentury = 21; [EOL] DateMidnight updatedDateMidnight = dateMidnight.withCenturyOfEra(newCentury); [EOL] assertEquals(new DateTime(2100, 3, 14, 0, 0), updatedDateMidnight.toDateTime()); [EOL] }
public void testWithCenturyOfEra_NegativeCentury() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 14); [EOL] int newCentury = -1; [EOL] try { [EOL] dateMidnight.withCenturyOfEra(newCentury); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithCenturyOfEra_FarFutureCentury() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 14); [EOL] int newCentury = 50; [EOL] DateMidnight updatedDateMidnight = dateMidnight.withCenturyOfEra(newCentury); [EOL] assertEquals(new DateTime(5000, 3, 14, 0, 0), updatedDateMidnight.toDateTime()); [EOL] }
public void testWithYearOfEra_ValidYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2020, 1, 1); [EOL] int newYearOfEra = 2021; [EOL] DateMidnight newDateMidnight = dateMidnight.withYearOfEra(newYearOfEra); [EOL] assertEquals(newYearOfEra, newDateMidnight.getYear()); [EOL] }
public void testWithYearOfEra_SameYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2020, 1, 1); [EOL] int newYearOfEra = 2020; [EOL] DateMidnight newDateMidnight = dateMidnight.withYearOfEra(newYearOfEra); [EOL] assertEquals(newYearOfEra, newDateMidnight.getYear()); [EOL] }
public void testWithYearOfCentury_ValidYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 15); [EOL] int yearOfCentury = 25; [EOL] DateMidnight newDateMidnight = dateMidnight.withYearOfCentury(yearOfCentury); [EOL] assertEquals(2025, newDateMidnight.getYear()); [EOL] }
public void testWithYearOfCentury_YearZero() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 15); [EOL] int yearOfCentury = 0; [EOL] DateMidnight newDateMidnight = dateMidnight.withYearOfCentury(yearOfCentury); [EOL] assertEquals(2000, newDateMidnight.getYear()); [EOL] }
public void testWithYear_ValidYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2020, 1, 1); [EOL] int newYear = 2021; [EOL] DateMidnight newDateMidnight = dateMidnight.withYear(newYear); [EOL] assertEquals(newYear, newDateMidnight.getYear()); [EOL] }
public void testWithYear_LeapYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2020, 1, 1); [EOL] int leapYear = 2024; [EOL] DateMidnight newDateMidnight = dateMidnight.withYear(leapYear); [EOL] assertEquals(leapYear, newDateMidnight.getYear()); [EOL] assertTrue(newDateMidnight.toDate().isLeapYear()); [EOL] }
public void testWithYear_EarBoundary() { [EOL] DateMidnight dateMidnight = new DateMidnight(2020, 1, 1); [EOL] int minYear = Integer.MIN_VALUE; [EOL] DateMidnight newDateMidnight = dateMidnight.withYear(minYear); [EOL] assertEquals(minYear, newDateMidnight.getYear()); [EOL] }
public void testWithYear_MaxBoundary() { [EOL] DateMidnight dateMidnight = new DateMidnight(2020, 1, 1); [EOL] int maxYear = Integer.MAX_VALUE; [EOL] DateMidnight newDateMidnight = dateMidnight.withYear(maxYear); [EOL] assertEquals(maxYear, newDateMidnight.getYear()); [EOL] }
public void testWithWeekyear_ValidWeekyear() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] int validWeekyear = 2023; [EOL] DateMidnight newDateMidnight = dateMidnight.withWeekyear(validWeekyear); [EOL] assertEquals(validWeekyear, newDateMidnight.getWeekyear()); [EOL] }
public void testWithWeekyear_NegativeWeekyear() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] int negativeWeekyear = -1; [EOL] DateMidnight newDateMidnight = dateMidnight.withWeekyear(negativeWeekyear); [EOL] assertEquals(negativeWeekyear, newDateMidnight.getWeekyear()); [EOL] }
public void testWithWeekyear_ZeroWeekyear() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] int zeroWeekyear = 0; [EOL] DateMidnight newDateMidnight = dateMidnight.withWeekyear(zeroWeekyear); [EOL] assertEquals(zeroWeekyear, newDateMidnight.getWeekyear()); [EOL] }
public void testWithMonthOfYear_ValidMonth() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] DateMidnight newDateMidnight = dateMidnight.withMonthOfYear(6); [EOL] assertEquals(6, newDateMidnight.getMonthOfYear()); [EOL] }
public void testWithMonthOfYear_InvalidMonthLow() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] try { [EOL] dateMidnight.withMonthOfYear(0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMonthOfYear_InvalidMonthHigh() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] try { [EOL] dateMidnight.withMonthOfYear(13); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithWeekOfWeekyear_ValidWeek() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] int validWeek = 10; [EOL] DateMidnight updatedDateMidnight = dateMidnight.withWeekOfWeekyear(validWeek); [EOL] assertEquals(validWeek, updatedDateMidnight.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_EdgeCaseStartOfYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] int firstWeek = 1; [EOL] DateMidnight updatedDateMidnight = dateMidnight.withWeekOfWeekyear(firstWeek); [EOL] assertEquals(firstWeek, updatedDateMidnight.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_EdgeCaseEndOfYear() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 12, 31); [EOL] int lastWeek = dateMidnight.getChronology().weekOfWeekyear().getMaximumValue(); [EOL] DateMidnight updatedDateMidnight = dateMidnight.withWeekOfWeekyear(lastWeek); [EOL] assertEquals(lastWeek, updatedDateMidnight.getWeekOfWeekyear()); [EOL] }
public void testWithDayOfYear_ValidDay() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] int dayOfYear = 50; // Assuming this is a valid day of the year [EOL] DateMidnight newDateMidnight = dateMidnight.withDayOfYear(dayOfYear); [EOL] assertEquals(newDateMidnight.getDayOfYear(), dayOfYear); [EOL] }
public void testWithDayOfYear_InvalidDay() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 1, 1); [EOL] int dayOfYear = 366; // Assuming this is an invalid day of the year for a non-leap year [EOL] try { [EOL] dateMidnight.withDayOfYear(dayOfYear); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfMonth_ValidDay() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 15); [EOL] int validDayOfMonth = 10; [EOL] DateMidnight newDateMidnight = dateMidnight.withDayOfMonth(validDayOfMonth); [EOL] assertEquals(newDateMidnight.getDayOfMonth(), validDayOfMonth); [EOL] }
public void testWithDayOfMonth_InvalidDay() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 15); [EOL] int invalidDayOfMonth = 32; [EOL] try { [EOL] dateMidnight.withDayOfMonth(invalidDayOfMonth); [EOL] fail("Should have thrown an exception for invalid day of month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfWeek_ValidDay() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 1); // Assuming a valid date [EOL] int dayOfWeek = 3; // Assuming 3 corresponds to a valid day of the week [EOL] DateMidnight newDateMidnight = dateMidnight.withDayOfWeek(dayOfWeek); [EOL] assertNotNull(newDateMidnight); [EOL] assertEquals(dayOfWeek, newDateMidnight.getDayOfWeek()); [EOL] }
public void testWithDayOfWeek_InvalidDay() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 1); // Assuming a valid date [EOL] int dayOfWeek = 8; // Assuming 8 is an invalid day of the week [EOL] try { [EOL] dateMidnight.withDayOfWeek(dayOfWeek); [EOL] fail("Should have thrown an exception for invalid day of the week"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWeekyearProperty() { [EOL] Time time = new Time(); [EOL] Property property = time.weekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().weekyear(), property.getField()); [EOL] }
public void testAddWrapFieldToCopy_Zero() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight result = initialDateMidnight.addWrapFieldToCopy(0); [EOL] assertEquals(initialDateMidnight, result); [EOL] }
public void testAddWrapFieldToCopy_Positive() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight result = initialDateMidnight.addWrapFieldToCopy(1); [EOL] assertNotEquals(initialDateMidnight, result); [EOL] }
public void testAddWrapFieldToCopy_Negative() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight result = initialDateMidnight.addWrapFieldToCopy(-1); [EOL] assertNotEquals(initialDateMidnight, result); [EOL] }
public void testRoundHalfEvenCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] long testMillis = 1000L; // Example millisecond value [EOL] long roundedMillis = 2000L; // Example rounded value [EOL] DateTime instant = new DateTime(testMillis, DateTimeZone.UTC); [EOL] DateMidnight testDateMidnight = new DateMidnight(instant, mockField); [EOL] Mockito.when(mockField.roundHalfEven(testMillis)).thenReturn(roundedMillis); [EOL] DateMidnight roundedDateMidnight = testDateMidnight.roundHalfEvenCopy(); [EOL] assertEquals(new DateMidnight(roundedMillis, DateTimeZone.UTC), roundedDateMidnight); [EOL] }
