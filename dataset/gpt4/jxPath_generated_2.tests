public void testCoreFunctionWithValidFunctionCodeAndArgs() { [EOL] int functionCode = 1; [EOL] Expression[] args = new Expression[] { mock(Expression.class) }; [EOL] CoreFunction coreFunction = new CoreFunction(functionCode, args); [EOL] assertNotNull(coreFunction); [EOL] assertEquals(functionCode, coreFunction.getFunctionCode()); [EOL] assertArrayEquals(args, coreFunction.getArguments()); [EOL] }
public void testGetArg1_NullArgs() { [EOL] YourClass instance = new YourClass(); [EOL] instance.args = null; [EOL] try { [EOL] instance.getArg1(); [EOL] fail("Expected an exception due to null args"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetArg1_EmptyArgs() { [EOL] YourClass instance = new YourClass(); [EOL] instance.args = new Expression[0]; [EOL] Expression result = instance.getArg1(); [EOL] assertNull("Expected null when args is empty", result); [EOL] }
public void testGetArg1_ValidArgs() { [EOL] YourClass instance = new YourClass(); [EOL] Expression exp = new Expression(); [EOL] instance.args = new Expression[]{exp}; [EOL] Expression result = instance.getArg1(); [EOL] assertSame("Expected the first argument", exp, result); [EOL] }
public Expression getArg2() { [EOL] return args[1]; [EOL] }
public void testGetArg3WithNonNullArgs() { [EOL] Expression[] args = new Expression[3]; [EOL] args[2] = new ExpressionStub(); [EOL] YourClass instance = new YourClass(args); [EOL] Expression result = instance.getArg3(); [EOL] assertNotNull(result); [EOL] assertEquals(args[2], result); [EOL] }
public void testGetArg3WithNullArgs() { [EOL] Expression[] args = new Expression[3]; [EOL] YourClass instance = new YourClass(args); [EOL] Expression result = instance.getArg3(); [EOL] assertNull(result); [EOL] }
public void testGetArgumentCountWithNullArgs() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] assertEquals(0, context.getArgumentCount()); [EOL] }
public void testGetArgumentCountWithEmptyArgs() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setArguments(new Object[0]); [EOL] assertEquals(0, context.getArgumentCount()); [EOL] }
public void testGetArgumentCountWithNonEmptyArgs() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setArguments(new Object[]{ "arg1", "arg2" }); [EOL] assertEquals(2, context.getArgumentCount()); [EOL] }
public void testComputeValueFunctionLast() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_LAST); [EOL] when(functionLast(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionPosition() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_POSITION); [EOL] when(functionPosition(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionCount() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_COUNT); [EOL] when(functionCount(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFormatNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(context.getFunctionCode()).thenReturn(Compiler.FUNCTION_FORMAT_NUMBER); [EOL] when(functionFormatNumber(context)).thenReturn(expected); [EOL] Object result = computeValue(context); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueDefaultCase() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getFunctionCode()).thenReturn(-1); // Assuming -1 is not a valid function code [EOL] Object result = computeValue(context); [EOL] assertNull(result); [EOL] }
public void testFunctionNameWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class)); [EOL] when(context.getCurrentNodePointer().getName()).thenReturn(mock(QName.class)); [EOL] when(context.getCurrentNodePointer().getName().toString()).thenReturn("NodeName"); [EOL] Object result = functionName(context); [EOL] assertEquals("NodeName", result); [EOL] }
public void testFunctionNameWithOneArgumentAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext setContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] QName qName = mock(QName.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(setContext); [EOL] when(setContext.hasNext()).thenReturn(true); [EOL] when(setContext.next()).thenReturn(nodePointer); [EOL] when(nodePointer.getName()).thenReturn(qName); [EOL] when(qName.toString()).thenReturn("NodeName"); [EOL] Object result = functionName(context); [EOL] assertEquals("NodeName", result); [EOL] }
public void testFunctionNameWithOneArgumentAndNoNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext setContext = mock(EvalContext.class); [EOL] when(getArgumentCount()).thenReturn(1); [EOL] when(getArg1().compute(context)).thenReturn(setContext); [EOL] when(setContext.hasNext()).thenReturn(false); [EOL] Object result = functionName(context); [EOL] assertEquals("", result); [EOL] }
public void testFunctionFormatNumberWithTwoArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] setArgumentCount(2); [EOL] setArg1Value(context, 123.45); [EOL] setArg2Value(context, "#.##"); [EOL] Object result = functionFormatNumber(context); [EOL] assertNotNull(result); [EOL] assertEquals("123.45", result.toString()); [EOL] }
public void testFunctionFormatNumberWithThreeArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] setArgumentCount(3); [EOL] setArg1Value(context, 123.45); [EOL] setArg2Value(context, "#.##"); [EOL] setArg3Value(context, "USD"); [EOL] Object result = functionFormatNumber(context); [EOL] assertNotNull(result); [EOL] assertEquals("123.45", result.toString()); [EOL] }
public void testFunctionFormatNumberWithInvalidArgumentCount() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] setArgumentCount(4); // Invalid argument count [EOL] try { [EOL] functionFormatNumber(context); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid argument count", e.getMessage()); [EOL] } [EOL] }
public void testFunctionFormatNumberWithNullPointerLocale() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] setArgumentCount(2); [EOL] setArg1Value(context, 123.45); [EOL] setArg2Value(context, "#.##"); [EOL] setCurrentNodePointer(context, null); // Simulate null pointer to trigger default locale [EOL] Object result = functionFormatNumber(context); [EOL] assertNotNull(result); [EOL] }
public void testJDOMNodePointerWithNonNullNode() { [EOL] Object node = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] JDOMNodePointer pointer = new JDOMNodePointer(node, locale); [EOL] assertNotNull(pointer.getNode()); [EOL] }
public void testJDOMNodePointerWithNullNode() { [EOL] Locale locale = Locale.getDefault(); [EOL] JDOMNodePointer pointer = new JDOMNodePointer(null, locale); [EOL] assertNull(pointer.getNode()); [EOL] }
public void testGetNamespaceURIDocumentWithValidPrefix() { [EOL] Node node = createMock(Document.class); [EOL] Element element = createMock(Element.class); [EOL] Namespace ns = createMock(Namespace.class); [EOL] expect(((Document) node).getRootElement()).andReturn(element); [EOL] expect(element.getNamespace("validPrefix")).andReturn(ns); [EOL] expect(ns.getURI()).andReturn("http://example.com/namespace"); [EOL] replay(node, element, ns); [EOL] String result = getNamespaceURI("validPrefix"); [EOL] assertEquals("http://example.com/namespace", result); [EOL] verify(node, element, ns); [EOL] }
public void testGetNamespaceURIDocumentWithInvalidPrefix() { [EOL] Node node = createMock(Document.class); [EOL] Element element = createMock(Element.class); [EOL] expect(((Document) node).getRootElement()).andReturn(element); [EOL] expect(element.getNamespace("invalidPrefix")).andReturn(null); [EOL] replay(node, element); [EOL] String result = getNamespaceURI("invalidPrefix"); [EOL] assertNull(result); [EOL] verify(node, element); [EOL] }
public void testGetNamespaceURIElementWithValidPrefix() { [EOL] Node node = createMock(Element.class); [EOL] Namespace ns = createMock(Namespace.class); [EOL] expect(((Element) node).getNamespace("validPrefix")).andReturn(ns); [EOL] expect(ns.getURI()).andReturn("http://example.com/namespace"); [EOL] replay(node, ns); [EOL] String result = getNamespaceURI("validPrefix"); [EOL] assertEquals("http://example.com/namespace", result); [EOL] verify(node, ns); [EOL] }
public void testGetNamespaceURIElementWithInvalidPrefix() { [EOL] Node node = createMock(Element.class); [EOL] expect(((Element) node).getNamespace("invalidPrefix")).andReturn(null); [EOL] replay(node); [EOL] String result = getNamespaceURI("invalidPrefix"); [EOL] assertNull(result); [EOL] verify(node); [EOL] }
public void testGetNamespaceURINonDocumentOrElement() { [EOL] Node node = createMock(Node.class); [EOL] replay(node); [EOL] String result = getNamespaceURI("anyPrefix"); [EOL] assertNull(result); [EOL] verify(node); [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL] Object node1 = pointer1.getBaseValue(); [EOL] Object node2 = pointer2.getBaseValue(); [EOL] if (node1 == node2) { [EOL] return 0; [EOL] } [EOL] if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) { [EOL] return -1; [EOL] } else if (!(node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL] return 1; [EOL] } else if ((node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL] List list = ((Element) getNode()).getAttributes(); [EOL] int length = list.size(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object n = list.get(i); [EOL] if (n == node1) { [EOL] return -1; [EOL] } else if (n == node2) { [EOL] return 1; [EOL] } [EOL] } [EOL] return 0; [EOL] } [EOL] if (!(node instanceof Element)) { [EOL] throw new RuntimeException("JXPath internal error: " + "compareChildNodes called for " + node); [EOL] } [EOL] List children = ((Element) node).getContent(); [EOL] int length = children.size(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object n = children.get(i); [EOL] if (n == node1) { [EOL] return -1; [EOL] } else if (n == node2) { [EOL] return 1; [EOL] } [EOL] } [EOL] return 0; [EOL] }
public Object getBaseValueTest() { [EOL] Object expected = new Object(); [EOL] instance.node = expected; [EOL] Object result = instance.getBaseValue(); [EOL] assertSame(expected, result); [EOL] }
public void testGetValueWithElement() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getTextTrim()).thenReturn("ElementText"); [EOL] Object result = getValue(node); [EOL] assertEquals("ElementText", result); [EOL] }
public void testGetValueWithCommentAndNonNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn("CommentText"); [EOL] Object result = getValue(node); [EOL] assertEquals("CommentText", result); [EOL] }
public void testGetValueWithCommentAndNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithText() { [EOL] Node node = mock(Text.class); [EOL] when(((Text) node).getTextTrim()).thenReturn("TextContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("TextContent", result); [EOL] }
public void testGetValueWithCdata() { [EOL] Node node = mock(CDATA.class); [EOL] when(((CDATA) node).getTextTrim()).thenReturn("CdataContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("CdataContent", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNonNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn("InstructionData"); [EOL] Object result = getValue(node); [EOL] assertEquals("InstructionData", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithUnknownNodeType() { [EOL] Node node = mock(Node.class); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testTestNodeWithNullTest() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] boolean result = JxPath.testNode(mockPointer, mockNode, null); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeNameTestAndElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Element mockElement = mock(Element.class); [EOL] NodeNameTest mockNodeNameTest = mock(NodeNameTest.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockNodeNameTest.getNodeName()).thenReturn(mockQName); [EOL] when(mockNodeNameTest.isWildcard()).thenReturn(false); [EOL] when(mockQName.getName()).thenReturn("testName"); [EOL] when(JDOMNodePointer.getLocalName(mockElement)).thenReturn("testName"); [EOL] when(mockNodeNameTest.getNamespaceURI()).thenReturn("testURI"); [EOL] when(JDOMNodePointer.getNamespaceURI(mockElement)).thenReturn("testURI"); [EOL] boolean result = JxPath.testNode(mockPointer, mockElement, mockNodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeNameTestAndNonElementNode() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] NodeNameTest mockNodeNameTest = mock(NodeNameTest.class); [EOL] boolean result = JxPath.testNode(mockPointer, mockNode, mockNodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testTestNodeWithNodeTypeTestElement() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Element mockElement = mock(Element.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = JxPath.testNode(mockPointer, mockElement, mockNodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeTypeTestDocument() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Document mockDocument = mock(Document.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = JxPath.testNode(mockPointer, mockDocument, mockNodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeTypeTestText() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Text mockText = mock(Text.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] boolean result = JxPath.testNode(mockPointer, mockText, mockNodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeTypeTestComment() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Comment mockComment = mock(Comment.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] boolean result = JxPath.testNode(mockPointer, mockComment, mockNodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeTypeTestProcessingInstruction() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockProcessingInstruction = mock(ProcessingInstruction.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] boolean result = JxPath.testNode(mockPointer, mockProcessingInstruction, mockNodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithProcessingInstructionTest() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] ProcessingInstruction mockProcessingInstruction = mock(ProcessingInstruction.class); [EOL] ProcessingInstructionTest mockProcessingInstructionTest = mock(ProcessingInstructionTest.class); [EOL] when(mockProcessingInstructionTest.getTarget()).thenReturn("testTarget"); [EOL] when(mockProcessingInstruction.getTarget()).thenReturn("testTarget"); [EOL] boolean result = JxPath.testNode(mockPointer, mockProcessingInstruction, mockProcessingInstructionTest); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithMismatchedNodeTypes() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] Object mockNode = mock(Object.class); [EOL] NodeTypeTest mockNodeTypeTest = mock(NodeTypeTest.class); [EOL] when(mockNodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] boolean result = JxPath.testNode(mockPointer, mockNode, mockNodeTypeTest); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithSameObject() { [EOL] JDOMNodePointer pointer = new JDOMNodePointer(new Object()); [EOL] boolean result = pointer.equals(pointer); [EOL] assert result; [EOL] } [EOL] public void testEqualsWithDifferentClass() { [EOL] JDOMNodePointer pointer = new JDOMNodePointer(new Object()); [EOL] Object other = new Object(); [EOL] boolean result = pointer.equals(other); [EOL] assert !result; [EOL] } [EOL] public void testEqualsWithDifferentJDOMNodePointer() { [EOL] Object node = new Object(); [EOL] JDOMNodePointer pointer1 = new JDOMNodePointer(node); [EOL] JDOMNodePointer pointer2 = new JDOMNodePointer(new Object()); [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert !result; [EOL] } [EOL] public void testEqualsWithSameNode() { [EOL] Object node = new Object(); [EOL] JDOMNodePointer pointer1 = new JDOMNodePointer(node); [EOL] JDOMNodePointer pointer2 = new JDOMNodePointer(node); [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert result; [EOL] }

public void testJXPathTypeConversionExceptionWithMessage() { [EOL] String expectedMessage = "Test message"; [EOL] JXPathTypeConversionException exception = new JXPathTypeConversionException(expectedMessage); [EOL] assertEquals("Exception message should match the expected message", expectedMessage, exception.getMessage()); [EOL] }
public void testUnescapeWithApos() { [EOL] String input = "This isn&apos;t escaped!"; [EOL] String expected = "This isn't escaped!"; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithQuot() { [EOL] String input = "This isn&apos;t &quot;escaped&quot; either!"; [EOL] String expected = "This isn't \"escaped\" either!"; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithoutSpecialCharacters() { [EOL] String input = "This has no special characters."; [EOL] String expected = "This has no special characters."; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithConsecutiveApos() { [EOL] String input = "Consecutive &apos;&apos;apos!"; [EOL] String expected = "Consecutive ''apos!"; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithConsecutiveQuot() { [EOL] String input = "Consecutive &quot;&quot;quot!"; [EOL] String expected = "Consecutive \"\"quot!"; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithMixedConsecutive() { [EOL] String input = "Mixed &apos;&quot;consecutive&apos;&quot;!"; [EOL] String expected = "Mixed '\"consecutive\"'!"; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public String testNCNameWithNCNameToken() throws ParseException { [EOL] jj_nt.kind = NCName; [EOL] String result = NCName(); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] }
public String testNCNameWithNodeToken() throws ParseException { [EOL] jj_nt.kind = NODE; [EOL] String result = NCName(); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] }
public String testNCNameWithTextToken() throws ParseException { [EOL] jj_nt.kind = TEXT; [EOL] String result = NCName(); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] }
public String testNCNameWithCommentToken() throws ParseException { [EOL] jj_nt.kind = COMMENT; [EOL] String result = NCName(); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] }
public String testNCNameWithPIToken() throws ParseException { [EOL] jj_nt.kind = PI; [EOL] String result = NCName(); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] }
public String testNCNameWithFunctionLastToken() throws ParseException { [EOL] jj_nt.kind = FUNCTION_LAST; [EOL] String result = NCName(); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] }
public void testNCNameWithInvalidToken() { [EOL] jj_nt.kind = INVALID_TOKEN; // Assuming INVALID_TOKEN is a constant for an invalid token [EOL] assertThrows(ParseException.class, () -> { [EOL] NCName(); [EOL] }); [EOL] }
public void testCoreFunctionNameWithFunctionLast() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LAST; [EOL] int expectedCode = Compiler.FUNCTION_LAST; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionPosition() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_POSITION; [EOL] int expectedCode = Compiler.FUNCTION_POSITION; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCount() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_COUNT; [EOL] int expectedCode = Compiler.FUNCTION_COUNT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionId() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ID; [EOL] int expectedCode = Compiler.FUNCTION_ID; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLocalName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LOCAL_NAME; [EOL] int expectedCode = Compiler.FUNCTION_LOCAL_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNamespaceUri() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAMESPACE_URI; [EOL] int expectedCode = Compiler.FUNCTION_NAMESPACE_URI; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAME; [EOL] int expectedCode = Compiler.FUNCTION_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionString() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING; [EOL] int expectedCode = Compiler.FUNCTION_STRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionConcat() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONCAT; [EOL] int expectedCode = Compiler.FUNCTION_CONCAT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStartsWith() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STARTS_WITH; [EOL] int expectedCode = Compiler.FUNCTION_STARTS_WITH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionContains() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONTAINS; [EOL] int expectedCode = Compiler.FUNCTION_CONTAINS; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringBefore() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_BEFORE; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringAfter() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_AFTER; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstring() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStringLength() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING_LENGTH; [EOL] int expectedCode = Compiler.FUNCTION_STRING_LENGTH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNormalizeSpace() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NORMALIZE_SPACE; [EOL] int expectedCode = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTranslate() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRANSLATE; [EOL] int expectedCode = Compiler.FUNCTION_TRANSLATE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionBoolean() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_BOOLEAN; [EOL] int expectedCode = Compiler.FUNCTION_BOOLEAN; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNot() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NOT; [EOL] int expectedCode = Compiler.FUNCTION_NOT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTrue() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRUE; [EOL] int expectedCode = Compiler.FUNCTION_TRUE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFalse() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FALSE; [EOL] int expectedCode = Compiler.FUNCTION_FALSE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNull() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NULL; [EOL] int expectedCode = Compiler.FUNCTION_NULL; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLang() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LANG; [EOL] int expectedCode = Compiler.FUNCTION_LANG; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSum() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUM; [EOL] int expectedCode = Compiler.FUNCTION_SUM; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFloor() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FLOOR; [EOL] int expectedCode = Compiler.FUNCTION_FLOOR; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCeiling() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CEILING; [EOL] int expectedCode = Compiler.FUNCTION_CEILING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionRound() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ROUND; [EOL] int expectedCode = Compiler.FUNCTION_ROUND; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionKey() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_KEY; [EOL] int expectedCode = Compiler.FUNCTION_KEY; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFormatNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FORMAT_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithInvalidKind() { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = INVALID_KIND; // Assuming INVALID_KIND is a constant representing an invalid kind [EOL] try { [EOL] CoreFunctionName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testQName_Without_CoreFunctions_Path1() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(true); [EOL] when(NCName()).thenReturn("localPart"); [EOL] when(compiler.qname(null, "localPart")).thenReturn(new Object()); [EOL] Object result = QName_Without_CoreFunctions(); [EOL] assertNotNull(result); [EOL] }
public void testQName_Without_CoreFunctions_Path2() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(true); [EOL] when(NCName()).thenReturn("prefix").thenReturn("localPart"); [EOL] when(compiler.qname("prefix", "localPart")).thenReturn(new Object()); [EOL] Object result = QName_Without_CoreFunctions(); [EOL] assertNotNull(result); [EOL] }
public void testQName_Without_CoreFunctions_Path3() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(false); [EOL] when(jj_nt.kind).thenReturn(NCName); [EOL] when(NCName_Without_CoreFunctions()).thenReturn("localPart"); [EOL] when(compiler.qname(null, "localPart")).thenReturn(new Object()); [EOL] Object result = QName_Without_CoreFunctions(); [EOL] assertNotNull(result); [EOL] }
public void testQName_Without_CoreFunctions_Path4() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(false); [EOL] when(jj_nt.kind).thenReturn(INVALID_KIND); // INVALID_KIND represents an invalid kind that triggers the default case [EOL] doThrow(new ParseException()).when(jj_consume_token(-1)); [EOL] assertThrows(ParseException.class, () -> { [EOL] QName_Without_CoreFunctions(); [EOL] }); [EOL] }
public Object testLocationPathWithRelativeLocationPath() throws ParseException { [EOL] jj_nt.kind = OR; // OR is one of the kinds that lead to RelativeLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming RelativeLocationPath returns a non-null object [EOL] return result; [EOL] }
public Object testLocationPathWithAbsoluteLocationPath() throws ParseException { [EOL] jj_nt.kind = SLASH; // SLASH is one of the kinds that lead to AbsoluteLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming AbsoluteLocationPath returns a non-null object [EOL] return result; [EOL] }
public void testLocationPathWithParseException() { [EOL] jj_nt.kind = 999; // An invalid kind that is not handled by the switch [EOL] assertThrows(ParseException.class, () -> { [EOL] LocationPath(); [EOL] }); [EOL] }
public void testAbsoluteLocationPathWithJj_2_2True() throws ParseException { [EOL] when(mockParser.jj_2_2(2147483647)).thenReturn(true); [EOL] when(mockParser.jj_nt.kind).thenReturn(SOME_KIND_NOT_SLASH_OR_SLASHSLASH); [EOL] Object result = mockParser.AbsoluteLocationPath(); [EOL] verify(mockCompiler).locationPath(true, any()); [EOL] assertNotNull(result); [EOL] }
public void testAbsoluteLocationPathWithJj_2_2FalseAndSlash() throws ParseException { [EOL] when(mockParser.jj_2_2(2147483647)).thenReturn(false); [EOL] when(mockParser.jj_nt.kind).thenReturn(SLASH); [EOL] Object result = mockParser.AbsoluteLocationPath(); [EOL] verify(mockParser).jj_consume_token(SLASH); [EOL] verify(mockCompiler).locationPath(true, any()); [EOL] assertNotNull(result); [EOL] }
public void testAbsoluteLocationPathWithJj_2_2FalseAndParseException() { [EOL] when(mockParser.jj_2_2(2147483647)).thenReturn(false); [EOL] when(mockParser.jj_nt.kind).thenReturn(SOME_KIND_NOT_SLASH); [EOL] assertThrows(ParseException.class, () -> { [EOL] mockParser.AbsoluteLocationPath(); [EOL] }); [EOL] verify(mockParser).jj_consume_token(-1); [EOL] }
public void testNodeTestWithNodeType() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NODE; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithProcessingInstruction() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.PI; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithWildcardName() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NCName; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithSelfAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 82; // Assuming 82 corresponds to a valid kind for AXIS_SELF [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParentAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 83; // Assuming 83 corresponds to a valid kind for AXIS_PARENT [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithPredicate() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 84; // Assuming 84 corresponds to a valid kind for a Predicate [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParseException() { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = -1; // Invalid kind to trigger ParseException [EOL] try { [EOL] jjParser.NodeTest(steps); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testAxisSpecifierWithAxisSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithDefault() throws ParseException { [EOL] jj_nt.kind = SOME_OTHER_KIND; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AbbreviatedAxisSpecifier(), result); [EOL] }
public void testAxisNameSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_SELF, result); [EOL] }
public void testAxisNameChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAxisNameParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PARENT, result); [EOL] }
public void testAxisNameAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR, result); [EOL] }
public void testAxisNameAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testAxisNameNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_NAMESPACE, result); [EOL] }
public void testAxisNamePreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING, result); [EOL] }
public void testAxisNameFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING, result); [EOL] }
public void testAxisNameDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT, result); [EOL] }
public void testAxisNameAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR_OR_SELF, result); [EOL] }
public void testAxisNameFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING_SIBLING, result); [EOL] }
public void testAxisNamePrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING_SIBLING, result); [EOL] }
public void testAxisNameDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT_OR_SELF, result); [EOL] }
public void testAxisNameInvalid() { [EOL] jj_nt.kind = INVALID_KIND; // INVALID_KIND should be a constant that is not covered by any case [EOL] assertThrows(ParseException.class, () -> { [EOL] AxisName(); [EOL] }); [EOL] }
public void testArgumentListWithSingleArgument() throws ParseException { [EOL] setupParserWithTokenKind(80); // Set the jj_nt.kind to 80 to trigger the case with a single argument [EOL] ArrayList result = ArgumentList(); [EOL] assertNotNull("The result should not be null", result); [EOL] assertEquals("The result should contain one argument", 1, result.size()); [EOL] }
public void testArgumentListWithMultipleArguments() throws ParseException { [EOL] setupParserWithTokenKind(80); // Set the jj_nt.kind to 80 to trigger the case with multiple arguments [EOL] setupParserWithAdditionalTokenKind(87); // Set up additional tokens of kind 87 to simulate multiple arguments [EOL] ArrayList result = ArgumentList(); [EOL] assertNotNull("The result should not be null", result); [EOL] assertTrue("The result should contain more than one argument", result.size() > 1); [EOL] }
public void testArgumentListWithNoArguments() throws ParseException { [EOL] setupParserWithTokenKind(81); // Set the jj_nt.kind to a kind that does not match any case [EOL] ArrayList result = ArgumentList(); [EOL] assertNull("The result should be null for no arguments", result); [EOL] }
public Object testPathExprWithFilterExpr() throws ParseException { [EOL] setJj_2_6ToReturn(true); [EOL] Object result = PathExpr(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedFilterExprResult, result); [EOL] }
public Object testPathExprWithLocationPath() throws ParseException { [EOL] setJj_ntKindTo(SLASH); // or any other value that leads to the LocationPath case [EOL] Object result = PathExpr(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedLocationPathResult, result); [EOL] }
public Object testPathExprWithParseException() throws ParseException { [EOL] setJj_ntKindTo(INVALID_KIND); // INVALID_KIND is a value not covered by any case [EOL] try { [EOL] Object result = PathExpr(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object MultiplicativeExpr() throws ParseException { [EOL] Object ex, r; [EOL] ex = UnaryExpr(); [EOL] label_14: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case MOD: [EOL] case DIV: [EOL] case 88: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[32] = jj_gen; [EOL] break label_14; [EOL] } [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] r = UnaryExpr(); [EOL] ex = compiler.multiply(ex, r); [EOL] break; [EOL] case DIV: [EOL] jj_consume_token(DIV); [EOL] r = UnaryExpr(); [EOL] ex = compiler.divide(ex, r); [EOL] break; [EOL] case MOD: [EOL] jj_consume_token(MOD); [EOL] r = UnaryExpr(); [EOL] ex = compiler.mod(ex, r); [EOL] break; [EOL] default: [EOL] jj_la1[33] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] } [EOL] { [EOL] if (true) [EOL] return ex; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testUnaryExprWithSlash() throws ParseException { [EOL] jj_nt.kind = SLASH; [EOL] Object result = UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithSlashSlash() throws ParseException { [EOL] jj_nt.kind = SLASHSLASH; [EOL] Object result = UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithVariable() throws ParseException { [EOL] jj_nt.kind = VARIABLE; [EOL] Object result = UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithMinus() throws ParseException { [EOL] jj_nt.kind = MINUS; [EOL] jj_consume_token(MINUS); // Assuming jj_consume_token is a method that consumes a token [EOL] Object result = UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testUnaryExprWithInvalidToken() { [EOL] jj_nt.kind = INVALID_TOKEN; // Assuming INVALID_TOKEN is a constant for an invalid token [EOL] assertThrows(ParseException.class, () -> { [EOL] UnaryExpr(); [EOL] }); [EOL] }
public Object wildcardNameCase88() throws ParseException { [EOL] jj_nt.kind = 88; [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] } [EOL] public Object wildcardNameCaseNCName() throws ParseException { [EOL] jj_nt.kind = NCName; [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] } [EOL] public Object wildcardNameCase79() throws ParseException { [EOL] jj_nt.kind = 79; [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] } [EOL] public void wildcardNameDefaultCase() { [EOL] jj_nt.kind = -1; // A kind that does not match any case [EOL] assertThrows(ParseException.class, () -> WildcardName()); [EOL] } [EOL] public Object wildcardNameCase79WithNCName() throws ParseException { [EOL] jj_nt.kind = 79; [EOL] jj_nt.nextKind = NCName; [EOL] Object result = WildcardName(); [EOL] assertNotNull(result); [EOL] assertEquals(token.image, result); [EOL] return result; [EOL] } [EOL] public void wildcardNameCase79DefaultCase() { [EOL] jj_nt.kind = 79; [EOL] jj_nt.nextKind = -1; // A kind that does not match any inner case [EOL] assertThrows(ParseException.class, () -> WildcardName()); [EOL] }
public void testJj_3R_45_WithFunctionFalseToken() { [EOL] boolean result = jj_3R_45(); [EOL] assert(result); // The assertion is true because jj_scan_token(FUNCTION_FALSE) should return true [EOL] }
public void testJj_3R_45_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_45(); [EOL] assert(!result); // The assertion is false because both conditions in the method will fail [EOL] }
public void testJj_3R_45_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_45(); [EOL] assert(!result); // The assertion is false because jj_scan_token(FUNCTION_FALSE) will return false and jj_la is not 0 or jj_scanpos does not equal jj_lastpos [EOL] }
public void testJj_3R_142_WithTokenAxisParent() { [EOL] boolean result = jj_3R_142(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_142_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_142(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_142_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and can be different [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_142(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_1() { [EOL] setupScanposLastpos(0, 0); [EOL] mockJj_3R_20(false); [EOL] boolean result = jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_2() { [EOL] setupScanposLastpos(0, 0); [EOL] mockJj_3R_20(true); [EOL] mockJj_3R_21(false); [EOL] boolean result = jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_3() { [EOL] setupScanposLastpos(0, 0); [EOL] mockJj_3R_20(true); [EOL] mockJj_3R_21(true); [EOL] mockJj_3R_54(false); [EOL] boolean result = jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_4() { [EOL] setupScanposLastpos(0, 0); [EOL] mockJj_3R_20(true); [EOL] mockJj_3R_21(true); [EOL] mockJj_3R_54(true); [EOL] boolean result = jj_3R_15(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_129_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_129()); [EOL] }
public void testJj_3R_129_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_129()); [EOL] }
public void testJj_3R_129_LastTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_129()); [EOL] }
public void testJj_3R_129_ScanposLastposNotEqual() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_lastpos.next = new Token(); // Make sure jj_scanpos != jj_lastpos [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_129()); [EOL] }
public void testJj_3R_192_SlashToken() { [EOL] boolean result = jj_3R_192(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_192_NoSlashTokenEndOfInput() { [EOL] boolean result = jj_3R_192(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_192_NoSlashTokenNotEndOfInput() { [EOL] boolean result = jj_3R_192(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_189_WithJj_3R_191True() { [EOL] boolean result = jj_3R_189(); [EOL] assertTrue("Expected jj_3R_189 to return true when jj_3R_191 is true", result); [EOL] }
public void testJj_3R_189_WithJj_3R_191FalseJj_3R_192True() { [EOL] boolean result = jj_3R_189(); [EOL] assertTrue("Expected jj_3R_189 to return true when jj_3R_191 is false and jj_3R_192 is true", result); [EOL] }
public void testJj_3R_189_WithJj_3R_191FalseJj_3R_192FalseJjLaZeroScanposEqLastpos() { [EOL] boolean result = jj_3R_189(); [EOL] assertFalse("Expected jj_3R_189 to return false when jj_3R_191 is false, jj_3R_192 is false, jj_la is 0, and jj_scanpos equals jj_lastpos", result); [EOL] }
public void testJj_3R_189_WithJj_3R_191FalseJjLaZeroScanposEqLastpos() { [EOL] boolean result = jj_3R_189(); [EOL] assertFalse("Expected jj_3R_189 to return false when jj_3R_191 is false, jj_la is 0, and jj_scanpos equals jj_lastpos", result); [EOL] }
public void testJj_la1_0Initialization() { [EOL] jj_la1_0(); [EOL] assertNotNull("jj_la1_0 array should be initialized", jj_la1_0); [EOL] assertEquals("Array length should be 38", 38, jj_la1_0.length); [EOL] assertEquals("First element should be 0xf8000000", 0xf8000000, jj_la1_0[0]); [EOL] assertEquals("Second element should be 0x78000000", 0x78000000, jj_la1_0[1]); [EOL] }
public void testJj_la1_1() { [EOL] jj_la1_1(); [EOL] assertArrayEquals(new int[] { [EOL] 0xffff0007, 0x0, 0xffff0000, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, [EOL] 0xffff0007, 0xffffffff, 0x0, 0xfff8, 0xfff8, 0x0, 0x0, 0xffff0007, 0x0, [EOL] 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, [EOL] 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0xffff0007, 0xffff0007, 0x0, 0x7 [EOL] }, jj_la1_1); [EOL] }
public void testJj_la1_2() { [EOL] jj_la1_2(); [EOL] assertArrayEquals(new int[] { 0x7fff, 0x4000, 0x3fff, 0x8000, 0x4000, 0x14c7fff, 0x0, 0x0, 0x0, 0x0, 0x1007fff, 0x14c7fff, 0x100000, 0x0, 0x0, 0x400000, 0x10000, 0x7fff, 0x800000, 0x14d7fff, 0x0, 0x14c7fff, 0x100000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1000000, 0x1000000, 0x14d7fff, 0x1007fff, 0x1007fff, 0x8000, 0x0 }, jj_la1_2); [EOL] }
public void testXPathParserWithValidReader() { [EOL] java.io.StringReader reader = new java.io.StringReader("some input"); [EOL] XPathParser parser = new XPathParser(reader); [EOL] assertNotNull(parser.jj_input_stream); [EOL] assertNotNull(parser.token_source); [EOL] assertNotNull(parser.token); [EOL] assertNotNull(parser.token.next); [EOL] assertEquals(0, parser.jj_gen); [EOL] for (int i = 0; i < 39; i++) { [EOL] assertEquals(-1, parser.jj_la1[i]); [EOL] } [EOL] for (JJCalls call : parser.jj_2_rtns) { [EOL] assertNotNull(call); [EOL] } [EOL] }
public void testParenthesizeWithNonCoreOperation() { [EOL] Expression expression = mock(Expression.class); [EOL] when(expression.toString()).thenReturn("NonCoreOperation"); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("NonCoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndLowerPrecedence() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(getPrecedence()).thenReturn(2); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndEqualPrecedenceSymmetric() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(getPrecedence()).thenReturn(1); [EOL] when(isSymmetric()).thenReturn(true); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndEqualPrecedenceNotSymmetricLeft() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(getPrecedence()).thenReturn(1); [EOL] when(isSymmetric()).thenReturn(false); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndEqualPrecedenceNotSymmetricRight() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(expression.getPrecedence()).thenReturn(1); [EOL] when(getPrecedence()).thenReturn(1); [EOL] when(isSymmetric()).thenReturn(false); [EOL] String result = parenthesize(expression, false); [EOL] assertEquals("(CoreOperation)", result); [EOL] }
public void testParenthesizeWithCoreOperationAndHigherPrecedence() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(expression.getPrecedence()).thenReturn(2); [EOL] when(getPrecedence()).thenReturn(1); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("(CoreOperation)", result); [EOL] }
public void testEqualsWithNonQNameObject() { [EOL] QName qName = new QName("localName", "prefix"); [EOL] Object nonQNameObject = new Object(); [EOL] assertFalse(qName.equals(nonQNameObject)); [EOL] }
public void testEqualsWithSelf() { [EOL] QName qName = new QName("localName", "prefix"); [EOL] assertTrue(qName.equals(qName)); [EOL] }
public void testEqualsWithDifferentLocalName() { [EOL] QName qName1 = new QName("localName1", "prefix"); [EOL] QName qName2 = new QName("localName2", "prefix"); [EOL] assertFalse(qName1.equals(qName2)); [EOL] }
public void testEqualsWithDifferentPrefix() { [EOL] QName qName1 = new QName("localName", "prefix1"); [EOL] QName qName2 = new QName("localName", "prefix2"); [EOL] assertFalse(qName1.equals(qName2)); [EOL] }
public void testEqualsWithNullPrefixInOne() { [EOL] QName qName1 = new QName("localName", null); [EOL] QName qName2 = new QName("localName", "prefix"); [EOL] assertFalse(qName1.equals(qName2)); [EOL] }
public void testEqualsWithNullPrefixInBoth() { [EOL] QName qName1 = new QName("localName", null); [EOL] QName qName2 = new QName("localName", null); [EOL] assertTrue(qName1.equals(qName2)); [EOL] }
public void testEqualsWithSameLocalNameAndPrefix() { [EOL] QName qName1 = new QName("localName", "prefix"); [EOL] QName qName2 = new QName("localName", "prefix"); [EOL] assertTrue(qName1.equals(qName2)); [EOL] }
public void testInterpretSimpleLocationPathWithNullContext() { [EOL] NodePointer result = JXPathContext.interpretSimpleLocationPath(null, null, null); [EOL] assertNull(result); [EOL] }
public void testInterpretSimpleLocationPathWithNonNullContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer root = mock(NodePointer.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] NodePointer expectedPointer = mock(NodePointer.class); [EOL] when(JXPathContext.doStep(context, root, steps, 0)).thenReturn(expectedPointer); [EOL] NodePointer result = JXPathContext.interpretSimpleLocationPath(context, root, steps); [EOL] assertSame(expectedPointer, result); [EOL] }
private static NodePointer doStep(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL] if (parent == null) { [EOL] return null; [EOL] } [EOL] if (currentStep == steps.length) { [EOL] return parent; [EOL] } [EOL] parent = valuePointer(parent); [EOL] Step step = steps[currentStep]; [EOL] Expression[] predicates = step.getPredicates(); [EOL] if (parent instanceof PropertyOwnerPointer) { [EOL] if (predicates == null || predicates.length == 0) { [EOL] return doStepNoPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL] } else { [EOL] return doStepPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL] } [EOL] } else { [EOL] if (predicates == null || predicates.length == 0) { [EOL] return doStepNoPredicatesStandard(context, parent, steps, currentStep); [EOL] } else { [EOL] return doStepPredicatesStandard(context, parent, steps, currentStep); [EOL] } [EOL] } [EOL] }
private static NodePointer doStepNoPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL] Step step = steps[currentStep]; [EOL] NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL] if (!childPointer.isActual()) { [EOL] return createNullPointer(context, parentPointer, steps, currentStep); [EOL] } else if (currentStep == steps.length - 1) { [EOL] return childPointer; [EOL] } else if (childPointer.isCollection()) { [EOL] int bestQuality = 0; [EOL] childPointer = (NodePointer) childPointer.clone(); [EOL] NodePointer bestMatch = null; [EOL] int count = childPointer.getLength(); [EOL] for (int i = 0; i < count; i++) { [EOL] childPointer.setIndex(i); [EOL] NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL] int quality = computeQuality(pointer); [EOL] if (quality == PERFECT_MATCH) { [EOL] return pointer; [EOL] } else if (quality > bestQuality) { [EOL] bestQuality = quality; [EOL] bestMatch = (NodePointer) pointer.clone(); [EOL] } [EOL] } [EOL] if (bestMatch != null) { [EOL] return bestMatch; [EOL] } [EOL] return createNullPointer(context, childPointer, steps, currentStep); [EOL] } else { [EOL] return doStep(context, childPointer, steps, currentStep + 1); [EOL] } [EOL] }
private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) { [EOL] Step step = steps[currentStep]; [EOL] if (step.getAxis() == Compiler.AXIS_SELF) { [EOL] return doStep(context, parentPointer, steps, currentStep + 1); [EOL] } [EOL] int bestQuality = 0; [EOL] NodePointer bestMatch = null; [EOL] NodeIterator it = getNodeIterator(context, parentPointer, step); [EOL] if (it != null) { [EOL] for (int i = 1; it.setPosition(i); i++) { [EOL] NodePointer childPointer = it.getNodePointer(); [EOL] if (steps.length == currentStep + 1) { [EOL] return childPointer; [EOL] } [EOL] NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL] int quality = computeQuality(pointer); [EOL] if (quality == PERFECT_MATCH) { [EOL] return pointer; [EOL] } else if (quality > bestQuality) { [EOL] bestQuality = quality; [EOL] bestMatch = (NodePointer) pointer.clone(); [EOL] } [EOL] } [EOL] } [EOL] if (bestMatch != null) { [EOL] return bestMatch; [EOL] } [EOL] return createNullPointer(context, parentPointer, steps, currentStep); [EOL] }
public void testDoStepPredicatesPropertyOwnerWithActualChildPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step[] steps = new Step[1]; [EOL] steps[0] = mock(Step.class); [EOL] Expression[] predicates = new Expression[0]; [EOL] when(steps[0].getPredicates()).thenReturn(predicates); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(childPointer.isActual()).thenReturn(true); [EOL] NodePointer result = doStepPredicatesPropertyOwner(context, parentPointer, steps, 0); [EOL] assertNotNull(result); [EOL] verify(childPointer, times(1)).isActual(); [EOL] }
public void testDoStepPredicatesPropertyOwnerWithNonActualChildPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step[] steps = new Step[1]; [EOL] steps[0] = mock(Step.class); [EOL] Expression[] predicates = new Expression[0]; [EOL] when(steps[0].getPredicates()).thenReturn(predicates); [EOL] NodePointer childPointer = mock(NodePointer.class); [EOL] when(childPointer.isActual()).thenReturn(false); [EOL] NodePointer result = doStepPredicatesPropertyOwner(context, parentPointer, steps, 0); [EOL] assertNull(result); [EOL] verify(childPointer, times(1)).isActual(); [EOL] }
public void testCreateChildPointerForStepWithChildAxis() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] verify(propertyPointer).setPropertyName(name.toString()); [EOL] assertFalse(result.isAttribute()); [EOL] }
public void testCreateChildPointerForStepWithAttributeAxis() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] verify(propertyPointer).setPropertyName(name.toString()); [EOL] assertTrue(result.isAttribute()); [EOL] }
public void testCreateChildPointerForStepWithLangAttribute() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("xml", "lang"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] assertTrue(result instanceof LangAttributePointer); [EOL] }
public void testCreateChildPointerForStepWithNonChildOrAttributeAxis() { [EOL] PropertyOwnerPointer parentPointer = mock(PropertyOwnerPointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_DESCENDANT); [EOL] NodePointer result = createChildPointerForStep(parentPointer, step); [EOL] assertSame(parentPointer, result); [EOL] }
public void testDoPredicateWithNoPredicates() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[0]; [EOL] NodePointer result = doPredicate(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] }
public void testDoPredicateWithNameAttributeTestPredicate() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[] { mock(NameAttributeTest.class) }; [EOL] NodePointer result = doPredicate(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] }
public void testDoPredicateWithNonNameAttributeTestPredicate() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[] { mock(Expression.class) }; [EOL] NodePointer result = doPredicate(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] }
private static NodePointer doPredicateName(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL] Expression predicate = predicates[currentPredicate]; [EOL] String key = keyFromPredicate(context, predicate); [EOL] NodePointer child = valuePointer(parent); [EOL] if (child instanceof PropertyOwnerPointer) { [EOL] PropertyPointer pointer = ((PropertyOwnerPointer) child).getPropertyPointer(); [EOL] pointer.setPropertyName(key); [EOL] if (pointer.isActual()) { [EOL] return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL] } [EOL] } else if (child.isCollection()) { [EOL] NodePointer bestMatch = null; [EOL] int bestQuality = 0; [EOL] child = (NodePointer) child.clone(); [EOL] int count = child.getLength(); [EOL] for (int i = 0; i < count; i++) { [EOL] child.setIndex(i); [EOL] NodePointer valuePointer = valuePointer(child); [EOL] NodePointer pointer; [EOL] if ((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()) { [EOL] pointer = doPredicateName(context, valuePointer, steps, currentStep, predicates, currentPredicate); [EOL] } else if (isNameAttributeEqual(valuePointer, key)) { [EOL] pointer = doPredicate(context, valuePointer, steps, currentStep, predicates, currentPredicate + 1); [EOL] } else { [EOL] pointer = null; [EOL] } [EOL] if (pointer != null) { [EOL] int quality = computeQuality(pointer); [EOL] if (quality == PERFECT_MATCH) { [EOL] return pointer; [EOL] } [EOL] if (quality > bestQuality) { [EOL] bestMatch = (NodePointer) pointer.clone(); [EOL] bestQuality = quality; [EOL] } [EOL] } [EOL] } [EOL] if (bestMatch != null) { [EOL] return bestMatch; [EOL] } [EOL] } else { [EOL] NodePointer found = doPredicatesStandard(context, Collections.singletonList(child), steps, currentStep, predicates, currentPredicate); [EOL] if (found != null) { [EOL] return found; [EOL] } [EOL] } [EOL] return createNullPointerForPredicates(context, child, steps, currentStep, predicates, currentPredicate); [EOL] }
public void testDoPredicatesStandardWithEmptyParents() { [EOL] EvalContext context = null; // Mock or create instance [EOL] List parents = new ArrayList(); [EOL] Step[] steps = null; // Mock or create instance [EOL] int currentStep = 0; [EOL] Expression[] predicates = null; // Mock or create instance [EOL] int currentPredicate = 0; [EOL] NodePointer result = doPredicatesStandard(context, parents, steps, currentStep, predicates, currentPredicate); [EOL] assertNull(result); [EOL] }
public void testDoPredicatesStandardWithNoMorePredicates() { [EOL] EvalContext context = null; // Mock or create instance [EOL] List parents = new ArrayList(); [EOL] parents.add(mock(NodePointer.class)); // Mock NodePointer [EOL] Step[] steps = null; // Mock or create instance [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[0]; // No predicates [EOL] int currentPredicate = 0; [EOL] NodePointer result = doPredicatesStandard(context, parents, steps, currentStep, predicates, currentPredicate); [EOL] assertNotNull(result); [EOL] }
public void testDoPredicatesStandardWithNameAttributeTestAndEmptyNewList() { [EOL] EvalContext context = null; // Mock or create instance [EOL] List parents = new ArrayList(); [EOL] parents.add(mock(NodePointer.class)); // Mock NodePointer [EOL] Step[] steps = null; // Mock or create instance [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(NameAttributeTest.class); // Mock NameAttributeTest [EOL] int currentPredicate = 0; [EOL] when(isNameAttributeEqual(any(NodePointer.class), anyString())).thenReturn(false); [EOL] NodePointer result = doPredicatesStandard(context, parents, steps, currentStep, predicates, currentPredicate); [EOL] assertNull(result); [EOL] }
public void testDoPredicatesStandardWithNameAttributeTestAndNonEmptyNewList() { [EOL] EvalContext context = null; // Mock or create instance [EOL] List parents = new ArrayList(); [EOL] NodePointer mockPointer = mock(NodePointer.class); // Mock NodePointer [EOL] parents.add(mockPointer); [EOL] Step[] steps = null; // Mock or create instance [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(NameAttributeTest.class); // Mock NameAttributeTest [EOL] int currentPredicate = 0; [EOL] when(isNameAttributeEqual(any(NodePointer.class), anyString())).thenReturn(true); [EOL] NodePointer result = doPredicatesStandard(context, parents, steps, currentStep, predicates, currentPredicate); [EOL] assertNotNull(result); [EOL] }
public void testDoPredicatesStandardWithInvalidIndex() { [EOL] EvalContext context = null; // Mock or create instance [EOL] List parents = new ArrayList(); [EOL] parents.add(mock(NodePointer.class)); // Mock NodePointer [EOL] Step[] steps = null; // Mock or create instance [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(Expression.class); // Mock Expression that is not NameAttributeTest [EOL] int currentPredicate = 0; [EOL] when(indexFromPredicate(context, predicates[0])).thenReturn(-1); // Invalid index [EOL] NodePointer result = doPredicatesStandard(context, parents, steps, currentStep, predicates, currentPredicate); [EOL] assertNull(result); [EOL] }
public void testDoPredicatesStandardWithValidIndex() { [EOL] EvalContext context = null; // Mock or create instance [EOL] List parents = new ArrayList(); [EOL] parents.add(mock(NodePointer.class)); // Mock NodePointer [EOL] Step[] steps = null; // Mock or create instance [EOL] int currentStep = 0; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(Expression.class); // Mock Expression that is not NameAttributeTest [EOL] int currentPredicate = 0; [EOL] when(indexFromPredicate(context, predicates[0])).thenReturn(0); // Valid index [EOL] NodePointer result = doPredicatesStandard(context, parents, steps, currentStep, predicates, currentPredicate); [EOL] assertNotNull(result); [EOL] }
private static NodePointer doPredicateIndex(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL] Expression predicate = predicates[currentPredicate]; [EOL] int index = indexFromPredicate(context, predicate); [EOL] NodePointer pointer = parent; [EOL] if (isCollectionElement(pointer, index)) { [EOL] pointer = (NodePointer) pointer.clone(); [EOL] pointer.setIndex(index); [EOL] return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL] } [EOL] return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, currentPredicate); [EOL] }
public void testIndexFromPredicateWithNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] Number number = 5; [EOL] when(predicate.computeValue(context)).thenReturn(number); [EOL] int result = indexFromPredicate(context, predicate); [EOL] assertEquals(4, result); [EOL] }
public void testIndexFromPredicateWithBooleanTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] when(predicate.computeValue(context)).thenReturn(Boolean.TRUE); [EOL] int result = indexFromPredicate(context, predicate); [EOL] assertEquals(0, result); [EOL] }
public void testIndexFromPredicateWithBooleanFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] when(predicate.computeValue(context)).thenReturn(Boolean.FALSE); [EOL] int result = indexFromPredicate(context, predicate); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexFromPredicateWithNull() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] when(predicate.computeValue(context)).thenReturn(null); [EOL] try { [EOL] indexFromPredicate(context, predicate); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Predicate value is null: " + predicate.toString(), e.getMessage()); [EOL] } [EOL] }
public void testIndexFromPredicateWithNodePointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(predicate.computeValue(context)).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn(5); [EOL] int result = indexFromPredicate(context, predicate); [EOL] assertEquals(4, result); [EOL] }
public void testIndexFromPredicateWithEvalContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(predicate.computeValue(context)).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn(5); [EOL] int result = indexFromPredicate(context, predicate); [EOL] assertEquals(4, result); [EOL] }
public void testKeyFromPredicateWithValidNameAttributeTest() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(NameAttributeTest.class); [EOL] Expression nameTestExpression = mock(Expression.class); [EOL] when(predicate.getNameTestExpression()).thenReturn(nameTestExpression); [EOL] when(nameTestExpression.computeValue(context)).thenReturn("expectedValue"); [EOL] String result = keyFromPredicate(context, predicate); [EOL] assertEquals("expectedValue", result); [EOL] }
public void testKeyFromPredicateWithInvalidType() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression predicate = mock(Expression.class); [EOL] try { [EOL] keyFromPredicate(context, predicate); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testComputeQualityWithNullPointer() { [EOL] int result = computeQuality(null); [EOL] assertEquals(PERFECT_MATCH, result); [EOL] }
public void testComputeQualityWithActualPointer() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] when(mockPointer.isActual()).thenReturn(true); [EOL] int result = computeQuality(mockPointer); [EOL] assertEquals(PERFECT_MATCH, result); [EOL] }
public void testComputeQualityWithNonActualPointer() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] NodePointer mockParentPointer = mock(NodePointer.class); [EOL] when(mockPointer.isActual()).thenReturn(false); [EOL] when(mockPointer.getImmediateParentPointer()).thenReturn(mockParentPointer); [EOL] when(mockParentPointer.isActual()).thenReturn(true); [EOL] int result = computeQuality(mockPointer); [EOL] assertEquals(PERFECT_MATCH - 1, result); [EOL] }
public void testComputeQualityWithMultipleNonActualPointers() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] NodePointer mockParentPointer = mock(NodePointer.class); [EOL] NodePointer mockGrandParentPointer = mock(NodePointer.class); [EOL] when(mockPointer.isActual()).thenReturn(false); [EOL] when(mockPointer.getImmediateParentPointer()).thenReturn(mockParentPointer); [EOL] when(mockParentPointer.isActual()).thenReturn(false); [EOL] when(mockParentPointer.getImmediateParentPointer()).thenReturn(mockGrandParentPointer); [EOL] when(mockGrandParentPointer.isActual()).thenReturn(true); [EOL] int result = computeQuality(mockPointer); [EOL] assertEquals(PERFECT_MATCH - 2, result); [EOL] }
public void testIsNameAttributeEqual_NullIterator() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] when(mockPointer.attributeIterator(QNAME_NAME)).thenReturn(null); [EOL] boolean result = isNameAttributeEqual(mockPointer, "anyName"); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeEqual_IteratorWithoutPosition() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] NodeIterator mockIterator = mock(NodeIterator.class); [EOL] when(mockPointer.attributeIterator(QNAME_NAME)).thenReturn(mockIterator); [EOL] when(mockIterator.setPosition(1)).thenReturn(false); [EOL] boolean result = isNameAttributeEqual(mockPointer, "anyName"); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeEqual_NameNotEqual() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] NodeIterator mockIterator = mock(NodeIterator.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockPointer.attributeIterator(QNAME_NAME)).thenReturn(mockIterator); [EOL] when(mockIterator.setPosition(1)).thenReturn(true); [EOL] when(mockIterator.getNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.getValue()).thenReturn("differentName"); [EOL] boolean result = isNameAttributeEqual(mockPointer, "anyName"); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeEqual_NameEqual() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] NodeIterator mockIterator = mock(NodeIterator.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockPointer.attributeIterator(QNAME_NAME)).thenReturn(mockIterator); [EOL] when(mockIterator.setPosition(1)).thenReturn(true); [EOL] when(mockIterator.getNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.getValue()).thenReturn("anyName"); [EOL] boolean result = isNameAttributeEqual(mockPointer, "anyName"); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionElementWithActualNonCollection() { [EOL] NodePointer mockPointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockPointer.isActual()).thenReturn(true); [EOL] Mockito.when(mockPointer.isCollection()).thenReturn(false); [EOL] boolean result = isCollectionElement(mockPointer, 0); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionElementWithNonActual() { [EOL] NodePointer mockPointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockPointer.isActual()).thenReturn(false); [EOL] boolean result = isCollectionElement(mockPointer, 0); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionElementWithActualCollectionInsideBounds() { [EOL] NodePointer mockPointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockPointer.isActual()).thenReturn(true); [EOL] Mockito.when(mockPointer.isCollection()).thenReturn(true); [EOL] Mockito.when(mockPointer.getLength()).thenReturn(5); [EOL] boolean result = isCollectionElement(mockPointer, 3); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionElementWithActualCollectionOutsideBounds() { [EOL] NodePointer mockPointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockPointer.isActual()).thenReturn(true); [EOL] Mockito.when(mockPointer.isCollection()).thenReturn(true); [EOL] Mockito.when(mockPointer.getLength()).thenReturn(2); [EOL] boolean result = isCollectionElement(mockPointer, 3); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionElementWithActualCollectionNegativeIndex() { [EOL] NodePointer mockPointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockPointer.isActual()).thenReturn(true); [EOL] Mockito.when(mockPointer.isCollection()).thenReturn(true); [EOL] boolean result = isCollectionElement(mockPointer, -1); [EOL] assertFalse(result); [EOL] }
public void testValuePointerWithNull() { [EOL] NodePointer result = valuePointer(null); [EOL] assertNull(result); [EOL] }
public void testValuePointerWithNonNull() { [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] NodePointer expectedValuePointer = mock(NodePointer.class); [EOL] when(mockPointer.getValuePointer()).thenReturn(expectedValuePointer); [EOL] NodePointer result = valuePointer(mockPointer); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValuePointer, result); [EOL] }
public void testCreateNullPointerWithCurrentStepEqualToStepsLength() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] int currentStep = 0; [EOL] NodePointer result = NodePointer.createNullPointer(context, parent, steps, currentStep); [EOL] assertEquals(parent, result); [EOL] }
public void testCreateNullPointerWithChildAxis() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("test"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] Step[] steps = {step}; [EOL] int currentStep = 0; [EOL] NodePointer result = NodePointer.createNullPointer(context, parent, steps, currentStep); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] assertEquals("test", ((NullPropertyPointer) result).getPropertyName()); [EOL] assertFalse(((NullPropertyPointer) result).isAttribute()); [EOL] }
public void testCreateNullPointerWithAttributeAxis() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName name = new QName("attribute"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(name); [EOL] when(step.getNodeTest()).thenReturn(nodeNameTest); [EOL] Step[] steps = {step}; [EOL] int currentStep = 0; [EOL] NodePointer result = NodePointer.createNullPointer(context, parent, steps, currentStep); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] assertEquals("attribute", ((NullPropertyPointer) result).getPropertyName()); [EOL] assertTrue(((NullPropertyPointer) result).isAttribute()); [EOL] }
public void testCreateNullPointerWithPredicates() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step step = mock(Step.class); [EOL] when(step.getAxis()).thenReturn(Compiler.AXIS_DESCENDANT); [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(Expression.class); [EOL] when(step.getPredicates()).thenReturn(predicates); [EOL] Step[] steps = {step}; [EOL] int currentStep = 0; [EOL] NodePointer result = NodePointer.createNullPointer(context, parent, steps, currentStep); [EOL] assertNotNull(result); [EOL] }
public void testCreateNullPointerForPredicatesWithEmptyPredicates() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[0]; [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateNullPointerForPredicatesWithNameAttributeTest() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(NameAttributeTest.class); [EOL] when(predicates[0].computeValue(context)).thenReturn("testKey"); [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] assertEquals("testKey", ((NullPropertyPointer) result).getNameAttributeValue()); [EOL] }
public void testCreateNullPointerForPredicatesWithNonNameAttributeTest() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[1]; [EOL] predicates[0] = mock(Expression.class); [EOL] when(predicates[0].computeValue(context)).thenReturn(1); [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullElementPointer || result instanceof NullPropertyPointer); [EOL] }
public void testCreateNullPointerForPredicatesWithMultiplePredicates() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Step[] steps = new Step[0]; [EOL] Expression[] predicates = new Expression[2]; [EOL] predicates[0] = mock(NameAttributeTest.class); [EOL] predicates[1] = mock(Expression.class); [EOL] when(predicates[0].computeValue(context)).thenReturn("testKey"); [EOL] when(predicates[1].computeValue(context)).thenReturn(1); [EOL] NodePointer result = createNullPointerForPredicates(context, parent, steps, 0, predicates, 0); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullElementPointer || result instanceof NullPropertyPointer); [EOL] }
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL] String prefix = qname.getPrefix(); [EOL] String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL] if (namespaceURI != null) { [EOL] nodeTest = new NodeNameTest(qname, namespaceURI); [EOL] } [EOL] return pointer.childIterator(nodeTest, false, null); [EOL] } else { [EOL] if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL] throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL] } [EOL] return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL] } [EOL] }
public PropertyDescriptor getPropertyDescriptor(String propertyName) { [EOL] if (propertyNames == null) { [EOL] PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL] String[] names = new String[pds.length]; [EOL] for (int i = 0; i < pds.length; i++) { [EOL] names[i] = pds[i].getName(); [EOL] } [EOL] propertyNames = names; [EOL] } [EOL] for (int i = 0; i < propertyNames.length; i++) { [EOL] if (propertyNames[i] == propertyName) { [EOL] return propertyDescriptors[i]; [EOL] } [EOL] } [EOL] for (int i = 0; i < propertyNames.length; i++) { [EOL] if (propertyNames[i].equals(propertyName)) { [EOL] return propertyDescriptors[i]; [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testSetValueWithNullParent() { [EOL] try { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathInvalidAccessException exception = assertThrows( [EOL] JXPathInvalidAccessException.class, [EOL] () -> context.setValue(null) [EOL] ); [EOL] assertEquals("Cannot set property /, the target object is null", exception.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Unexpected exception: " + e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetValueWithContainerParent() { [EOL] try { [EOL] JXPathContext context = JXPathContext.newContext(new Container()); [EOL] JXPathInvalidAccessException exception = assertThrows( [EOL] JXPathInvalidAccessException.class, [EOL] () -> context.setValue("value") [EOL] ); [EOL] assertEquals("Cannot set property /, the target object is null", exception.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Unexpected exception: " + e.getMessage()); [EOL] } [EOL] }
public void testSetValueWithPropertyOwnerPointerSupportingDynamicProperties() { [EOL] try { [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] when(parent.isDynamicPropertyDeclarationSupported()).thenReturn(true); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parent.getPropertyPointer()).thenReturn(propertyPointer); [EOL] JXPathContext context = JXPathContext.newContext(parent); [EOL] context.setValue("value"); [EOL] verify(propertyPointer).setPropertyName(anyString()); [EOL] verify(propertyPointer).setValue("value"); [EOL] } catch (Exception e) { [EOL] fail("Unexpected exception: " + e.getMessage()); [EOL] } [EOL] }
public void testSetValueWithNonChangeableLocation() { [EOL] try { [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] when(parent.isDynamicPropertyDeclarationSupported()).thenReturn(false); [EOL] JXPathContext context = JXPathContext.newContext(parent); [EOL] JXPathInvalidAccessException exception = assertThrows( [EOL] JXPathInvalidAccessException.class, [EOL] () -> context.setValue("value") [EOL] ); [EOL] assertEquals("Cannot set property /, path does not match a changeable location", exception.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Unexpected exception: " + e.getMessage()); [EOL] } [EOL] }
public void testGetPropertyNamesReturnsEmptyArray() { [EOL] String[] propertyNames = instance.getPropertyNames(); [EOL] assertNotNull("Property names should not be null", propertyNames); [EOL] assertEquals("Property names array should be empty", 0, propertyNames.length); [EOL] }
public void testAsPathWhenByNameAttributeIsFalse() { [EOL] instance.setByNameAttribute(false); [EOL] String result = instance.asPath(); [EOL] String expected = getExpectedPathWhenByNameAttributeIsFalse(); [EOL] assertEquals(expected, result); [EOL] }
public void testAsPathWhenByNameAttributeIsTrueAndIndexIsWholeCollection() { [EOL] instance.setByNameAttribute(true); [EOL] instance.setIndex(WHOLE_COLLECTION); [EOL] String result = instance.asPath(); [EOL] String expected = getExpectedPathWhenByNameAttributeIsTrueAndIndexIsWholeCollection(); [EOL] assertEquals(expected, result); [EOL] }
public void testAsPathWhenByNameAttributeIsTrueAndIndexIsNotWholeCollection() { [EOL] instance.setByNameAttribute(true); [EOL] instance.setIndex(1); // Set to a value different from WHOLE_COLLECTION [EOL] String result = instance.asPath(); [EOL] String expected = getExpectedPathWhenByNameAttributeIsTrueAndIndexIsNotWholeCollection(); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithSingleQuote() { [EOL] String input = "test'string"; [EOL] String expected = "test&apostring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithDoubleQuote() { [EOL] String input = "test\"string"; [EOL] String expected = "test&quotstring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithBothQuotes() { [EOL] String input = "test'str\"ing"; [EOL] String expected = "test&apostring&quoting"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithoutQuotes() { [EOL] String input = "teststring"; [EOL] String expected = "teststring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public boolean isLeafTest() { [EOL] boolean result = instance.isLeaf(); [EOL] assert result == true; // Assert that the result should be true as the method always returns true [EOL] }
public void testCoreOperationGreaterThanOrEqualWithNonNullArgs() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationGreaterThanOrEqual operation = new CoreOperationGreaterThanOrEqual(arg1, arg2); [EOL] assertNotNull(operation); [EOL] }
public void testCoreOperationGreaterThanOrEqualWithNullArgs() { [EOL] try { [EOL] new CoreOperationGreaterThanOrEqual(null, null); [EOL] fail("Should throw an exception if the arguments are null"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 3; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
protected boolean isSymmetric() { [EOL] return false; [EOL] }
public void testGetSymbol() { [EOL] ClassName instance = new ClassName(); [EOL] String result = instance.getSymbol(); [EOL] assertEquals(">=", result); [EOL] }
public void testStringValueWithString() { [EOL] String input = "testString"; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("testString", result); [EOL] }
public void testStringValueWithNumberDouble() { [EOL] Number input = 123.456; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("123.456", result); [EOL] }
public void testStringValueWithNumberLong() { [EOL] Number input = 123L; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("123", result); [EOL] }
public void testStringValueWithBooleanTrue() { [EOL] Boolean input = Boolean.TRUE; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("true", result); [EOL] }
public void testStringValueWithBooleanFalse() { [EOL] Boolean input = Boolean.FALSE; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("false", result); [EOL] }
public void testStringValueWithNull() { [EOL] Object input = null; [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("", result); [EOL] }
public void testStringValueWithNodePointer() { [EOL] NodePointer input = mock(NodePointer.class); [EOL] when(input.getValue()).thenReturn("nodeValue"); [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals("nodeValue", result); [EOL] }
public void testStringValueWithEvalContextWithPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.getValue()).thenReturn("pointerValue"); [EOL] String result = YourClass.stringValue(ctx); [EOL] assertEquals("pointerValue", result); [EOL] }
public void testStringValueWithEvalContextWithoutPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] String result = YourClass.stringValue(ctx); [EOL] assertEquals("", result); [EOL] }
public void testStringValueWithOtherObject() { [EOL] Object input = new Object(); [EOL] String result = YourClass.stringValue(input); [EOL] assertEquals(input.toString(), result); [EOL] }
public void testDoubleValueWithNumber() { [EOL] double expected = 123.456; [EOL] Object numberObject = new Double(expected); [EOL] double result = doubleValue(numberObject); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithBooleanTrue() { [EOL] double expected = 0.0; [EOL] Object booleanObject = Boolean.TRUE; [EOL] double result = doubleValue(booleanObject); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithBooleanFalse() { [EOL] double expected = 1.0; [EOL] Object booleanObject = Boolean.FALSE; [EOL] double result = doubleValue(booleanObject); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithEmptyString() { [EOL] double expected = 0.0; [EOL] Object stringObject = ""; [EOL] double result = doubleValue(stringObject); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithValidString() { [EOL] double expected = 123.456; [EOL] Object stringObject = "123.456"; [EOL] double result = doubleValue(stringObject); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithInvalidString() { [EOL] Object stringObject = "not a number"; [EOL] double result = doubleValue(stringObject); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testDoubleValueWithNodePointer() { [EOL] double expected = 123.456; [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(nodePointer.getValue()).thenReturn(expected); [EOL] double result = doubleValue(nodePointer); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNonNullEvalContext() { [EOL] double expected = 123.456; [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.getValue()).thenReturn(expected); [EOL] double result = doubleValue(ctx); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testDoubleValueWithNullEvalContext() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] double result = doubleValue(ctx); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testDoubleValueWithOtherObject() { [EOL] Object otherObject = new Object(); [EOL] double result = doubleValue(otherObject); [EOL] double expected = Double.parseDouble(stringValue(otherObject)); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testIsCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testEquals_SameObject() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] assertTrue(beanPointer.equals(beanPointer)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] Object other = new Object(); [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_NullParent() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.parent = null; [EOL] other.parent = new Object(); // Assuming parent is of type Object [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualParent() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] Object parent = new Object(); [EOL] beanPointer.parent = parent; [EOL] other.parent = parent; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentName() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.name = "name"; [EOL] other.name = null; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualName() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.name = "name"; [EOL] other.name = "name"; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentIndex() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.index = 1; [EOL] other.index = 2; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualIndex() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.index = 1; [EOL] other.index = 1; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualBeanSpecialTypes() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = "test"; [EOL] other.bean = "test"; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentBeanSpecialTypes() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = "test"; [EOL] other.bean = "different"; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualBeanGenericTypes() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] Object bean = new Object(); [EOL] beanPointer.bean = bean; [EOL] other.bean = bean; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentBeanGenericTypes() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = new Object(); [EOL] other.bean = new Object(); [EOL] assertFalse(beanPointer.equals(other)); [EOL] }

public void testSetValueWithWholeCollection() { [EOL] int WHOLE_COLLECTION = -1; // Assuming -1 is the constant value for WHOLE_COLLECTION [EOL] int index = WHOLE_COLLECTION; [EOL] Object value = new Object(); // Replace with appropriate value [EOL] PropertyHandler handler = mock(PropertyHandler.class); [EOL] Object bean = new Object(); // Replace with appropriate bean [EOL] String propertyName = "testProperty"; // Replace with appropriate property name [EOL] YourClass instance = new YourClass(index, handler, bean, propertyName); [EOL] instance.setValue(value); [EOL] verify(handler).setProperty(bean, propertyName, value); [EOL] }
public void testSetValueWithSpecificIndex() { [EOL] int specificIndex = 1; // Replace with a valid index other than WHOLE_COLLECTION [EOL] int index = specificIndex; [EOL] Object value = new Object(); // Replace with appropriate value [EOL] PropertyHandler handler = mock(PropertyHandler.class); [EOL] Object bean = new Object(); // Replace with appropriate bean [EOL] String propertyName = "testProperty"; // Replace with appropriate property name [EOL] Object propertyValue = new Object(); // Replace with appropriate property value [EOL] when(handler.getProperty(bean, propertyName)).thenReturn(propertyValue); [EOL] YourClass instance = new YourClass(index, handler, bean, propertyName); [EOL] instance.setValue(value); [EOL] verify(handler).getProperty(bean, propertyName); [EOL] verifyStatic(ValueUtils.class); [EOL] ValueUtils.setValue(propertyValue, specificIndex, value); [EOL] }
public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] }
private boolean constructIterator() { [EOL] HashSet set = new HashSet(); [EOL] ArrayList list = new ArrayList(); [EOL] while (nextSet()) { [EOL] while (nextNode()) { [EOL] NodePointer pointer = getCurrentNodePointer(); [EOL] if (!set.contains(pointer)) { [EOL] set.add(pointer); [EOL] list.add(pointer); [EOL] } [EOL] } [EOL] } [EOL] if (list.isEmpty()) { [EOL] return false; [EOL] } [EOL] if (getDocumentOrder() == 1) { [EOL] Collections.sort(list); [EOL] } else { [EOL] Collections.sort(list, REVERSE_COMPARATOR); [EOL] } [EOL] pointerIterator = list.iterator(); [EOL] return true; [EOL] }
public NodeSet getNodeSet() { [EOL] if (position != 0) { [EOL] throw new JXPathException("Simultaneous operations: " + "should not request pointer list while " + "iterating over an EvalContext"); [EOL] } [EOL] BasicNodeSet set = new BasicNodeSet(); [EOL] while (nextSet()) { [EOL] while (nextNode()) { [EOL] set.add((Pointer) getCurrentNodePointer().clone()); [EOL] } [EOL] } [EOL] return set; [EOL] }
public Object getValueTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] Object value = context.getValue(); [EOL] assertNotNull(value); [EOL] }
public void compareTest() { [EOL] Comparator reverseComparator = EvalContext.REVERSE_COMPARATOR; [EOL] int result = reverseComparator.compare("a", "b"); [EOL] assertTrue(result > 0); [EOL] }
public void getContextNodePointerTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] Pointer pointer = context.getContextNodePointer(); [EOL] assertNull(pointer); [EOL] }
public void getJXPathContextTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] JXPathContext jxPathContext = context.getJXPathContext(); [EOL] assertNull(jxPathContext); [EOL] }
public void getPositionTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] int position = context.getPosition(); [EOL] assertEquals(0, position); [EOL] }
public void getDocumentOrderTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(0, order); [EOL] }
public void isChildOrderingRequiredTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean required = context.isChildOrderingRequired(); [EOL] assertFalse(required); [EOL] }
public void hasNextTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean hasNext = context.hasNext(); [EOL] assertFalse(hasNext); [EOL] }
public void nextTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] try { [EOL] context.next(); [EOL] fail("Expected NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void removeTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] try { [EOL] context.remove(); [EOL] fail("Expected UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void getContextNodeListTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] List nodeList = context.getContextNodeList(); [EOL] assertNull(nodeList); [EOL] }
public void getNodeSetTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] NodeSet nodeSet = context.getNodeSet(); [EOL] assertNull(nodeSet); [EOL] }
public void toStringTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] String stringRepresentation = context.toString(); [EOL] assertNotNull(stringRepresentation); [EOL] }
public void getRootContextTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] RootContext rootContext = context.getRootContext(); [EOL] assertNull(rootContext); [EOL] }
public void resetTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.reset(); [EOL] assertEquals(0, context.getCurrentPosition()); [EOL] assertFalse(context.hasPerformedIteratorStep); [EOL] }
public void getCurrentPositionTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] int currentPosition = context.getCurrentPosition(); [EOL] assertEquals(0, currentPosition); [EOL] }
public void getSingleNodePointerTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] Pointer singleNodePointer = context.getSingleNodePointer(); [EOL] assertNull(singleNodePointer); [EOL] }
public void getCurrentNodePointerTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] NodePointer currentNodePointer = context.getCurrentNodePointer(); [EOL] assertNull(currentNodePointer); [EOL] }
public void nextSetTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean nextSet = context.nextSet(); [EOL] assertFalse(nextSet); [EOL] }
public void nextNodeTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean nextNode = context.nextNode(); [EOL] assertFalse(nextNode); [EOL] }
public void setPositionTest() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean setPosition = context.setPosition(1); [EOL] assertTrue(setPosition); [EOL] assertEquals(1, context.getCurrentPosition()); [EOL] }
public void testJXPathCompiledExpressionWithNonNullValues() { [EOL] String testXPath = "/test/path"; [EOL] Expression testExpression = new Expression() {}; // Assuming Expression is an interface or abstract class [EOL] JXPathCompiledExpression compiledExpression = new JXPathCompiledExpression(testXPath, testExpression); [EOL] assertNotNull(compiledExpression); [EOL] }
public void testJXPathCompiledExpressionWithNullValues() { [EOL] JXPathCompiledExpression compiledExpression = new JXPathCompiledExpression(null, null); [EOL] assertNotNull(compiledExpression); [EOL] }
public void testGetExpression() { [EOL] Expression result = testInstance.getExpression(); [EOL] assertEquals("The expression should be the expected one.", expectedExpression, result); [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL] if ((namespace == null && this.namespace != null) || (namespace != null && !namespace.equals(this.namespace))) { [EOL] return null; [EOL] } [EOL] if (parameters == null) { [EOL] parameters = EMPTY_ARRAY; [EOL] } [EOL] if (parameters.length >= 1) { [EOL] Object target = TypeUtils.convert(parameters[0], Object.class); [EOL] if (target != null) { [EOL] Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] if (target instanceof NodeSet) { [EOL] target = ((NodeSet) target).getPointers(); [EOL] } [EOL] method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] if (target instanceof Collection) { [EOL] Iterator iter = ((Collection) target).iterator(); [EOL] if (iter.hasNext()) { [EOL] target = iter.next(); [EOL] if (target instanceof Pointer) { [EOL] target = ((Pointer) target).getValue(); [EOL] } [EOL] } else { [EOL] target = null; [EOL] } [EOL] } [EOL] } [EOL] if (target != null) { [EOL] Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] } [EOL] } [EOL] String fullName = classPrefix + name; [EOL] int inx = fullName.lastIndexOf('.'); [EOL] if (inx == -1) { [EOL] return null; [EOL] } [EOL] String className = fullName.substring(0, inx); [EOL] String methodName = fullName.substring(inx + 1); [EOL] Class functionClass; [EOL] try { [EOL] functionClass = Class.forName(className); [EOL] } catch (ClassNotFoundException ex) { [EOL] throw new JXPathException("Cannot invoke extension function " + (namespace != null ? namespace + ":" + name : name), ex); [EOL] } [EOL] if (methodName.equals("new")) { [EOL] Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL] if (constructor != null) { [EOL] return new ConstructorFunction(constructor); [EOL] } [EOL] } else { [EOL] Method method = MethodLookupUtils.lookupStaticMethod(functionClass, methodName, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testJDOMAttributeIteratorWithElementAndSpecificName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] Namespace ns = Namespace.getNamespace("testPrefix", "testURI"); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", ns)).thenReturn(attribute); [EOL] when(element.getNamespace("testPrefix")).thenReturn(ns); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertTrue(iterator.attributes.contains(attribute)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndWildcardName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("*"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] List allAttributes = new ArrayList(); [EOL] allAttributes.add(attribute); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttributes()).thenReturn(allAttributes); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertTrue(iterator.attributes.contains(attribute)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndNoNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName(null, "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] Namespace ns = Namespace.NO_NAMESPACE; [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", ns)).thenReturn(attribute); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertTrue(iterator.attributes.contains(attribute)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndXmlNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("xml", "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", Namespace.XML_NAMESPACE)).thenReturn(attribute); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertTrue(iterator.attributes.contains(attribute)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndNullNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("nonExistingPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getNamespace("nonExistingPrefix")).thenReturn(null); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertTrue(iterator.attributes.isEmpty()); [EOL] }
public void testJDOMAttributeIteratorWithNonElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] when(parent.getNode()).thenReturn(mock(Node.class)); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNull(iterator.attributes); [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL] if (object == null) { [EOL] return true; [EOL] } [EOL] if (toType == Object.class) { [EOL] return true; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType)) { [EOL] return true; [EOL] } [EOL] if (toType.isAssignableFrom(fromType)) { [EOL] return true; [EOL] } [EOL] if (toType == String.class) { [EOL] return true; [EOL] } [EOL] if (object instanceof Boolean) { [EOL] if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Number) { [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof String) { [EOL] if (toType.isPrimitive()) { [EOL] return true; [EOL] } [EOL] if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL] return true; [EOL] } [EOL] } else if (fromType.isArray()) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] int length = Array.getLength(object); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (Array.getLength(object) > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] while (it.hasNext()) { [EOL] Object value = it.next(); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (((Collection) object).size() > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return canConvert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return canConvert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL] if (object == null) { [EOL] if (toType.isPrimitive()) { [EOL] return convertNullToPrimitive(toType); [EOL] } [EOL] return null; [EOL] } [EOL] if (toType == Object.class) { [EOL] if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return object; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL] return object; [EOL] } [EOL] if (fromType.isArray()) { [EOL] int length = Array.getLength(object); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] for (int i = 0; i < length; i++) { [EOL] collection.add(Array.get(object, i)); [EOL] } [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] int length = ((Collection) object).size(); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = it.next(); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] collection.addAll((Collection) object); [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } else if (toType == String.class) { [EOL] return object.toString(); [EOL] } else if (object instanceof Boolean) { [EOL] if (toType == boolean.class) { [EOL] return object; [EOL] } [EOL] boolean value = ((Boolean) object).booleanValue(); [EOL] return allocateNumber(toType, value ? 1 : 0); [EOL] } else if (object instanceof Number) { [EOL] double value = ((Number) object).doubleValue(); [EOL] if (toType == boolean.class || toType == Boolean.class) { [EOL] return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL] } [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return allocateNumber(toType, value); [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return object; [EOL] } [EOL] } else if (object instanceof String) { [EOL] Object value = convertStringToPrimitive(object, toType); [EOL] if (value != null) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter converter = ConvertUtils.lookup(toType); [EOL] if (converter != null) { [EOL] return converter.convert(toType, object); [EOL] } [EOL] throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
public void testConvertNullToPrimitiveBoolean() { [EOL] Object result = convertNullToPrimitive(boolean.class); [EOL] assert result instanceof Boolean; [EOL] assert result.equals(Boolean.FALSE); [EOL] }
public void testConvertNullToPrimitiveChar() { [EOL] Object result = convertNullToPrimitive(char.class); [EOL] assert result instanceof Character; [EOL] assert result.equals(new Character('\0')); [EOL] }
public void testConvertNullToPrimitiveByte() { [EOL] Object result = convertNullToPrimitive(byte.class); [EOL] assert result instanceof Byte; [EOL] assert result.equals(new Byte((byte) 0)); [EOL] }
public void testConvertNullToPrimitiveShort() { [EOL] Object result = convertNullToPrimitive(short.class); [EOL] assert result instanceof Short; [EOL] assert result.equals(new Short((short) 0)); [EOL] }
public void testConvertNullToPrimitiveInt() { [EOL] Object result = convertNullToPrimitive(int.class); [EOL] assert result instanceof Integer; [EOL] assert result.equals(new Integer(0)); [EOL] }
public void testConvertNullToPrimitiveLong() { [EOL] Object result = convertNullToPrimitive(long.class); [EOL] assert result instanceof Long; [EOL] assert result.equals(new Long(0L)); [EOL] }
public void testConvertNullToPrimitiveFloat() { [EOL] Object result = convertNullToPrimitive(float.class); [EOL] assert result instanceof Float; [EOL] assert result.equals(new Float(0.0f)); [EOL] }
public void testConvertNullToPrimitiveDouble() { [EOL] Object result = convertNullToPrimitive(double.class); [EOL] assert result instanceof Double; [EOL] assert result.equals(new Double(0.0)); [EOL] }
public void testConvertNullToPrimitiveNull() { [EOL] Object result = convertNullToPrimitive(null); [EOL] assert result == null; [EOL] }
public void testConvertStringToPrimitiveBooleanTrue() { [EOL] Object result = convertStringToPrimitive("true", boolean.class); [EOL] assertTrue(result instanceof Boolean); [EOL] assertTrue((Boolean) result); [EOL] }
public void testConvertStringToPrimitiveBooleanFalse() { [EOL] Object result = convertStringToPrimitive("false", Boolean.class); [EOL] assertTrue(result instanceof Boolean); [EOL] assertFalse((Boolean) result); [EOL] }
public void testConvertStringToPrimitiveChar() { [EOL] Object result = convertStringToPrimitive("a", char.class); [EOL] assertTrue(result instanceof Character); [EOL] assertEquals('a', ((Character) result).charValue()); [EOL] }
public void testConvertStringToPrimitiveByte() { [EOL] Object result = convertStringToPrimitive("1", byte.class); [EOL] assertTrue(result instanceof Byte); [EOL] assertEquals((byte) 1, ((Byte) result).byteValue()); [EOL] }
public void testConvertStringToPrimitiveShort() { [EOL] Object result = convertStringToPrimitive("1", short.class); [EOL] assertTrue(result instanceof Short); [EOL] assertEquals((short) 1, ((Short) result).shortValue()); [EOL] }
public void testConvertStringToPrimitiveInt() { [EOL] Object result = convertStringToPrimitive("1", int.class); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(1, ((Integer) result).intValue()); [EOL] }
public void testConvertStringToPrimitiveLong() { [EOL] Object result = convertStringToPrimitive("1", long.class); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(1L, ((Long) result).longValue()); [EOL] }
public void testConvertStringToPrimitiveFloat() { [EOL] Object result = convertStringToPrimitive("1.0", float.class); [EOL] assertTrue(result instanceof Float); [EOL] assertEquals(1.0f, ((Float) result).floatValue(), 0.0f); [EOL] }
public void testConvertStringToPrimitiveDouble() { [EOL] Object result = convertStringToPrimitive("1.0", double.class); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(1.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testConvertStringToPrimitiveNull() { [EOL] Object result = convertStringToPrimitive("test", String.class); [EOL] assertNull(result); [EOL] }
public void testDeclareVariableWithNonNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.declareVariable("testVar", new Object()); [EOL] Object result = context.getVariables().get("testVar"); [EOL] assertNotNull(result); [EOL] } [EOL] public void testDeclareVariableWithNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.declareVariable("testVar", null); [EOL] Object result = context.getVariables().get("testVar"); [EOL] assertNull(result); [EOL] } [EOL] public void testDeclareVariableWithExistingName() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object initialValue = new Object(); [EOL] context.declareVariable("testVar", initialValue); [EOL] Object newValue = new Object(); [EOL] context.declareVariable("testVar", newValue); [EOL] Object result = context.getVariables().get("testVar"); [EOL] assertSame(newValue, result); [EOL] }
public void testUndeclareVariable_ExistingVar() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.declareVariable("testVar", "testValue"); [EOL] context.undeclareVariable("testVar"); [EOL] assertNull(context.getVariables().get("testVar")); [EOL] }
public void testUndeclareVariable_NonExistingVar() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.undeclareVariable("nonExistingVar"); [EOL] assertNull(context.getVariables().get("nonExistingVar")); [EOL] }
public void testCoreOperationLessThanOrEqualInstantiation() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationLessThanOrEqual operation = new CoreOperationLessThanOrEqual(arg1, arg2); [EOL] assertNotNull(operation); [EOL] }
public String getSymbol() { [EOL] return "<="; [EOL] }
public void testBackupWithPositiveAmountLessThanBufpos() { [EOL] int amount = 10; [EOL] int initialBufpos = 20; [EOL] int initialInBuf = 5; [EOL] int bufsize = 50; [EOL] YourClass instance = new YourClass(initialBufpos, initialInBuf, bufsize); [EOL] instance.backup(amount); [EOL] assertEquals(initialInBuf + amount, instance.getInBuf()); [EOL] assertEquals(initialBufpos - amount, instance.getBufpos()); [EOL] }
public void testBackupWithPositiveAmountGreaterThanBufpos() { [EOL] int amount = 60; [EOL] int initialBufpos = 50; [EOL] int initialInBuf = 5; [EOL] int bufsize = 100; [EOL] YourClass instance = new YourClass(initialBufpos, initialInBuf, bufsize); [EOL] instance.backup(amount); [EOL] assertEquals(initialInBuf + amount, instance.getInBuf()); [EOL] assertEquals(initialBufpos - amount + bufsize, instance.getBufpos()); [EOL] }
public void testSimpleCharStreamWithValidInput() { [EOL] Reader dstream = new StringReader("test data"); [EOL] int startline = 1; [EOL] int startcolumn = 1; [EOL] int buffersize = 1024; [EOL] SimpleCharStream charStream = new SimpleCharStream(dstream, startline, startcolumn, buffersize); [EOL] assertNotNull(charStream.inputStream); [EOL] assertEquals(startline, charStream.line); [EOL] assertEquals(startcolumn - 1, charStream.column); [EOL] assertEquals(buffersize, charStream.available); [EOL] assertEquals(buffersize, charStream.bufsize); [EOL] assertNotNull(charStream.buffer); [EOL] assertEquals(buffersize, charStream.buffer.length); [EOL] assertNotNull(charStream.bufline); [EOL] assertEquals(buffersize, charStream.bufline.length); [EOL] assertNotNull(charStream.bufcolumn); [EOL] assertEquals(buffersize, charStream.bufcolumn.length); [EOL] }
public void testSimpleCharStreamWithValidInput() { [EOL] java.io.Reader dstream = new java.io.StringReader("Test input"); [EOL] int startline = 1; [EOL] int startcolumn = 1; [EOL] SimpleCharStream charStream = new SimpleCharStream(dstream, startline, startcolumn); [EOL] assertNotNull(charStream); [EOL] }
public void testIsDynamicPropertyDeclarationSupported() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isDynamicPropertyDeclarationSupported(); [EOL] assertTrue(result); [EOL] }
public void testComputeValueWhenEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[2]; [EOL] args[0] = "testValue"; [EOL] args[1] = "testValue"; [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testComputeValueWhenNotEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object[] args = new Object[2]; [EOL] args[0] = "testValue1"; [EOL] args[1] = "testValue2"; [EOL] MyClass myClass = new MyClass(args); [EOL] Object result = myClass.computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testGetNodePointer_PositionZero_NameNotNull_TargetNotReady_Empty() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = "someName"; [EOL] instance.targetReady = false; [EOL] instance.empty = true; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNotNull_TargetReady_NotEmpty() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = "someName"; [EOL] instance.targetReady = true; [EOL] instance.empty = false; [EOL] instance.propertyNodePointer = mock(PropertyNodePointer.class); [EOL] when(instance.propertyNodePointer.getValuePointer()).thenReturn(mock(NodePointer.class)); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNull_SetPositionFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = null; [EOL] instance.targetReady = false; // Irrelevant in this case, but included for completeness [EOL] doReturn(false).when(instance).setPosition(1); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionNotZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 1; [EOL] instance.propertyNodePointer = mock(PropertyNodePointer.class); [EOL] when(instance.propertyNodePointer.getValuePointer()).thenReturn(mock(NodePointer.class)); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_ThrowsException() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 1; [EOL] instance.propertyNodePointer = mock(PropertyNodePointer.class); [EOL] when(instance.propertyNodePointer.getValuePointer()).thenThrow(new RuntimeException()); [EOL] when(instance.propertyNodePointer.getImmediateParentPointer()).thenReturn(mock(NodePointer.class)); [EOL] when(instance.propertyNodePointer.getPropertyName()).thenReturn("propertyName"); [EOL] when(instance.propertyNodePointer.getIndex()).thenReturn(1); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] }
public void testGetLengthWithValidPropertyNodePointer() { [EOL] PropertyNodePointer mockPropertyNodePointer = Mockito.mock(PropertyNodePointer.class); [EOL] Mockito.when(mockPropertyNodePointer.getLength()).thenReturn(5); [EOL] YourClass instance = new YourClass(mockPropertyNodePointer); [EOL] int result = instance.getLength(); [EOL] assertEquals(5, result); [EOL] }
public void testGetLengthWithException() { [EOL] PropertyNodePointer mockPropertyNodePointer = Mockito.mock(PropertyNodePointer.class); [EOL] Mockito.when(mockPropertyNodePointer.getLength()).thenThrow(new RuntimeException()); [EOL] YourClass instance = new YourClass(mockPropertyNodePointer); [EOL] int result = instance.getLength(); [EOL] assertEquals(0, result); [EOL] }
public void testGetFunctionWithNullByNamespace() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertEquals("Expected function name", name, result.getName()); [EOL] }
public void testGetFunctionWithFunctionsInstance() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Functions functions = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(functions.getFunction(namespace, name, parameters)).thenReturn(expectedFunction); [EOL] byNamespace.put(namespace, functions); [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertSame("Expected function instance", expectedFunction, result); [EOL] }
public void testGetFunctionWithListInstance() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Functions functions1 = mock(Functions.class); [EOL] Functions functions2 = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(functions1.getFunction(namespace, name, parameters)).thenReturn(null); [EOL] when(functions2.getFunction(namespace, name, parameters)).thenReturn(expectedFunction); [EOL] List<Functions> functionsList = new ArrayList<>(); [EOL] functionsList.add(functions1); [EOL] functionsList.add(functions2); [EOL] byNamespace.put(namespace, functionsList); [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertSame("Expected function instance", expectedFunction, result); [EOL] }
public void testGetFunctionReturnsNull() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Functions functions = mock(Functions.class); [EOL] when(functions.getFunction(namespace, name, parameters)).thenReturn(null); [EOL] byNamespace.put(namespace, functions); [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testPrepareCacheWithEmptyAllFunctions() { [EOL] allFunctions = new ArrayList(); // Initialize with an empty list [EOL] prepareCache(); // Call the method under test [EOL] assertTrue(byNamespace.isEmpty()); // Assert that byNamespace is empty as allFunctions was empty [EOL] }
public void testPrepareCacheWithSingleFunctionNoNamespaces() { [EOL] allFunctions = new ArrayList(); [EOL] Functions singleFunction = new Functions(); // Stub or mock of Functions [EOL] when(singleFunction.getUsedNamespaces()).thenReturn(Collections.emptySet()); // Assuming no namespaces used [EOL] allFunctions.add(singleFunction); [EOL] prepareCache(); [EOL] assertTrue(byNamespace.isEmpty()); // Assert that byNamespace is empty as no namespaces are used [EOL] }
public void testPrepareCacheWithSingleFunctionSingleNamespace() { [EOL] allFunctions = new ArrayList(); [EOL] Functions singleFunction = new Functions(); // Stub or mock of Functions [EOL] Set<String> namespaces = new HashSet<>(); [EOL] namespaces.add("http://example.com/ns"); // Add a single namespace [EOL] when(singleFunction.getUsedNamespaces()).thenReturn(namespaces); [EOL] allFunctions.add(singleFunction); [EOL] prepareCache(); [EOL] assertEquals(1, byNamespace.size()); // Assert that byNamespace has one entry [EOL] assertSame(singleFunction, byNamespace.get("http://example.com/ns")); // Assert that the function is mapped to the namespace [EOL] }
public void testPrepareCacheWithMultipleFunctionsSameNamespace() { [EOL] allFunctions = new ArrayList(); [EOL] Functions firstFunction = new Functions(); // Stub or mock of Functions [EOL] Functions secondFunction = new Functions(); // Another stub or mock of Functions [EOL] Set<String> namespaces = new HashSet<>(); [EOL] namespaces.add("http://example.com/ns"); // Both functions use the same namespace [EOL] when(firstFunction.getUsedNamespaces()).thenReturn(namespaces); [EOL] when(secondFunction.getUsedNamespaces()).thenReturn(namespaces); [EOL] allFunctions.add(firstFunction); [EOL] allFunctions.add(secondFunction); [EOL] prepareCache(); [EOL] assertEquals(1, byNamespace.size()); // Assert that byNamespace has one entry [EOL] Object candidates = byNamespace.get("http://example.com/ns"); [EOL] assertTrue(candidates instanceof List); // Assert that it's a list [EOL] List candidateList = (List) candidates; [EOL] assertEquals(2, candidateList.size()); // Assert that the list has two functions [EOL] assertTrue(candidateList.contains(firstFunction) && candidateList.contains(secondFunction)); // Assert both functions are in the list [EOL] }
public void testPrepareCacheWithMultipleFunctionsDifferentNamespaces() { [EOL] allFunctions = new ArrayList(); [EOL] Functions firstFunction = new Functions(); // Stub or mock of Functions [EOL] Functions secondFunction = new Functions(); // Another stub or mock of Functions [EOL] Set<String> firstNamespaces = new HashSet<>(); [EOL] Set<String> secondNamespaces = new HashSet<>(); [EOL] firstNamespaces.add("http://example.com/ns1"); [EOL] secondNamespaces.add("http://example.com/ns2"); [EOL] when(firstFunction.getUsedNamespaces()).thenReturn(firstNamespaces); [EOL] when(secondFunction.getUsedNamespaces()).thenReturn(secondNamespaces); [EOL] allFunctions.add(firstFunction); [EOL] allFunctions.add(secondFunction); [EOL] prepareCache(); [EOL] assertEquals(2, byNamespace.size()); // Assert that byNamespace has two entries [EOL] assertSame(firstFunction, byNamespace.get("http://example.com/ns1")); // Assert that the first function is mapped to its namespace [EOL] assertSame(secondFunction, byNamespace.get("http://example.com/ns2")); // Assert that the second function is mapped to its namespace [EOL] }
public void testModWithValidExpressions() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] Object result = mod(left, right); [EOL] assertTrue(result instanceof CoreOperationMod); [EOL] CoreOperationMod modResult = (CoreOperationMod) result; [EOL] assertSame(left, modResult.getLeft()); [EOL] assertSame(right, modResult.getRight()); [EOL] }
public void testIsNameAttributeTest_NotInstanceOfLocationPath() { [EOL] Expression arg = mock(Expression.class); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_StepsNotEqualOne() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] when(arg.getSteps()).thenReturn(new Step[2]); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_StepAxisNotAttribute() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NodeTestNotInstanceOfNodeNameTest() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeTest); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NodeNameNotEqualsQNAME_NAME() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class)); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_ValidCase() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[]{mock(Step.class)}; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(QNAME_NAME); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertTrue(result); [EOL] }
public void testGetPropertyIndexWhenUnspecified() { [EOL] this.propertyIndex = UNSPECIFIED_PROPERTY; [EOL] this.name = "testName"; [EOL] String[] mockPropertyNames = {"testName"}; [EOL] int result = getPropertyIndex(); [EOL] assertEquals("The property index should be updated to the index of 'testName'", 0, result); [EOL] }
public void testGetPropertyIndexWhenSpecified() { [EOL] this.propertyIndex = 1; // Any value other than UNSPECIFIED_PROPERTY [EOL] this.name = "testName"; [EOL] int result = getPropertyIndex(); [EOL] assertEquals("The property index should be the specified value", 1, result); [EOL] }
public void testCoreOperationMultiplyWithBothArgsNonNull() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationMultiply multiply = new CoreOperationMultiply(arg1, arg2); [EOL] assertNotNull(multiply); [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 5; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetSymbol() { [EOL] MyClass instance = new MyClass(); [EOL] String expected = "*"; [EOL] String actual = instance.getSymbol(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCoreOperationModConstructor() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationMod operationMod = new CoreOperationMod(arg1, arg2); [EOL] }
public void testGetSymbol() { [EOL] ClassName instance = new ClassName(); [EOL] String result = instance.getSymbol(); [EOL] assertEquals("mod", result); [EOL] }
public void testStepConstructor() { [EOL] int axis = 1; [EOL] NodeTest nodeTest = new NodeTest(); [EOL] Expression[] predicates = new Expression[0]; [EOL] Step step = new Step(axis, nodeTest, predicates); [EOL] assertNotNull(step); [EOL] assertEquals(axis, step.getAxis()); [EOL] assertEquals(nodeTest, step.getNodeTest()); [EOL] assertArrayEquals(predicates, step.getPredicates()); [EOL] }
public void testGetAxis() { [EOL] int expectedAxisValue = 5; [EOL] MyClass obj = new MyClass(); [EOL] obj.setAxis(expectedAxisValue); // This line is hypothetical, as we don't have the actual method to set the axis [EOL] int result = obj.getAxis(); [EOL] assertEquals(expectedAxisValue, result); [EOL] }
public void testGetNodeTest() { [EOL] NodeTest expected = instance.nodeTest; [EOL] NodeTest actual = instance.getNodeTest(); [EOL] assertEquals(expected, actual); [EOL] }
public Expression[] getPredicates() { [EOL] return predicates; [EOL] }
public void testGetNamespaceURIWithNullPrefixAndNoPointerNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String prefix = null; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceURIWithValidPrefixAndNoPointerNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.registerNamespace("testPrefix", "http://test.com/"); [EOL] String prefix = "testPrefix"; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://test.com/", result); [EOL] }
public void testGetNamespaceURIWithNullPrefixAndPointerButNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Pointer pointer = mock(Pointer.class); [EOL] when(pointer.getNamespaceURI(null)).thenReturn("http://pointer.com/"); [EOL] context.setPointer(pointer); [EOL] String prefix = null; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://pointer.com/", result); [EOL] }
public void testGetNamespaceURIWithNullPrefixNoPointerAndParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] parentContext.registerNamespace("testPrefix", "http://parent.com/"); [EOL] JXPathContext context = JXPathContext.newContext(parentContext); [EOL] String prefix = "testPrefix"; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://parent.com/", result); [EOL] }
public void testGetPrefixWithNullReverseMapAndNonNullNamespaceIterator() { [EOL] setupWithNullReverseMapAndNonNullNamespaceIterator(); [EOL] String namespaceURI = "http://example.com/ns"; [EOL] String expectedPrefix = "ex"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertEquals(expectedPrefix, actualPrefix); [EOL] }
public void testGetPrefixWithNullReverseMapAndNullNamespaceIterator() { [EOL] setupWithNullReverseMapAndNullNamespaceIterator(); [EOL] String namespaceURI = "http://example.com/ns"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertNull(actualPrefix); [EOL] }
public void testGetPrefixWithNonNullReverseMap() { [EOL] setupWithNonNullReverseMap(); [EOL] String namespaceURI = "http://example.com/ns"; [EOL] String expectedPrefix = "ex"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertEquals(expectedPrefix, actualPrefix); [EOL] }
public void testGetPrefixWithParentNotNull() { [EOL] setupWithParentNotNull(); [EOL] String namespaceURI = "http://example.com/ns"; [EOL] String expectedPrefix = "ex"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertEquals(expectedPrefix, actualPrefix); [EOL] }
public void testNewContextWithNonNullContextBean() { [EOL] Object contextBean = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(contextBean); [EOL] assertNotNull("Context should not be null", context); [EOL] }
public void testNewContextWithNullContextBean() { [EOL] Object contextBean = null; [EOL] try { [EOL] JXPathContext.newContext(contextBean); [EOL] fail("Should throw IllegalArgumentException for null contextBean"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNewContextWithNullParentContextAndNullContextBean() { [EOL] try { [EOL] JXPathContext.newContext(null, null); [EOL] fail("Should have thrown IllegalArgumentException for null contextBean"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNewContextWithNullParentContext() { [EOL] Object contextBean = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(null, contextBean); [EOL] assertNotNull("Context should not be null", context); [EOL] }
public void testNewContextWithValidParentContextAndContextBean() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null, new Object()); [EOL] Object contextBean = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(parentContext, contextBean); [EOL] assertNotNull("Context should not be null", context); [EOL] assertSame("Parent context should be the one provided", parentContext, context.getParentContext()); [EOL] }
public void testGetContextFactoryWhenNull() { [EOL] assertNull("contextFactory should be null before initialization", JXPathContextFactoryTest.contextFactory); [EOL] JXPathContextFactory result = JXPathContextFactoryTest.getContextFactory(); [EOL] assertNotNull("contextFactory should not be null after getContextFactory", result); [EOL] }
public void testGetContextFactoryWhenNotNull() { [EOL] JXPathContextFactory firstCallResult = JXPathContextFactoryTest.getContextFactory(); [EOL] assertNotNull("contextFactory should not be null after first getContextFactory", firstCallResult); [EOL] JXPathContextFactory secondCallResult = JXPathContextFactoryTest.getContextFactory(); [EOL] assertSame("contextFactory should be the same for subsequent calls", firstCallResult, secondCallResult); [EOL] }
public void testGetFunctionsWhenFunctionsIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Functions expectedFunctions = new Functions(); [EOL] context.setFunctions(expectedFunctions); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertEquals(expectedFunctions, actualFunctions); [EOL] }
public void testGetFunctionsWhenFunctionsIsNullAndParentContextIsNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFunctions(null); [EOL] context.setParentContext(null); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertEquals(Functions.GENERIC_FUNCTIONS, actualFunctions); [EOL] }
public void testGetFunctionsWhenFunctionsIsNullAndParentContextIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFunctions(null); [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] context.setParentContext(parentContext); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertNull(actualFunctions); [EOL] }
public void testGetLocale_WithNullLocaleAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Locale result = context.getLocale(); [EOL] assertEquals("Expected default locale", Locale.getDefault(), result); [EOL] }
public void testGetLocale_WithNullLocaleAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] parentContext.setLocale(Locale.FRENCH); [EOL] Locale result = childContext.getLocale(); [EOL] assertEquals("Expected parent context locale", Locale.FRENCH, result); [EOL] }
public void testGetLocale_WithNonNullLocale() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(Locale.GERMAN); [EOL] Locale result = context.getLocale(); [EOL] assertEquals("Expected set locale", Locale.GERMAN, result); [EOL] }
public void testSetDecimalFormatSymbols_NewMap() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] DecimalFormatSymbols symbols = new DecimalFormatSymbols(); [EOL] context.setDecimalFormatSymbols("custom", symbols); [EOL] assertEquals("DecimalFormatSymbols should be set", symbols, context.getDecimalFormatSymbols("custom")); [EOL] }
public void testSetDecimalFormatSymbols_ExistingMap() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] DecimalFormatSymbols symbols1 = new DecimalFormatSymbols(); [EOL] DecimalFormatSymbols symbols2 = new DecimalFormatSymbols(); [EOL] context.setDecimalFormatSymbols("custom1", symbols1); [EOL] context.setDecimalFormatSymbols("custom2", symbols2); [EOL] assertEquals("DecimalFormatSymbols for 'custom1' should be set", symbols1, context.getDecimalFormatSymbols("custom1")); [EOL] assertEquals("DecimalFormatSymbols for 'custom2' should be set", symbols2, context.getDecimalFormatSymbols("custom2")); [EOL] }
public void testGetDecimalFormatSymbolsWithNullDecimalFormatsAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] DecimalFormatSymbols result = context.getDecimalFormatSymbols("USD"); [EOL] assertNull("Expected null when decimalFormats and parentContext are null", result); [EOL] }
public void testGetDecimalFormatSymbolsWithNullDecimalFormatsAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext, new Object()); [EOL] DecimalFormatSymbols expectedSymbols = new DecimalFormatSymbols(); [EOL] when(parentContext.getDecimalFormatSymbols("USD")).thenReturn(expectedSymbols); [EOL] DecimalFormatSymbols result = childContext.getDecimalFormatSymbols("USD"); [EOL] assertSame("Expected DecimalFormatSymbols from parentContext", expectedSymbols, result); [EOL] }
public void testGetDecimalFormatSymbolsWithNonNullDecimalFormats() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] DecimalFormatSymbols expectedSymbols = new DecimalFormatSymbols(); [EOL] Map decimalFormats = new HashMap(); [EOL] decimalFormats.put("USD", expectedSymbols); [EOL] setInternalState(context, "decimalFormats", decimalFormats); [EOL] DecimalFormatSymbols result = context.getDecimalFormatSymbols("USD"); [EOL] assertSame("Expected DecimalFormatSymbols from decimalFormats map", expectedSymbols, result); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL] try { [EOL] Object target; [EOL] Object[] args; [EOL] if (Modifier.isStatic(method.getModifiers())) { [EOL] target = null; [EOL] if (parameters == null) { [EOL] parameters = EMPTY_ARRAY; [EOL] } [EOL] int pi = 0; [EOL] Class[] types = method.getParameterTypes(); [EOL] if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL] pi = 1; [EOL] } [EOL] args = new Object[parameters.length + pi]; [EOL] if (pi == 1) { [EOL] args[0] = context; [EOL] } [EOL] for (int i = 0; i < parameters.length; i++) { [EOL] args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL] } [EOL] } else { [EOL] int pi = 0; [EOL] Class[] types = method.getParameterTypes(); [EOL] if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL] pi = 1; [EOL] } [EOL] target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); [EOL] args = new Object[parameters.length - 1 + pi]; [EOL] if (pi == 1) { [EOL] args[0] = context; [EOL] } [EOL] for (int i = 1; i < parameters.length; i++) { [EOL] args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); [EOL] } [EOL] } [EOL] return method.invoke(target, args); [EOL] } catch (Throwable ex) { [EOL] if (ex instanceof InvocationTargetException) { [EOL] ex = ((InvocationTargetException) ex).getTargetException(); [EOL] } [EOL] throw new JXPathInvalidAccessException("Cannot invoke " + method, ex); [EOL] } [EOL] }
public void testSetValueWithContainerParent() { [EOL] ParentContainer parent = mock(ParentContainer.class); [EOL] when(parent.isContainer()).thenReturn(true); [EOL] MyClass instance = new MyClass(parent, -1); // Assuming -1 is not WHOLE_COLLECTION [EOL] Object sampleValue = new Object(); [EOL] instance.setValue(sampleValue); [EOL] verify(parent).setValue(sampleValue); [EOL] }
public void testSetValueWithNonContainerParentAndWholeCollection() { [EOL] ParentContainer parent = mock(ParentContainer.class); [EOL] when(parent.isContainer()).thenReturn(false); [EOL] MyClass instance = new MyClass(parent, MyClass.WHOLE_COLLECTION); [EOL] Object sampleValue = new Object(); [EOL] try { [EOL] instance.setValue(sampleValue); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testSetValueWithNonContainerParentAndInvalidIndex() { [EOL] ParentContainer parent = mock(ParentContainer.class); [EOL] when(parent.isContainer()).thenReturn(false); [EOL] MyClass instance = new MyClass(parent, 1); // Assuming 1 is a valid index but the element does not exist [EOL] Object sampleValue = new Object(); [EOL] try { [EOL] instance.setValue(sampleValue); [EOL] fail("Expected a JXPathInvalidAccessException to be thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] } [EOL] }
public void testSetValueWithNullParent() { [EOL] MyClass instance = new MyClass(null, -1); // Assuming -1 is not WHOLE_COLLECTION [EOL] Object sampleValue = new Object(); [EOL] try { [EOL] instance.setValue(sampleValue); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
protected boolean isSimpleStep(Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_SELF) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeTypeTest)) { [EOL] return false; [EOL] } [EOL] int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL] if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeNameTest)) { [EOL] return false; [EOL] } [EOL] if (((NodeNameTest) nodeTest).isWildcard()) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } [EOL] return false; [EOL] }
public void testSearchForPathWithNonNullPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(buildContextChain(context, steps.length, true)).thenReturn(ctx); [EOL] when(ctx.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testSearchForPathWithNullPointerAndSimpleSteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(buildContextChain(context, steps.length, true)).thenReturn(ctx); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] for (int i = 0; i < steps.length; i++) { [EOL] when(isSimpleStep(steps[i])).thenReturn(true); [EOL] } [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithNullPointerAndComplexStep() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(buildContextChain(context, steps.length, true)).thenReturn(ctx); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] when(isSimpleStep(steps[steps.length - 1])).thenReturn(false); [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialPointerAndNoNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer partialPointer = mock(NodePointer.class); [EOL] when(buildContextChain(context, steps.length, true)).thenReturn(ctx); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] when(isSimpleStep(anyInt())).thenReturn(true); [EOL] when(buildContextChain(context, steps.length - 1, true)).thenReturn(ctx); [EOL] when(ctx.hasNext()).thenReturn(true).thenReturn(false); [EOL] when(ctx.next()).thenReturn(partialPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
public void testSearchForPathWithPartialPointerAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer partialPointer = mock(Pointer.class); [EOL] when(buildContextChain(context, steps.length, true)).thenReturn(ctx); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] when(isSimpleStep(anyInt())).thenReturn(true); [EOL] when(buildContextChain(context, steps.length - 1, true)).thenReturn(ctx); [EOL] when(ctx.hasNext()).thenReturn(true).thenReturn(true); [EOL] when(ctx.next()).thenReturn(partialPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testRemoveWithActualFalse() { [EOL] context.setActual(false); [EOL] context.remove(); [EOL] }
public void testRemoveWithActualTrueAndWholeCollection() { [EOL] context.setActual(true); [EOL] context.setIndex(WHOLE_COLLECTION); [EOL] context.remove(); [EOL] verify(variables).undeclareVariable(name.toString()); [EOL] }
public void testRemoveWithActualTrueAndNegativeIndex() { [EOL] context.setActual(true); [EOL] context.setIndex(-1); [EOL] try { [EOL] context.remove(); [EOL] fail("Expected JXPathInvalidAccessException to be thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] assertEquals("Index is less than 1: " + context.asPath(), e.getMessage()); [EOL] } [EOL] }
public void testRemoveWithActualTrueAndValidIndex() { [EOL] context.setActual(true); [EOL] context.setIndex(1); [EOL] context.setBaseValue(new ArrayList<>()); [EOL] context.remove(); [EOL] verify(variables).declareVariable(name.toString(), any()); [EOL] }
public void testRemoveWithActualTrueAndIndexOutOfBounds() { [EOL] context.setActual(true); [EOL] context.setIndex(10); [EOL] context.setBaseValue(new ArrayList<>()); [EOL] context.remove(); [EOL] verify(variables, never()).declareVariable(anyString(), any()); [EOL] }
public void testCompareTo_SameParentNull() { [EOL] NodePointer pointer1 = new NodePointer(); [EOL] pointer1.parent = null; [EOL] NodePointer pointer2 = new NodePointer(); [EOL] pointer2.parent = null; [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_SameParentNonNull() { [EOL] NodePointer parent = new NodePointer(); [EOL] NodePointer pointer1 = new NodePointer(); [EOL] pointer1.parent = parent; [EOL] NodePointer pointer2 = new NodePointer(); [EOL] pointer2.parent = parent; [EOL] when(parent.compareChildNodePointers(pointer1, pointer2)).thenReturn(1); [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(1, result); [EOL] }
public void testCompareTo_DifferentParents() { [EOL] NodePointer parent1 = new NodePointer(); [EOL] NodePointer parent2 = new NodePointer(); [EOL] NodePointer pointer1 = new NodePointer(); [EOL] pointer1.parent = parent1; [EOL] NodePointer pointer2 = new NodePointer(); [EOL] pointer2.parent = parent2; [EOL] when(compareNodePointers(pointer1, 1, pointer2, 1)).thenReturn(-1); [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_DifferentDepth() { [EOL] NodePointer grandparent = new NodePointer(); [EOL] NodePointer parent = new NodePointer(); [EOL] parent.parent = grandparent; [EOL] NodePointer pointer1 = new NodePointer(); [EOL] pointer1.parent = parent; [EOL] NodePointer pointer2 = new NodePointer(); [EOL] pointer2.parent = grandparent; [EOL] when(compareNodePointers(pointer1, 2, pointer2, 1)).thenReturn(1); [EOL] int result = pointer1.compareTo(pointer2); [EOL] assertEquals(1, result); [EOL] }
public void testGetNameWithPrefix() { [EOL] Attr attr = document.createAttributeNS("http://example.com", "ex:attrName"); [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(attr, new DocumentContainer(document)); [EOL] QName result = nodePointer.getName(); [EOL] assertEquals("ex", result.getPrefix()); [EOL] assertEquals("attrName", result.getLocalPart()); [EOL] assertEquals("http://example.com", result.getNamespaceURI()); [EOL] }
public void testGetNameWithoutPrefix() { [EOL] Attr attr = document.createAttribute("attrName"); [EOL] JDOMNodePointer nodePointer = new JDOMNodePointer(attr, new DocumentContainer(document)); [EOL] QName result = nodePointer.getName(); [EOL] assertNull(result.getPrefix()); [EOL] assertEquals("attrName", result.getLocalPart()); [EOL] assertEquals(XMLConstants.NULL_NS_URI, result.getNamespaceURI()); [EOL] }
public void testGetNamespaceURI_NonNullNonEmpty() { [EOL] when(attr.getNamespaceURI()).thenReturn("http://example.com"); [EOL] String result = instance.getNamespaceURI(); [EOL] assertNotNull(result); [EOL] assertNotEquals("", result); [EOL] }
public void testGetNamespaceURI_Null() { [EOL] when(attr.getNamespaceURI()).thenReturn(null); [EOL] String result = instance.getNamespaceURI(); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceURI_EmptyString() { [EOL] when(attr.getNamespaceURI()).thenReturn(""); [EOL] String result = instance.getNamespaceURI(); [EOL] assertNull(result); [EOL] }
public boolean isActual() { [EOL] return true; [EOL] }
public void testAsPathWithParent() { [EOL] Node parent = new Node("parent"); [EOL] Node child = new Node("child"); [EOL] child.setParent(parent); [EOL] String result = child.asPath(); [EOL] assertEquals("/parent/@child", result); [EOL] }
public void testAsPathWithoutParent() { [EOL] Node child = new Node("child"); [EOL] String result = child.asPath(); [EOL] assertEquals("@child", result); [EOL] }
public void testRemoveWithNullCollection() { [EOL] Object result = remove(null, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveWithArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Object result = remove(array, 1); [EOL] assertNotNull(result); [EOL] assertTrue(result.getClass().isArray()); [EOL] assertEquals(2, Array.getLength(result)); [EOL] assertEquals(1, Array.get(result, 0)); [EOL] assertEquals(3, Array.get(result, 1)); [EOL] }
public void testRemoveWithList() { [EOL] List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3)); [EOL] Object result = remove(list, 1); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof List); [EOL] assertEquals(2, ((List) result).size()); [EOL] assertEquals(1, ((List) result).get(0)); [EOL] assertEquals(3, ((List) result).get(1)); [EOL] }
public void testRemoveWithCollection() { [EOL] Collection<Integer> collection = new HashSet<>(Arrays.asList(1, 2, 3)); [EOL] Object result = remove(collection, 1); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Collection); [EOL] assertEquals(2, ((Collection) result).size()); [EOL] }
public void testRemoveWithUnsupportedType() { [EOL] try { [EOL] remove("UnsupportedType", 1); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot remove java.lang.String[1]", e.getMessage()); [EOL] } [EOL] }
public void testGetValueWithValidReadMethod() { [EOL] Object bean = new MyBean(); // Assuming MyBean is a valid bean class with a readable property [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("propertyName", MyBean.class); // Assuming propertyName is a valid property with a read method [EOL] Object value = JXPath.getValue(bean, propertyDescriptor); [EOL] assertNotNull(value); // Assuming the property value should not be null [EOL] } [EOL] public void testGetValueWithNullReadMethod() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("invalidProperty", MyBean.class); // Assuming invalidProperty has no read method [EOL] try { [EOL] JXPath.getValue(bean, propertyDescriptor); [EOL] fail("JXPathException expected due to no read method"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] } [EOL] public void testGetValueWithNullBean() { [EOL] Object bean = null; [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("propertyName", MyBean.class); // Assuming propertyName is a valid property [EOL] try { [EOL] JXPath.getValue(bean, propertyDescriptor); [EOL] fail("JXPathException expected due to null bean"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] } [EOL] public void testGetValueWithInaccessibleProperty() { [EOL] Object bean = new MyBean(); [EOL] PropertyDescriptor propertyDescriptor = new PropertyDescriptor("inaccessibleProperty", MyBean.class); // Assuming inaccessibleProperty exists but is not accessible [EOL] try { [EOL] JXPath.getValue(bean, propertyDescriptor); [EOL] fail("JXPathException expected due to inaccessible property"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetAccessibleMethodWithNullMethod() { [EOL] Method result = ClassName.getAccessibleMethod(null); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleMethodWithNonPublicMethod() throws NoSuchMethodException { [EOL] Method method = NonPublicClass.class.getDeclaredMethod("nonPublicMethod"); [EOL] Method result = ClassName.getAccessibleMethod(method); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleMethodWithPublicMethodInPublicClass() throws NoSuchMethodException { [EOL] Method method = PublicClass.class.getMethod("publicMethod"); [EOL] Method result = ClassName.getAccessibleMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals(method, result); [EOL] }
public void testGetAccessibleMethodWithPublicMethodInNonPublicSuperclass() throws NoSuchMethodException { [EOL] Method method = NonPublicSuperclass.class.getMethod("publicMethodInherited"); [EOL] Method result = ClassName.getAccessibleMethod(method); [EOL] assertNotNull(result); [EOL] assertNull(result); [EOL] }
public void testGetAccessibleMethodWithPublicMethodInPublicSuperclass() throws NoSuchMethodException { [EOL] Method method = PublicSuperclass.class.getMethod("publicMethodInherited"); [EOL] Method result = ClassName.getAccessibleMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals(PublicSuperclass.class.getSuperclass().getDeclaredMethod("publicMethodInherited"), result); [EOL] }
public void testGetAccessibleMethodFromInterfaceNest_PublicInterfaceMethod() { [EOL] Class<?> clazz = PublicInterface.class; [EOL] String methodName = "publicMethod"; [EOL] Class<?>[] parameterTypes = new Class<?>[0]; [EOL] Method method = getAccessibleMethodFromInterfaceNest(clazz, methodName, parameterTypes); [EOL] assertNotNull(method); [EOL] assertEquals("publicMethod", method.getName()); [EOL] } [EOL] public void testGetAccessibleMethodFromInterfaceNest_NonPublicInterfaceMethod() { [EOL] Class<?> clazz = NonPublicInterface.class; [EOL] String methodName = "nonPublicMethod"; [EOL] Class<?>[] parameterTypes = new Class<?>[0]; [EOL] Method method = getAccessibleMethodFromInterfaceNest(clazz, methodName, parameterTypes); [EOL] assertNull(method); [EOL] } [EOL] public void testGetAccessibleMethodFromInterfaceNest_NoSuchMethod() { [EOL] Class<?> clazz = PublicInterface.class; [EOL] String methodName = "nonExistentMethod"; [EOL] Class<?>[] parameterTypes = new Class<?>[0]; [EOL] Method method = getAccessibleMethodFromInterfaceNest(clazz, methodName, parameterTypes); [EOL] assertNull(method); [EOL] } [EOL] public void testGetAccessibleMethodFromInterfaceNest_WithParameters() { [EOL] Class<?> clazz = PublicInterfaceWithParameters.class; [EOL] String methodName = "methodWithParameters"; [EOL] Class<?>[] parameterTypes = new Class<?>[]{String.class, int.class}; [EOL] Method method = getAccessibleMethodFromInterfaceNest(clazz, methodName, parameterTypes); [EOL] assertNotNull(method); [EOL] assertEquals("methodWithParameters", method.getName()); [EOL] } [EOL] public void testGetAccessibleMethodFromInterfaceNest_InheritedInterfaceMethod() { [EOL] Class<?> clazz = ChildInterface.class; [EOL] String methodName = "inheritedPublicMethod"; [EOL] Class<?>[] parameterTypes = new Class<?>[0]; [EOL] Method method = getAccessibleMethodFromInterfaceNest(clazz, methodName, parameterTypes); [EOL] assertNotNull(method); [EOL] assertEquals("inheritedPublicMethod", method.getName()); [EOL] }
public void testCreateNodePointerWithDocument() { [EOL] QName name = new QName("test"); [EOL] Document document = createSampleDocument(); // You need to implement this method [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, document, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] }
public void testCreateNodePointerWithElement() { [EOL] QName name = new QName("test"); [EOL] Element element = createSampleElement(); // You need to implement this method [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, element, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] }
public void testCreateNodePointerWithNonNode() { [EOL] QName name = new QName("test"); [EOL] Object nonNodeBean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, nonNodeBean, locale); [EOL] assertNull(result); [EOL] }
public void testParentContextWithNonNullParentContextAndNodeTest() { [EOL] EvalContext mockParentContext = mock(EvalContext.class); [EOL] NodeTest mockNodeTest = mock(NodeTest.class); [EOL] ParentContext parentContext = new ParentContext(mockParentContext, mockNodeTest); [EOL] assertNotNull(parentContext); [EOL] assertEquals(mockParentContext, parentContext.getParentContext()); [EOL] assertEquals(mockNodeTest, parentContext.getNodeTest()); [EOL] }
public NodePointer getCurrentNodePointer() { [EOL] return currentNodePointer; [EOL] }
public void reset() { [EOL] super.reset(); [EOL] setStarted = false; [EOL] }
public void testNextNode_SetStartedTrue() { [EOL] context.setStarted(true); // setStarted is initially false [EOL] boolean result = context.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_SetStartedFalse_NodePointerIsContainer() { [EOL] context.setStarted(false); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.isContainer()).thenReturn(true); [EOL] when(mockNodePointer.getImmediateParentPointer()).thenReturn(null); [EOL] boolean result = context.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_SetStartedFalse_NodePointerIsNotContainer_TestNodeTrue() { [EOL] context.setStarted(false); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.isContainer()).thenReturn(false); [EOL] when(mockNodePointer.testNode(any(NodeTest.class))).thenReturn(true); [EOL] boolean result = context.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, context.getPosition()); [EOL] }
public void testNextNode_SetStartedFalse_NodePointerIsNotContainer_TestNodeFalse() { [EOL] context.setStarted(false); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.isContainer()).thenReturn(false); [EOL] when(mockNodePointer.testNode(any(NodeTest.class))).thenReturn(false); [EOL] boolean result = context.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testContainerPointerWithNonNullContainerAndLocale() { [EOL] Container container = new Container(); [EOL] Locale locale = new Locale("en", "US"); [EOL] ContainerPointer pointer = new ContainerPointer(container, locale); [EOL] assertNotNull(pointer.getContainer()); [EOL] assertEquals(locale, pointer.getLocale()); [EOL] }
public void testContainerPointerWithNullContainerAndLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] ContainerPointer pointer = new ContainerPointer(null, locale); [EOL] assertNull(pointer.getContainer()); [EOL] assertEquals(locale, pointer.getLocale()); [EOL] }
public void testContainerPointerWithNonNullParentAndContainer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Container container = mock(Container.class); [EOL] ContainerPointer containerPointer = new ContainerPointer(parent, container); [EOL] assertNotNull(containerPointer); [EOL] assertSame(parent, containerPointer.getParent()); [EOL] assertSame(container, containerPointer.getContainer()); [EOL] }
public void testContainerPointerWithNullParentAndNonNullContainer() { [EOL] Container container = mock(Container.class); [EOL] ContainerPointer containerPointer = new ContainerPointer(null, container); [EOL] assertNotNull(containerPointer); [EOL] assertNull(containerPointer.getParent()); [EOL] assertSame(container, containerPointer.getContainer()); [EOL] }
public void testContainerPointerWithNonNullParentAndNullContainer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] ContainerPointer containerPointer = new ContainerPointer(parent, null); [EOL] assertNotNull(containerPointer); [EOL] assertSame(parent, containerPointer.getParent()); [EOL] assertNull(containerPointer.getContainer()); [EOL] }
public void testContainerPointerWithNullParentAndNullContainer() { [EOL] ContainerPointer containerPointer = new ContainerPointer(null, null); [EOL] assertNotNull(containerPointer); [EOL] assertNull(containerPointer.getParent()); [EOL] assertNull(containerPointer.getContainer()); [EOL] }
public void testAsPathWithNonNullParent() { [EOL] node.parent = parentNode; [EOL] when(parentNode.asPath()).thenReturn("/parentPath"); [EOL] String result = node.asPath(); [EOL] assertEquals("/parentPath", result); [EOL] }
public void testAsPathWithNullParent() { [EOL] node.parent = null; [EOL] String result = node.asPath(); [EOL] assertEquals("/", result); [EOL] }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(0, active0, active1); [EOL] return 1; [EOL] } [EOL] switch(curChar) { [EOL] case 46: [EOL] if ((active1 & 0x80000L) != 0L) [EOL] return jjStopAtPos(1, 83); [EOL] break; [EOL] case 47: [EOL] if ((active0 & 0x80L) != 0L) [EOL] return jjStopAtPos(1, 7); [EOL] break; [EOL] case 61: [EOL] if ((active0 & 0x1000L) != 0L) [EOL] return jjStopAtPos(1, 12); [EOL] else if ((active0 & 0x4000L) != 0L) [EOL] return jjStopAtPos(1, 14); [EOL] else if ((active0 & 0x10000L) != 0L) [EOL] return jjStopAtPos(1, 16); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL] case 100: [EOL] if ((active0 & 0x8000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 51, 12); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL] case 104: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL] case 114: [EOL] if ((active0 & 0x8000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 27, 12); [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(0, active0, active1); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(0, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(1, active0, active1); [EOL] return 2; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL] case 100: [EOL] if ((active0 & 0x10000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 28, 12); [EOL] else if ((active0 & 0x20000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 29, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL] case 109: [EOL] if ((active1 & 0x200L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 73, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL] case 116: [EOL] if ((active1 & 0x8L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 67, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL] case 118: [EOL] if ((active0 & 0x40000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 30, 12); [EOL] break; [EOL] case 120: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL] case 121: [EOL] if ((active0 & 0x10000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 52, 12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\
```java [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(4, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(5, active0, active1); [EOL] return 6; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL] case 58: [EOL] if ((active0 & 0x1000000000L) != 0L) [EOL] return jjStopAtPos(6, 36); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x800L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 75, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL] case 110: [EOL] if ((active1 & 0x4L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 66, 12); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 33, 12); [EOL] break; [EOL] case 117: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(5, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151
```java [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(5, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(6, active0, active1); [EOL] return 7; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x2000000000L) != 0L) [EOL] return jjStopAtPos(7, 37); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 110: [EOL] if ((active0 & 0x2000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 49, 12); [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL] case 115: [EOL] if ((active0 & 0x800000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 59, 12); [EOL] break; [EOL] case 116: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 122: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(6, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\
public void testConstructorWithStaticCharStreamFlagTrue() { [EOL] SimpleCharStream.staticFlag = true; [EOL] try { [EOL] new XPathParserTokenManager(new SimpleCharStream(new StringReader(""))); [EOL] fail("Expected an Error to be thrown when staticFlag is true"); [EOL] } catch (Error e) { [EOL] assertEquals("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.", e.getMessage()); [EOL] } [EOL] }
public void testConstructorWithStaticCharStreamFlagFalse() { [EOL] SimpleCharStream.staticFlag = false; [EOL] try { [EOL] XPathParserTokenManager manager = new XPathParserTokenManager(new SimpleCharStream(new StringReader(""))); [EOL] assertNotNull(manager); [EOL] } finally { [EOL] SimpleCharStream.staticFlag = true; // Reset to default to avoid side effects on other tests [EOL] } [EOL] }
public void testDOMNodePointerWithNonNullNode() { [EOL] Node node = mock(Node.class); [EOL] Locale locale = Locale.getDefault(); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(node, locale); [EOL] assertNotNull(domNodePointer); [EOL] assertEquals(node, domNodePointer.node); [EOL] assertEquals(locale, domNodePointer.getLocale()); [EOL] }
public void testDOMNodePointerWithNullNode() { [EOL] Locale locale = Locale.getDefault(); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(null, locale); [EOL] assertNotNull(domNodePointer); [EOL] assertNull(domNodePointer.node); [EOL] assertEquals(locale, domNodePointer.getLocale()); [EOL] }
public void testNodeWithNullTest() { [EOL] Node node = mock(Node.class); [EOL] boolean result = testNode(node, null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testNamespace", "testLocalName"); [EOL] when(testNameTest.getNodeName()).thenReturn(testName); [EOL] when(testNameTest.getNamespaceURI()).thenReturn("testNamespace"); [EOL] when(testNameTest.isWildcard()).thenReturn(false); [EOL] boolean result = testNode(node, testNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndNonElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] boolean result = testNode(node, testNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeTypeTestElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestDocumentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestPINode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithProcessingInstructionTestMatchingTarget() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("testTarget"); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] boolean result = testNode(node, piTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithProcessingInstructionTestNonMatchingTarget() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("nodeTarget"); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] boolean result = testNode(node, piTest); [EOL] assertFalse(result); [EOL] }
public void testGetNamespaceURIWithNullPrefix() { [EOL] String result = getNamespaceURI(null); [EOL] assertEquals(getDefaultNamespaceURI(), result); [EOL] }
public void testGetNamespaceURIWithEmptyPrefix() { [EOL] String result = getNamespaceURI(""); [EOL] assertEquals(getDefaultNamespaceURI(), result); [EOL] }
public void testGetNamespaceURIWithXMLPrefix() { [EOL] String result = getNamespaceURI("xml"); [EOL] assertEquals(XML_NAMESPACE_URI, result); [EOL] }
public void testGetNamespaceURIWithXMLNSPrefix() { [EOL] String result = getNamespaceURI("xmlns"); [EOL] assertEquals(XMLNS_NAMESPACE_URI, result); [EOL] }
public void testGetNamespaceURIWithUnboundPrefix() { [EOL] String result = getNamespaceURI("unbound"); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceURIWithBoundPrefix() { [EOL] namespaces.put("prefix", "namespaceURI"); [EOL] String result = getNamespaceURI("prefix"); [EOL] assertEquals("namespaceURI", result); [EOL] }
public void testGetNamespaceURIWithUnknownNamespace() { [EOL] namespaces.put("prefix", NodePointer.UNKNOWN_NAMESPACE); [EOL] String result = getNamespaceURI("prefix"); [EOL] assertNull(result); [EOL] }
public void testEquals_SameObject() { [EOL] DOMNodePointer pointer = new DOMNodePointer(null, null); [EOL] boolean result = pointer.equals(pointer); [EOL] assert result; [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] DOMNodePointer pointer = new DOMNodePointer(null, null); [EOL] Object other = new Object(); [EOL] boolean result = pointer.equals(other); [EOL] assert !result; [EOL] } [EOL] public void testEquals_Null() { [EOL] DOMNodePointer pointer = new DOMNodePointer(null, null); [EOL] boolean result = pointer.equals(null); [EOL] assert !result; [EOL] } [EOL] public void testEquals_EqualObjects() { [EOL] Node node = mock(Node.class); [EOL] DOMNodePointer pointer1 = new DOMNodePointer(node, null); [EOL] DOMNodePointer pointer2 = new DOMNodePointer(node, null); [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert result; [EOL] } [EOL] public void testEquals_NotEqualObjects() { [EOL] Node node1 = mock(Node.class); [EOL] Node node2 = mock(Node.class); [EOL] DOMNodePointer pointer1 = new DOMNodePointer(node1, null); [EOL] DOMNodePointer pointer2 = new DOMNodePointer(node2, null); [EOL] boolean result = pointer1.equals(pointer2); [EOL] assert !result; [EOL] }
public void testStringValueWithCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] when(node.getData()).thenReturn(" comment "); [EOL] String result = stringValue(node); [EOL] assertEquals("comment", result); [EOL] }
public void testStringValueWithTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(node.getNodeValue()).thenReturn(" text "); [EOL] String result = stringValue(node); [EOL] assertEquals("text", result); [EOL] }
public void testStringValueWithCDataSectionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE); [EOL] when(node.getNodeValue()).thenReturn(" cdata "); [EOL] String result = stringValue(node); [EOL] assertEquals("cdata", result); [EOL] }
public void testStringValueWithProcessingInstructionNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction)node).getData()).thenReturn(" instruction "); [EOL] String result = stringValue(node); [EOL] assertEquals("instruction", result); [EOL] }
public void testStringValueWithOtherNodeHavingTextChild() { [EOL] Node node = mock(Node.class); [EOL] Node childNode = mock(Node.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(childNode); [EOL] when(childNode.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(childNode.getNodeValue()).thenReturn(" child text "); [EOL] String result = stringValue(node); [EOL] assertEquals("child text", result); [EOL] }
public void testStringValueWithOtherNodeHavingNonTextChild() { [EOL] Node node = mock(Node.class); [EOL] Node childNode = mock(Node.class); [EOL] NodeList nodeList = mock(NodeList.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getChildNodes()).thenReturn(nodeList); [EOL] when(nodeList.getLength()).thenReturn(1); [EOL] when(nodeList.item(0)).thenReturn(childNode); [EOL] when(childNode.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(childNode.getChildNodes()).thenReturn(mock(NodeList.class)); [EOL] String result = stringValue(node); [EOL] assertEquals("", result); [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL] Node node1 = (Node) pointer1.getBaseValue(); [EOL] Node node2 = (Node) pointer2.getBaseValue(); [EOL] if (node1 == node2) { [EOL] return 0; [EOL] } [EOL] int t1 = node1.getNodeType(); [EOL] int t2 = node2.getNodeType(); [EOL] if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) { [EOL] return -1; [EOL] } else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) { [EOL] return 1; [EOL] } else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) { [EOL] NamedNodeMap map = ((Node) getNode()).getAttributes(); [EOL] int length = map.getLength(); [EOL] for (int i = 0; i < length; i++) { [EOL] Node n = map.item(i); [EOL] if (n == node1) { [EOL] return -1; [EOL] } else if (n == node2) { [EOL] return 1; [EOL] } [EOL] } [EOL] return 0; [EOL] } [EOL] Node current = node.getFirstChild(); [EOL] while (current != null) { [EOL] if (current == node1) { [EOL] return -1; [EOL] } else if (current == node2) { [EOL] return 1; [EOL] } [EOL] current = current.getNextSibling(); [EOL] } [EOL] return 0; [EOL] }
public void testGetFunctionWithDifferentNamespace() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction("http://different.com", name, parameters); [EOL] assertNull(result); [EOL] }
public void testGetFunctionWithNullParameters() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Function result = getFunction(namespace, name, null); [EOL] assertNotNull(result); [EOL] }
public void testGetFunctionWithConstructor() { [EOL] String namespace = "http://example.com"; [EOL] String name = "new"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ConstructorFunction); [EOL] }
public void testGetFunctionWithStaticMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] }
public void testGetFunctionWithInstanceMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "instanceMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] }
public void testGetFunctionWithNoMatchingMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "noSuchMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testComputeValueWithNullArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getFunction(anyString(), any())).thenReturn(mock(Function.class)); [EOL] Object result = computeValue(context); [EOL] assertNotNull(result); [EOL] }
public void testComputeValueWithNonNullArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] Function function = mock(Function.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getFunction(anyString(), any())).thenReturn(function); [EOL] when(function.invoke(any(EvalContext.class), any())).thenReturn(new Object()); [EOL] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].compute(context)).thenReturn(new Object()); [EOL] when(args[1].compute(context)).thenReturn(new Object()); [EOL] Object result = computeValue(context); [EOL] assertNotNull(result); [EOL] }
public void testComputeValueFunctionNotFound() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getFunction(anyString(), any())).thenReturn(null); [EOL] try { [EOL] computeValue(context); [EOL] fail("Expected JXPathFunctionNotFoundException to be thrown"); [EOL] } catch (JXPathFunctionNotFoundException e) { [EOL] assertEquals("No such function: " + functionName + Arrays.asList((Object[]) null), e.getMessage()); [EOL] } [EOL] }
public void testConvertWithEvalContext() { [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] Object expectedValue = new Object(); [EOL] when(evalContext.getValue()).thenReturn(expectedValue); [EOL] Object result = convert(evalContext); [EOL] assertSame(expectedValue, result); [EOL] }
public void testConvertWithNonEvalContext() { [EOL] Object nonEvalContextObject = new Object(); [EOL] Object result = convert(nonEvalContextObject); [EOL] assertSame(nonEvalContextObject, result); [EOL] }
public void testSetPositionForward() { [EOL] int targetPosition = 5; [EOL] boolean result = setPosition(targetPosition); [EOL] assertTrue(result); [EOL] assertEquals(targetPosition, this.position); [EOL] }
public void testSetPositionBackward() { [EOL] this.position = 10; [EOL] int targetPosition = 5; [EOL] boolean result = setPosition(targetPosition); [EOL] assertTrue(result); [EOL] assertEquals(targetPosition, this.position); [EOL] }
public void testSetPositionForwardFails() { [EOL] int targetPosition = 5; [EOL] when(next()).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] boolean result = setPosition(targetPosition); [EOL] assertFalse(result); [EOL] assertNotEquals(targetPosition, this.position); [EOL] }
public void testSetPositionBackwardFails() { [EOL] this.position = 10; [EOL] int targetPosition = 5; [EOL] when(previous()).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] boolean result = setPosition(targetPosition); [EOL] assertFalse(result); [EOL] assertNotEquals(targetPosition, this.position); [EOL] }
public void testPreviousAtStartPositionNotReversed() { [EOL] position = 0; [EOL] reverse = false; [EOL] child = null; [EOL] node = mock(Node.class); [EOL] when(node.getLastChild()).thenReturn(null); [EOL] assertFalse(previous()); [EOL] assertNull(child); [EOL] }
public void testPreviousWithChildNotNullNotReversed() { [EOL] position = 1; [EOL] reverse = false; [EOL] child = mock(Node.class); [EOL] Node previousChild = mock(Node.class); [EOL] when(child.getPreviousSibling()).thenReturn(previousChild); [EOL] when(previousChild.getPreviousSibling()).thenReturn(null); [EOL] assertTrue(previous()); [EOL] assertEquals(previousChild, child); [EOL] }
public void testPreviousWithChildNullNotReversed() { [EOL] position = 1; [EOL] reverse = false; [EOL] child = null; [EOL] node = mock(Node.class); [EOL] Node lastChild = mock(Node.class); [EOL] when(node.getLastChild()).thenReturn(lastChild); [EOL] when(lastChild.getPreviousSibling()).thenReturn(null); [EOL] assertTrue(previous()); [EOL] assertEquals(lastChild, child); [EOL] }
public void testPreviousWithTestChildFailingNotReversed() { [EOL] position = 1; [EOL] reverse = false; [EOL] child = mock(Node.class); [EOL] Node previousChild = mock(Node.class); [EOL] when(child.getPreviousSibling()).thenReturn(previousChild); [EOL] when(previousChild.getPreviousSibling()).thenReturn(null); [EOL] doReturn(false).when(this).testChild(); [EOL] assertFalse(previous()); [EOL] assertNull(child); [EOL] }
public void testPreviousAtStartPositionReversed() { [EOL] position = 0; [EOL] reverse = true; [EOL] child = mock(Node.class); [EOL] when(child.getNextSibling()).thenReturn(null); [EOL] assertFalse(previous()); [EOL] assertNull(child); [EOL] }
public void testPreviousWithChildNotNullReversed() { [EOL] position = 1; [EOL] reverse = true; [EOL] child = mock(Node.class); [EOL] Node nextChild = mock(Node.class); [EOL] when(child.getNextSibling()).thenReturn(nextChild); [EOL] when(nextChild.getNextSibling()).thenReturn(null); [EOL] assertTrue(previous()); [EOL] assertEquals(nextChild, child); [EOL] }
public void testPreviousWithTestChildFailingReversed() { [EOL] position = 1; [EOL] reverse = true; [EOL] child = mock(Node.class); [EOL] Node nextChild = mock(Node.class); [EOL] when(child.getNextSibling()).thenReturn(nextChild); [EOL] when(nextChild.getNextSibling()).thenReturn(null); [EOL] doReturn(false).when(this).testChild(); [EOL] assertFalse(previous()); [EOL] assertNull(child); [EOL] }
public void testLookupConstructorWithExactMatch() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { "stringParam", 123 }; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNotNull(constructor); [EOL] assertEquals(2, constructor.getParameterTypes().length); [EOL] assertEquals(String.class, constructor.getParameterTypes()[0]); [EOL] assertEquals(Integer.class, constructor.getParameterTypes()[1]); [EOL] }
public void testLookupConstructorWithNullParameters() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = null; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNotNull(constructor); [EOL] assertEquals(0, constructor.getParameterTypes().length); [EOL] }
public void testLookupConstructorWithSomeNullParameters() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { null, 123 }; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNotNull(constructor); [EOL] assertEquals(1, constructor.getParameterTypes().length); [EOL] assertEquals(Integer.class, constructor.getParameterTypes()[0]); [EOL] }
public void testLookupConstructorWithAmbiguousMatch() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { "stringParam", "anotherStringParam" }; [EOL] try { [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] fail("Should have thrown JXPathException due to ambiguous match"); [EOL] } catch (JXPathException ex) { [EOL] } [EOL] }
public void testLookupConstructorWithNoMatch() { [EOL] Class<?> targetClass = SampleClass.class; [EOL] Object[] parameters = new Object[] { new Object(), new Object() }; [EOL] Constructor constructor = jxPath.lookupConstructor(targetClass, parameters); [EOL] assertNull(constructor); [EOL] }
public void testLookupMethodWithNullParameters() { [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", null); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithEmptyParameters() { [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", new Object[]{}); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithNullFirstParameter() { [EOL] Object[] parameters = {null, "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithNoMatch() { [EOL] Object[] parameters = {new Object(), "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithExactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = {"test", "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] Method expected = String.class.getMethod("valueOf", String.class); [EOL] assertEquals(expected, result); [EOL] }
public void testLookupMethodWithInexactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = {new Object(), "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] Method expected = String.class.getMethod("valueOf", Object.class); [EOL] assertEquals(expected, result); [EOL] }
public void testLookupMethodWithAmbiguousMatch() { [EOL] Object[] parameters = {new Object(), "test", "test"}; [EOL] try { [EOL] YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] fail("Should have thrown JXPathException due to ambiguous method call"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testMatchTypeWithNullObject() { [EOL] int result = matchType(String.class, null); [EOL] assertEquals(APPROXIMATE_MATCH, result); [EOL] }
public void testMatchTypeWithExactMatch() { [EOL] int result = matchType(String.class, "test"); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchTypeWithAssignableMatch() { [EOL] int result = matchType(Object.class, "test"); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchTypeWithNoMatch() { [EOL] int result = matchType(Integer.class, "test"); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchTypeWithApproximateMatch() { [EOL] int result = matchType(Number.class, new BigDecimal("10")); [EOL] assertEquals(APPROXIMATE_MATCH, result); [EOL] }
public void testGetNamespaceURIWithNullPrefix() { [EOL] DOMNodePointer nodePointer = createMockedDOMNodePointerWithAttr(null); [EOL] assertNull(nodePointer.getNamespaceURI()); [EOL] } [EOL] public void testGetNamespaceURIWithNonNullPrefix() { [EOL] String expectedNamespaceURI = "http://example.com/ns"; [EOL] DOMNodePointer nodePointer = createMockedDOMNodePointerWithAttr("prefix"); [EOL] DOMNodePointer parentNode = createMockedParentNodeWithNamespaceURI(expectedNamespaceURI); [EOL] nodePointer.parent = parentNode; [EOL] assertEquals(expectedNamespaceURI, nodePointer.getNamespaceURI()); [EOL] }
private DOMNodePointer createMockedDOMNodePointerWithAttr(String prefix) { [EOL] Attr attr = mock(Attr.class); [EOL] when(attr.getPrefix()).thenReturn(prefix); [EOL] return new DOMNodePointer(attr, null); [EOL] } [EOL] private DOMNodePointer createMockedParentNodeWithNamespaceURI(String namespaceURI) { [EOL] DOMNodePointer parentNode = mock(DOMNodePointer.class); [EOL] when(parentNode.getNamespaceURI(anyString())).thenReturn(namespaceURI); [EOL] return parentNode; [EOL] }
public void testHashCode() { [EOL] Object attr = new Object(); [EOL] MyClass instance = new MyClass(attr); [EOL] int expected = System.identityHashCode(attr); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCreateNodePointerWithNode() { [EOL] QName name = new QName("test"); [EOL] Node node = mock(Node.class); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, node, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodePointer); [EOL] }
public void testCreateNodePointerWithNonNode() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNull(result); [EOL] }
public void testIsCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsContainerTrue() { [EOL] int WHOLE_COLLECTION = -1; // Assuming WHOLE_COLLECTION is a constant with value -1 [EOL] int index = 0; // Set index to a value different from WHOLE_COLLECTION [EOL] YourClass instance = new YourClass(); [EOL] instance.index = index; // Set the index for the instance [EOL] boolean result = instance.isContainer(); [EOL] assertTrue(result); // Assert that the result should be true [EOL] }
public void testIsContainerFalse() { [EOL] int WHOLE_COLLECTION = -1; [EOL] int index = WHOLE_COLLECTION; // Set index to the same value as WHOLE_COLLECTION [EOL] YourClass instance = new YourClass(); [EOL] instance.index = index; [EOL] boolean result = instance.isContainer(); [EOL] assertFalse(result); // Assert that the result should be false [EOL] }
public void testGetImmediateNodeWithIndexNotWholeCollection() { [EOL] int index = 1; // Assuming WHOLE_COLLECTION is a constant not equal to 1 [EOL] Object[] collection = new Object[] {"a", "b", "c"}; // Sample collection [EOL] JXPathContext context = JXPathContext.newContext(collection); [EOL] context.getVariables().declareVariable("index", index); [EOL] Object result = context.getImmediateNode(); [EOL] assertEquals("b", result); [EOL] }
public void testGetImmediateNodeWithIndexWholeCollection() { [EOL] int index = WHOLE_COLLECTION; // Assuming WHOLE_COLLECTION is a constant [EOL] Object[] collection = new Object[] {"a", "b", "c"}; // Sample collection [EOL] JXPathContext context = JXPathContext.newContext(collection); [EOL] context.getVariables().declareVariable("index", index); [EOL] Object result = context.getImmediateNode(); [EOL] assertEquals(collection, result); [EOL] }
public void testConstructorFunctionWithNonNullConstructor() { [EOL] Constructor constructor = String.class.getConstructors()[0]; [EOL] ConstructorFunction constructorFunction = new ConstructorFunction(constructor); [EOL] assertNotNull(constructorFunction); [EOL] }
public void testInvokeWithNullParameters() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] Constructor constructor = String.class.getConstructor(new Class[0]); [EOL] MyConstructorFunction function = new MyConstructorFunction(constructor); [EOL] Object result = function.invoke(context, null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof String); [EOL] }
public void testInvokeWithContextParameter() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] Constructor constructor = CustomClass.class.getConstructor(ExpressionContext.class, String.class); [EOL] MyConstructorFunction function = new MyConstructorFunction(constructor); [EOL] Object[] parameters = new Object[]{"test"}; [EOL] Object result = function.invoke(context, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CustomClass); [EOL] }
public void testInvokeWithConversion() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] Constructor constructor = CustomClass.class.getConstructor(String.class); [EOL] MyConstructorFunction function = new MyConstructorFunction(constructor); [EOL] Object[] parameters = new Object[]{new Integer(123)}; [EOL] Object result = function.invoke(context, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CustomClass); [EOL] }
public void testInvokeWithInvocationTargetException() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] Constructor constructor = CustomClass.class.getConstructor(String.class); [EOL] MyConstructorFunction function = new MyConstructorFunction(constructor) { [EOL] @Override [EOL] public Object invoke(ExpressionContext context, Object[] parameters) { [EOL] throw new InvocationTargetException(new Exception("Test Exception")); [EOL] } [EOL] }; [EOL] try { [EOL] Object[] parameters = new Object[]{"test"}; [EOL] function.invoke(context, parameters); [EOL] fail("JXPathInvalidAccessException expected"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] } [EOL] }
public void testDOMAttributeIteratorWithElementNodeAndSpecificName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("specificName"); [EOL] Node node = mock(Node.class); [EOL] Attr attr = mock(Attr.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(getAttribute((Element) node, name)).thenReturn(attr); [EOL] DOMAttributeIterator iterator = new DOMAttributeIterator(parent, name); [EOL] assertTrue(iterator.attributes.contains(attr)); [EOL] }
public void testDOMAttributeIteratorWithElementNodeAndWildcardName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("*"); [EOL] Node node = mock(Node.class); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] Attr attr = mock(Attr.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(1); [EOL] when(map.item(0)).thenReturn(attr); [EOL] when(testAttr(attr, name)).thenReturn(true); [EOL] DOMAttributeIterator iterator = new DOMAttributeIterator(parent, name); [EOL] assertTrue(iterator.attributes.contains(attr)); [EOL] }
public void testDOMAttributeIteratorWithNonElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("name"); [EOL] Node node = mock(Node.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] DOMAttributeIterator iterator = new DOMAttributeIterator(parent, name); [EOL] assertTrue(iterator.attributes.isEmpty()); [EOL] }
private boolean testAttr(Attr attr, QName testName) { [EOL] String nodePrefix = DOMNodePointer.getPrefix(attr); [EOL] String nodeLocalName = DOMNodePointer.getLocalName(attr); [EOL] if (nodePrefix != null && nodePrefix.equals("xmlns")) { [EOL] return false; [EOL] } [EOL] if (nodePrefix == null && nodeLocalName.equals("xmlns")) { [EOL] return false; [EOL] } [EOL] String testLocalName = testName.getName(); [EOL] if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { [EOL] String testPrefix = testName.getPrefix(); [EOL] if (equalStrings(testPrefix, nodePrefix)) { [EOL] return true; [EOL] } [EOL] String testNS = null; [EOL] if (testPrefix != null) { [EOL] testNS = parent.getNamespaceURI(testPrefix); [EOL] } [EOL] String nodeNS = null; [EOL] if (nodePrefix != null) { [EOL] nodeNS = parent.getNamespaceURI(nodePrefix); [EOL] } [EOL] return equalStrings(testNS, nodeNS); [EOL] } [EOL] return false; [EOL] }
public void testEqualStringsBothNull() { [EOL] boolean result = equalStrings(null, null); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsFirstNull() { [EOL] boolean result = equalStrings(null, "test"); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsSecondNull() { [EOL] boolean result = equalStrings("test", null); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsBothNonNullEqual() { [EOL] boolean result = equalStrings("test", "test"); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsBothNonNullNotEqual() { [EOL] boolean result = equalStrings("test", "different"); [EOL] assertFalse(result); [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespace() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespaceURI"); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockElement.getAttributeNodeNS("namespaceURI", "name")).thenReturn(mockAttr); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNonNullPrefixButNullNamespace() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn(null); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(0); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNull(result); [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespaceButNoMatchingAttribute() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespaceURI"); [EOL] when(mockElement.getAttributeNodeNS("namespaceURI", "name")).thenReturn(null); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(1); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockNamedNodeMap.item(0)).thenReturn(mockAttr); [EOL] when(testAttr(mockAttr, mockQName)).thenReturn(false); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNull(result); [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespaceAndMatchingAttributeInNamedNodeMap() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespaceURI"); [EOL] when(mockElement.getAttributeNodeNS("namespaceURI", "name")).thenReturn(null); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(1); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockNamedNodeMap.item(0)).thenReturn(mockAttr); [EOL] when(testAttr(mockAttr, mockQName)).thenReturn(true); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNullPrefix() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn(null); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockElement.getAttributeNode("name")).thenReturn(mockAttr); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testIsActualWhenPropertyIsNotActual() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest() { [EOL] @Override [EOL] public boolean isActualProperty() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public boolean isActual() { [EOL] return super.isActual(); [EOL] } [EOL] }; [EOL] boolean result = obj.isActual(); [EOL] assertFalse(result); [EOL] }
public void testIsActualWhenPropertyIsActual() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest() { [EOL] @Override [EOL] public boolean isActualProperty() { [EOL] return true; [EOL] } [EOL] @Override [EOL] public boolean isActual() { [EOL] return true; // Assuming the superclass method returns true [EOL] } [EOL] }; [EOL] boolean result = obj.isActual(); [EOL] assertTrue(result); [EOL] }
public void testCreateNodePointerWithContainer() { [EOL] QName name = new QName("test"); [EOL] Container container = new Container(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, container, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ContainerPointer); [EOL] }
public void testCreateNodePointerWithNonContainer() { [EOL] QName name = new QName("test"); [EOL] Object nonContainerBean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, nonContainerBean, locale); [EOL] assertNull(result); [EOL] }
public void testCreateNodePointerWithContainer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Container container = mock(Container.class); [EOL] NodePointer result = createNodePointer(parent, name, container); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ContainerPointer); [EOL] }
public void testCreateNodePointerWithNonContainer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object nonContainerBean = new Object(); [EOL] NodePointer result = createNodePointer(parent, name, nonContainerBean); [EOL] assertNull(result); [EOL] }
public void testJXPathContextReferenceImplWithNonNullParentAndContextBean() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] Object contextBean = new Object(); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean); [EOL] assertNotNull(contextReference); [EOL] }
public void testJXPathContextReferenceImplWithNullParentAndNonNullContextBean() { [EOL] Object contextBean = new Object(); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(null, contextBean); [EOL] assertNotNull(contextReference); [EOL] }
public void testJXPathContextReferenceImplWithNonNullParentAndNullContextBean() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, null); [EOL] assertNotNull(contextReference); [EOL] }
public void testJXPathContextReferenceImplWithNullParentAndNullContextBean() { [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(null, null); [EOL] assertNotNull(contextReference); [EOL] }
public void testJXPathContextReferenceImplWithNonNullContextPointer() { [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] Object contextBean = new Object(); [EOL] Pointer contextPointer = mock(Pointer.class); [EOL] when(contextPointer.getRootNode()).thenReturn(new Object()); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer); [EOL] assertNotNull(contextReference); [EOL] assertSame(contextPointer, contextReference.contextPointer); [EOL] assertNotNull(contextReference.rootPointer); [EOL] assertNotSame(contextReference.contextPointer, contextReference.rootPointer); [EOL] }
public void testJXPathContextReferenceImplWithNullContextPointer() { [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] Object contextBean = new Object(); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, null); [EOL] assertNotNull(contextReference); [EOL] assertNotNull(contextReference.contextPointer); [EOL] assertSame(contextReference.contextPointer, contextReference.rootPointer); [EOL] }
public void testJXPathContextReferenceImplWithParentContextBeingJXPathContextReferenceImpl() { [EOL] JXPathContextReferenceImpl parentContext = mock(JXPathContextReferenceImpl.class); [EOL] NamespaceResolver namespaceResolver = mock(NamespaceResolver.class); [EOL] when(parentContext.getNamespaceResolver()).thenReturn(namespaceResolver); [EOL] Object contextBean = new Object(); [EOL] Pointer contextPointer = mock(Pointer.class); [EOL] when(contextPointer.getRootNode()).thenReturn(new Object()); [EOL] JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer); [EOL] assertNotNull(contextReference); [EOL] assertNotNull(contextReference.namespaceResolver); [EOL] assertSame(namespaceResolver, contextReference.namespaceResolver.getParent()); [EOL] }
public void testGetValueWithNullResultAndNonLenientPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = new Path("nonexistent/path"); [EOL] try { [EOL] context.getValue("nonexistent/path", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNullResultAndLenientPath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = new Path("nonexistent/path"); [EOL] Object result = context.getValue("nonexistent/path", expr); [EOL] assertNull("Result should be null for lenient path", result); [EOL] }
public void testGetValueWithNonNullResultAndEvalContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] when(nodePointer.getValue()).thenReturn("expectedValue"); [EOL] Object result = context.getValue("existent/path", expr); [EOL] assertEquals("Result should be 'expectedValue'", "expectedValue", result); [EOL] }
public void testGetValueWithNonNullResultAndNonActualNodePointer() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] NodePointer parentNodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] when(nodePointer.getImmediateParentPointer()).thenReturn(parentNodePointer); [EOL] when(parentNodePointer.isContainer()).thenReturn(true); [EOL] when(parentNodePointer.isActual()).thenReturn(true); [EOL] try { [EOL] context.getValue("existent/path", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNonNullResultAndActualNodePointer() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] when(nodePointer.getValue()).thenReturn("expectedValue"); [EOL] Object result = context.getValue("existent/path", expr); [EOL] assertEquals("Result should be 'expectedValue'", "expectedValue", result); [EOL] }
public void testCreatePathWithPointerResult() { [EOL] String xpath = "/some/path"; [EOL] Expression expr = mock(Expression.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(expectedPointer); [EOL] Pointer result = createPath(xpath, expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] verify(expectedPointer).createPath(any(JXPathContext.class)); [EOL] }
public void testCreatePathWithEvalContextResult() { [EOL] String xpath = "/some/other/path"; [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = createPath(xpath, expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] verify(expectedPointer).createPath(any(JXPathContext.class)); [EOL] }
public void testCreatePathWithInvalidResult() { [EOL] String xpath = "/invalid/path"; [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(new Object()); [EOL] try { [EOL] createPath(xpath, expr); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot create path:" + xpath, e.getMessage()); [EOL] } [EOL] }
public void testCreatePathWithException() { [EOL] String xpath = "/exception/path"; [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenThrow(new RuntimeException("Test Exception")); [EOL] try { [EOL] createPath(xpath, expr); [EOL] fail("Expected JXPathException to be thrown"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Exception trying to create xpath " + xpath, e.getMessage()); [EOL] assertNotNull(e.getCause()); [EOL] assertEquals("Test Exception", e.getCause().getMessage()); [EOL] } [EOL] }
public void testCoreOperationNegateWithNullArgument() { [EOL] try { [EOL] new CoreOperationNegate(null); [EOL] fail("Should throw IllegalArgumentException for null argument"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testCoreOperationNegateWithValidArgument() { [EOL] Expression mockExpression = mock(Expression.class); [EOL] CoreOperationNegate operationNegate = new CoreOperationNegate(mockExpression); [EOL] assertNotNull("CoreOperationNegate instance should be created", operationNegate); [EOL] }
protected int getPrecedence() { [EOL] return 6; [EOL] }
public void testGetSymbol() { [EOL] MyClass instance = new MyClass(); [EOL] String expected = "-"; [EOL] String actual = instance.getSymbol(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 7; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousWithReverseFalseAndChildTestFails() { [EOL] initializePreviousTest(false, false); [EOL] boolean result = previous(); [EOL] assertFalse(result); [EOL] } [EOL] public void testPreviousWithReverseFalseAndChildTestPasses() { [EOL] initializePreviousTest(false, true); [EOL] boolean result = previous(); [EOL] assertTrue(result); [EOL] }
public void testPreviousWithReverseTrueAndChildTestFails() { [EOL] initializePreviousTest(true, false); [EOL] boolean result = previous(); [EOL] assertFalse(result); [EOL] } [EOL] public void testPreviousWithReverseTrueAndChildTestPasses() { [EOL] initializePreviousTest(true, true); [EOL] boolean result = previous(); [EOL] assertTrue(result); [EOL] }
