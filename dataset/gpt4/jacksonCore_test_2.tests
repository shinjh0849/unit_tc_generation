public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testIntPrinting() throws Exception { [EOL]     assertIntPrint(0); [EOL]     assertIntPrint(-3); [EOL]     assertIntPrint(1234); [EOL]     assertIntPrint(-1234); [EOL]     assertIntPrint(56789); [EOL]     assertIntPrint(-56789); [EOL]     assertIntPrint(999999); [EOL]     assertIntPrint(-999999); [EOL]     assertIntPrint(1000000); [EOL]     assertIntPrint(-1000000); [EOL]     assertIntPrint(10000001); [EOL]     assertIntPrint(-10000001); [EOL]     assertIntPrint(-100000012); [EOL]     assertIntPrint(100000012); [EOL]     assertIntPrint(1999888777); [EOL]     assertIntPrint(-1999888777); [EOL]     assertIntPrint(Integer.MAX_VALUE); [EOL]     assertIntPrint(Integer.MIN_VALUE); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 251000; ++i) { [EOL]         assertIntPrint(rnd.nextInt()); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testLongPrinting() throws Exception { [EOL]     assertLongPrint(0L, 0); [EOL]     assertLongPrint(1L, 0); [EOL]     assertLongPrint(-1L, 0); [EOL]     assertLongPrint(Long.MAX_VALUE, 0); [EOL]     assertLongPrint(Long.MIN_VALUE, 0); [EOL]     assertLongPrint(Long.MAX_VALUE - 1L, 0); [EOL]     assertLongPrint(Long.MIN_VALUE + 1L, 0); [EOL]     Random rnd = new Random(12345L); [EOL]     for (int i = 0; i < 678000; ++i) { [EOL]         long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt(); [EOL]         assertLongPrint(l, i); [EOL]     } [EOL] }
public void testNonStandardNameChars() throws Exception { [EOL]     _testNonStandardNameChars(false); [EOL]     _testNonStandardNameChars(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testIsClosed() throws IOException { [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         String JSON = "[ 1, 2, 3 ]"; [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonParser jp = stream ? createParserUsingStream(JSON, "UTF-8") : createParserUsingReader(JSON); [EOL]         boolean partial = ((i & 2) == 0); [EOL]         assertFalse(jp.isClosed()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertFalse(jp.isClosed()); [EOL]         if (partial) { [EOL]             jp.close(); [EOL]             assertTrue(jp.isClosed()); [EOL]         } else { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             assertNull(jp.nextToken()); [EOL]             assertTrue(jp.isClosed()); [EOL]         } [EOL]     } [EOL] }
public void testIssue38() throws Exception { [EOL]     _testIssue38(false); [EOL]     _testIssue38(true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     PrettyPrinter p = new DefaultPrettyPrinter(); [EOL]     byte[] stuff = jdkSerialize(p); [EOL]     PrettyPrinter back = jdkDeserialize(stuff); [EOL]     assertNotNull(back); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testStreamReaderParser() throws Exception { [EOL]     _testWith(true); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "{ \"a\":1, \"b\":[{ \"c\" : null }] }"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("{\"a\":1,\"b\":[{\"c\":null}]}", sw.toString()); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "{ \"a\":1, \"b\":[{ \"c\" : null }] }"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("{\"a\":1,\"b\":[{\"c\":null}]}", sw.toString()); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "{ \"a\":1, \"b\":[{ \"c\" : null }] }"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("{\"a\":1,\"b\":[{\"c\":null}]}", sw.toString()); [EOL] }
public void testCopyObjectTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "{ \"a\":1, \"b\":[{ \"c\" : null }] }"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("{\"a\":1,\"b\":[{\"c\":null}]}", sw.toString()); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testLongerRandomSingleChunk() throws Exception { [EOL]     for (int round = 0; round < 80; ++round) { [EOL]         String content = generateRandom(75000 + round); [EOL]         doTestLongerRandom(content, false); [EOL]         doTestLongerRandom(content, true); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidObject() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "{  \"field\" : true }"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("field", jp.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testIssue55() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     JsonGenerator gen = f.createGenerator(bytes); [EOL]     ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     final int EXP_LEN = 2670; [EOL]     assertEquals(EXP_LEN, bytes.size()); [EOL]     StringWriter sw = new StringWriter(); [EOL]     gen = f.createGenerator(sw); [EOL]     data = new ByteArrayInputStream(new byte[2000]); [EOL]     gen.writeBinary(data, 1999); [EOL]     gen.close(); [EOL]     assertEquals(EXP_LEN, sw.toString().length()); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testCurrentName() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testCurrentName(jf, false); [EOL]     _testCurrentName(jf, true); [EOL] }
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testLongWrite() throws Exception { [EOL]     doTestLongWrite(false); [EOL]     doTestLongWrite(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testAllowNaN() throws Exception { [EOL]     _testAllowNaN(false); [EOL]     _testAllowNaN(true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = "[" + "\"LF=\\n\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("LF=\n", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = "[\"NULL:\\u0000!\"]"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("NULL:\0!", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0123\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("\u0123", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0041\\u0043\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("AC", jp.getText()); [EOL]     jp.close(); [EOL] }
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = "[" + "\"LF=\\n\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("LF=\n", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = "[\"NULL:\\u0000!\"]"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("NULL:\0!", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0123\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("\u0123", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0041\\u0043\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("AC", jp.getText()); [EOL]     jp.close(); [EOL] }
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = "[" + "\"LF=\\n\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("LF=\n", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = "[\"NULL:\\u0000!\"]"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("NULL:\0!", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0123\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("\u0123", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0041\\u0043\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("AC", jp.getText()); [EOL]     jp.close(); [EOL] }
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = "[" + "\"LF=\\n\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("LF=\n", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = "[\"NULL:\\u0000!\"]"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("NULL:\0!", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0123\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("\u0123", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0041\\u0043\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("AC", jp.getText()); [EOL]     jp.close(); [EOL] }
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = "[" + "\"LF=\\n\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("LF=\n", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = "[\"NULL:\\u0000!\"]"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("NULL:\0!", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0123\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("\u0123", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0041\\u0043\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("AC", jp.getText()); [EOL]     jp.close(); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testInvalidKeywordsReader() throws Exception { [EOL]     _testInvalidKeywords(false); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testConvenienceMethodsWithNulls() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeStringField("str", null); [EOL]     gen.writeNumberField("num", null); [EOL]     gen.writeObjectField("obj", null); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("str", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("num", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("obj", jp.getCurrentName()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testStreamingWrites() throws Exception { [EOL]     final JsonFactory f = new JsonFactory(); [EOL]     _testStreamingWrites(f, true); [EOL]     _testStreamingWrites(f, false); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { "a", "foobar", "p\u00f6ll\u00f6", "\"foo\"", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes("UTF-8"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { "a", "foobar", "p\u00f6ll\u00f6", "\"foo\"", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes("UTF-8"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { "a", "foobar", "p\u00f6ll\u00f6", "\"foo\"", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes("UTF-8"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { "a", "foobar", "p\u00f6ll\u00f6", "\"foo\"", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes("UTF-8"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testEncodeAsUTF8() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     String[] strings = new String[] { "a", "foobar", "p\u00f6ll\u00f6", "\"foo\"", generateRandom(200), generateRandom(5000), generateRandom(39000) }; [EOL]     for (String str : strings) { [EOL]         assertArrayEquals(str.getBytes("UTF-8"), encoder.encodeAsUTF8(str)); [EOL]     } [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testBigDecimalAsPlain() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     BigDecimal ENG = new BigDecimal("1E+2"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("1E+2", sw.toString()); [EOL]     jf.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true); [EOL]     sw = new StringWriter(); [EOL]     jg = jf.createGenerator(sw); [EOL]     jg.writeNumber(ENG); [EOL]     jg.close(); [EOL]     assertEquals("100", sw.toString()); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsDisabled() throws Exception { [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testCustomRootSeparatorWithFactory() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setRootValueSeparator("##"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeNumber(13); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeNull(); [EOL]     gen.close(); [EOL]     assertEquals("13##false##null", sw.toString()); [EOL] }
public void testCustomRootSeparatorWithFactory() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setRootValueSeparator("##"); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeNumber(13); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeNull(); [EOL]     gen.close(); [EOL]     assertEquals("13##false##null", sw.toString()); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
public void testInputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setInputDecorator(new SimpleInputDecorator()); [EOL]     JsonParser jp; [EOL]     jp = f.createParser(new StringReader("{ }")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(789, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser(new ByteArrayInputStream("[ ]".getBytes("UTF-8"))); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     jp.close(); [EOL]     jp = f.createParser("[ ]".getBytes("UTF-8")); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(456, jp.getIntValue()); [EOL]     jp.close(); [EOL] }
