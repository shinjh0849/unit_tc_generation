public void testGetArgumentCountWithNullArgs() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] int count = context.getArgumentCount(); [EOL] assertEquals(0, count); [EOL] }
public void testGetArgumentCountWithEmptyArgs() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setArguments(new Object[0]); [EOL] int count = context.getArgumentCount(); [EOL] assertEquals(0, count); [EOL] }
public void testGetArgumentCountWithNonEmptyArgs() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setArguments(new Object[]{new Object(), new Object()}); [EOL] int count = context.getArgumentCount(); [EOL] assertEquals(2, count); [EOL] }
public void testComputeContextDependent_SuperTrue() { [EOL] when(super.computeContextDependent()).thenReturn(true); [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionLast() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_LAST; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionBoolean_NoArgs() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_BOOLEAN; [EOL] objectUnderTest.args = null; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionBoolean_EmptyArgs() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_BOOLEAN; [EOL] objectUnderTest.args = new Object[0]; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionBoolean_WithArgs() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_BOOLEAN; [EOL] objectUnderTest.args = new Object[]{new Object()}; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependent_FunctionCount() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_COUNT; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependent_FunctionFormatNumber_WithTwoArgs() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] objectUnderTest.args = new Object[]{new Object(), new Object()}; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertTrue(result); [EOL] }
public void testComputeContextDependent_FunctionFormatNumber_WithOneArg() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] objectUnderTest.args = new Object[]{new Object()}; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public void testComputeContextDependent_FunctionFormatNumber_NoArgs() { [EOL] objectUnderTest.functionCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] objectUnderTest.args = null; [EOL] boolean result = objectUnderTest.computeContextDependent(); [EOL] assertFalse(result); [EOL] }
public Object compute(EvalContext context) { [EOL] return computeValue(context); [EOL] }
public void testComputeValueFunctionLast() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionLast(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_LAST); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionPosition() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionPosition(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_POSITION); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionCount() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionCount(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_COUNT); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionLang() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionLang(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_LANG); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionID() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionID(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_ID); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionLocalName() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionLocalName(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_LOCAL_NAME); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNamespaceURI() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionNamespaceURI(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_NAMESPACE_URI); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionName() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionName(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_NAME); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionString() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionString(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_STRING); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionConcat() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionConcat(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_CONCAT); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionStartsWith() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionStartsWith(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_STARTS_WITH); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionContains() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionContains(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_CONTAINS); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSubstringBefore() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionSubstringBefore(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_SUBSTRING_BEFORE); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSubstringAfter() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionSubstringAfter(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_SUBSTRING_AFTER); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSubstring() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionSubstring(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_SUBSTRING); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionStringLength() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionStringLength(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_STRING_LENGTH); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNormalizeSpace() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionNormalizeSpace(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_NORMALIZE_SPACE); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionTranslate() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionTranslate(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_TRANSLATE); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionBoolean() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionBoolean(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_BOOLEAN); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNot() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionNot(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_NOT); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionTrue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionTrue(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_TRUE); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFalse() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionFalse(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_FALSE); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNull() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionNull(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_NULL); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionNumber(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_NUMBER); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionSum() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionSum(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_SUM); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFloor() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionFloor(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_FLOOR); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionCeiling() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionCeiling(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_CEILING); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionRound() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionRound(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_ROUND); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionKey() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionKey(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_KEY); [EOL] assertEquals(expected, result); [EOL] }
public void testComputeValueFunctionFormatNumber() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object expected = new Object(); [EOL] when(functionFormatNumber(context)).thenReturn(expected); [EOL] Object result = computeValue(context, Compiler.FUNCTION_FORMAT_NUMBER); [EOL] assertEquals(expected, result); [EOL] }
protected Object functionLast(EvalContext context) { [EOL] assertArgCount(0); [EOL] int old = context.getCurrentPosition(); [EOL] context.reset(); [EOL] int count = 0; [EOL] while (context.nextNode()) { [EOL] count++; [EOL] } [EOL] if (old != 0) { [EOL] context.setPosition(old); [EOL] } [EOL] return new Double(count); [EOL] }
public void testFunctionPositionWithValidContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentPosition()).thenReturn(1); [EOL] Object result = functionPosition(context); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(1, ((Integer) result).intValue()); [EOL] }
public void testFunctionPositionWithNegativePosition() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getCurrentPosition()).thenReturn(-1); [EOL] Object result = functionPosition(context); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(-1, ((Integer) result).intValue()); [EOL] }
public void testFunctionLangWithNullPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] Object result = functionLang(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testFunctionLangWithNonNullPointerLanguageMatch() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(mockPointer); [EOL] when(mockPointer.isLanguage("en")).thenReturn(true); [EOL] setArg1ToReturnString("en", context); [EOL] Object result = functionLang(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testFunctionLangWithNonNullPointerLanguageMismatch() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(mockPointer); [EOL] when(mockPointer.isLanguage("en")).thenReturn(false); [EOL] setArg1ToReturnString("fr", context); [EOL] Object result = functionLang(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] } [EOL] private void setArg1ToReturnString(String value, EvalContext context) { [EOL] Expression arg1 = mock(Expression.class); [EOL] when(arg1.computeValue(context)).thenReturn(value); [EOL] when(getArg1()).thenReturn(arg1); [EOL] }
public void testFunctionIDWithValidContextAndID() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] JXPathContext mockJXPathContext = mock(JXPathContext.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] Expression mockExpression = mock(Expression.class); [EOL] Object expected = new Object(); [EOL] when(mockContext.getJXPathContext()).thenReturn(mockJXPathContext); [EOL] when(mockJXPathContext.getContextPointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.getPointerByID(any(JXPathContext.class), anyString())).thenReturn(expected); [EOL] when(mockExpression.computeValue(mockContext)).thenReturn("validID"); [EOL] when(getArg1()).thenReturn(mockExpression); [EOL] Object result = functionID(mockContext); [EOL] assertEquals("Expected to get the correct object by ID", expected, result); [EOL] }
public void testFunctionIDWithInvalidContext() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] JXPathContext mockJXPathContext = mock(JXPathContext.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] Expression mockExpression = mock(Expression.class); [EOL] when(mockContext.getJXPathContext()).thenReturn(mockJXPathContext); [EOL] when(mockJXPathContext.getContextPointer()).thenReturn(null); [EOL] when(mockExpression.computeValue(mockContext)).thenReturn("invalidID"); [EOL] when(getArg1()).thenReturn(mockExpression); [EOL] Object result = functionID(mockContext); [EOL] assertNull("Expected to get null when context pointer is null", result); [EOL] }
public void testFunctionIDWithInvalidID() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] JXPathContext mockJXPathContext = mock(JXPathContext.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] Expression mockExpression = mock(Expression.class); [EOL] when(mockContext.getJXPathContext()).thenReturn(mockJXPathContext); [EOL] when(mockJXPathContext.getContextPointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.getPointerByID(any(JXPathContext.class), anyString())).thenReturn(null); [EOL] when(mockExpression.computeValue(mockContext)).thenReturn("invalidID"); [EOL] when(getArg1()).thenReturn(mockExpression); [EOL] Object result = functionID(mockContext); [EOL] assertNull("Expected to get null when ID is invalid", result); [EOL] }
public void testFunctionStringLengthWithZeroArguments() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(context.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.getValue()).thenReturn("test"); [EOL] Object result = functionStringLength(context); [EOL] assertEquals("Result should be the length of the string 'test'.", new Double(4), result); [EOL] }
public void testFunctionStringLengthWithOneArgument() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JXPathContext jxPathContext = JXPathContext.newContext(new Object()); [EOL] Pointer pointer = jxPathContext.getPointer("testValue"); [EOL] when(context.getCurrentNodePointer()).thenReturn(pointer); [EOL] setArgCount(1); [EOL] setArg1(new Literal(pointer)); [EOL] Object result = functionStringLength(context); [EOL] assertEquals("Result should be the length of the string 'testValue'.", new Double(9), result); [EOL] }
public void testFunctionBooleanWithTrueValue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JXPathContext jxPathContext = JXPathContext.newContext(new Object()); [EOL] Pointer pointer = jxPathContext.getPointer("true()"); [EOL] when(context.getPointer()).thenReturn(pointer); [EOL] Object result = functionBoolean(context); [EOL] assertEquals("The result should be Boolean.TRUE", Boolean.TRUE, result); [EOL] }
public void testFunctionBooleanWithFalseValue() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] JXPathContext jxPathContext = JXPathContext.newContext(new Object()); [EOL] Pointer pointer = jxPathContext.getPointer("false()"); [EOL] when(context.getPointer()).thenReturn(pointer); [EOL] Object result = functionBoolean(context); [EOL] assertEquals("The result should be Boolean.FALSE", Boolean.FALSE, result); [EOL] }
public void testFunctionFalseWithNoArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object result = functionFalse(context); [EOL] assertEquals("The result should be Boolean.FALSE", Boolean.FALSE, result); [EOL] }
public void testFunctionFalseWithArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getArgumentCount()).thenReturn(1); [EOL] try { [EOL] functionFalse(context); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Expected exception message", "Wrong number of arguments.", e.getMessage()); [EOL] } [EOL] }
public void testFunctionSumWithNullArgument() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(getArg1().compute(context)).thenReturn(null); [EOL] Object result = functionSum(context); [EOL] assertEquals("Expected ZERO to be returned when argument is null", ZERO, result); [EOL] }
public void testFunctionSumWithEvalContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext argContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(getArg1().compute(context)).thenReturn(argContext); [EOL] when(argContext.hasNext()).thenReturn(true, false); [EOL] when(argContext.next()).thenReturn(nodePointer); [EOL] when(InfoSetUtil.doubleValue(nodePointer)).thenReturn(10.0); [EOL] Object result = functionSum(context); [EOL] assertEquals("Expected sum to be returned when argument is EvalContext", new Double(10.0), result); [EOL] }
public void testFunctionSumWithInvalidArgumentType() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Object invalidType = new Object(); [EOL] when(getArg1().compute(context)).thenReturn(invalidType); [EOL] try { [EOL] functionSum(context); [EOL] fail("Expected JXPathException to be thrown for invalid argument type"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Invalid argument type for 'sum': " + invalidType.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testAssertArgCountWithCorrectCount() { [EOL] obj.setArgumentCount(3); [EOL] obj.assertArgCount(3); [EOL] }
public void testAssertArgCountWithIncorrectCount() { [EOL] obj.setArgumentCount(2); [EOL] try { [EOL] obj.assertArgCount(3); [EOL] fail("Expected JXPathInvalidSyntaxException was not thrown."); [EOL] } catch (JXPathInvalidSyntaxException e) { [EOL] assertEquals("Incorrect number of argument: " + obj.toString(), e.getMessage()); [EOL] } [EOL] }
public void testGetAbsoluteRootContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] EvalContext evalContext = context.getAbsoluteRootContext(); [EOL] assertNotNull(evalContext); [EOL] }
public void testGetConstantContextWithNodeSet() { [EOL] NodeSet nodeSet = new NodeSet(); // Assuming NodeSet is a valid type for the context [EOL] EvalContext result = getConstantContext(nodeSet); [EOL] assertTrue(result instanceof NodeSetContext); [EOL] }
public void testGetConstantContextWithNodePointer() { [EOL] NodePointer nodePointer = NodePointer.newNodePointer(new QName(null, "test"), new Object(), null); // Assuming this is a valid way to create a NodePointer [EOL] EvalContext result = getConstantContext(nodePointer); [EOL] assertTrue(result instanceof InitialContext); [EOL] }
public void testGetConstantContextWithOtherObject() { [EOL] Object constant = new Object(); // Any object that is not an instance of NodeSet or NodePointer [EOL] EvalContext result = getConstantContext(constant); [EOL] assertTrue(result instanceof InitialContext); [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL] Object node1 = pointer1.getBaseValue(); [EOL] Object node2 = pointer2.getBaseValue(); [EOL] if (node1 == node2) { [EOL] return 0; [EOL] } [EOL] if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) { [EOL] return -1; [EOL] } else if (!(node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL] return 1; [EOL] } else if ((node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL] List list = ((Element) getNode()).getAttributes(); [EOL] int length = list.size(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object n = list.get(i); [EOL] if (n == node1) { [EOL] return -1; [EOL] } else if (n == node2) { [EOL] return 1; [EOL] } [EOL] } [EOL] return 0; [EOL] } [EOL] if (!(node instanceof Element)) { [EOL] throw new RuntimeException("JXPath internal error: " + "compareChildNodes called for " + node); [EOL] } [EOL] List children = ((Element) node).getContent(); [EOL] int length = children.size(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object n = children.get(i); [EOL] if (n == node1) { [EOL] return -1; [EOL] } else if (n == node2) { [EOL] return 1; [EOL] } [EOL] } [EOL] return 0; [EOL] }
public void testIsLeafWithElementNodeHavingNoContent() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getContent()).thenReturn(Collections.emptyList()); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testIsLeafWithElementNodeHavingContent() { [EOL] Node node = mock(Element.class); [EOL] List content = mock(List.class); [EOL] when(content.size()).thenReturn(1); [EOL] when(((Element) node).getContent()).thenReturn(content); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertFalse(result); [EOL] }
public void testIsLeafWithDocumentNodeHavingNoContent() { [EOL] Node node = mock(Document.class); [EOL] when(((Document) node).getContent()).thenReturn(Collections.emptyList()); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testIsLeafWithDocumentNodeHavingContent() { [EOL] Node node = mock(Document.class); [EOL] List content = mock(List.class); [EOL] when(content.size()).thenReturn(1); [EOL] when(((Document) node).getContent()).thenReturn(content); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertFalse(result); [EOL] }
public void testIsLeafWithNonElementOrDocumentNode() { [EOL] Node node = mock(Node.class); [EOL] JxPath jxPath = new JxPath(node); [EOL] boolean result = jxPath.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testGetNameWithElementHavingNamespace() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespacePrefix()).thenReturn("ns"); [EOL] when(((Element) node).getName()).thenReturn("localName"); [EOL] QName result = new QName().getName(); [EOL] assertNotNull(result); [EOL] assertEquals("ns", result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameWithElementHavingEmptyNamespace() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespacePrefix()).thenReturn(""); [EOL] when(((Element) node).getName()).thenReturn("localName"); [EOL] QName result = new QName().getName(); [EOL] assertNotNull(result); [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameWithElementNoNamespace() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getNamespacePrefix()).thenReturn(null); [EOL] when(((Element) node).getName()).thenReturn("localName"); [EOL] QName result = new QName().getName(); [EOL] assertNotNull(result); [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameWithProcessingInstruction() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("target"); [EOL] QName result = new QName().getName(); [EOL] assertNotNull(result); [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("target", result.getLocalPart()); [EOL] }
public void testGetValueWithElement() { [EOL] Node node = mock(Element.class); [EOL] when(((Element) node).getTextTrim()).thenReturn("ElementText"); [EOL] Object result = getValue(node); [EOL] assertEquals("ElementText", result); [EOL] }
public void testGetValueWithCommentAndNonNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn(" CommentText "); [EOL] Object result = getValue(node); [EOL] assertEquals("CommentText", result); [EOL] }
public void testGetValueWithCommentAndNullText() { [EOL] Node node = mock(Comment.class); [EOL] when(((Comment) node).getText()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithText() { [EOL] Node node = mock(Text.class); [EOL] when(((Text) node).getTextTrim()).thenReturn("TextContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("TextContent", result); [EOL] }
public void testGetValueWithCdata() { [EOL] Node node = mock(CDATA.class); [EOL] when(((CDATA) node).getTextTrim()).thenReturn("CdataContent"); [EOL] Object result = getValue(node); [EOL] assertEquals("CdataContent", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNonNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn(" Data "); [EOL] Object result = getValue(node); [EOL] assertEquals("Data", result); [EOL] }
public void testGetValueWithProcessingInstructionAndNullData() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(((ProcessingInstruction) node).getData()).thenReturn(null); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public void testGetValueWithUnknownNodeType() { [EOL] Node node = mock(Node.class); [EOL] Object result = getValue(node); [EOL] assertNull(result); [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL] if (test == null) { [EOL] return true; [EOL] } else if (test instanceof NodeNameTest) { [EOL] if (!(node instanceof Element)) { [EOL] return false; [EOL] } [EOL] NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL] QName testName = nodeNameTest.getNodeName(); [EOL] String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL] boolean wildcard = nodeNameTest.isWildcard(); [EOL] String testPrefix = testName.getPrefix(); [EOL] if (wildcard && testPrefix == null) { [EOL] return true; [EOL] } [EOL] if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL] String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL] return equalStrings(namespaceURI, nodeNS); [EOL] } [EOL] } else if (test instanceof NodeTypeTest) { [EOL] switch(((NodeTypeTest) test).getNodeType()) { [EOL] case Compiler.NODE_TYPE_NODE: [EOL] return (node instanceof Element) || (node instanceof Document); [EOL] case Compiler.NODE_TYPE_TEXT: [EOL] return (node instanceof Text) || (node instanceof CDATA); [EOL] case Compiler.NODE_TYPE_COMMENT: [EOL] return node instanceof Comment; [EOL] case Compiler.NODE_TYPE_PI: [EOL] return node instanceof ProcessingInstruction; [EOL] } [EOL] return false; [EOL] } else if (test instanceof ProcessingInstructionTest) { [EOL] if (node instanceof ProcessingInstruction) { [EOL] String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL] String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL] return testPI.equals(nodePI); [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testEqualStringsBothNull() { [EOL] boolean result = equalStrings(null, null); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsFirstNull() { [EOL] boolean result = equalStrings(null, "test"); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsSecondNull() { [EOL] boolean result = equalStrings("test", null); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsBothNonTrimmed() { [EOL] boolean result = equalStrings(" test ", " test "); [EOL] assertTrue(result); [EOL] }
public void testEqualStringsDifferent() { [EOL] boolean result = equalStrings("test", "different"); [EOL] assertFalse(result); [EOL] }
public void testEqualStringsSameNonTrimmed() { [EOL] boolean result = equalStrings(" test ", "test"); [EOL] assertTrue(result); [EOL] }
public void testIsLanguageWithNullCurrentLanguage() { [EOL] when(instance.getLanguage()).thenReturn(null); [EOL] when(super.isLanguage("en")).thenReturn(true); [EOL] boolean result = instance.isLanguage("en"); [EOL] assertTrue(result); [EOL] }
public void testIsLanguageWithNonNullCurrentLanguageMatching() { [EOL] when(instance.getLanguage()).thenReturn("English"); [EOL] boolean result = instance.isLanguage("en"); [EOL] assertTrue(result); [EOL] }
public void testIsLanguageWithNonNullCurrentLanguageNotMatching() { [EOL] when(instance.getLanguage()).thenReturn("French"); [EOL] boolean result = instance.isLanguage("en"); [EOL] assertFalse(result); [EOL] }
public void testGetLanguageWithElementHavingLangAttribute() { [EOL] Element element = mock(Element.class); [EOL] when(element.getAttributeValue("lang", Namespace.XML_NAMESPACE)).thenReturn("en"); [EOL] when(element instanceof Element).thenReturn(true); [EOL] YourClass instance = new YourClass(element); [EOL] String result = instance.getLanguage(); [EOL] assertEquals("en", result); [EOL] }
public void testGetLanguageWithElementNotHavingLangAttribute() { [EOL] Element element = mock(Element.class); [EOL] when(element.getAttributeValue("lang", Namespace.XML_NAMESPACE)).thenReturn(null); [EOL] when(element instanceof Element).thenReturn(true); [EOL] YourClass instance = new YourClass(element); [EOL] String result = instance.getLanguage(); [EOL] assertNull(result); [EOL] }
public void testGetLanguageWithNonElementNode() { [EOL] Object node = mock(Object.class); [EOL] when(node instanceof Element).thenReturn(false); [EOL] YourClass instance = new YourClass(node); [EOL] String result = instance.getLanguage(); [EOL] assertNull(result); [EOL] }
public void testGetLanguageWithElementHavingEmptyLangAttribute() { [EOL] Element element = mock(Element.class); [EOL] when(element.getAttributeValue("lang", Namespace.XML_NAMESPACE)).thenReturn(""); [EOL] when(element instanceof Element).thenReturn(true); [EOL] YourClass instance = new YourClass(element); [EOL] String result = instance.getLanguage(); [EOL] assertNull(result); [EOL] }
public void testGetLanguageWithInheritedLangAttribute() { [EOL] Element parentElement = mock(Element.class); [EOL] when(parentElement.getAttributeValue("lang", Namespace.XML_NAMESPACE)).thenReturn("fr"); [EOL] when(parentElement instanceof Element).thenReturn(true); [EOL] Element childElement = mock(Element.class); [EOL] when(childElement.getAttributeValue("lang", Namespace.XML_NAMESPACE)).thenReturn(null); [EOL] when(childElement instanceof Element).thenReturn(true); [EOL] YourClass instance = new YourClass(childElement); [EOL] when(instance.nodeParent(childElement)).thenReturn(parentElement); [EOL] String result = instance.getLanguage(); [EOL] assertEquals("fr", result); [EOL] }
public void testNodeParentWithElementHavingElementParent() { [EOL] Element mockElement = mock(Element.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockElement.getParent()).thenReturn(mockParent); [EOL] when(mockParent instanceof Element).thenReturn(true); [EOL] Element result = nodeParent(mockElement); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithElementHavingNonElementParent() { [EOL] Element mockElement = mock(Element.class); [EOL] when(mockElement.getParent()).thenReturn(new Object()); [EOL] Element result = nodeParent(mockElement); [EOL] assertNull(result); [EOL] }
public void testNodeParentWithText() { [EOL] Text mockText = mock(Text.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockText.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockText); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithCDATA() { [EOL] CDATA mockCdata = mock(CDATA.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockCdata.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockCdata); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithProcessingInstruction() { [EOL] ProcessingInstruction mockInstruction = mock(ProcessingInstruction.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockInstruction.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockInstruction); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithComment() { [EOL] Comment mockComment = mock(Comment.class); [EOL] Element mockParent = mock(Element.class); [EOL] when(mockComment.getParent()).thenReturn(mockParent); [EOL] Element result = nodeParent(mockComment); [EOL] assertNotNull(result); [EOL] assertEquals(mockParent, result); [EOL] }
public void testNodeParentWithUnrecognizedObject() { [EOL] Object mockObject = new Object(); [EOL] Element result = nodeParent(mockObject); [EOL] assertNull(result); [EOL] }
public void testAsPathWithIdNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setId("someId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id('someId')", result); [EOL] }
public void testAsPathWithParentNotNullElementNode() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Element node = mock(Element.class); [EOL] instance.setNode(node); [EOL] when(parentInstance.asPath()).thenReturn("/parentPath"); [EOL] when(node instanceof JDOMNodePointer).thenReturn(true); [EOL] when(instance.getNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(JDOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(instance.getRelativePositionByName()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/localName[1]", result); [EOL] }
public void testAsPathWithParentNotNullTextNode() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Text node = mock(Text.class); [EOL] instance.setNode(node); [EOL] when(parentInstance.asPath()).thenReturn("/parentPath"); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/text()[1]", result); [EOL] }
public void testAsPathWithParentNotNullProcessingInstruction() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] ProcessingInstruction node = mock(ProcessingInstruction.class); [EOL] instance.setNode(node); [EOL] when(parentInstance.asPath()).thenReturn("/parentPath"); [EOL] when(node.getTarget()).thenReturn("target"); [EOL] when(instance.getRelativePositionOfPI("target")).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/processing-instruction('target')[1]", result); [EOL] }
public void testAsPathWithParentNotNullElementNodeWithDifferentNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Element node = mock(Element.class); [EOL] instance.setNode(node); [EOL] when(parentInstance.asPath()).thenReturn("/parentPath"); [EOL] when(node instanceof JDOMNodePointer).thenReturn(true); [EOL] when(instance.getNamespaceURI()).thenReturn("differentNamespaceURI"); [EOL] when(JDOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(instance.getNamespaceResolver().getPrefix("differentNamespaceURI")).thenReturn("prefix"); [EOL] when(instance.getRelativePositionByName()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/prefix:localName[1]", result); [EOL] }
public void testAsPathWithParentNotNullElementNodeWithNoNamespacePrefix() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Element node = mock(Element.class); [EOL] instance.setNode(node); [EOL] when(parentInstance.asPath()).thenReturn("/parentPath"); [EOL] when(node instanceof JDOMNodePointer).thenReturn(true); [EOL] when(instance.getNamespaceURI()).thenReturn("differentNamespaceURI"); [EOL] when(JDOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(instance.getNamespaceResolver().getPrefix("differentNamespaceURI")).thenReturn(null); [EOL] when(instance.getRelativePositionOfElement()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/node()[1]", result); [EOL] }
public void testGetRelativePositionOfElementWithNullParent() { [EOL] Element node = mock(Element.class); [EOL] when(node.getParent()).thenReturn(null); [EOL] int position = getRelativePositionOfElement(node); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfElementWithElementParent() { [EOL] Element node = mock(Element.class); [EOL] Element parent = mock(Element.class); [EOL] List content = new ArrayList(); [EOL] content.add(node); [EOL] when(node.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(content); [EOL] int position = getRelativePositionOfElement(node); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfElementWithDocumentParent() { [EOL] Element node = mock(Element.class); [EOL] Document parent = mock(Document.class); [EOL] List content = new ArrayList(); [EOL] content.add(node); [EOL] when(node.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(content); [EOL] int position = getRelativePositionOfElement(node); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfElementWithMultipleChildren() { [EOL] Element node = mock(Element.class); [EOL] Element parent = mock(Element.class); [EOL] Element child1 = mock(Element.class); [EOL] Element child2 = mock(Element.class); [EOL] List content = new ArrayList(); [EOL] content.add(child1); [EOL] content.add(node); [EOL] content.add(child2); [EOL] when(node.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(content); [EOL] int position = getRelativePositionOfElement(node); [EOL] assertEquals(2, position); [EOL] }
public void testGetRelativePositionOfPIWithNullParent() { [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] when(pi.getParent()).thenReturn(null); [EOL] int result = getRelativePositionOfPI(null); [EOL] assertEquals(1, result); [EOL] }
public void testGetRelativePositionOfPIWithNoMatchingTarget() { [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] Element parent = mock(Element.class); [EOL] List children = new ArrayList(); [EOL] children.add(mock(ProcessingInstruction.class)); // This PI has a different target [EOL] children.add(pi); [EOL] when(pi.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(children); [EOL] int result = getRelativePositionOfPI("target"); [EOL] assertEquals(1, result); // Assuming the target of the first PI is not "target" [EOL] }
public void testGetRelativePositionOfPIWithMatchingTarget() { [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] Element parent = mock(Element.class); [EOL] ProcessingInstruction childPI = mock(ProcessingInstruction.class); [EOL] List children = new ArrayList(); [EOL] children.add(childPI); [EOL] children.add(pi); [EOL] when(pi.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(children); [EOL] when(childPI.getTarget()).thenReturn("target"); [EOL] int result = getRelativePositionOfPI("target"); [EOL] assertEquals(2, result); // There are two PIs with the target "target" [EOL] }
public void testGetRelativePositionOfPIWithNullTarget() { [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] Element parent = mock(Element.class); [EOL] ProcessingInstruction childPI = mock(ProcessingInstruction.class); [EOL] List children = new ArrayList(); [EOL] children.add(childPI); [EOL] children.add(pi); [EOL] when(pi.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(children); [EOL] when(childPI.getTarget()).thenReturn(null); [EOL] int result = getRelativePositionOfPI(null); [EOL] assertEquals(2, result); // There are two PIs and we are looking for null target [EOL] }
public void testHashCode() { [EOL] Object node = new Object(); [EOL] JXPathContextReferenceImpl.NodePointerTestWrapper pointer = new JXPathContextReferenceImpl.NodePointerTestWrapper(node); [EOL] int expectedHashCode = System.identityHashCode(node); [EOL] int actualHashCode = pointer.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testGetName() { [EOL] MyClass instance = new MyClass(); // Replace MyClass with the actual class name [EOL] QName expected = new QName("localPart"); // Replace with the expected QName value [EOL] instance.name = expected; // Assuming 'name' can be accessed, otherwise use a constructor or setter method [EOL] QName actual = instance.getName(); [EOL] assertEquals(expected, actual); [EOL] }
public int getLength() { [EOL] return 1; [EOL] }
public boolean isLeafTest() { [EOL] Node node = new Node(); [EOL] boolean result = node.isLeaf(); [EOL] assert !result; // The method always returns false, so the assertion checks for false [EOL] }
public void testHashCodeWithNameNull() { [EOL] JXPath jxPath = new JXPath(); [EOL] jxPath.setName(null); [EOL] int result = jxPath.hashCode(); [EOL] assertEquals(0, result); [EOL] }
public void testHashCodeWithNameNotNull() { [EOL] JXPath jxPath = new JXPath(); [EOL] jxPath.setName("testName"); [EOL] int result = jxPath.hashCode(); [EOL] assertEquals("testName".hashCode(), result); [EOL] }
public void testEquals_SameObject() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] assertTrue(pointer.equals(pointer)); [EOL] }
public void testEquals_DifferentClass() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] Object other = new Object(); [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_NullParent() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.parent = null; [EOL] other.parent = new Object(); [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_NonNullParent() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] Object parent = new Object(); [EOL] pointer.parent = parent; [EOL] other.parent = parent; [EOL] assertTrue(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_NullName() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.name = null; [EOL] other.name = "test"; [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_NonNullName() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.name = "test"; [EOL] other.name = "test"; [EOL] assertTrue(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_DifferentIndex() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.index = 1; [EOL] other.index = 2; [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_SameIndex() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.index = 1; [EOL] other.index = 1; [EOL] assertTrue(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_DifferentDynaBean() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.dynaBean = new Object(); [EOL] other.dynaBean = new Object(); [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_SameDynaBean() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] Object dynaBean = new Object(); [EOL] pointer.dynaBean = dynaBean; [EOL] other.dynaBean = dynaBean; [EOL] assertTrue(pointer.equals(other)); [EOL] }
public void testUnescapeWithApos() { [EOL] String input = "This isn't the best example."; [EOL] String expected = "This isn't the best example."; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithQuot() { [EOL] String input = "He said, \"Hello, World!\""; [EOL] String expected = "He said, \"Hello, World!\""; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithBothAposAndQuot() { [EOL] String input = "It&apos;s a &quot;beautiful&quot; day!"; [EOL] String expected = "It's a \"beautiful\" day!"; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithNoSpecialCharacters() { [EOL] String input = "Just a normal string."; [EOL] String expected = "Just a normal string."; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithConsecutiveSpecialCharacters() { [EOL] String input = "This &apos;&apos;is&apos;&apos; &quot;&quot;quoted&quot;&quot;."; [EOL] String expected = "This ''is'' \"\"quoted\"\"."; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testUnescapeWithSpecialCharactersAtTheBeginningAndEnd() { [EOL] String input = "&apos;At the beginning and end&quot;"; [EOL] String expected = "'At the beginning and end\""; [EOL] String result = unescape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testNCNameWithNCNameToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NCName; [EOL] token.image = "expectedNCName"; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] String result = parser.NCName(); [EOL] assertEquals("expectedNCName", result); [EOL] }
public void testNCNameWithNodeToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NODE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(NODE, parser.token.kind); [EOL] }
public void testNCNameWithTextToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = TEXT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(TEXT, parser.token.kind); [EOL] }
public void testNCNameWithCommentToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = COMMENT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(COMMENT, parser.token.kind); [EOL] }
public void testNCNameWithPIToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = PI; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(PI, parser.token.kind); [EOL] }
public void testNCNameWithFunctionLastToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_LAST; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_LAST, parser.token.kind); [EOL] }
public void testNCNameWithInvalidToken() { [EOL] Token token = new Token(); [EOL] token.kind = -1; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] assertThrows(ParseException.class, parser::NCName); [EOL] }
public int testCoreFunctionNameWithFunctionLast() throws ParseException { [EOL] jj_nt.kind = FUNCTION_LAST; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_LAST, result); [EOL] }
public int testCoreFunctionNameWithFunctionPosition() throws ParseException { [EOL] jj_nt.kind = FUNCTION_POSITION; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_POSITION, result); [EOL] }
public int testCoreFunctionNameWithFunctionCount() throws ParseException { [EOL] jj_nt.kind = FUNCTION_COUNT; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_COUNT, result); [EOL] }
public int testCoreFunctionNameWithFunctionId() throws ParseException { [EOL] jj_nt.kind = FUNCTION_ID; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_ID, result); [EOL] }
public int testCoreFunctionNameWithFunctionLocalName() throws ParseException { [EOL] jj_nt.kind = FUNCTION_LOCAL_NAME; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_LOCAL_NAME, result); [EOL] }
public int testCoreFunctionNameWithFunctionNamespaceUri() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NAMESPACE_URI; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_NAMESPACE_URI, result); [EOL] }
public int testCoreFunctionNameWithFunctionName() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NAME; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_NAME, result); [EOL] }
public int testCoreFunctionNameWithFunctionString() throws ParseException { [EOL] jj_nt.kind = FUNCTION_STRING; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_STRING, result); [EOL] }
public int testCoreFunctionNameWithFunctionConcat() throws ParseException { [EOL] jj_nt.kind = FUNCTION_CONCAT; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_CONCAT, result); [EOL] }
public int testCoreFunctionNameWithFunctionStartsWith() throws ParseException { [EOL] jj_nt.kind = FUNCTION_STARTS_WITH; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_STARTS_WITH, result); [EOL] }
public int testCoreFunctionNameWithFunctionContains() throws ParseException { [EOL] jj_nt.kind = FUNCTION_CONTAINS; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_CONTAINS, result); [EOL] }
public int testCoreFunctionNameWithFunctionSubstringBefore() throws ParseException { [EOL] jj_nt.kind = FUNCTION_SUBSTRING_BEFORE; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_SUBSTRING_BEFORE, result); [EOL] }
public int testCoreFunctionNameWithFunctionSubstringAfter() throws ParseException { [EOL] jj_nt.kind = FUNCTION_SUBSTRING_AFTER; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_SUBSTRING_AFTER, result); [EOL] }
public int testCoreFunctionNameWithFunctionSubstring() throws ParseException { [EOL] jj_nt.kind = FUNCTION_SUBSTRING; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_SUBSTRING, result); [EOL] }
public int testCoreFunctionNameWithFunctionStringLength() throws ParseException { [EOL] jj_nt.kind = FUNCTION_STRING_LENGTH; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_STRING_LENGTH, result); [EOL] }
public int testCoreFunctionNameWithFunctionNormalizeSpace() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NORMALIZE_SPACE; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_NORMALIZE_SPACE, result); [EOL] }
public int testCoreFunctionNameWithFunctionTranslate() throws ParseException { [EOL] jj_nt.kind = FUNCTION_TRANSLATE; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_TRANSLATE, result); [EOL] }
public int testCoreFunctionNameWithFunctionBoolean() throws ParseException { [EOL] jj_nt.kind = FUNCTION_BOOLEAN; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_BOOLEAN, result); [EOL] }
public int testCoreFunctionNameWithFunctionNot() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NOT; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_NOT, result); [EOL] }
public int testCoreFunctionNameWithFunctionTrue() throws ParseException { [EOL] jj_nt.kind = FUNCTION_TRUE; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_TRUE, result); [EOL] }
public int testCoreFunctionNameWithFunctionFalse() throws ParseException { [EOL] jj_nt.kind = FUNCTION_FALSE; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_FALSE, result); [EOL] }
public int testCoreFunctionNameWithFunctionNull() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NULL; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_NULL, result); [EOL] }
public int testCoreFunctionNameWithFunctionLang() throws ParseException { [EOL] jj_nt.kind = FUNCTION_LANG; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_LANG, result); [EOL] }
public int testCoreFunctionNameWithFunctionNumber() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NUMBER; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_NUMBER, result); [EOL] }
public int testCoreFunctionNameWithFunctionSum() throws ParseException { [EOL] jj_nt.kind = FUNCTION_SUM; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_SUM, result); [EOL] }
public int testCoreFunctionNameWithFunctionFloor() throws ParseException { [EOL] jj_nt.kind = FUNCTION_FLOOR; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_FLOOR, result); [EOL] }
public int testCoreFunctionNameWithFunctionCeiling() throws ParseException { [EOL] jj_nt.kind = FUNCTION_CEILING; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_CEILING, result); [EOL] }
public int testCoreFunctionNameWithFunctionRound() throws ParseException { [EOL] jj_nt.kind = FUNCTION_ROUND; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_ROUND, result); [EOL] }
public int testCoreFunctionNameWithFunctionKey() throws ParseException { [EOL] jj_nt.kind = FUNCTION_KEY; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_KEY, result); [EOL] }
public int testCoreFunctionNameWithFunctionFormatNumber() throws ParseException { [EOL] jj_nt.kind = FUNCTION_FORMAT_NUMBER; [EOL] int result = CoreFunctionName(); [EOL] assertEquals(Compiler.FUNCTION_FORMAT_NUMBER, result); [EOL] }
public int testCoreFunctionNameWithInvalidKind() { [EOL] jj_nt.kind = INVALID_KIND; [EOL] try { [EOL] CoreFunctionName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object testLocationPathWithOR() throws ParseException { [EOL] jj_nt.kind = OR; [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testLocationPathWithSLASH() throws ParseException { [EOL] jj_nt.kind = SLASH; [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testLocationPathWithDefault() { [EOL] jj_nt.kind = INVALID_KIND; // Assuming INVALID_KIND is a constant for an invalid kind [EOL] try { [EOL] LocationPath(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] return null; [EOL] }
public void testAbsoluteLocationPathWithSteps() throws ParseException { [EOL] when(mockParser.jj_2_2(2147483647)).thenReturn(true); [EOL] when(mockParser.jj_nt.kind).thenReturn(KIND_OTHER); [EOL] Object result = mockParser.AbsoluteLocationPath(); [EOL] assertNotNull(result); [EOL] verify(mockParser).LocationStep(any(ArrayList.class)); [EOL] }
public void testAbsoluteLocationPathWithSlash() throws ParseException { [EOL] when(mockParser.jj_2_2(2147483647)).thenReturn(false); [EOL] when(mockParser.jj_nt.kind).thenReturn(SLASH); [EOL] Object result = mockParser.AbsoluteLocationPath(); [EOL] assertNotNull(result); [EOL] verify(mockParser).jj_consume_token(SLASH); [EOL] }
public void testAbsoluteLocationPathWithParseException() { [EOL] when(mockParser.jj_2_2(2147483647)).thenReturn(false); [EOL] when(mockParser.jj_nt.kind).thenReturn(KIND_OTHER); [EOL] doThrow(new ParseException()).when(mockParser).jj_consume_token(-1); [EOL] assertThrows(ParseException.class, () -> mockParser.AbsoluteLocationPath()); [EOL] }
public void testNodeTestWithNodeType() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NODE; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithProcessingInstruction() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.PI; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithWildcardName() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NCName; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithSelfAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 82; // Assuming 82 corresponds to the AXIS_SELF [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParentAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 83; // Assuming 83 corresponds to the AXIS_PARENT [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithPredicate() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 84; // Assuming 84 corresponds to a Predicate [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParseException() { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = -1; // Invalid kind to trigger ParseException [EOL] try { [EOL] jjParser.NodeTest(steps); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public int testAxisSpecifierWithAxisSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForSelf, result); [EOL] }
public int testAxisSpecifierWithAxisChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForChild, result); [EOL] }
public int testAxisSpecifierWithAxisParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForParent, result); [EOL] }
public int testAxisSpecifierWithAxisAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForAncestor, result); [EOL] }
public int testAxisSpecifierWithAxisAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForAttribute, result); [EOL] }
public int testAxisSpecifierWithAxisNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForNamespace, result); [EOL] }
public int testAxisSpecifierWithAxisPreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForPreceding, result); [EOL] }
public int testAxisSpecifierWithAxisFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForFollowing, result); [EOL] }
public int testAxisSpecifierWithAxisDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForDescendant, result); [EOL] }
public int testAxisSpecifierWithAxisAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForAncestorOrSelf, result); [EOL] }
public int testAxisSpecifierWithAxisFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForFollowingSibling, result); [EOL] }
public int testAxisSpecifierWithAxisPrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForPrecedingSibling, result); [EOL] }
public int testAxisSpecifierWithAxisDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForDescendantOrSelf, result); [EOL] }
public int testAxisSpecifierWithDefault() throws ParseException { [EOL] jj_nt.kind = DEFAULT_AXIS_KIND; // Replace with an actual default kind that is not covered by the cases [EOL] int result = AxisSpecifier(); [EOL] assertEquals(expectedAxisValueForDefault, result); [EOL] }
public void testAxisNameSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_SELF, result); [EOL] }
public void testAxisNameChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAxisNameParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PARENT, result); [EOL] }
public void testAxisNameAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR, result); [EOL] }
public void testAxisNameAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testAxisNameNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_NAMESPACE, result); [EOL] }
public void testAxisNamePreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING, result); [EOL] }
public void testAxisNameFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING, result); [EOL] }
public void testAxisNameDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT, result); [EOL] }
public void testAxisNameAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR_OR_SELF, result); [EOL] }
public void testAxisNameFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING_SIBLING, result); [EOL] }
public void testAxisNamePrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING_SIBLING, result); [EOL] }
public void testAxisNameDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT_OR_SELF, result); [EOL] }
public void testAxisNameInvalid() { [EOL] jj_nt.kind = INVALID_KIND; [EOL] assertThrows(ParseException.class, () -> { [EOL] AxisName(); [EOL] }); [EOL] }
public void testAbbreviatedAxisSpecifierWithAxisChild() throws ParseException { [EOL] jj_nt.kind = 85; // Any value other than 86 [EOL] int result = AbbreviatedAxisSpecifier(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAbbreviatedAxisSpecifierWithAxisAttribute() throws ParseException { [EOL] jj_nt.kind = 86; [EOL] jj_consume_token(86); // Assuming this method is mocked and does not throw [EOL] int result = AbbreviatedAxisSpecifier(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testPrimaryExprWithVariable() throws ParseException { [EOL] jj_nt.kind = VARIABLE; [EOL] Object expected = new Object(); [EOL] when(VariableReference()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithLiteral() throws ParseException { [EOL] jj_nt.kind = Literal; [EOL] Token token = new Token(); [EOL] token.image = "\"literal\""; [EOL] when(jj_consume_token(Literal)).thenReturn(token); [EOL] Object expected = new Object(); [EOL] when(compiler.literal("literal")).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithNumber() throws ParseException { [EOL] jj_nt.kind = Number; [EOL] Token token = new Token(); [EOL] token.image = "123"; [EOL] when(jj_consume_token(Number)).thenReturn(token); [EOL] Object expected = new Object(); [EOL] when(compiler.number(token.image)).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithParentheses() throws ParseException { [EOL] jj_nt.kind = 80; [EOL] Object expected = new Object(); [EOL] when(Expression()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] verify(jj_consume_token, times(2)).consume(anyInt()); [EOL] }
public void testPrimaryExprWithCoreFunctionCall() throws ParseException { [EOL] jj_nt.kind = FUNCTION_NAME; // Assuming FUNCTION_NAME is not handled by the switch-case [EOL] Object expected = new Object(); [EOL] when(jj_2_5(2147483647)).thenReturn(true); [EOL] when(CoreFunctionCall()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithFunctionCall() throws ParseException { [EOL] jj_nt.kind = FUNCTION_COUNT; // Assuming FUNCTION_COUNT is one of the function call cases [EOL] Object expected = new Object(); [EOL] when(FunctionCall()).thenReturn(expected); [EOL] Object result = PrimaryExpr(); [EOL] assertEquals(expected, result); [EOL] }
public void testPrimaryExprWithParseException() { [EOL] jj_nt.kind = -1; // Assuming -1 is not handled by any case [EOL] assertThrows(ParseException.class, () -> { [EOL] PrimaryExpr(); [EOL] }); [EOL] }
public void testCoreFunctionCallWithNullArguments() throws ParseException { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] when(mockCompiler.function(anyInt(), isNull())).thenReturn(new Object()); [EOL] MyClass myClass = new MyClass(mockCompiler); [EOL] when(myClass.CoreFunctionName()).thenReturn(0); [EOL] when(myClass.ArgumentList()).thenReturn(null); [EOL] Object result = myClass.CoreFunctionCall(); [EOL] verify(mockCompiler).function(0, null); [EOL] assertNotNull(result); [EOL] }
public void testCoreFunctionCallWithNonNullArguments() throws ParseException { [EOL] Compiler mockCompiler = mock(Compiler.class); [EOL] ArrayList<Object> arguments = new ArrayList<>(); [EOL] arguments.add(new Object()); [EOL] when(mockCompiler.function(anyInt(), any())).thenReturn(new Object()); [EOL] MyClass myClass = new MyClass(mockCompiler); [EOL] when(myClass.CoreFunctionName()).thenReturn(0); [EOL] when(myClass.ArgumentList()).thenReturn(arguments); [EOL] Object result = myClass.CoreFunctionCall(); [EOL] verify(mockCompiler).function(0, arguments.toArray()); [EOL] assertNotNull(result); [EOL] }
public void testArgumentListWithSingleArgument() throws ParseException { [EOL] setupTokenKind(SLASH); // Replace SLASH with the actual constant value [EOL] jj_consume_token(80); [EOL] ArrayList result = ArgumentList(); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] Object expectedArg = getExpectedArgument(); // Replace with actual method to get expected argument [EOL] assertEquals(expectedArg, result.get(0)); [EOL] }
public void testArgumentListWithMultipleArguments() throws ParseException { [EOL] setupTokenKind(SLASH); // Replace SLASH with the actual constant value [EOL] jj_consume_token(80); [EOL] setupTokenKind(87); // Replace 87 with the actual constant value for multiple arguments [EOL] ArrayList result = ArgumentList(); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() > 1); [EOL] Object expectedArg = getExpectedArgument(); // Replace with actual method to get expected argument [EOL] for (Object arg : result) { [EOL] assertEquals(expectedArg, arg); [EOL] } [EOL] }
public void testArgumentListWithNoArguments() throws ParseException { [EOL] setupTokenKind(81); // Replace 81 with the actual constant value for no arguments [EOL] jj_consume_token(80); [EOL] ArrayList result = ArgumentList(); [EOL] assertNull(result); [EOL] }
public Object testArgumentReturnsExpressionResult() throws ParseException { [EOL] Object expected = new Object(); // Replace with the actual expected result from Expression() [EOL] Object result = Argument(); [EOL] assertSame("Argument should return the result of Expression", expected, result); [EOL] }
public Object testUnionExpr_SinglePathExpr() throws ParseException { [EOL] Object result = UnionExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnionExpr_MultiplePathExpr() throws ParseException { [EOL] Object result = UnionExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testPathExprWithFilterExpr() throws ParseException { [EOL] when(jj_2_6(2147483647)).thenReturn(true); [EOL] Object expected = new Object(); [EOL] when(FilterExpr()).thenReturn(expected); [EOL] Object result = PathExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testPathExprWithLocationPath() throws ParseException { [EOL] when(jj_2_6(2147483647)).thenReturn(false); [EOL] Token token = new Token(); [EOL] token.kind = TokenKind.SLASH; // Replace with actual constant value [EOL] when(jj_nt.kind).thenReturn(token.kind); [EOL] Object expected = new Object(); [EOL] when(LocationPath()).thenReturn(expected); [EOL] Object result = PathExpr(); [EOL] assertEquals(expected, result); [EOL] }
public Object testPathExprWithParseException() throws ParseException { [EOL] when(jj_2_6(2147483647)).thenReturn(false); [EOL] Token token = new Token(); [EOL] token.kind = -1; // Use an invalid kind to trigger the default case [EOL] when(jj_nt.kind).thenReturn(token.kind); [EOL] assertThrows(ParseException.class, () -> { [EOL] PathExpr(); [EOL] }); [EOL] }
public Object testFilterExprWithNoPath() throws ParseException { [EOL] Object result = FilterExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testFilterExprWithPathAndNoSteps() throws ParseException { [EOL] Object result = FilterExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testFilterExprWithPathAndSteps() throws ParseException { [EOL] Object result = FilterExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object MultiplicativeExpr() throws ParseException { [EOL] Object ex, r; [EOL] ex = UnaryExpr(); [EOL] label_14: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case MOD: [EOL] case DIV: [EOL] case 88: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[32] = jj_gen; [EOL] break label_14; [EOL] } [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] r = UnaryExpr(); [EOL] ex = compiler.multiply(ex, r); [EOL] break; [EOL] case DIV: [EOL] jj_consume_token(DIV); [EOL] r = UnaryExpr(); [EOL] ex = compiler.divide(ex, r); [EOL] break; [EOL] case MOD: [EOL] jj_consume_token(MOD); [EOL] r = UnaryExpr(); [EOL] ex = compiler.mod(ex, r); [EOL] break; [EOL] default: [EOL] jj_la1[33] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] } [EOL] { [EOL] if (true) [EOL] return ex; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testUnaryExprWithSlash() throws ParseException { [EOL] initParser("/"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithMinus() throws ParseException { [EOL] initParser("-"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testUnaryExprWithInvalidToken() { [EOL] initParser("#"); // Assuming '#' is an invalid token for this parser [EOL] try { [EOL] parser.UnaryExpr(); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
final public Object WildcardName() throws ParseException { [EOL] Object qn; [EOL] String nc1, nc2 = null; [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] break; [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] NCName(); [EOL] break; [EOL] default: [EOL] jj_la1[35] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] nc1 = token.image; [EOL] switch(jj_nt.kind) { [EOL] case 79: [EOL] jj_consume_token(79); [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] break; [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] NCName(); [EOL] break; [EOL] default: [EOL] jj_la1[36] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] nc2 = token.image; [EOL] break; [EOL] default: [EOL] jj_la1[37] = jj_gen; [EOL] ; [EOL] } [EOL] if (nc2 != null) { [EOL] qn = compiler.qname(nc1, nc2); [EOL] } else { [EOL] qn = compiler.qname(null, nc1); [EOL] } [EOL] { [EOL] if (true) [EOL] return qn; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public void testNodeTypeText() throws ParseException { [EOL] NodeTypeParser parser = new NodeTypeParser(); [EOL] parser.jj_nt.kind = NodeTypeParserConstants.TEXT; [EOL] int result = parser.NodeType(); [EOL] assertEquals(Compiler.NODE_TYPE_TEXT, result); [EOL] }
public void testNodeTypeNode() throws ParseException { [EOL] NodeTypeParser parser = new NodeTypeParser(); [EOL] parser.jj_nt.kind = NodeTypeParserConstants.NODE; [EOL] int result = parser.NodeType(); [EOL] assertEquals(Compiler.NODE_TYPE_NODE, result); [EOL] }
public void testNodeTypeComment() throws ParseException { [EOL] NodeTypeParser parser = new NodeTypeParser(); [EOL] parser.jj_nt.kind = NodeTypeParserConstants.COMMENT; [EOL] int result = parser.NodeType(); [EOL] assertEquals(Compiler.NODE_TYPE_COMMENT, result); [EOL] }
public void testNodeTypePI() throws ParseException { [EOL] NodeTypeParser parser = new NodeTypeParser(); [EOL] parser.jj_nt.kind = NodeTypeParserConstants.PI; [EOL] int result = parser.NodeType(); [EOL] assertEquals(Compiler.NODE_TYPE_PI, result); [EOL] }
public void testNodeTypeInvalid() { [EOL] NodeTypeParser parser = new NodeTypeParser(); [EOL] parser.jj_nt.kind = -1; // Assuming -1 is not a valid kind [EOL] assertThrows(ParseException.class, parser::NodeType); [EOL] }
public void testJj_2_2WithXlaZero() { [EOL] int xla = 0; [EOL] boolean result = jj_2_2(xla); [EOL] assertFalse(result); [EOL] }
public void testJj_2_2WithXlaPositive() { [EOL] int xla = 1; [EOL] boolean result = jj_2_2(xla); [EOL] assertFalse(result); [EOL] }
public void testJj_2_5_WhenJj3_5ReturnsTrue() { [EOL] initTokenAndJj_la(0); // Assuming initTokenAndJj_la is a method that initializes 'token' and 'jj_la' [EOL] boolean result = jj_2_5(1); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_2_5_WhenJj3_5ReturnsFalse() { [EOL] initTokenAndJj_la(0); // Assuming initTokenAndJj_la is a method that initializes 'token' and 'jj_la' [EOL] boolean result = jj_2_5(1); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_65_TokenIsFunctionId() { [EOL] boolean result = jj_3R_65(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_65_AtEndOfInput() { [EOL] boolean result = jj_3R_65(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_104_WhenJj_3R_118IsTrue() { [EOL] boolean result = jj_3R_104(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_104_WhenJj_3R_118IsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_104(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_104_WhenJj_3R_118IsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_104(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_64_WithFunctionCountToken() { [EOL] boolean result = jj_3R_64(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_64_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_64(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_64_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value not equal to jj_lastpos [EOL] boolean result = jj_3R_64(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_63_TokenIsFunctionPosition() { [EOL] boolean result = jj_3R_63(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_63_AtEndOfInput() { [EOL] boolean result = jj_3R_63(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_63_NotAtEndOfInput() { [EOL] boolean result = jj_3R_63(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_62_TokenIsFunctionLast() { [EOL] boolean result = jj_3R_62(); [EOL] assert(result); [EOL] }
public void testJj_3R_62_AtEndOfInput() { [EOL] boolean result = jj_3R_62(); [EOL] assert(!result); [EOL] }
public void testJj_3R_62_NotAtEndOfInput() { [EOL] boolean result = jj_3R_62(); [EOL] assert(!result); [EOL] }
final private boolean jj_3R_18() { [EOL] Token xsp; [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_62()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_63()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_64()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_65()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_66()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_67()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_68()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_69()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_70()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_71()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_72()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_73()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_74()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_75()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_76()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_77()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_78()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_79()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_80()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_81()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_82()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_83()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_84()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_85()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_86()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_87()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_88()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_89()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_90()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_91()) [EOL] return true; [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] return false; [EOL] }
public void testJj_3R_111_TokenIsDiv() { [EOL] when(jj_scan_token(DIV)).thenReturn(true); [EOL] boolean result = jj_3R_111(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_111_AtEndOfInput() { [EOL] when(jj_scan_token(DIV)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_111(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_111_NotAtEndOfInput() { [EOL] when(jj_scan_token(DIV)).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object [EOL] jj_lastpos = new Object(); // and different from jj_scanpos [EOL] boolean result = jj_3R_111(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_110_WithModToken() { [EOL] jj_scan_token(MOD); [EOL] boolean result = jj_3R_110(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_110_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_110(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_110_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_110(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_109_TokenIsAND() { [EOL] assertTrue(jj_3R_109()); [EOL] }
public void testJj_3R_109_AtEndOfInput() { [EOL] assertFalse(jj_3R_109()); [EOL] }
public void testJj_3R_108_WhenScanTokenIsOR() { [EOL] boolean result = jj_3R_108(); [EOL] assert(result); [EOL] }
public void testJj_3R_108_WhenLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_108(); [EOL] assert(!result); [EOL] }
public void testJj_3R_108_WhenScanTokenIsNotORAndLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_108(); [EOL] assert(!result); [EOL] }
public void testJj_3R_98_WhenJj_3R_107ReturnsTrue() { [EOL] when(jj_3R_107()).thenReturn(true); [EOL] when(jj_3R_108()).thenReturn(false); [EOL] when(jj_3R_109()).thenReturn(false); [EOL] when(jj_3R_110()).thenReturn(false); [EOL] when(jj_3R_111()).thenReturn(false); [EOL] boolean result = jj_3R_98(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_98_WhenJj_3R_107ThroughJj_3R_111AllReturnFalse() { [EOL] when(jj_3R_107()).thenReturn(false); [EOL] when(jj_3R_108()).thenReturn(false); [EOL] when(jj_3R_109()).thenReturn(false); [EOL] when(jj_3R_110()).thenReturn(false); [EOL] when(jj_3R_111()).thenReturn(false); [EOL] boolean result = jj_3R_98(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_98_WhenJj_3R_111ReturnsTrue() { [EOL] when(jj_3R_107()).thenReturn(false); [EOL] when(jj_3R_108()).thenReturn(false); [EOL] when(jj_3R_109()).thenReturn(false); [EOL] when(jj_3R_110()).thenReturn(false); [EOL] when(jj_3R_111()).thenReturn(true); [EOL] boolean result = jj_3R_98(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_171_WhenJj_3R_174IsTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure that jj_la is not zero to avoid early return [EOL] when(jj_3R_174()).thenReturn(true); [EOL] when(jj_3R_175()).thenReturn(false); [EOL] boolean result = jj_3R_171(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_171_WhenJj_3R_174IsFalseAndJj_3R_175IsTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure that jj_la is not zero to avoid early return [EOL] when(jj_3R_174()).thenReturn(false); [EOL] when(jj_3R_175()).thenReturn(true); [EOL] when(jj_3R_176()).thenReturn(false); [EOL] boolean result = jj_3R_171(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_171_WhenJj_3R_174IsFalseAndJj_3R_175IsFalseAndJj_3R_176IsTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure that jj_la is not zero to avoid early return [EOL] when(jj_3R_174()).thenReturn(false); [EOL] when(jj_3R_175()).thenReturn(false); [EOL] when(jj_3R_176()).thenReturn(true); [EOL] boolean result = jj_3R_171(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_171_WhenAllConditionsAreFalseAndJjLaIsZero() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; // Set jj_lastpos to be equal to jj_scanpos [EOL] jj_la = 0; // Set jj_la to zero to trigger the return false condition [EOL] when(jj_3R_174()).thenReturn(false); [EOL] when(jj_3R_175()).thenReturn(false); [EOL] when(jj_3R_176()).thenReturn(false); [EOL] boolean result = jj_3R_171(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_172_WhenJj_3R_177ReturnsTrue() { [EOL] boolean result = jj_3R_172(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_172_WhenJj_3R_177ReturnsFalseAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_172(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_172_WhenJj_3R_177ReturnsFalseAndScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_172(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_153_Token86() { [EOL] boolean result = jj_3R_153(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_153_EndOfLookahead() { [EOL] boolean result = jj_3R_153(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_153_NotToken86AndNotEndOfLookahead() { [EOL] boolean result = jj_3R_153(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningTrue() { [EOL] boolean result = jj_3R_130(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningFalseAndJj_laNotZero() { [EOL] boolean result = jj_3R_130(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningFalseAndJj_laZeroAndScanposNotLastpos() { [EOL] boolean result = jj_3R_130(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_130_WithJj_3R_153ReturningFalseAndJj_laZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_130(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_54_TokenIsFunctionFormatNumber() { [EOL] when(jj_scan_token(FUNCTION_FORMAT_NUMBER)).thenReturn(true); [EOL] boolean result = jj_3R_54(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_54_AtEndOfInput() { [EOL] when(jj_scan_token(FUNCTION_FORMAT_NUMBER)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_54(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_54_NotAtEndOfInput() { [EOL] when(jj_scan_token(FUNCTION_FORMAT_NUMBER)).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos is of type Token and different from jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_54(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningTrueAndJj_3R_173ReturningTrue() { [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningTrueAndJj_3R_173ReturningFalse() { [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningFalse() { [EOL] }
public void testJj_3R_53_WithFunctionKeyToken() { [EOL] initToken(FUNCTION_KEY); [EOL] boolean result = jj_3R_53(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_53_WithNonFunctionKeyTokenAndLaZeroAndScanposEqualsLastpos() { [EOL] initToken(NON_FUNCTION_KEY); [EOL] setLaAndScanpos(0); [EOL] boolean result = jj_3R_53(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_53_WithNonFunctionKeyTokenAndLaNotZero() { [EOL] initToken(NON_FUNCTION_KEY); [EOL] setLaAndScanpos(1); // Assuming 1 is not zero [EOL] boolean result = jj_3R_53(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_52_WithFunctionRoundToken() { [EOL] boolean result = jj_3R_52(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_52_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_52(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_52_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_52(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_51_WithFunctionCeilingToken() { [EOL] boolean result = jj_3R_51(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_51_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_51(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_51_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos is of type Token and different from jj_lastpos [EOL] boolean result = jj_3R_51(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_50_TokenIsFunctionFloor() { [EOL] boolean result = jj_3R_50(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_50_TokenIsNotFunctionFloorAndLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_50(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_50_TokenIsNotFunctionFloorAndLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_50(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_49_WithFunctionSumToken() { [EOL] initToken(FUNCTION_SUM); [EOL] boolean result = jj_3R_49(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_49_WithNonFunctionSumTokenAndLaZeroAndScanposEqualsLastpos() { [EOL] initToken(NON_FUNCTION_SUM); [EOL] setLaAndScanpos(0, true); [EOL] boolean result = jj_3R_49(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_49_WithNonFunctionSumTokenAndLaNotZero() { [EOL] initToken(NON_FUNCTION_SUM); [EOL] setLaAndScanpos(1, false); [EOL] boolean result = jj_3R_49(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_48_TokenIsFunctionNumber() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = FUNCTION_NUMBER; [EOL] boolean result = parser.jj_3R_48(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_48_AtEndOfInput() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = NOT_FUNCTION_NUMBER; [EOL] parser.jj_la = 0; [EOL] parser.jj_scanpos = parser.jj_lastpos; [EOL] boolean result = parser.jj_3R_48(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_48_NotAtEndOfInput() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = NOT_FUNCTION_NUMBER; [EOL] parser.jj_la = 1; // or any non-zero value [EOL] boolean result = parser.jj_3R_48(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_176_WithTokenMod() { [EOL] setupTokenMod(); // This method should set the condition to make jj_scan_token(MOD) return true [EOL] boolean result = jj_3R_176(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_176_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Set jj_scanpos to be equal to jj_lastpos [EOL] boolean result = jj_3R_176(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_176_WithJj_3R_170ReturningTrue() { [EOL] setupJj_3R_170ToReturnTrue(); // This method should set the condition to make jj_3R_170() return true [EOL] boolean result = jj_3R_176(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_176_WithJj_3R_170ReturningFalseAndLaZeroAndScanposEqualsLastpos() { [EOL] setupJj_3R_170ToReturnFalse(); // This method should set the condition to make jj_3R_170() return false [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Set jj_scanpos to be equal to jj_lastpos [EOL] boolean result = jj_3R_176(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_47_TokenIsFunctionLang() { [EOL] boolean result = jj_3R_47(); [EOL] assert(result); [EOL] }
public void testJj_3R_47_AtEndOfInput() { [EOL] boolean result = jj_3R_47(); [EOL] assert(!result); [EOL] }
public void testJj_3R_175_WithTokenDiv() { [EOL] setupToken(DIV); // DIV is a constant that should be defined somewhere relevant in the codebase [EOL] boolean result = jj_3R_175(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_175_WithLaZeroAndScanposEqualsLastpos() { [EOL] setupLaAndPositions(0, true); // Assuming setupLaAndPositions sets jj_la to 0 and makes jj_scanpos equal to jj_lastpos [EOL] boolean result = jj_3R_175(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_175_WithJj_3R_170ReturningTrue() { [EOL] setupJj_3R_170(true); // Assuming setupJj_3R_170 sets up the environment so that jj_3R_170() will return true [EOL] boolean result = jj_3R_175(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_175_WithJj_3R_170ReturningFalseAndLaZeroAndScanposNotEqualsLastpos() { [EOL] setupJj_3R_170(false); // Assuming setupJj_3R_170 sets up the environment so that jj_3R_170() will return false [EOL] setupLaAndPositions(0, false); // Assuming setupLaAndPositions sets jj_la to 0 and makes jj_scanpos not equal to jj_lastpos [EOL] boolean result = jj_3R_175(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_46_TokenIsFunctionNull() { [EOL] boolean result = jj_3R_46(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_46_LaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_46(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_46_LaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_46(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_174_Token88() { [EOL] boolean result = jj_3R_174(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_174_EndOfLookahead() { [EOL] boolean result = jj_3R_174(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_174_Jj_3R_170() { [EOL] boolean result = jj_3R_174(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_174_False() { [EOL] boolean result = jj_3R_174(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_45_WithFunctionFalseToken() { [EOL] boolean result = jj_3R_45(); [EOL] assert(result); // The assertion is that the result should be true when jj_scan_token(FUNCTION_FALSE) is true [EOL] }
public void testJj_3R_45_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_45(); [EOL] assert(!result); // The assertion is that the result should be false when jj_la is 0 and jj_scanpos equals jj_lastpos [EOL] }
public void testJj_3R_45_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_45(); [EOL] assert(!result); // The assertion is that the result should be false when either jj_la is not 0 or jj_scanpos is not equal to jj_lastpos [EOL] }
public void testJj_3R_44_WithFunctionTrueToken() { [EOL] boolean result = jj_3R_44(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_44_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_44(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_44_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_44(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_43_WithFunctionNotToken() { [EOL] boolean result = jj_3R_43(); [EOL] assert(result); // The method should return true [EOL] }
public void testJj_3R_43_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos = new Object(); // Assuming jj_scanpos and jj_lastpos are of type Object [EOL] boolean result = jj_3R_43(); [EOL] assert(!result); // The method should return false [EOL] }
public void testJj_3R_43_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero value [EOL] jj_scanpos = new Object(); [EOL] jj_lastpos = new Object(); // Different object to ensure they are not equal [EOL] boolean result = jj_3R_43(); [EOL] assert(!result); // The method should return false [EOL] }
public void testJj_3R_42_WithFunctionBooleanToken() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = FUNCTION_BOOLEAN; [EOL] boolean result = parser.jj_3R_42(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_42_WithLaZeroAndScanposEqualsLastpos() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 0; [EOL] parser.jj_scanpos = parser.jj_lastpos; [EOL] boolean result = parser.jj_3R_42(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_42_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 1; // any non-zero value [EOL] parser.jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and jj_lastpos [EOL] parser.jj_lastpos = new Token(); [EOL] assertNotSame(parser.jj_scanpos, parser.jj_lastpos); [EOL] boolean result = parser.jj_3R_42(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_41_WithFunctionTranslateToken() { [EOL] boolean result = jj_3R_41(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_41_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_41(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_41_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object and not equal to jj_lastpos [EOL] jj_lastpos = new Object(); // ensure jj_scanpos is not equal to jj_lastpos [EOL] boolean result = jj_3R_41(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_116_Token84() { [EOL] boolean result = jj_3R_116(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_116_JjLaAndScanpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_116(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_116_Jj3R104() { [EOL] boolean result = jj_3R_116(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_116_Token85() { [EOL] boolean result = jj_3R_116(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_116_DefaultFalse() { [EOL] boolean result = jj_3R_116(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_40_WithFunctionNormalizeSpaceToken() { [EOL] jj_scan_token(FUNCTION_NORMALIZE_SPACE); // mock or simulate this call to return true [EOL] boolean result = jj_3R_40(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_40_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // mock or simulate these values to be equal [EOL] boolean result = jj_3R_40(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_40_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // or any value that is not equal to jj_lastpos [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_40(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_39_WithFunctionStringLengthToken() { [EOL] initToken(FUNCTION_STRING_LENGTH); [EOL] boolean result = jj_3R_39(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_39_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_39(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_39_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] assertNotSame(jj_scanpos, jj_lastpos); [EOL] boolean result = jj_3R_39(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_38_WithFunctionSubstringToken() { [EOL] boolean result = jj_3R_38(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_38_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_38(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_38_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_38(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_37_WithFunctionSubstringAfterToken() { [EOL] boolean result = jj_3R_37(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_37_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_37(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_37_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_37(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_36_WithFunctionSubstringBeforeToken() { [EOL] boolean result = jj_3R_36(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_36_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_36(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_36_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_36(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_168_WithJj_3R_170ReturningTrue() { [EOL] assertTrue(jj_3R_168()); [EOL] } [EOL] public void testJj_3R_168_WithJj_3R_170ReturningFalseAndScanPositionsEqual() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos = new Token(); [EOL] assertFalse(jj_3R_168()); [EOL] } [EOL] public void testJj_3R_168_WithJj_3R_170ReturningFalseAndJj_3R_171ReturningTrue() { [EOL] jj_la = 1; // to avoid the second if condition [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] assertFalse(jj_3R_168()); [EOL] } [EOL] public void testJj_3R_168_WithJj_3R_170ReturningFalseAndJj_3R_171NeverReturningTrue() { [EOL] jj_la = 1; // to avoid the second if condition [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] assertFalse(jj_3R_168()); [EOL] }
public void testJj_3R_35_WithFunctionContainsToken() { [EOL] boolean result = jj_3R_35(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_35_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_35(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_35_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object and not equal to jj_lastpos [EOL] jj_lastpos = new Object(); // ensure jj_lastpos is a different object [EOL] boolean result = jj_3R_35(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_34_WithFunctionStartsWithToken() { [EOL] boolean result = jj_3R_34(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_34_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_34(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_33_WithFunctionConcatToken() { [EOL] initToken(FUNCTION_CONCAT); [EOL] boolean result = jj_3R_33(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_33_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_33(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_33_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero to avoid matching the second if [EOL] jj_scanpos = new Token(); // Different from jj_lastpos to avoid matching the second if [EOL] boolean result = jj_3R_33(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_32_WithFunctionStringToken() { [EOL] boolean result = jj_3R_32(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_32_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_32(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_32_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_32(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_31_WithFunctionNameToken() { [EOL] boolean result = jj_3R_31(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_31_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_31(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_31_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_31(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_30_TokenIsFunctionNamespaceUri() { [EOL] when(jj_scan_token(FUNCTION_NAMESPACE_URI)).thenReturn(true); [EOL] boolean result = jj_3R_30(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_30_AtEndOfInputWithLastPos() { [EOL] when(jj_scan_token(FUNCTION_NAMESPACE_URI)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_30(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_30_NotAtEndOfInput() { [EOL] when(jj_scan_token(FUNCTION_NAMESPACE_URI)).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] boolean result = jj_3R_30(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_29_TokenIsFunctionLocalName() { [EOL] boolean result = jj_3R_29(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_29_AtEndOfInput() { [EOL] boolean result = jj_3R_29(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_29_NotAtEndOfInput() { [EOL] boolean result = jj_3R_29(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_169_TokenMinus() { [EOL] initToken(MINUS); [EOL] boolean result = jj_3R_169(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_169_ScanAtLastPos() { [EOL] setScanAtLastPos(); [EOL] boolean result = jj_3R_169(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_169_3R_168True() { [EOL] set3R_168True(); [EOL] boolean result = jj_3R_169(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_169_DefaultFalse() { [EOL] setConditionsForDefaultFalse(); [EOL] boolean result = jj_3R_169(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_28_WithFunctionIdToken() { [EOL] boolean result = jj_3R_28(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_28_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_28(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_28_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_28(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_27_ScanTokenFunctionCount() { [EOL] boolean result = jj_3R_27(); [EOL] assertTrue("Expected true when jj_scan_token(FUNCTION_COUNT) is true", result); [EOL] }
public void testJj_3R_27_ScanTokenNotFunctionCountAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_27(); [EOL] assertFalse("Expected false when jj_scan_token is not FUNCTION_COUNT and jj_la is 0 and jj_scanpos equals jj_lastpos", result); [EOL] }
public void testJj_3R_27_ScanTokenNotFunctionCountAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_27(); [EOL] assertFalse("Expected false when jj_scan_token is not FUNCTION_COUNT and either jj_la is not 0 or jj_scanpos does not equal jj_lastpos", result); [EOL] }
public void testJj_3R_152_TokenIsAxisDescendantOrSelf() { [EOL] boolean result = jj_3R_152(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_152_AtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_152(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_152_NotAtEndOfInput() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_152(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_26_WithFunctionPositionToken() { [EOL] boolean result = jj_3R_26(); [EOL] assert(result); [EOL] }
public void testJj_3R_26_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_26(); [EOL] assert(!result); [EOL] }
public void testJj_3R_26_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_26(); [EOL] assert(!result); [EOL] }
public void testJj_3R_25_WithFunctionLastToken() { [EOL] boolean result = jj_3R_25(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_25_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_25(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_25_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_25(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_151_TokenIsAxisPrecedingSibling() { [EOL] boolean result = jj_3R_151(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_151_ScanPositionAtEnd() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_151(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_151_ScanPositionNotAtEnd() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and not equal [EOL] boolean result = jj_3R_151(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_24_WithPIToken() { [EOL] boolean result = jj_3R_24(); [EOL] assertTrue("Expected true when PI token is scanned", result); [EOL] }
public void testJj_3R_24_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_24(); [EOL] assertFalse("Expected false when jj_la is 0 and jj_scanpos equals jj_lastpos", result); [EOL] }
public void testJj_3R_24_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and can be set to different instances [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_24(); [EOL] assertFalse("Expected false when jj_la is not 0 or jj_scanpos does not equal jj_lastpos", result); [EOL] }
public void testJj_3R_150_WithTokenAxisFollowingSibling() { [EOL] boolean result = jj_3R_150(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_150_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_150(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_150_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos is of type Token and different from jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_150(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_23_WithCommentToken() { [EOL] boolean result = jj_3R_23(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_23_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_23(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_23_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_23(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_149_TokenIsAxisAncestorOrSelf() { [EOL] when(jj_scan_token(AXIS_ANCESTOR_OR_SELF)).thenReturn(true); [EOL] boolean result = jj_3R_149(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_149_AtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assume jj_lastpos is set to a value that represents the last position [EOL] boolean result = jj_3R_149(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_163_WithPlusToken() { [EOL] when(jj_scan_token(PLUS)).thenReturn(true); [EOL] boolean result = jj_3R_163(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_163_WithLaAndScanposEqualLastpos() { [EOL] when(jj_scan_token(PLUS)).thenReturn(false); [EOL] when(jj_la).thenReturn(0); [EOL] when(jj_scanpos).thenReturn(jj_lastpos); [EOL] boolean result = jj_3R_163(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_163_With3R_162ReturningTrue() { [EOL] when(jj_scan_token(PLUS)).thenReturn(false); [EOL] when(jj_la).thenReturn(1); // Ensure the condition jj_la == 0 is false [EOL] when(jj_3R_162()).thenReturn(true); [EOL] boolean result = jj_3R_163(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_163_With3R_162ReturningFalse() { [EOL] when(jj_scan_token(PLUS)).thenReturn(false); [EOL] when(jj_la).thenReturn(1); // Ensure the condition jj_la == 0 is false [EOL] when(jj_3R_162()).thenReturn(false); [EOL] boolean result = jj_3R_163(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_22_WithTextToken() { [EOL] jj_scan_token(TEXT); // Assuming TEXT is a constant and jj_scan_token is a method that can be called [EOL] boolean result = jj_3R_22(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_22_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assuming these are variables that can be set [EOL] boolean result = jj_3R_22(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_22_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero value [EOL] jj_scanpos = new Object(); // Assuming jj_scanpos and jj_lastpos are objects and they are not equal [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_22(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_148_WithTokenAxisDescendant() { [EOL] boolean result = jj_3R_148(); [EOL] assert(result); [EOL] }
public void testJj_3R_148_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_148(); [EOL] assert(!result); [EOL] }
public void testJj_3R_148_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_148(); [EOL] assert(!result); [EOL] }
public void testJj_3R_21_NodeToken() { [EOL] mockJj_scan_token(NODE, true); // Mock jj_scan_token to return true when NODE is passed [EOL] boolean result = jj_3R_21(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_21_EndOfLookahead() { [EOL] mockJj_scan_token(NODE, false); // Mock jj_scan_token to return false when NODE is passed [EOL] jj_la = 0; // Set jj_la to 0 to simulate end of lookahead [EOL] jj_scanpos = jj_lastpos; // Set jj_scanpos to jj_lastpos to simulate end of lookahead [EOL] boolean result = jj_3R_21(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_21_NotEndOfLookahead() { [EOL] mockJj_scan_token(NODE, false); // Mock jj_scan_token to return false when NODE is passed [EOL] jj_la = 1; // Set jj_la to a non-zero value to simulate not being at the end of lookahead [EOL] jj_scanpos = new Position(); // Set jj_scanpos to a new position [EOL] jj_lastpos = new Position(); // Set jj_lastpos to a different new position [EOL] boolean result = jj_3R_21(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_147_WithTokenAxisFollowing() { [EOL] initTokenStreamWithToken(AXIS_FOLLOWING); [EOL] boolean result = jj_3R_147(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_147_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_147(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_147_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] boolean result = jj_3R_147(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_146_TokenIsAxisPreceding() { [EOL] boolean result = jj_3R_146(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_146_TokenNotAxisPrecedingLaEqualsZeroScanposEqualsLastpos() { [EOL] boolean result = jj_3R_146(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_146_TokenNotAxisPrecedingLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_146(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_145_WithTokenAxisNamespace() { [EOL] mockJj_scan_token(AXIS_NAMESPACE, true); [EOL] boolean result = jj_3R_145(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_145_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_145(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_145_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object and not equal to jj_lastpos [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_145(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_162_WithJj_3R_168ReturningTrue() { [EOL] when(jj_3R_168()).thenReturn(true); [EOL] boolean result = jj_3R_162(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_162_WithJj_3R_168ReturningFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_168()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_162(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_162_WithJj_3R_168ReturningFalseAndJj_3R_169ReturningTrue() { [EOL] when(jj_3R_168()).thenReturn(false); [EOL] when(jj_3R_169()).thenReturn(true); [EOL] jj_la = 1; [EOL] boolean result = jj_3R_162(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_162_WithJj_3R_168ReturningFalseAndJj_3R_169ReturningFalse() { [EOL] when(jj_3R_168()).thenReturn(false); [EOL] when(jj_3R_169()).thenReturn(false); [EOL] jj_la = 1; [EOL] boolean result = jj_3R_162(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_144_WithTokenAxisAttribute() { [EOL] boolean result = jj_3R_144(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_144_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Set scan position to be the same as the last position [EOL] boolean result = jj_3R_144(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_144_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Set jj_la to a non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // Ensure jj_scanpos is not equal to jj_lastpos [EOL] boolean result = jj_3R_144(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_143_TokenIsAxisAncestor() { [EOL] when(jj_scan_token(AXIS_ANCESTOR)).thenReturn(true); [EOL] boolean result = jj_3R_143(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_143_AtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_143(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_142_TokenIsAxisParent() { [EOL] boolean result = jj_3R_142(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_142_AtEndOfInput() { [EOL] boolean result = jj_3R_142(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_142_NotAtEndOfInput() { [EOL] boolean result = jj_3R_142(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_AllFalse() { [EOL] setupForJj_3R_15(); [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_FirstTrueRestFalse() { [EOL] setupForJj_3R_15(); [EOL] when(mockedObject.jj_3R_20()).thenReturn(true); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }

public void testJj_3R_15_LastTrue() { [EOL] setupForJj_3R_15(); [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_53()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_141_WithTokenAxisChild() { [EOL] initTokenState(AXIS_CHILD); [EOL] boolean result = jj_3R_141(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_141_WithLaZeroAndScanposEqualsLastpos() { [EOL] initLaAndScanposState(0, true); [EOL] boolean result = jj_3R_141(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_141_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] initLaAndScanposState(1, false); [EOL] boolean result = jj_3R_141(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_140_ScanTokenAxisSelfReturnsTrue() { [EOL] boolean result = jj_3R_140(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_140_ScanTokenNotAxisSelfAndLaEqualsZeroAndScanposEqualsLastposReturnsFalse() { [EOL] boolean result = jj_3R_140(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_140_ScanTokenNotAxisSelfAndLaNotZeroOrScanposNotEqualsLastposReturnsFalse() { [EOL] boolean result = jj_3R_140(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_129()); [EOL] }
public void testJj_3R_129_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] when(jj_3R_140()).thenReturn(true); [EOL] for (int i = 141; i <= 152; i++) { [EOL] when(callMethodByName("jj_3R_" + i)).thenReturn(false); [EOL] } [EOL] assertTrue(jj_3R_129()); [EOL] }
public void testJj_3R_129_LastTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] for (int i = 140; i <= 151; i++) { [EOL] when(callMethodByName("jj_3R_" + i)).thenReturn(false); [EOL] } [EOL] when(jj_3R_152()).thenReturn(true); [EOL] assertTrue(jj_3R_129()); [EOL] } [EOL] private boolean callMethodByName(String methodName) { [EOL] return false; [EOL] }
public void testJj_3R_159_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Set to a non-zero value to avoid the condition [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] when(jj_3R_167()).thenReturn(false); [EOL] boolean result = jj_3R_159(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_159_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; [EOL] when(jj_3R_164()).thenReturn(true); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] when(jj_3R_167()).thenReturn(false); [EOL] boolean result = jj_3R_159(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_159_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(true); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] when(jj_3R_167()).thenReturn(false); [EOL] boolean result = jj_3R_159(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_159_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(true); [EOL] when(jj_3R_167()).thenReturn(false); [EOL] boolean result = jj_3R_159(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_159_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] when(jj_3R_167()).thenReturn(true); [EOL] boolean result = jj_3R_159(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_159_LaZeroScanposLastposEqual() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; // Make them reference the same object [EOL] jj_la = 0; // Set to zero to satisfy the condition [EOL] when(jj_3R_164()).thenReturn(false); [EOL] when(jj_3R_165()).thenReturn(false); [EOL] when(jj_3R_166()).thenReturn(false); [EOL] when(jj_3R_167()).thenReturn(false); [EOL] boolean result = jj_3R_159(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_158_WhenJj_3R_162ReturnsTrue() { [EOL] boolean result = jj_3R_158(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_158_WhenJj_3R_162ReturnsFalseAndScanPositionAtLastPosition() { [EOL] boolean result = jj_3R_158(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_158_WhenJj_3R_162ReturnsFalseAndJj_3R_163ReturnsTrue() { [EOL] boolean result = jj_3R_158(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_158_WhenJj_3R_162ReturnsFalseAndJj_3R_163NeverReturnsTrue() { [EOL] boolean result = jj_3R_158(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_122_WhenJj_3R_130ReturnsTrue() { [EOL] setJj_3R_130(true); [EOL] boolean result = jj_3R_122(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_122_WhenJj_3R_130ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_130(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_122(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_122_WhenJj_3R_130ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_130(false); [EOL] jj_la = 1; [EOL] jj_scanpos = new Scanpos(); // Assuming Scanpos is a class and jj_lastpos is an instance of it [EOL] jj_lastpos = new Scanpos(); [EOL] boolean result = jj_3R_122(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_121_WhenJj_3R_129ReturnsTrue() { [EOL] setJj_3R_129ToReturn(true); [EOL] boolean result = jj_3R_121(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_121_WhenJj_3R_129ReturnsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] setJj_3R_129ToReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_121(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_121_WhenJj_3R_129ReturnsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] setJj_3R_129ToReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and can be set to different instances [EOL] boolean result = jj_3R_121(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_167_WithGteToken() { [EOL] jj_scan_token(GTE); // Assuming this method sets up the condition for jj_scan_token(GTE) to return true [EOL] boolean result = jj_3R_167(); [EOL] assert(result); // Assert that the result is true when jj_scan_token(GTE) returns true [EOL] }
public void testJj_3R_167_AtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assuming this sets up the condition for end of input [EOL] boolean result = jj_3R_167(); [EOL] assert(!result); // Assert that the result is false when at the end of input [EOL] }
public void testJj_3R_167_WithSuccessfulJj_3R_158() { [EOL] boolean result = jj_3R_167(); [EOL] assert(result); // Assert that the result is true when jj_3R_158() returns true [EOL] }
public void testJj_3R_167_WithFailedJj_3R_158() { [EOL] boolean result = jj_3R_167(); [EOL] assert(!result); // Assert that the result is false when jj_3R_158() returns false [EOL] }
public void testJj_3R_112_WithJj_3R_121ReturningTrueAndJj_3R_122ReturningTrue() { [EOL] boolean result = jj_3R_112(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_112_WithJj_3R_121ReturningTrueAndJj_3R_122ReturningFalse() { [EOL] boolean result = jj_3R_112(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_112_WithJj_3R_121ReturningFalse() { [EOL] boolean result = jj_3R_112(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_166_TokenLTE() { [EOL] assertTrue(jj_3R_166()); [EOL] }
public void testJj_3R_166_EndOfLookahead() { [EOL] assertFalse(jj_3R_166()); [EOL] }
public void testJj_3R_166_Rule158True() { [EOL] assertTrue(jj_3R_166()); [EOL] }
public void testJj_3R_166_AlwaysFalse() { [EOL] assertFalse(jj_3R_166()); [EOL] }
public void testJj_3R_165_TokenGT() { [EOL] jj_scan_token = GT; // Assuming GT is a constant and jj_scan_token is a method or variable that can be set [EOL] boolean result = jj_3R_165(); [EOL] assert(result); [EOL] }
public void testJj_3R_165_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assuming these are variables that can be set [EOL] boolean result = jj_3R_165(); [EOL] assert(!result); [EOL] }
public void testJj_3R_165_Rule158True() { [EOL] boolean result = jj_3R_165(); [EOL] assert(result); [EOL] }
public void testJj_3R_165_DefaultFalse() { [EOL] boolean result = jj_3R_165(); [EOL] assert(!result); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningTrue() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] when(mockJj_3R_160()).thenReturn(true); [EOL] when(mockJj_3R_161()).thenReturn(false); [EOL] boolean result = jj_3R_157(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningFalseAndLaEqualsZero() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] jj_lastpos = mockJj_scanpos; // Make sure jj_scanpos equals jj_lastpos [EOL] jj_la = 0; [EOL] when(mockJj_3R_160()).thenReturn(false); [EOL] boolean result = jj_3R_157(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_157_WithJj_3R_160ReturningTrueAndJj_3R_161ReturningTrue() { [EOL] jj_scanpos = mockJj_scanpos; [EOL] when(mockJj_3R_160()).thenReturn(true); [EOL] when(mockJj_3R_161()).thenReturn(true); [EOL] boolean result = jj_3R_157(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_164_TokenLT() { [EOL] boolean result = jj_3R_164(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_164_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_164(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_164_Rule158True() { [EOL] boolean result = jj_3R_164(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_164_DefaultFalse() { [EOL] boolean result = jj_3R_164(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_156_WhenJj_3R_158ReturnsTrue() { [EOL] assertTrue(jj_3R_156()); [EOL] }
public void testJj_3R_156_WhenJj_3R_158ReturnsFalseAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] assertFalse(jj_3R_156()); [EOL] }
public void testJj_3R_156_WhenJj_3R_158ReturnsFalseAndJj_3R_159ReturnsTrue() { [EOL] assertFalse(jj_3R_156()); [EOL] }
public void testJj_3R_156_WhenJj_3R_158ReturnsFalseAndJj_3R_159NeverReturnsTrue() { [EOL] }
public void testJj_3R_161_TokenNEQ() { [EOL] boolean result = jj_3R_161(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_161_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_161(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_161_Rule156True() { [EOL] boolean result = jj_3R_161(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_161_NoConditionsMet() { [EOL] boolean result = jj_3R_161(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_160_TokenEq() { [EOL] jj_scan_token = EQ; [EOL] boolean result = jj_3R_160(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_160_ScanposLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = new Object(); [EOL] jj_lastpos = jj_scanpos; [EOL] boolean result = jj_3R_160(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_160_Rule156True() { [EOL] jj_scan_token = OTHER_TOKEN; // Assuming OTHER_TOKEN does not equal EQ [EOL] jj_la = 1; // To bypass the jj_la == 0 condition [EOL] boolean result = jj_3R_160(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_160_DefaultFalse() { [EOL] jj_scan_token = OTHER_TOKEN; // Assuming OTHER_TOKEN does not equal EQ [EOL] jj_la = 1; // To bypass the jj_la == 0 condition [EOL] boolean result = jj_3R_160(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_102_WhenJj_3R_116ReturnsTrue() { [EOL] boolean result = jj_3R_102(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_102_WhenJj_3R_116ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_102(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_102_WhenJj_3R_116ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_102(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_4_WithPIToken() { [EOL] boolean result = jj_3_4(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_4_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3_4(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_4_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3_4(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsTrue() { [EOL] setJj_3R_17(true); [EOL] boolean result = jj_3_3(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanposEqualsLastpos() { [EOL] setJj_3R_17(false); [EOL] setJj_la(0); [EOL] setJj_scanposEqualsLastpos(true); [EOL] boolean result = jj_3_3(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanToken80IsTrue() { [EOL] setJj_3R_17(false); [EOL] setJj_scan_token(80, true); [EOL] boolean result = jj_3_3(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanToken80IsFalseAndScanposEqualsLastpos() { [EOL] setJj_3R_17(false); [EOL] setJj_scan_token(80, false); [EOL] setJj_la(0); [EOL] setJj_scanposEqualsLastpos(true); [EOL] boolean result = jj_3_3(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanToken80And81AreFalse() { [EOL] setJj_3R_17(false); [EOL] setJj_scan_token(80, false); [EOL] setJj_scan_token(81, false); [EOL] boolean result = jj_3_3(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_115_WhenJj_3R_123ReturnsTrue() { [EOL] assertTrue(jj_3R_115()); [EOL] }
public void testJj_3R_115_WhenJj_3R_123ReturnsFalseAndScanposEqualsLastpos() { [EOL] assertFalse(jj_3R_115()); [EOL] }
public void testJj_3R_115_WhenJj_3R_123ReturnsFalseAndScanposNotEqualsLastpos() { [EOL] assertFalse(jj_3R_115()); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsTrue() { [EOL] boolean result = jj_3R_134(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsFalseAndScanPositionsMatch() { [EOL] boolean result = jj_3R_134(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsFalseAndJj_3R_157ReturnsTrue() { [EOL] boolean result = jj_3R_134(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_134_WhenJj_3R_156ReturnsFalseAndJj_3R_157NeverReturnsTrue() { [EOL] boolean result = jj_3R_134(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_114_WithPiToken() { [EOL] when(jj_scan_token(PI)).thenReturn(true); [EOL] boolean result = jj_3R_114(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_114_WithLaZeroAndScanposEqualsLastpos() { [EOL] when(jj_scan_token(anyInt())).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_114(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_114_With80Token() { [EOL] when(jj_scan_token(PI)).thenReturn(false); [EOL] when(jj_scan_token(80)).thenReturn(true); [EOL] boolean result = jj_3R_114(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_114_WithLiteralToken() { [EOL] when(jj_scan_token(PI)).thenReturn(false); [EOL] when(jj_scan_token(80)).thenReturn(false); [EOL] when(jj_scan_token(Literal)).thenReturn(true); [EOL] boolean result = jj_3R_114(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_114_With81Token() { [EOL] when(jj_scan_token(PI)).thenReturn(false); [EOL] when(jj_scan_token(80)).thenReturn(false); [EOL] when(jj_scan_token(Literal)).thenReturn(false); [EOL] when(jj_scan_token(81)).thenReturn(true); [EOL] boolean result = jj_3R_114(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_114_WithAllTokensFailing() { [EOL] when(jj_scan_token(PI)).thenReturn(false); [EOL] when(jj_scan_token(80)).thenReturn(false); [EOL] when(jj_scan_token(Literal)).thenReturn(false); [EOL] when(jj_scan_token(81)).thenReturn(false); [EOL] boolean result = jj_3R_114(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_113_WhenJj_3R_17IsTrue() { [EOL] boolean result = jj_3R_113(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_113_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_113(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_113_WhenJjScanToken80IsTrue() { [EOL] boolean result = jj_3R_113(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_113_WhenJjScanToken81IsTrue() { [EOL] boolean result = jj_3R_113(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_113_WhenAllConditionsAreFalse() { [EOL] boolean result = jj_3R_113(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_112IsTrue() { [EOL] when(jj_3R_112()).thenReturn(true); [EOL] boolean result = jj_3R_99(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_112IsFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_99(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsTrueAndJj_3R_114IsTrue() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(true); [EOL] when(jj_3R_114()).thenReturn(true); [EOL] boolean result = jj_3R_99(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsTrueAndJj_3R_114IsFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(true); [EOL] when(jj_3R_114()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_99(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsFalseAndScanposEqualsLastpos() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_99(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_99_WhenJj_3R_113IsTrueAndJj_3R_114IsFalseAndJj_3R_115IsTrue() { [EOL] when(jj_3R_112()).thenReturn(false); [EOL] when(jj_3R_113()).thenReturn(true); [EOL] when(jj_3R_114()).thenReturn(false); [EOL] when(jj_3R_115()).thenReturn(true); [EOL] boolean result = jj_3R_99(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_135_WithTrueFromScanToken() { [EOL] when(jj_scan_token(AND)).thenReturn(true); [EOL] boolean result = jj_3R_135(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_135_WithFalseFromScanTokenAndLaEqualsZero() { [EOL] when(jj_scan_token(AND)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_135(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_135_WithFalseFromScanTokenAndLaNotZero() { [EOL] when(jj_scan_token(AND)).thenReturn(false); [EOL] jj_la = 1; [EOL] when(jj_3R_134()).thenReturn(true); [EOL] boolean result = jj_3R_135(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_135_WithFalseFromScanTokenAndJj_3R_134False() { [EOL] when(jj_scan_token(AND)).thenReturn(false); [EOL] jj_la = 1; [EOL] when(jj_3R_134()).thenReturn(false); [EOL] boolean result = jj_3R_135(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(false); // This line won't be reached but added for completeness [EOL] when(jj_3R_101()).thenReturn(false); // This line won't be reached but added for completeness [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99ReturnsFalseAndJj_3R_100ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(true); [EOL] when(jj_3R_101()).thenReturn(false); // This line won't be reached but added for completeness [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_99AndJj_3R_100ReturnFalseAndJj_3R_101ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(true); [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WhenAllConditionsReturnFalse() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(false); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WhenJj_3R_102ReturnsTrue() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(true); [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsTrue() { [EOL] when(mockedObject.jj_3R_134()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_125(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsFalseAndScanposEqualsLastpos() { [EOL] when(mockedObject.jj_3R_134()).thenReturn(false); [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_125(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsFalseAndJj_3R_135IsTrue() { [EOL] when(mockedObject.jj_3R_134()).thenReturn(false); [EOL] when(mockedObject.jj_3R_135()).thenReturn(true); [EOL] mockedObject.jj_la = 1; [EOL] boolean result = mockedObject.jj_3R_125(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_125_WhenJj_3R_134IsFalseAndJj_3R_135IsFalseAndScanposEqualsLastpos() { [EOL] when(mockedObject.jj_3R_134()).thenReturn(false); [EOL] when(mockedObject.jj_3R_135()).thenReturn(false); [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_125(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_56_SlashSlashToken() { [EOL] setNextToken(SLASHSLASH); [EOL] boolean result = jj_3R_56(); [EOL] assert(result); // Assert that the result is true when SLASHSLASH is the next token [EOL] }
public void testJj_3R_56_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_56(); [EOL] assert(!result); // Assert that the result is false when jj_la is 0 and jj_scanpos is equal to jj_lastpos [EOL] }
public void testJj_3R_56_NotSlashSlashTokenNorEndOfLookahead() { [EOL] setNextToken(NOT_SLASHSLASH); // NOT_SLASHSLASH is a placeholder for any token that is not SLASHSLASH [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_56(); [EOL] assert(!result); // Assert that the result is false when neither condition in jj_3R_56 is met [EOL] }
public void testJj_3R_55_SlashToken() { [EOL] boolean result = jj_3R_55(); [EOL] assertTrue("Expected true when SLASH token is scanned", result); [EOL] }
public void testJj_3R_55_NoSlashTokenLaZeroScanposEqualsLastpos() { [EOL] boolean result = jj_3R_55(); [EOL] assertFalse("Expected false when no SLASH token, jj_la is 0, and jj_scanpos equals jj_lastpos", result); [EOL] }
public void testJj_3R_55_NoSlashTokenLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_55(); [EOL] assertFalse("Expected false when no SLASH token and either jj_la is not 0 or jj_scanpos does not equal jj_lastpos", result); [EOL] }
public void testJj_3R_126_WithTrueFromScanToken() { [EOL] boolean result = jj_3R_126(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_126_WithFalseFromScanTokenAndLaEqualsZero() { [EOL] boolean result = jj_3R_126(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_126_WithFalseFromScanTokenAndLaNotZero() { [EOL] boolean result = jj_3R_126(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_126_WithAllConditionsFalse() { [EOL] boolean result = jj_3R_126(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_16_WhenJj_3R_55TrueAndJj_3R_56True() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure jj_la is not 0 to avoid early return [EOL] when(jj_3R_55()).thenReturn(true); [EOL] when(jj_3R_56()).thenReturn(true); [EOL] boolean result = jj_3R_16(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_16_WhenJj_3R_55TrueAndJj_3R_56FalseAndJj_3R_57True() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure jj_la is not 0 to avoid early return [EOL] when(jj_3R_55()).thenReturn(true); [EOL] when(jj_3R_56()).thenReturn(false); [EOL] when(jj_3R_57()).thenReturn(true); [EOL] boolean result = jj_3R_16(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_16_WhenJj_3R_55FalseAndJj_3R_57True() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 1; // Ensure jj_la is not 0 to avoid early return [EOL] when(jj_3R_55()).thenReturn(false); [EOL] when(jj_3R_57()).thenReturn(true); [EOL] boolean result = jj_3R_16(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_16_WhenAllConditionsFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; // Set jj_la to 0 to simulate end of lookahead [EOL] jj_scanpos = jj_lastpos; // Simulate that scanning has reached the last position [EOL] when(jj_3R_55()).thenReturn(false); [EOL] when(jj_3R_56()).thenReturn(false); [EOL] when(jj_3R_57()).thenReturn(false); [EOL] boolean result = jj_3R_16(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningTrue() { [EOL] assertTrue(jj_3R_118()); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningFalseAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] assertFalse(jj_3R_118()); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningFalseAndJj_3R_126ReturningTrue() { [EOL] jj_la = 1; // or any value other than 0 [EOL] jj_scanpos = new Token(); // assuming Token is a valid type and jj_scanpos is not equal to jj_lastpos [EOL] jj_lastpos = new Token(); // different from jj_scanpos [EOL] assertFalse(jj_3R_118()); [EOL] }
public void testJj_3R_118_WithJj_3R_125ReturningFalseAndJj_3R_126ReturningFalse() { [EOL] jj_la = 1; // or any value other than 0 [EOL] jj_scanpos = new Token(); // assuming Token is a valid type and jj_scanpos is not equal to jj_lastpos [EOL] jj_lastpos = new Token(); // different from jj_scanpos [EOL] assertFalse(jj_3R_118()); [EOL] }
public void testJj_3_2WhenJj_3R_16ReturnsTrue() { [EOL] setJj_3R_16Condition(true); [EOL] boolean result = jj_3_2(); [EOL] assert(result); [EOL] } [EOL] public void testJj_3_2WhenJj_3R_16ReturnsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] setJj_3R_16Condition(false); [EOL] setJj_la(0); [EOL] setJj_scanposEqualsJj_lastpos(); [EOL] boolean result = jj_3_2(); [EOL] assert(!result); [EOL] } [EOL] public void testJj_3_2WhenJj_3R_16ReturnsFalseAndJj_laIsNotZero() { [EOL] setJj_3R_16Condition(false); [EOL] setJj_la(1); [EOL] boolean result = jj_3_2(); [EOL] assert(!result); [EOL] }
public void testJj_3_2WhenJj_3R_16ReturnsFalseAndJj_scanposNotEqualsJj_lastpos() { [EOL] setJj_3R_16Condition(false); [EOL] setJj_scanposNotEqualsJj_lastpos(); [EOL] boolean result = jj_3_2(); [EOL] assert(!result); [EOL] }
public void testJj_3R_185_WhenJj_3R_16IsTrue() { [EOL] boolean result = jj_3R_185(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_185_WhenJj_3R_16IsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_185(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_185_WhenJj_3R_16IsFalseAndJj_laIsNotZeroOrJj_scanposNotEqualsJj_lastpos() { [EOL] boolean result = jj_3R_185(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_184_WhenJj_3R_116ReturnsTrue() { [EOL] boolean result = jj_3R_184(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_184_WhenJj_3R_116ReturnsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] boolean result = jj_3R_184(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_184_WhenJj_3R_116ReturnsFalseAndJj_laIsNotZeroOrJj_scanposNotEqualsJj_lastpos() { [EOL] boolean result = jj_3R_184(); [EOL] assertFalse(result); [EOL] }
final private boolean jj_3R_182() { [EOL] if (jj_3R_19()) [EOL] return true; [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] Token xsp; [EOL] while (true) { [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_184()) { [EOL] jj_scanpos = xsp; [EOL] break; [EOL] } [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } [EOL] while (true) { [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_185()) { [EOL] jj_scanpos = xsp; [EOL] break; [EOL] } [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } [EOL] return false; [EOL] }
public void testJj_3R_180_WhenJj_3R_182IsTrue() { [EOL] boolean result = jj_3R_180(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_180_WhenJj_3R_182IsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_180(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_180_WhenJj_3R_182IsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_180(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_178_WhenJj_3R_180ReturnsTrueAndJj_3R_181ReturnsTrue() { [EOL] boolean result = jj_3R_178(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_178_WhenJj_3R_180ReturnsTrueAndJj_3R_181ReturnsFalse() { [EOL] boolean result = jj_3R_178(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_178_WhenJj_3R_180ReturnsFalse() { [EOL] boolean result = jj_3R_178(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_179_UnionToken() { [EOL] boolean result = jj_3R_179(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_179_EndOfLookahead() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_179(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_179_RecursiveCallTrue() { [EOL] boolean result = jj_3R_179(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_179_AllConditionsFalse() { [EOL] boolean result = jj_3R_179(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_177_WithJj_3R_178ReturningTrue() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_177_WithJj_3R_178ReturningFalseAndScanposEqualsLastpos() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(false); [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_177_WithJj_3R_178ReturningFalseAndJj_3R_179ReturningTrue() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(false); [EOL] mockedObject.jj_la = 1; [EOL] when(mockedObject.jj_3R_179()).thenReturn(false, false, true); [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_177_WithJj_3R_178ReturningFalseAndJj_3R_179NeverReturningTrue() { [EOL] when(mockedObject.jj_3R_178()).thenReturn(false); [EOL] mockedObject.jj_la = 1; [EOL] when(mockedObject.jj_3R_179()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_177(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_136_WhenJj_3R_104ReturnsTrue() { [EOL] setJj_3R_104ToReturnTrue(); [EOL] boolean result = jj_3R_136(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_136_WhenJj_3R_104ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_104ToReturnFalse(); [EOL] setJjLaToZero(); [EOL] makeScanposEqualToLastpos(); [EOL] boolean result = jj_3R_136(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_136_WhenJj_3R_104ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_104ToReturnFalse(); [EOL] setJjLaToNonZeroOrMakeScanposNotEqualToLastpos(); [EOL] boolean result = jj_3R_136(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_137_Token87() { [EOL] boolean result = jj_3R_137(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_137_EndOfLookahead() { [EOL] boolean result = jj_3R_137(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_137_Rule136() { [EOL] boolean result = jj_3R_137(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_137_FalseByDefault() { [EOL] boolean result = jj_3R_137(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningTrue() { [EOL] assertTrue(jj_3R_127()); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningFalseAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] assertFalse(jj_3R_127()); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningFalseAndJj_3R_137ReturningTrue() { [EOL] assertFalse(jj_3R_127()); [EOL] }
public void testJj_3R_127_WithJj_3R_136ReturningFalseAndJj_3R_137NeverReturningTrue() { [EOL] }
public void testJj_3R_119_Token80() { [EOL] boolean result = jj_3R_119(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_119_AtEndOfInput() { [EOL] boolean result = jj_3R_119(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_119_Jj_3R_127() { [EOL] boolean result = jj_3R_119(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_119_Token81() { [EOL] boolean result = jj_3R_119(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_61_WithPIToken() { [EOL] setupToken(PI); [EOL] boolean result = jj_3R_61(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_61_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_61(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_61_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] assertNotSame(jj_scanpos, jj_lastpos); [EOL] boolean result = jj_3R_61(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_60_WithCommentToken() { [EOL] when(jj_scan_token(COMMENT)).thenReturn(true); [EOL] boolean result = jj_3R_60(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_60_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] when(jj_scan_token(COMMENT)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_60(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_60_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] when(jj_scan_token(COMMENT)).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are objects and not equal [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_60(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_59_NodeToken() { [EOL] boolean result = jj_3R_59(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_59_NoNodeTokenEndOfLookahead() { [EOL] boolean result = jj_3R_59(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_59_NoNodeTokenNotEndOfLookahead() { [EOL] boolean result = jj_3R_59(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_58_WithTextToken() { [EOL] initToken(TEXT); [EOL] boolean result = jj_3R_58(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_58_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_58(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_58_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_58(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_17_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_17()); [EOL] }
public void testJj_3R_17_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_17_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_17_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_17_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_139_WhenJj_3R_98IsTrue() { [EOL] setJj_3R_98Condition(true); [EOL] boolean result = jj_3R_139(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_139_WhenJj_3R_98IsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_98Condition(false); [EOL] setJjLaAndScanpos(0, true); [EOL] boolean result = jj_3R_139(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_139_WhenJj_3R_98IsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_98Condition(false); [EOL] setJjLaAndScanpos(1, false); [EOL] boolean result = jj_3R_139(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_138_WhenJj_3R_15IsTrue() { [EOL] boolean result = jj_3R_138(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_138_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_138(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_138_WhenJjScanTokenWith79ReturnsTrue() { [EOL] boolean result = jj_3R_138(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_138_WhenAllConditionsFail() { [EOL] boolean result = jj_3R_138(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_132_WhenJj_3R_15IsTrue() { [EOL] boolean result = jj_3R_132(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_132_WhenJj_3R_15IsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_132(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_132_WhenJj_3R_15IsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_132(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_105_WhenJj_3R_18IsTrue() { [EOL] boolean result = jj_3R_105(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_105_WhenJj_3R_18IsFalseAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_105(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_105_WhenJj_3R_18IsFalseAndJj_3R_119IsTrue() { [EOL] boolean result = jj_3R_105(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_105_WhenJj_3R_18AndJj_3R_119AreFalseAndScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_105(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_133_Token79() { [EOL] boolean result = jj_3R_133(); [EOL] }
public void testJj_3R_133_EndOfLookahead() { [EOL] boolean result = jj_3R_133(); [EOL] }
public void testJj_3R_133_Jj_3R_154_True() { [EOL] boolean result = jj_3R_133(); [EOL] }
public void testJj_3R_133_Jj_3R_155_True() { [EOL] boolean result = jj_3R_133(); [EOL] }
public void testJj_3R_133_AllFalse() { [EOL] boolean result = jj_3R_133(); [EOL] }
public void testJj_3R_128_WithJj_3R_138ReturningTrueAndJj_3R_139ReturningTrue() { [EOL] boolean result = jj_3R_128(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_128_WithJj_3R_138ReturningTrueAndJj_3R_139ReturningFalse() { [EOL] boolean result = jj_3R_128(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_128_WithJj_3R_138ReturningFalse() { [EOL] boolean result = jj_3R_128(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_131_Token88() { [EOL] assertTrue("Expected jj_3R_131 to return true when jj_scan_token(88) is true", jj_3R_131()); [EOL] }
public void testJj_3R_131_EndOfLookahead() { [EOL] assertFalse("Expected jj_3R_131 to return false when jj_la == 0 and jj_scanpos == jj_lastpos", jj_3R_131()); [EOL] }
public void testJj_3R_131_DefaultFalse() { [EOL] assertFalse("Expected jj_3R_131 to return false by default", jj_3R_131()); [EOL] }
public void testJj_3R_123_1() { [EOL] jj_scanpos = ...; // assign appropriate value [EOL] jj_lastpos = ...; // assign appropriate value [EOL] jj_la = ...; // assign appropriate value [EOL] boolean result = jj_3R_123(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_123_2() { [EOL] jj_scanpos = ...; // assign appropriate value [EOL] jj_lastpos = ...; // assign appropriate value [EOL] jj_la = 0; // set to trigger the condition [EOL] boolean result = jj_3R_123(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_123_3() { [EOL] jj_scanpos = ...; // assign appropriate value [EOL] jj_lastpos = ...; // assign appropriate value [EOL] jj_la = 0; // set to trigger the condition [EOL] boolean result = jj_3R_123(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_123_4() { [EOL] jj_scanpos = ...; // assign appropriate value [EOL] jj_lastpos = ...; // assign appropriate value [EOL] jj_la = 0; // set to trigger the condition [EOL] boolean result = jj_3R_123(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningTrue() { [EOL] setJj_3R_120Condition(true); [EOL] boolean result = jj_3R_106(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningFalseAndScanposEqualsLastpos() { [EOL] setJj_3R_120Condition(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_106(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_106_WithJj_3R_120ReturningFalseAndJj_3R_119ReturningTrue() { [EOL] setJj_3R_120Condition(false); [EOL] setJj_3R_119Condition(true); [EOL] boolean result = jj_3R_106(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_106_WithAllConditionsReturningFalse() { [EOL] setJj_3R_120Condition(false); [EOL] setJj_3R_119Condition(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_106(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_5_AllConditionsTrue() { [EOL] setJj_3R_18(true); [EOL] setJj_la(0); [EOL] setJj_scanpos(jj_lastpos); [EOL] setJj_scan_token(80, true); [EOL] boolean result = jj_3_5(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3_5_FirstConditionTrue() { [EOL] setJj_3R_18(true); [EOL] boolean result = jj_3_5(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3_5_SecondConditionTrue() { [EOL] setJj_3R_18(false); [EOL] setJj_la(0); [EOL] setJj_scanpos(jj_lastpos); [EOL] boolean result = jj_3_5(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3_5_ThirdConditionTrue() { [EOL] setJj_3R_18(false); [EOL] setJj_la(1); // Ensure this condition is false [EOL] setJj_scan_token(80, true); [EOL] boolean result = jj_3_5(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3_5_AllConditionsFalse() { [EOL] setJj_3R_18(false); [EOL] setJj_la(1); [EOL] setJj_scanpos(new Object()); // Ensure this is not equal to jj_lastpos [EOL] setJj_scan_token(80, false); [EOL] boolean result = jj_3_5(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_91_TokenIsFunctionFormatNumber() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = FUNCTION_FORMAT_NUMBER; [EOL] boolean result = parser.jj_3R_91(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_91_AtEndOfInput() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 0; [EOL] parser.jj_scanpos = parser.jj_lastpos; [EOL] boolean result = parser.jj_3R_91(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_91_NotAtEndOfInput() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 1; // or any non-zero value [EOL] boolean result = parser.jj_3R_91(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_90_WithFunctionKeyToken() { [EOL] boolean result = jj_3R_90(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_90_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = 1; [EOL] jj_lastpos = 1; [EOL] boolean result = jj_3R_90(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_90_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = 1; [EOL] jj_lastpos = 2; // or any value such that jj_scanpos != jj_lastpos [EOL] boolean result = jj_3R_90(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_89_WithFunctionRoundToken() { [EOL] initToken(FUNCTION_ROUND); [EOL] boolean result = jj_3R_89(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_89_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_89(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_89_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and different [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_89(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_88_WithFunctionCeilingToken() { [EOL] boolean result = jj_3R_88(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_88_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = 1; [EOL] jj_lastpos = 1; [EOL] boolean result = jj_3R_88(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_88_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero value [EOL] jj_scanpos = 1; [EOL] jj_lastpos = 2; // Different from jj_scanpos [EOL] boolean result = jj_3R_88(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_97_WhenJj_3R_106ReturnsTrue() { [EOL] setJj_3R_106(true); [EOL] boolean result = jj_3R_97(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_97_WhenJj_3R_106ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setJj_3R_106(false); [EOL] setJj_la(0); [EOL] setJj_scanpos(jj_lastpos); [EOL] boolean result = jj_3R_97(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_97_WhenJj_3R_106ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setJj_3R_106(false); [EOL] setJj_la(1); [EOL] setJj_scanpos(differentThan(jj_lastpos)); [EOL] boolean result = jj_3R_97(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_87_WithFunctionFloorToken() { [EOL] initToken(FUNCTION_FLOOR); [EOL] boolean result = jj_3R_87(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_87_WithNonFunctionFloorToken() { [EOL] initToken(NON_FUNCTION_FLOOR); [EOL] boolean result = jj_3R_87(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_87_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] initLaAndPositions(0, SAME_POSITION); [EOL] boolean result = jj_3R_87(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_96_WhenJj_3R_105ReturnsTrue() { [EOL] boolean result = jj_3R_96(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_96_WhenJj_3R_105ReturnsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_96(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_96_WhenJj_3R_105ReturnsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_96(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_86_WithFunctionSumToken() { [EOL] boolean result = jj_3R_86(); [EOL] assert(result); [EOL] }
public void testJj_3R_86_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_86(); [EOL] assert(!result); [EOL] }
public void testJj_3R_86_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_86(); [EOL] assert(!result); [EOL] }
public void testJj_3R_85_TokenIsFunctionNumber() { [EOL] boolean result = jj_3R_85(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_85_LaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_85(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_85_Otherwise() { [EOL] boolean result = jj_3R_85(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_94_WithLiteralToken() { [EOL] jj_scan_token(Literal); [EOL] boolean result = jj_3R_94(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_94_WithNonLiteralTokenAndLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_94(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_94_WithNonLiteralTokenAndLaNotZero() { [EOL] jj_la = 1; // any non-zero value [EOL] boolean result = jj_3R_94(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_84_WithFunctionLangToken() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_scan_token = FUNCTION_LANG; [EOL] assertTrue(parser.jj_3R_84()); [EOL] }
public void testJj_3R_84_WithLaZeroAndScanposEqualsLastpos() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 0; [EOL] parser.jj_scanpos = parser.jj_lastpos; [EOL] assertFalse(parser.jj_3R_84()); [EOL] }
public void testJj_3R_84_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] MyParser parser = new MyParser(); [EOL] parser.jj_la = 1; // or any non-zero value [EOL] parser.jj_scanpos = new Token(); [EOL] parser.jj_lastpos = new Token(); [EOL] parser.jj_scanpos.next = parser.jj_lastpos; [EOL] assertFalse(parser.jj_3R_84()); [EOL] }
public void testJj_3R_93_Token80() { [EOL] boolean result = jj_3R_93(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_93_JjLaAndJjScanposEqualJjLastposFirst() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_93(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_93_Jj3R104() { [EOL] boolean result = jj_3R_93(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_93_Token81() { [EOL] boolean result = jj_3R_93(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_93_JjLaAndJjScanposEqualJjLastposSecond() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_93(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_93_JjLaAndJjScanposEqualJjLastposThird() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_93(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_93_AllConditionsFalse() { [EOL] boolean result = jj_3R_93(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_83_WithFunctionNullToken() { [EOL] boolean result = jj_3R_83(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_83_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos = new Token(); // Assuming Token is the type of jj_scanpos and jj_lastpos [EOL] boolean result = jj_3R_83(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_83_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // Non-zero value [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); // Different instances so they are not equal [EOL] boolean result = jj_3R_83(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_82_WithFunctionFalseToken() { [EOL] boolean result = jj_3R_82(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_82_WithNonFunctionFalseTokenAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_82(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_82_WithNonFunctionFalseTokenAndLaNotZero() { [EOL] boolean result = jj_3R_82(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_81_WhenFunctionTrueToken() { [EOL] boolean result = jj_3R_81(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_81_WhenNotFunctionTrueTokenAndLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_81(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_81_WhenNotFunctionTrueTokenAndLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_81(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_120_WhenJj_3R_128ReturnsTrue() { [EOL] boolean result = jj_3R_120(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_120_WhenJj_3R_128ReturnsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] boolean result = jj_3R_120(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_120_WhenJj_3R_128ReturnsFalseAndJj_laIsNotZeroOrJj_scanposNotEqualsJj_lastpos() { [EOL] boolean result = jj_3R_120(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_80_WithFunctionNotToken() { [EOL] boolean result = jj_3R_80(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_80_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_80(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_80_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_80(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_79_WithFunctionBooleanToken() { [EOL] boolean result = jj_3R_79(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_79_WithLaAndScanposConditions() { [EOL] boolean result = jj_3R_79(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_78_WithFunctionTranslateToken() { [EOL] boolean result = jj_3R_78(); [EOL] assert(result); [EOL] }
public void testJj_3R_78_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_78(); [EOL] assert(!result); [EOL] }
public void testJj_3R_78_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_78(); [EOL] assert(!result); [EOL] }
public void testJj_3R_77_TokenIsFunctionNormalizeSpace() { [EOL] boolean result = jj_3R_77(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_77_AtEndOfInput() { [EOL] boolean result = jj_3R_77(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_77_NotAtEndOfInput() { [EOL] boolean result = jj_3R_77(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_19_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_FifthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_19_SixthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_76_WithFunctionStringLengthToken() { [EOL] boolean result = jj_3R_76(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_76_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_76(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_76_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_76(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_75_WithFunctionSubstringToken() { [EOL] boolean result = jj_3R_75(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_75_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_75(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_75_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_75(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_74_WithFunctionSubstringAfterToken() { [EOL] boolean result = jj_3R_74(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_74_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = 1; // or any arbitrary value [EOL] jj_lastpos = jj_scanpos; [EOL] boolean result = jj_3R_74(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_74_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = 1; [EOL] jj_lastpos = 2; // or any value that is not equal to jj_scanpos [EOL] boolean result = jj_3R_74(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_73_WithFunctionSubstringBeforeToken() { [EOL] boolean result = jj_3R_73(); [EOL] assert(result); [EOL] }
public void testJj_3R_73_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_73(); [EOL] assert(!result); [EOL] }
public void testJj_3R_73_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value not equal to jj_lastpos [EOL] boolean result = jj_3R_73(); [EOL] assert(!result); [EOL] }
public void testJj_3R_72_WithFunctionContainsToken() { [EOL] boolean result = jj_3R_72(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_72_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // assuming jj_scanpos and jj_lastpos are initialized properly [EOL] boolean result = jj_3R_72(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_72_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and it's not equal to jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_72(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_71_WithFunctionStartsWithToken() { [EOL] boolean result = jj_3R_71(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_71_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_71(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_71_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value that is not equal to jj_lastpos [EOL] boolean result = jj_3R_71(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_70_WithFunctionConcatToken() { [EOL] initToken(FUNCTION_CONCAT); [EOL] boolean result = jj_3R_70(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_70_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_70(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_70_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and they are not equal [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_70(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_69_TokenIsFunctionString() { [EOL] boolean result = jj_3R_69(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_69_TokenIsNotFunctionStringAndLaIsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_69(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_69_TokenIsNotFunctionStringAndLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_69(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_68_WithFunctionNameToken() { [EOL] boolean result = jj_3R_68(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_68_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_68(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_68_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_68(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_67_TokenIsFunctionNamespaceUri() { [EOL] boolean result = jj_3R_67(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_67_AtEndOfInputWithLastPos() { [EOL] boolean result = jj_3R_67(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_67_NotAtEndOfInputNorNamespaceUri() { [EOL] boolean result = jj_3R_67(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_66_TokenIsFunctionLocalName() { [EOL] when(jj_scan_token(FUNCTION_LOCAL_NAME)).thenReturn(true); [EOL] boolean result = jj_3R_66(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_66_AtEndOfInput() { [EOL] when(jj_scan_token(FUNCTION_LOCAL_NAME)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_66(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_66_NotAtEndOfInput() { [EOL] when(jj_scan_token(FUNCTION_LOCAL_NAME)).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] jj_scanpos.next = jj_lastpos; // assuming Token has a 'next' field to simulate different positions [EOL] boolean result = jj_3R_66(); [EOL] assertFalse(result); [EOL] }
public void testJjSave_NewJJCalls() { [EOL] int index = 0; // Assuming index is within the bounds of jj_2_rtns array [EOL] int xla = 1; // Arbitrary value for xla [EOL] jj_save(index, xla); // Call the method to test [EOL] JJCalls p = jj_2_rtns[index]; [EOL] assertNotNull(p.next); // Check if new JJCalls object was created [EOL] assertEquals(jj_gen + xla - jj_la, p.gen); // Check if 'gen' is set correctly [EOL] assertEquals(token, p.first); // Check if 'first' is set to 'token' [EOL] assertEquals(xla, p.arg); // Check if 'arg' is set to 'xla' [EOL] }
public void testJjSave_ExistingJJCalls() { [EOL] int index = 0; // Assuming index is within the bounds of jj_2_rtns array [EOL] int xla = 1; // Arbitrary value for xla [EOL] JJCalls initial = new JJCalls(); [EOL] initial.gen = jj_gen - 1; // Set gen to be less than jj_gen to not enter the loop [EOL] jj_2_rtns[index] = initial; [EOL] jj_save(index, xla); // Call the method to test [EOL] JJCalls p = jj_2_rtns[index]; [EOL] assertNull(p.next); // Check if no new JJCalls object was created [EOL] assertEquals(jj_gen + xla - jj_la, p.gen); // Check if 'gen' is set correctly [EOL] assertEquals(token, p.first); // Check if 'first' is set to 'token' [EOL] assertEquals(xla, p.arg); // Check if 'arg' is set to 'xla' [EOL] }
public void testToStringWithSingleArg() { [EOL] Object[] singleArg = {new Object()}; [EOL] YourClass instance = new YourClass(singleArg); [EOL] String expected = instance.getSymbol() + instance.parenthesize(singleArg[0], false); [EOL] String result = instance.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testToStringWithMultipleArgs() { [EOL] Object[] multipleArgs = {new Object(), new Object(), new Object()}; [EOL] YourClass instance = new YourClass(multipleArgs); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] for (int i = 0; i < multipleArgs.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(' '); [EOL] buffer.append(instance.getSymbol()); [EOL] buffer.append(' '); [EOL] } [EOL] buffer.append(instance.parenthesize(multipleArgs[i], i == 0)); [EOL] } [EOL] String expected = buffer.toString(); [EOL] String result = instance.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testParenthesizeWithNonCoreOperation() { [EOL] Expression expression = mock(Expression.class); [EOL] when(expression.toString()).thenReturn("NonCoreOperation"); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("NonCoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndLowerPrecedence() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(10); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(5); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndEqualPrecedenceSymmetric() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(10); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(10); [EOL] when(isSymmetric()).thenReturn(true); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndEqualPrecedenceNotSymmetricLeft() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(10); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(10); [EOL] when(isSymmetric()).thenReturn(false); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("CoreOperation", result); [EOL] }
public void testParenthesizeWithCoreOperationAndEqualPrecedenceNotSymmetricRight() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(10); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(10); [EOL] when(isSymmetric()).thenReturn(false); [EOL] String result = parenthesize(expression, false); [EOL] assertEquals("(CoreOperation)", result); [EOL] }
public void testParenthesizeWithCoreOperationAndHigherPrecedence() { [EOL] CoreOperation expression = mock(CoreOperation.class); [EOL] when(expression instanceof CoreOperation).thenReturn(true); [EOL] when(expression.getPrecedence()).thenReturn(5); [EOL] when(expression.toString()).thenReturn("CoreOperation"); [EOL] when(getPrecedence()).thenReturn(10); [EOL] String result = parenthesize(expression, true); [EOL] assertEquals("(CoreOperation)", result); [EOL] }
public void testGetPropertyNamesWithNonEmptyMap() { [EOL] Map<String, String> map = new HashMap<>(); [EOL] map.put("key1", "value1"); [EOL] map.put("key2", "value2"); [EOL] String[] propertyNames = getPropertyNames(map); [EOL] Arrays.sort(propertyNames); // Sorting to ensure order for assertion [EOL] assertEquals("key1", propertyNames[0]); [EOL] assertEquals("key2", propertyNames[1]); [EOL] }
public void testGetPropertyNamesWithEmptyMap() { [EOL] Map<String, String> map = new HashMap<>(); [EOL] String[] propertyNames = getPropertyNames(map); [EOL] assertEquals(0, propertyNames.length); [EOL] }
public void testIsLangAttributeWithNullPrefix() { [EOL] QName name = new QName(null, "lang"); [EOL] boolean result = isLangAttribute(name); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLangAttributeWithIncorrectPrefix() { [EOL] QName name = new QName("wrongPrefix", "lang"); [EOL] boolean result = isLangAttribute(name); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLangAttributeWithCorrectPrefixButWrongName() { [EOL] QName name = new QName("xml", "wrongName"); [EOL] boolean result = isLangAttribute(name); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLangAttributeWithCorrectPrefixAndName() { [EOL] QName name = new QName("xml", "lang"); [EOL] boolean result = isLangAttribute(name); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION - 1); [EOL] boolean result = instance.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(YourClass.WHOLE_COLLECTION); [EOL] boolean result = instance.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testNullPointerWithNameAndLocale() { [EOL] QName testName = new QName("testName"); [EOL] Locale testLocale = new Locale("en", "US"); [EOL] NullPointer exception = new NullPointer(testName, testLocale); [EOL] assertNotNull(exception); [EOL] assertEquals(testName, exception.getName()); [EOL] assertEquals(testLocale, exception.getLocale()); [EOL] }
public void testNullPointerWithNullName() { [EOL] Locale testLocale = new Locale("en", "US"); [EOL] NullPointer exception = new NullPointer(null, testLocale); [EOL] assertNotNull(exception); [EOL] assertNull(exception.getName()); [EOL] assertEquals(testLocale, exception.getLocale()); [EOL] }
public void testNullPointerWithNullLocale() { [EOL] QName testName = new QName("testName"); [EOL] NullPointer exception = new NullPointer(testName, null); [EOL] assertNotNull(exception); [EOL] assertEquals(testName, exception.getName()); [EOL] assertNull(exception.getLocale()); [EOL] }
public void testNullPointerWithNullNameAndLocale() { [EOL] NullPointer exception = new NullPointer(null, null); [EOL] assertNotNull(exception); [EOL] assertNull(exception.getName()); [EOL] assertNull(exception.getLocale()); [EOL] }
public void testNullPointerWithLocaleAndId() { [EOL] Locale testLocale = new Locale("en", "US"); [EOL] String testId = "testId"; [EOL] NullPointer nullPointer = new NullPointer(testLocale, testId); [EOL] assertNull(nullPointer.getMessage()); [EOL] assertEquals(testLocale, nullPointer.getLocale()); [EOL] assertEquals(testId, nullPointer.getId()); [EOL] }
public void testCreateChildWithValidArguments() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = new QName("namespace", "localName"); [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new NodePointerTestSubclass(); [EOL] NodePointerTestSubclass.createPathResult = nodePointer; [EOL] NodePointer result = nodePointer.createChild(context, name, index, value); [EOL] assertNotNull(result); [EOL] assertEquals(nodePointer, result); [EOL] }
public void testCreateChildWithNullContext() { [EOL] QName name = new QName("namespace", "localName"); [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new NodePointerTestSubclass(); [EOL] NodePointerTestSubclass.createPathResult = nodePointer; [EOL] try { [EOL] nodePointer.createChild(null, name, index, value); [EOL] fail("Should throw IllegalArgumentException for null context"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateChildWithNullName() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new NodePointerTestSubclass(); [EOL] NodePointerTestSubclass.createPathResult = nodePointer; [EOL] try { [EOL] nodePointer.createChild(context, null, index, value); [EOL] fail("Should throw IllegalArgumentException for null QName"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAsPathWithNonNullId() { [EOL] YourClass instance = new YourClass("someId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id(someId)", result); [EOL] } [EOL] public void testAsPathWithNullIdAndNonNullParent() { [EOL] YourClass parentInstance = new YourClass("parentId"); [EOL] YourClass instance = new YourClass(null); [EOL] instance.setParent(parentInstance); [EOL] String result = instance.asPath(); [EOL] assertEquals(parentInstance.asPath(), result); [EOL] } [EOL] public void testAsPathWithNullIdAndNullParent() { [EOL] YourClass instance = new YourClass(null); [EOL] String result = instance.asPath(); [EOL] assertEquals("null()", result); [EOL] }
public void testBooleanValueWithNumberNonZero() { [EOL] double nonZeroNumber = 1.0; [EOL] assertTrue(JXPath.booleanValue(nonZeroNumber)); [EOL] }
public void testBooleanValueWithNumberZero() { [EOL] double zeroNumber = 0.0; [EOL] assertFalse(JXPath.booleanValue(zeroNumber)); [EOL] }
public void testBooleanValueWithNumberNaN() { [EOL] double nanValue = Double.NaN; [EOL] assertFalse(JXPath.booleanValue(nanValue)); [EOL] }
public void testBooleanValueWithBooleanTrue() { [EOL] Boolean trueValue = Boolean.TRUE; [EOL] assertTrue(JXPath.booleanValue(trueValue)); [EOL] }
public void testBooleanValueWithBooleanFalse() { [EOL] Boolean falseValue = Boolean.FALSE; [EOL] assertFalse(JXPath.booleanValue(falseValue)); [EOL] }
public void testBooleanValueWithEvalContextNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] assertFalse(JXPath.booleanValue(ctx)); [EOL] }
public void testBooleanValueWithEvalContextNonNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.isActual()).thenReturn(true); [EOL] assertTrue(JXPath.booleanValue(ctx)); [EOL] }
public void testBooleanValueWithStringEmpty() { [EOL] String emptyString = ""; [EOL] assertFalse(JXPath.booleanValue(emptyString)); [EOL] }
public void testBooleanValueWithStringNonEmpty() { [EOL] String nonEmptyString = "JXPath"; [EOL] assertTrue(JXPath.booleanValue(nonEmptyString)); [EOL] }
public void testBooleanValueWithNodePointerActual() { [EOL] NodePointer pointer = mock(NodePointer.class); [EOL] when(pointer.isActual()).thenReturn(true); [EOL] assertTrue(JXPath.booleanValue(pointer)); [EOL] }
public void testBooleanValueWithNodePointerNotActual() { [EOL] NodePointer pointer = mock(NodePointer.class); [EOL] when(pointer.isActual()).thenReturn(false); [EOL] assertFalse(JXPath.booleanValue(pointer)); [EOL] }
public void testBooleanValueWithVariablePointer() { [EOL] VariablePointer pointer = mock(VariablePointer.class); [EOL] Node node = mock(Node.class); [EOL] when(pointer.getNode()).thenReturn(node); [EOL] when(pointer.isActual()).thenReturn(true); [EOL] assertTrue(JXPath.booleanValue(pointer)); [EOL] }
public void testBooleanValueWithNull() { [EOL] assertFalse(JXPath.booleanValue(null)); [EOL] }
public void testBooleanValueWithOtherObject() { [EOL] Object otherObject = new Object(); [EOL] assertTrue(JXPath.booleanValue(otherObject)); [EOL] }
public void testEquals_SameObject() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] assertTrue(beanPointer.equals(beanPointer)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] Object other = new Object(); [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_NullParent() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.parent = null; [EOL] other.parent = new Object(); // Assuming parent is of type Object [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualParent() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] Object parent = new Object(); [EOL] beanPointer.parent = parent; [EOL] other.parent = parent; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentName() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.name = "name"; [EOL] other.name = null; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualName() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.name = "name"; [EOL] other.name = "name"; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentIndex() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.index = 1; [EOL] other.index = 2; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualIndex() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.index = 1; [EOL] other.index = 1; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_EqualBeanPrimitive() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = "test"; [EOL] other.bean = "test"; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentBeanPrimitive() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = "test"; [EOL] other.bean = "different"; [EOL] assertFalse(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_SameBeanReference() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] Object bean = new Object(); [EOL] beanPointer.bean = bean; [EOL] other.bean = bean; [EOL] assertTrue(beanPointer.equals(other)); [EOL] } [EOL] public void testEquals_DifferentBeanReference() { [EOL] BeanPointer beanPointer = new BeanPointer(); // Assuming a constructor exists [EOL] BeanPointer other = new BeanPointer(); // Assuming a constructor exists [EOL] beanPointer.bean = new Object(); [EOL] other.bean = new Object(); [EOL] assertFalse(beanPointer.equals(other)); [EOL] }

public void testAsPathWithParentNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setParent(new ParentClass()); // Assuming setParent method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("Expected path from parent", result); // Replace with actual expected result [EOL] }
public void testAsPathWithBeanNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean(null); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("null()", result); [EOL] }
public void testAsPathWithBeanNumberWithoutDecimal() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean(42); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("42", result); [EOL] }
public void testAsPathWithBeanNumberWithDecimal() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean(42.0); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("42", result); [EOL] }
public void testAsPathWithBeanBooleanTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean(true); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("true()", result); [EOL] }
public void testAsPathWithBeanBooleanFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean(false); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("false()", result); [EOL] }
public void testAsPathWithBeanString() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean("testString"); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("'testString'", result); [EOL] }
public void testAsPathWithBeanNotHandledType() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setBean(new Object()); // Assuming setBean method exists [EOL] String result = instance.asPath(); [EOL] assertEquals("/", result); [EOL] }
public void testSetValueThrowsUnsupportedOperationException() { [EOL] CollectionPointer cp = new CollectionPointer(); // Assuming CollectionPointer is the class where setValue is defined [EOL] try { [EOL] cp.setValue("someValue"); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Collection element does not exist: " + cp, e.getMessage()); [EOL] } [EOL] }
public void testAsPathWithNonNullParentAndIndexWholeCollection() { [EOL] NodePointer mockParent = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockParent.asPath()).thenReturn("/parentPath"); [EOL] Mockito.when(mockParent.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] NodePointer nodePointer = new ConcreteNodePointer(mockParent, NodePointer.WHOLE_COLLECTION); [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/parentPath", result); [EOL] }
public void testAsPathWithNonNullParentAndSpecificIndex() { [EOL] NodePointer mockParent = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockParent.asPath()).thenReturn("/parentPath"); [EOL] Mockito.when(mockParent.getIndex()).thenReturn(1); [EOL] NodePointer nodePointer = new ConcreteNodePointer(mockParent, 2); [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/parentPath/.[3]", result); [EOL] }
public void testAsPathWithNullParentAndSpecificIndex() { [EOL] NodePointer nodePointer = new ConcreteNodePointer(null, 2); [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("[3]", result); [EOL] }
public void testAsPathWithNonNullParentAndParentIndexNotWholeCollection() { [EOL] NodePointer mockParent = Mockito.mock(NodePointer.class); [EOL] NodePointer mockGrandParent = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockParent.asPath()).thenReturn("/parentPath"); [EOL] Mockito.when(mockParent.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] Mockito.when(mockParent.getImmediateParentPointer()).thenReturn(mockGrandParent); [EOL] Mockito.when(mockGrandParent.getIndex()).thenReturn(1); [EOL] NodePointer nodePointer = new ConcreteNodePointer(mockParent, 2); [EOL] String result = nodePointer.asPath(); [EOL] assertEquals("/parentPath/.[3]", result); [EOL] }
public void testAddNonNullPointer() { [EOL] PointerContainer container = new PointerContainer(); [EOL] Pointer pointer = new MockPointer(); [EOL] container.add(pointer); [EOL] assertEquals(1, container.size()); [EOL] }
public void testAddNullPointer() { [EOL] PointerContainer container = new PointerContainer(); [EOL] try { [EOL] container.add(null); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testGetPointers_WhenReadOnlyPointersIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.pointers = new ArrayList(); // Assuming 'pointers' is a modifiable list in the class [EOL] List result = instance.getPointers(); [EOL] assertNotNull("The result should not be null.", result); [EOL] assertTrue("The result should be an unmodifiable list.", result instanceof UnmodifiableList); [EOL] }
public void testGetPointers_WhenReadOnlyPointersIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.pointers = new ArrayList(); // Assuming 'pointers' is a modifiable list in the class [EOL] instance.readOnlyPointers = Collections.unmodifiableList(instance.pointers); // Set readOnlyPointers to a non-null value [EOL] List initialReadOnlyPointers = instance.readOnlyPointers; [EOL] List result = instance.getPointers(); [EOL] assertSame("The result should be the same as the initial readOnlyPointers.", initialReadOnlyPointers, result); [EOL] }
public void testGetValues_ValuesNull() { [EOL] MyClass testInstance = new MyClass(); [EOL] testInstance.pointers = new ArrayList(); [EOL] Pointer mockPointer1 = mock(Pointer.class); [EOL] when(mockPointer1.getValue()).thenReturn("Value1"); [EOL] testInstance.pointers.add(mockPointer1); [EOL] Pointer mockPointer2 = mock(Pointer.class); [EOL] when(mockPointer2.getValue()).thenReturn("Value2"); [EOL] testInstance.pointers.add(mockPointer2); [EOL] List result = testInstance.getValues(); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("Value1", result.get(0)); [EOL] assertEquals("Value2", result.get(1)); [EOL] }
public void testGetValues_ValuesNotNull() { [EOL] MyClass testInstance = new MyClass(); [EOL] testInstance.values = new ArrayList(); [EOL] testInstance.values.add("PreExistingValue"); [EOL] List result = testInstance.getValues(); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("PreExistingValue", result.get(0)); [EOL] }
public void testGetPropertyCountWithNoProperties() { [EOL] instance.setPropertyNames(new String[0]); [EOL] int count = instance.getPropertyCount(); [EOL] assert(count == 0); [EOL] } [EOL] public void testGetPropertyCountWithProperties() { [EOL] instance.setPropertyNames(new String[]{"property1", "property2", "property3"}); [EOL] int count = instance.getPropertyCount(); [EOL] assert(count == 3); [EOL] }
public void testGetPropertyNamesWithNullNamesAndRequiredProperty() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setRequiredPropertyName("requiredProperty"); [EOL] String[] result = instance.getPropertyNames(); [EOL] assertNotNull(result); [EOL] assertEquals("requiredProperty", result[0]); [EOL] }
public void testGetPropertyNamesWithNullNamesAndNoRequiredProperty() { [EOL] YourClass instance = new YourClass(); [EOL] String[] result = instance.getPropertyNames(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] }
public void testGetPropertyNamesWithNonNullNames() { [EOL] YourClass instance = new YourClass(); [EOL] instance.getPropertyNames(); // Call once to initialize names [EOL] String[] initialResult = instance.getPropertyNames(); [EOL] String[] result = instance.getPropertyNames(); [EOL] assertSame(initialResult, result); [EOL] }
public void testGetPropertyNameWithNullNameAndValidIndex() { [EOL] this.name = null; [EOL] this.propertyIndex = 1; // Assuming this is a valid index within the names array bounds [EOL] String result = getPropertyName(); [EOL] assertEquals("ExpectedPropertyName", result); [EOL] }
public void testGetPropertyNameWithNullNameAndInvalidIndex() { [EOL] this.name = null; [EOL] this.propertyIndex = -1; // Assuming this is an invalid index [EOL] String result = getPropertyName(); [EOL] assertEquals("*", result); [EOL] }
public void testGetPropertyNameWithNameAlreadySet() { [EOL] this.name = "AlreadySetName"; [EOL] String result = getPropertyName(); [EOL] assertEquals("AlreadySetName", result); [EOL] }
public void testSetPropertyIndex_NewIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int newIndex = 1; [EOL] instance.setPropertyIndex(newIndex); [EOL] assertEquals(newIndex, instance.getPropertyIndex()); [EOL] assertNull(instance.getName()); [EOL] }
public void testSetPropertyIndex_SameIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int initialIndex = 0; [EOL] instance.setPropertyIndex(initialIndex); [EOL] instance.setPropertyIndex(initialIndex); [EOL] assertEquals(initialIndex, instance.getPropertyIndex()); [EOL] assertNotNull(instance.getName()); [EOL] }
public Object getImmediateNode() { [EOL] Object value; [EOL] if (index == WHOLE_COLLECTION) { [EOL] value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName())); [EOL] } else { [EOL] value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index); [EOL] } [EOL] return value; [EOL] }
public Pointer getSingleNodePointer() { [EOL] reset(); [EOL] while (nextSet()) { [EOL] if (nextNode()) { [EOL] return getCurrentNodePointer(); [EOL] } [EOL] } [EOL] return null; [EOL] }
public boolean nextSet() { [EOL] reset(); [EOL] if (!startedSetIteration) { [EOL] startedSetIteration = true; [EOL] while (parentContext.nextSet()) { [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] } [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] while (parentContext.nextSet()) { [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] }
public Set getUsedNamespaces() { [EOL] return Collections.singleton(namespace); [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL] if ((namespace == null && this.namespace != null) || (namespace != null && !namespace.equals(this.namespace))) { [EOL] return null; [EOL] } [EOL] if (parameters == null) { [EOL] parameters = EMPTY_ARRAY; [EOL] } [EOL] if (parameters.length >= 1) { [EOL] Object target = TypeUtils.convert(parameters[0], Object.class); [EOL] if (target != null) { [EOL] Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] if (target instanceof NodeSet) { [EOL] target = ((NodeSet) target).getPointers(); [EOL] } [EOL] method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] if (target instanceof Collection) { [EOL] Iterator iter = ((Collection) target).iterator(); [EOL] if (iter.hasNext()) { [EOL] target = iter.next(); [EOL] if (target instanceof Pointer) { [EOL] target = ((Pointer) target).getValue(); [EOL] } [EOL] } else { [EOL] target = null; [EOL] } [EOL] } [EOL] } [EOL] if (target != null) { [EOL] Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] } [EOL] } [EOL] String fullName = classPrefix + name; [EOL] int inx = fullName.lastIndexOf('.'); [EOL] if (inx == -1) { [EOL] return null; [EOL] } [EOL] String className = fullName.substring(0, inx); [EOL] String methodName = fullName.substring(inx + 1); [EOL] Class functionClass; [EOL] try { [EOL] functionClass = Class.forName(className); [EOL] } catch (ClassNotFoundException ex) { [EOL] throw new JXPathException("Cannot invoke extension function " + (namespace != null ? namespace + ":" + name : name), ex); [EOL] } [EOL] if (methodName.equals("new")) { [EOL] Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL] if (constructor != null) { [EOL] return new ConstructorFunction(constructor); [EOL] } [EOL] } else { [EOL] Method method = MethodLookupUtils.lookupStaticMethod(functionClass, methodName, parameters); [EOL] if (method != null) { [EOL] return new MethodFunction(method); [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testComputeValueGreater() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(10.0); [EOL] when(args[1].computeValue(context)).thenReturn(5.0); [EOL] YourClass instance = new YourClass(args); [EOL] Object result = instance.computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueLess() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(5.0); [EOL] when(args[1].computeValue(context)).thenReturn(10.0); [EOL] YourClass instance = new YourClass(args); [EOL] Object result = instance.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testComputeValueEqual() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression[] args = new Expression[2]; [EOL] args[0] = mock(Expression.class); [EOL] args[1] = mock(Expression.class); [EOL] when(args[0].computeValue(context)).thenReturn(5.0); [EOL] when(args[1].computeValue(context)).thenReturn(5.0); [EOL] YourClass instance = new YourClass(args); [EOL] Object result = instance.computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testJDOMAttributeIteratorWithElementAndSpecificName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] Namespace ns = Namespace.getNamespace("testPrefix", "testURI"); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", ns)).thenReturn(attribute); [EOL] when(element.getNamespace("testPrefix")).thenReturn(ns); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertEquals(attribute, iterator.attributes.get(0)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndWildcardName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName(null, "*"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] List allAttributes = Arrays.asList(attribute); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttributes()).thenReturn(allAttributes); [EOL] when(attribute.getNamespace()).thenReturn(Namespace.NO_NAMESPACE); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertEquals(attribute, iterator.attributes.get(0)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndNoNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName(null, "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] Namespace ns = Namespace.NO_NAMESPACE; [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", ns)).thenReturn(attribute); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertEquals(attribute, iterator.attributes.get(0)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndXmlNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("xml", "testName"); [EOL] Element element = mock(Element.class); [EOL] Attribute attribute = mock(Attribute.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getAttribute("testName", Namespace.XML_NAMESPACE)).thenReturn(attribute); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertFalse(iterator.attributes.isEmpty()); [EOL] assertEquals(attribute, iterator.attributes.get(0)); [EOL] }
public void testJDOMAttributeIteratorWithElementAndNullNamespace() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("nonExistingPrefix", "testName"); [EOL] Element element = mock(Element.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getNamespace("nonExistingPrefix")).thenReturn(null); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertTrue(iterator.attributes.isEmpty()); [EOL] }
public void testJDOMAttributeIteratorWithNonElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("testPrefix", "testName"); [EOL] when(parent.getNode()).thenReturn(mock(Node.class)); [EOL] JDOMAttributeIterator iterator = new JDOMAttributeIterator(parent, name); [EOL] assertNull(iterator.attributes); [EOL] }
protected boolean equal(Object l, Object r) { [EOL] if (l instanceof Pointer && r instanceof Pointer) { [EOL] if (l.equals(r)) { [EOL] return true; [EOL] } [EOL] } [EOL] if (l instanceof Pointer) { [EOL] l = ((Pointer) l).getValue(); [EOL] } [EOL] if (r instanceof Pointer) { [EOL] r = ((Pointer) r).getValue(); [EOL] } [EOL] if (l == r) { [EOL] return true; [EOL] } [EOL] if (l instanceof Boolean || r instanceof Boolean) { [EOL] return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL] } else if (l instanceof Number || r instanceof Number) { [EOL] return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL] } else if (l instanceof String || r instanceof String) { [EOL] return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL] } else if (l == null) { [EOL] return r == null; [EOL] } [EOL] return l.equals(r); [EOL] }
public boolean nextNode() { [EOL] if (done) { [EOL] return false; [EOL] } [EOL] while (parentContext.nextNode()) { [EOL] if (setupDynamicPropertyPointer()) { [EOL] Object pred = nameTestExpression.computeValue(parentContext); [EOL] String propertyName = InfoSetUtil.stringValue(pred); [EOL] boolean ok = false; [EOL] String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL] for (int i = 0; i < names.length; i++) { [EOL] if (names[i].equals(propertyName)) { [EOL] ok = true; [EOL] break; [EOL] } [EOL] } [EOL] if (ok) { [EOL] dynamicPropertyPointer.setPropertyName(propertyName); [EOL] position++; [EOL] return true; [EOL] } [EOL] } else { [EOL] Object pred = expression.computeValue(parentContext); [EOL] if (pred instanceof Iterator) { [EOL] if (!((Iterator) pred).hasNext()) { [EOL] return false; [EOL] } [EOL] pred = ((Iterator) pred).next(); [EOL] } [EOL] if (pred instanceof NodePointer) { [EOL] pred = ((NodePointer) pred).getNode(); [EOL] } [EOL] if (pred instanceof Number) { [EOL] int pos = (int) InfoSetUtil.doubleValue(pred); [EOL] position++; [EOL] done = true; [EOL] return parentContext.setPosition(pos); [EOL] } else if (InfoSetUtil.booleanValue(pred)) { [EOL] position++; [EOL] return true; [EOL] } [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testSetupDynamicPropertyPointer_NameTestExpressionIsNull() { [EOL] this.nameTestExpression = null; [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_ParentIsNull() { [EOL] this.nameTestExpression = someExpression; [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(null); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_ParentIsNotPropertyOwnerPointer() { [EOL] this.nameTestExpression = someExpression; [EOL] NodePointer nonPropertyOwnerPointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(nonPropertyOwnerPointer); [EOL] when(nonPropertyOwnerPointer.getValuePointer()).thenReturn(nonPropertyOwnerPointer); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertFalse(result); [EOL] }
public void testSetupDynamicPropertyPointer_SuccessfulSetup() { [EOL] this.nameTestExpression = someExpression; [EOL] PropertyOwnerPointer propertyOwnerPointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getValuePointer()).thenReturn(propertyOwnerPointer); [EOL] when(propertyOwnerPointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] boolean result = setupDynamicPropertyPointer(); [EOL] assertTrue(result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionFails() { [EOL] context.setPosition(0); [EOL] Mockito.when(context.setPosition(1)).thenReturn(false); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds_DynamicPropertyPointerNotNull() { [EOL] context.setPosition(0); [EOL] Mockito.when(context.setPosition(1)).thenReturn(true); [EOL] DynamicPropertyPointer mockDynamicPropertyPointer = Mockito.mock(DynamicPropertyPointer.class); [EOL] context.dynamicPropertyPointer = mockDynamicPropertyPointer; [EOL] NodePointer mockValuePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockDynamicPropertyPointer.getValuePointer()).thenReturn(mockValuePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockValuePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds_DynamicPropertyPointerNull() { [EOL] context.setPosition(0); [EOL] Mockito.when(context.setPosition(1)).thenReturn(true); [EOL] context.dynamicPropertyPointer = null; [EOL] NodePointer mockParentNodePointer = Mockito.mock(NodePointer.class); [EOL] Context mockParentContext = Mockito.mock(Context.class); [EOL] context.parentContext = mockParentContext; [EOL] Mockito.when(mockParentContext.getCurrentNodePointer()).thenReturn(mockParentNodePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockParentNodePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionNotZero_DynamicPropertyPointerNotNull() { [EOL] context.setPosition(1); [EOL] DynamicPropertyPointer mockDynamicPropertyPointer = Mockito.mock(DynamicPropertyPointer.class); [EOL] context.dynamicPropertyPointer = mockDynamicPropertyPointer; [EOL] NodePointer mockValuePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockDynamicPropertyPointer.getValuePointer()).thenReturn(mockValuePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockValuePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionNotZero_DynamicPropertyPointerNull() { [EOL] context.setPosition(1); [EOL] context.dynamicPropertyPointer = null; [EOL] NodePointer mockParentNodePointer = Mockito.mock(NodePointer.class); [EOL] Context mockParentContext = Mockito.mock(Context.class); [EOL] context.parentContext = mockParentContext; [EOL] Mockito.when(mockParentContext.getCurrentNodePointer()).thenReturn(mockParentNodePointer); [EOL] NodePointer result = context.getCurrentNodePointer(); [EOL] assertSame(mockParentNodePointer, result); [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL] if (object == null) { [EOL] return true; [EOL] } [EOL] if (toType == Object.class) { [EOL] return true; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType)) { [EOL] return true; [EOL] } [EOL] if (toType.isAssignableFrom(fromType)) { [EOL] return true; [EOL] } [EOL] if (toType == String.class) { [EOL] return true; [EOL] } [EOL] if (object instanceof Boolean) { [EOL] if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Number) { [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof String) { [EOL] if (toType.isPrimitive()) { [EOL] return true; [EOL] } [EOL] if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL] return true; [EOL] } [EOL] } else if (fromType.isArray()) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] int length = Array.getLength(object); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (Array.getLength(object) > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] while (it.hasNext()) { [EOL] Object value = it.next(); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (((Collection) object).size() > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return canConvert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return canConvert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL] if (object == null) { [EOL] if (toType.isPrimitive()) { [EOL] return convertNullToPrimitive(toType); [EOL] } [EOL] return null; [EOL] } [EOL] if (toType == Object.class) { [EOL] if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return object; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL] return object; [EOL] } [EOL] if (fromType.isArray()) { [EOL] int length = Array.getLength(object); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] for (int i = 0; i < length; i++) { [EOL] collection.add(Array.get(object, i)); [EOL] } [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] int length = ((Collection) object).size(); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = it.next(); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] collection.addAll((Collection) object); [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } else if (toType == String.class) { [EOL] return object.toString(); [EOL] } else if (object instanceof Boolean) { [EOL] if (toType == boolean.class) { [EOL] return object; [EOL] } [EOL] boolean value = ((Boolean) object).booleanValue(); [EOL] return allocateNumber(toType, value ? 1 : 0); [EOL] } else if (object instanceof Number) { [EOL] double value = ((Number) object).doubleValue(); [EOL] if (toType == boolean.class || toType == Boolean.class) { [EOL] return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL] } [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return allocateNumber(toType, value); [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return object; [EOL] } [EOL] } else if (object instanceof String) { [EOL] Object value = convertStringToPrimitive(object, toType); [EOL] if (value != null) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter converter = ConvertUtils.lookup(toType); [EOL] if (converter != null) { [EOL] return converter.convert(toType, object); [EOL] } [EOL] throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
public void testConvertStringToPrimitiveBooleanTrue() { [EOL] Object result = convertStringToPrimitive("true", boolean.class); [EOL] assertTrue(result instanceof Boolean); [EOL] assertTrue((Boolean) result); [EOL] }
public void testConvertStringToPrimitiveBooleanFalse() { [EOL] Object result = convertStringToPrimitive("false", Boolean.class); [EOL] assertTrue(result instanceof Boolean); [EOL] assertFalse((Boolean) result); [EOL] }
public void testConvertStringToPrimitiveChar() { [EOL] Object result = convertStringToPrimitive("a", char.class); [EOL] assertTrue(result instanceof Character); [EOL] assertEquals('a', ((Character) result).charValue()); [EOL] }
public void testConvertStringToPrimitiveByte() { [EOL] Object result = convertStringToPrimitive("1", byte.class); [EOL] assertTrue(result instanceof Byte); [EOL] assertEquals((byte) 1, ((Byte) result).byteValue()); [EOL] }
public void testConvertStringToPrimitiveShort() { [EOL] Object result = convertStringToPrimitive("1", short.class); [EOL] assertTrue(result instanceof Short); [EOL] assertEquals((short) 1, ((Short) result).shortValue()); [EOL] }
public void testConvertStringToPrimitiveInt() { [EOL] Object result = convertStringToPrimitive("1", int.class); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(1, ((Integer) result).intValue()); [EOL] }
public void testConvertStringToPrimitiveLong() { [EOL] Object result = convertStringToPrimitive("1", long.class); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(1L, ((Long) result).longValue()); [EOL] }
public void testConvertStringToPrimitiveFloat() { [EOL] Object result = convertStringToPrimitive("1.0", float.class); [EOL] assertTrue(result instanceof Float); [EOL] assertEquals(1.0f, ((Float) result).floatValue(), 0.0f); [EOL] }
public void testConvertStringToPrimitiveDouble() { [EOL] Object result = convertStringToPrimitive("1.0", double.class); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(1.0, ((Double) result).doubleValue(), 0.0); [EOL] }
public void testConvertStringToPrimitiveNull() { [EOL] Object result = convertStringToPrimitive("test", Object.class); [EOL] assertNull(result); [EOL] }
public void testDynamicPointerWithValidArguments() { [EOL] QName name = new QName("testNamespace", "testLocalPart"); [EOL] Object bean = new Object(); [EOL] DynamicPropertyHandler handler = mock(DynamicPropertyHandler.class); [EOL] Locale locale = Locale.ENGLISH; [EOL] DynamicPointer dynamicPointer = new DynamicPointer(name, bean, handler, locale); [EOL] assertNotNull(dynamicPointer); [EOL] assertEquals(name, dynamicPointer.getName()); [EOL] assertEquals(bean, dynamicPointer.getBean()); [EOL] assertEquals(handler, dynamicPointer.getHandler()); [EOL] assertEquals(locale, dynamicPointer.getLocale()); [EOL] }
public void testCreateNodeIteratorWithReverseTrue() { [EOL] String property = "someProperty"; [EOL] boolean reverse = true; [EOL] NodePointer startWith = new NodePointerMock(); [EOL] NodeIterator result = createNodeIterator(property, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyIterator); [EOL] } [EOL] public void testCreateNodeIteratorWithReverseFalse() { [EOL] String property = "someProperty"; [EOL] boolean reverse = false; [EOL] NodePointer startWith = new NodePointerMock(); [EOL] NodeIterator result = createNodeIterator(property, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyIterator); [EOL] } [EOL] public void testCreateNodeIteratorWithNullStartWith() { [EOL] String property = "someProperty"; [EOL] boolean reverse = true; [EOL] NodePointer startWith = null; [EOL] NodeIterator result = createNodeIterator(property, reverse, startWith); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PropertyIterator); [EOL] }
public void testIsLeafWithNullNode() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathNode node = context.getPointer(null); [EOL] boolean result = node.isLeaf(); [EOL] assertTrue("Expected the result to be true when node is null", result); [EOL] }
public void testIsLeafWithAtomicNode() { [EOL] JXPathContext context = JXPathContext.newContext(new Integer(10)); [EOL] JXPathNode node = context.getPointer("dummyPath"); [EOL] boolean result = node.isLeaf(); [EOL] assertTrue("Expected the result to be true for an atomic node", result); [EOL] }
public void testIsLeafWithNonAtomicNode() { [EOL] JXPathContext context = JXPathContext.newContext(new ArrayList()); [EOL] JXPathNode node = context.getPointer("dummyPath"); [EOL] boolean result = node.isLeaf(); [EOL] assertFalse("Expected the result to be false for a non-atomic node", result); [EOL] }
public void testHashCode_WithNonNullBeanAndName() { [EOL] Object bean = new Object(); [EOL] String name = "testName"; [EOL] JXPathBeanProperty property = new JXPathBeanProperty(bean, name); [EOL] int result = property.hashCode(); [EOL] int expectedHashCode = System.identityHashCode(bean) + name.hashCode(); [EOL] assertEquals(expectedHashCode, result); [EOL] }
public void testGetNodePointer_PositionZero_NameNotNull_TargetNotReady_Empty() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = "someName"; [EOL] instance.targetReady = false; [EOL] instance.empty = true; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNotNull_TargetReady_NotEmpty() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = "someName"; [EOL] instance.targetReady = true; [EOL] instance.empty = false; [EOL] instance.propertyNodePointer = mock(PropertyNodePointer.class); [EOL] when(instance.propertyNodePointer.getValuePointer()).thenReturn(mock(NodePointer.class)); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNull_SetPositionFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = null; [EOL] instance.targetReady = false; // This value is irrelevant in this scenario [EOL] instance.empty = false; // This value is irrelevant in this scenario [EOL] doReturn(false).when(instance).setPosition(1); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionZero_NameNull_SetPositionTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] instance.name = null; [EOL] doReturn(true).when(instance).setPosition(1); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetNodePointer_PositionNotZero_ThrowsException() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 1; // Any non-zero value [EOL] instance.propertyNodePointer = mock(PropertyNodePointer.class); [EOL] when(instance.propertyNodePointer.getValuePointer()).thenThrow(new RuntimeException()); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPropertyPointer); [EOL] }
public void testGetPosition() { [EOL] MyClass instance = new MyClass(); [EOL] int expected = 10; // Assuming 'position' should be 10 for this test case [EOL] instance.position = expected; // Directly setting the position for the purpose of the test [EOL] int result = instance.getPosition(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetPositionWithNameNotNull() { [EOL] instance.setName("someName"); [EOL] boolean result = instance.setPosition(1); [EOL] }
public void testSetPositionWithNameNull() { [EOL] instance.setName(null); [EOL] boolean result = instance.setPosition(1); [EOL] }
public void testSetPositionIndividualProperty_PositionLessThanOne() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] boolean result = setPositionIndividualProperty(0); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_TargetNotReady() { [EOL] setTargetReady(false); [EOL] setEmpty(false); [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionIndividualProperty_Empty() { [EOL] setTargetReady(true); [EOL] setEmpty(true); [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_ReverseIndexOutOfBounds() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(true); [EOL] setIncludeStart(false); [EOL] setStartIndex(5); // Assuming length is less than 5 for this test [EOL] boolean result = setPositionIndividualProperty(10); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_NonReverseIndexOutOfBounds() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(false); [EOL] setIncludeStart(false); [EOL] setStartIndex(0); // Assuming length is 5 for this test [EOL] boolean result = setPositionIndividualProperty(6); [EOL] assertFalse(result); [EOL] }
public void testSetPositionIndividualProperty_ValidReverse() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(true); [EOL] setIncludeStart(true); [EOL] setStartIndex(-1); // Assuming length is greater than 2 for this test [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionIndividualProperty_ValidNonReverse() { [EOL] setTargetReady(true); [EOL] setEmpty(false); [EOL] setReverse(false); [EOL] setIncludeStart(true); [EOL] setStartIndex(0); // Assuming length is greater than 1 for this test [EOL] boolean result = setPositionIndividualProperty(1); [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_PositionLessThanOne() { [EOL] boolean result = setPositionAllProperties(0); [EOL] assertFalse(result); [EOL] }
public void testSetPositionAllProperties_ForwardTraversal_WithinBounds() { [EOL] boolean result = setPositionAllProperties(2); // Assuming this position is within bounds [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_ForwardTraversal_OutOfBounds() { [EOL] boolean result = setPositionAllProperties(999); // Assuming this position is out of bounds [EOL] assertFalse(result); [EOL] }
public void testSetPositionAllProperties_ReverseTraversal_WithinBounds() { [EOL] reverse = true; [EOL] boolean result = setPositionAllProperties(2); // Assuming this position is within bounds [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_ReverseTraversal_OutOfBounds() { [EOL] reverse = true; [EOL] boolean result = setPositionAllProperties(999); // Assuming this position is out of bounds [EOL] assertFalse(result); [EOL] }
public void testGetFunctionWithNullByNamespace() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertEquals("Expected function name", name, result.getName()); [EOL] }
public void testGetFunctionWithFunctionsInstance() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Functions functions = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(functions.getFunction(namespace, name, parameters)).thenReturn(expectedFunction); [EOL] byNamespace.put(namespace, functions); [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertSame("Expected function instance", expectedFunction, result); [EOL] }
public void testGetFunctionWithListInstance() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Functions functions1 = mock(Functions.class); [EOL] Functions functions2 = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(functions1.getFunction(namespace, name, parameters)).thenReturn(null); [EOL] when(functions2.getFunction(namespace, name, parameters)).thenReturn(expectedFunction); [EOL] List<Functions> functionsList = new ArrayList<>(); [EOL] functionsList.add(functions1); [EOL] functionsList.add(functions2); [EOL] byNamespace.put(namespace, functionsList); [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertSame("Expected function instance", expectedFunction, result); [EOL] }
public void testGetFunctionReturnsNull() { [EOL] String namespace = "testNamespace"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Functions functions = mock(Functions.class); [EOL] when(functions.getFunction(namespace, name, parameters)).thenReturn(null); [EOL] byNamespace.put(namespace, functions); [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testVariableReferenceWithNonNullVarName() { [EOL] QName varName = new QName("namespace", "localPart"); [EOL] VariableReference variableReference = new VariableReference(varName); [EOL] assertNotNull(variableReference); [EOL] assertEquals(varName, variableReference.getVarName()); [EOL] }
public void testVariableReferenceWithNullVarName() { [EOL] VariableReference variableReference = new VariableReference(null); [EOL] assertNotNull(variableReference); [EOL] assertNull(variableReference.getVarName()); [EOL] }
public void testToString() { [EOL] MyClass instance = new MyClass("testVar"); [EOL] String expected = "$testVar"; [EOL] String result = instance.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testAncestorContextWithIncludeSelfTrue() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] AncestorContext ancestorContext = new AncestorContext(parentContext, true, nodeTest); [EOL] assertTrue(ancestorContext.includeSelf); [EOL] assertEquals(nodeTest, ancestorContext.nodeTest); [EOL] }
public void testAncestorContextWithIncludeSelfFalse() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] AncestorContext ancestorContext = new AncestorContext(parentContext, false, nodeTest); [EOL] assertFalse(ancestorContext.includeSelf); [EOL] assertEquals(nodeTest, ancestorContext.nodeTest); [EOL] }
public NodePointer getCurrentNodePointerTest() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer pointer = context.getPointer(); [EOL] assertNotNull(pointer.getCurrentNodePointer()); [EOL] }
public int getDocumentOrder() { [EOL] return -1; [EOL] }
public void testReset() { [EOL] YourClass instance = new YourClass(); [EOL] instance.reset(); [EOL] assertFalse(instance.isSetStarted()); [EOL] }
public void testSetPositionLessThanCurrent() { [EOL] int currentPosition = 5; [EOL] int newPosition = 3; [EOL] boolean result = setPosition(newPosition); [EOL] }
public void testSetPositionEqualToCurrent() { [EOL] int currentPosition = 5; [EOL] int newPosition = 5; [EOL] boolean result = setPosition(newPosition); [EOL] }
public void testSetPositionGreaterThanCurrentSuccess() { [EOL] int currentPosition = 5; [EOL] int newPosition = 7; [EOL] boolean result = setPosition(newPosition); [EOL] }
public void testSetPositionGreaterThanCurrentFail() { [EOL] int currentPosition = 5; [EOL] int newPosition = 10; [EOL] boolean result = setPosition(newPosition); [EOL] }
public void testNextNode_InitialSetNotStarted_IncludeSelfTrue_NodeTestPasses() { [EOL] boolean includeSelf = true; [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(nodeTest.testNode(any())).thenReturn(true); [EOL] Context parentContext = mock(Context.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] when(currentNodePointer.testNode(nodeTest)).thenReturn(true); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(parentContext, includeSelf, nodeTest); [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, yourObjectUnderTest.getPosition()); [EOL] }
public void testNextNode_InitialSetNotStarted_IncludeSelfFalse_NodeTestFails() { [EOL] boolean includeSelf = false; [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(nodeTest.testNode(any())).thenReturn(false); [EOL] Context parentContext = mock(Context.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] when(currentNodePointer.getImmediateParentPointer()).thenReturn(null); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(parentContext, includeSelf, nodeTest); [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] assertEquals(0, yourObjectUnderTest.getPosition()); [EOL] }
public void testNextNode_AfterSetStarted_NodeTestPasses() { [EOL] boolean includeSelf = true; [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(nodeTest.testNode(any())).thenReturn(true); [EOL] Context parentContext = mock(Context.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] NodePointer parentPointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] when(currentNodePointer.getImmediateParentPointer()).thenReturn(parentPointer); [EOL] when(parentPointer.testNode(nodeTest)).thenReturn(true); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(parentContext, includeSelf, nodeTest); [EOL] yourObjectUnderTest.setStarted(true); [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, yourObjectUnderTest.getPosition()); [EOL] }
public void testNextNode_AfterSetStarted_NodeTestFails_ParentIsNull() { [EOL] boolean includeSelf = true; [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(nodeTest.testNode(any())).thenReturn(false); [EOL] Context parentContext = mock(Context.class); [EOL] NodePointer currentNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer); [EOL] when(currentNodePointer.getImmediateParentPointer()).thenReturn(null); [EOL] YourClassUnderTest yourObjectUnderTest = new YourClassUnderTest(parentContext, includeSelf, nodeTest); [EOL] yourObjectUnderTest.setStarted(true); [EOL] boolean result = yourObjectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] assertEquals(0, yourObjectUnderTest.getPosition()); [EOL] }
public boolean nextNode() { [EOL] if (!setStarted) { [EOL] setStarted = true; [EOL] currentRootLocation = parentContext.getCurrentNodePointer(); [EOL] NodePointer parent = currentRootLocation.getParent(); [EOL] if (parent != null) { [EOL] stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL] } [EOL] } [EOL] while (true) { [EOL] if (stack.isEmpty()) { [EOL] currentRootLocation = currentRootLocation.getParent(); [EOL] if (currentRootLocation == null || currentRootLocation.isRoot()) { [EOL] break; [EOL] } [EOL] NodePointer parent = currentRootLocation.getParent(); [EOL] if (parent != null) { [EOL] stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL] } [EOL] } [EOL] while (!stack.isEmpty()) { [EOL] if (!reverse) { [EOL] NodeIterator it = (NodeIterator) stack.peek(); [EOL] if (it.setPosition(it.getPosition() + 1)) { [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (!currentNodePointer.isLeaf()) { [EOL] stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL] } [EOL] if (currentNodePointer.testNode(nodeTest)) { [EOL] super.setPosition(getCurrentPosition() + 1); [EOL] return true; [EOL] } [EOL] } else { [EOL] stack.pop(); [EOL] } [EOL] } else { [EOL] NodeIterator it = (NodeIterator) stack.peek(); [EOL] if (it.setPosition(it.getPosition() + 1)) { [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (!currentNodePointer.isLeaf()) { [EOL] stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL] } else if (currentNodePointer.testNode(nodeTest)) { [EOL] super.setPosition(getCurrentPosition() + 1); [EOL] return true; [EOL] } [EOL] } else { [EOL] stack.pop(); [EOL] if (!stack.isEmpty()) { [EOL] it = (PropertyIterator) stack.peek(); [EOL] currentNodePointer = it.getNodePointer(); [EOL] if (currentNodePointer.testNode(nodeTest)) { [EOL] super.setPosition(getCurrentPosition() + 1); [EOL] return true; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] return false; [EOL] }
public void testLocationPathWithAbsoluteTrueAndNonNullSteps() { [EOL] Step[] steps = new Step[] { new Step(Step.AXIS_CHILD, "test", null) }; [EOL] LocationPath locationPath = new LocationPath(true, steps); [EOL] assertTrue(locationPath.isAbsolute()); [EOL] assertNotNull(locationPath.getSteps()); [EOL] assertEquals("test", locationPath.getSteps()[0].getNodeTest()); [EOL] }
public void testLocationPathWithAbsoluteFalseAndEmptySteps() { [EOL] Step[] steps = new Step[0]; [EOL] LocationPath locationPath = new LocationPath(false, steps); [EOL] assertFalse(locationPath.isAbsolute()); [EOL] assertEquals(0, locationPath.getSteps().length); [EOL] }
public void testToStringWithNoSteps() { [EOL] JXPath jxPath = new JXPath(false); // false indicates 'absolute' is false [EOL] String result = jxPath.toString(); [EOL] assertEquals("", result); [EOL] } [EOL] public void testToStringWithEmptySteps() { [EOL] JXPath jxPath = new JXPath(false); [EOL] Step[] emptySteps = new Step[0]; [EOL] jxPath.setSteps(emptySteps); [EOL] String result = jxPath.toString(); [EOL] assertEquals("", result); [EOL] } [EOL] public void testToStringWithSingleStep() { [EOL] JXPath jxPath = new JXPath(false); [EOL] Step[] steps = new Step[]{new Step("step1")}; [EOL] jxPath.setSteps(steps); [EOL] String result = jxPath.toString(); [EOL] assertEquals("step1", result); [EOL] } [EOL] public void testToStringWithMultipleSteps() { [EOL] JXPath jxPath = new JXPath(false); [EOL] Step[] steps = new Step[]{new Step("step1"), new Step("step2")}; [EOL] jxPath.setSteps(steps); [EOL] String result = jxPath.toString(); [EOL] assertEquals("step1/step2", result); [EOL] } [EOL] public void testToStringWithAbsoluteTrue() { [EOL] JXPath jxPath = new JXPath(true); [EOL] Step[] steps = new Step[]{new Step("step1"), new Step("step2")}; [EOL] jxPath.setSteps(steps); [EOL] String result = jxPath.toString(); [EOL] assertEquals("/step1/step2", result); [EOL] }
public void testComputeValueWithAbsoluteContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext rootContext = mock(EvalContext.class); [EOL] EvalContext absoluteRootContext = mock(EvalContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getAbsoluteRootContext()).thenReturn(absoluteRootContext); [EOL] when(absoluteRootContext.isAbsolute()).thenReturn(true); [EOL] Object expectedValue = new Object(); [EOL] JXPathContext jxPath = new JXPathContext(); [EOL] jxPath.setSingleNodePointerForSteps(expectedValue); [EOL] Object result = jxPath.computeValue(context); [EOL] assertEquals("Expected the result to be the value set for single node pointer for steps", expectedValue, result); [EOL] }
public void testComputeValueWithRelativeContext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.isAbsolute()).thenReturn(false); [EOL] Object expectedValue = new Object(); [EOL] JXPathContext jxPath = new JXPathContext(); [EOL] jxPath.setSingleNodePointerForSteps(expectedValue); [EOL] Object result = jxPath.computeValue(context); [EOL] assertEquals("Expected the result to be the value set for single node pointer for steps", expectedValue, result); [EOL] }
public void testLiteralWithNonNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Object result = context.literal("testValue"); [EOL] assertTrue(result instanceof Constant); [EOL] assertEquals("testValue", ((Constant) result).computeValue(null)); [EOL] }
public void testLiteralWithNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Object result = context.literal(null); [EOL] assertTrue(result instanceof Constant); [EOL] assertNull(((Constant) result).computeValue(null)); [EOL] }
public void testMultiplyWithValidExpressions() { [EOL] Expression left = new DefaultExpression("2"); [EOL] Expression right = new DefaultExpression("3"); [EOL] Object result = multiply(left, right); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreOperationMultiply); [EOL] CoreOperationMultiply multiplyResult = (CoreOperationMultiply) result; [EOL] assertEquals(left, multiplyResult.getLeft()); [EOL] assertEquals(right, multiplyResult.getRight()); [EOL] }
public void testMinusWithNullArgument() { [EOL] try { [EOL] Object result = minus(null); [EOL] assertNull("Result should be null when argument is null", result); [EOL] } catch (Exception e) { [EOL] fail("No exception should be thrown for null argument"); [EOL] } [EOL] }
public void testMinusWithValidExpressionArgument() { [EOL] Expression mockExpression = mock(Expression.class); [EOL] Object result = minus(mockExpression); [EOL] assertNotNull("Result should not be null when argument is a valid Expression", result); [EOL] assertTrue("Result should be an instance of CoreOperationNegate", result instanceof CoreOperationNegate); [EOL] assertEquals("The argument of CoreOperationNegate should be the mockExpression", mockExpression, ((CoreOperationNegate) result).getArgument(0)); [EOL] }
public void testFunctionWithValidCodeAndArgs() { [EOL] int code = 1; [EOL] Object[] args = new Object[] { "arg1", "arg2" }; [EOL] Object result = function(code, args); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreFunction); [EOL] CoreFunction coreFunction = (CoreFunction) result; [EOL] assertEquals(code, coreFunction.getCode()); [EOL] Expression[] expressions = coreFunction.getArguments(); [EOL] assertEquals(args.length, expressions.length); [EOL] for (int i = 0; i < args.length; i++) { [EOL] assertEquals(args[i], expressions[i].computeValue(null)); [EOL] } [EOL] }
public void testFunctionWithEmptyArgs() { [EOL] int code = 1; [EOL] Object[] args = new Object[] {}; [EOL] Object result = function(code, args); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreFunction); [EOL] CoreFunction coreFunction = (CoreFunction) result; [EOL] assertEquals(code, coreFunction.getCode()); [EOL] Expression[] expressions = coreFunction.getArguments(); [EOL] assertEquals(0, expressions.length); [EOL] }
public void testFunctionWithNullArgs() { [EOL] int code = 1; [EOL] Object result = function(code, null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CoreFunction); [EOL] CoreFunction coreFunction = (CoreFunction) result; [EOL] assertEquals(code, coreFunction.getCode()); [EOL] Expression[] expressions = coreFunction.getArguments(); [EOL] assertNull(expressions); [EOL] }
public Object union(Object[] arguments) { [EOL] return new CoreOperationUnion(toExpressionArray(arguments)); [EOL] }
public void testLocationPathWithAbsoluteTrue() { [EOL] boolean absolute = true; [EOL] Object[] steps = new Object[] { /* steps initialization */ }; [EOL] Object result = locationPath(absolute, steps); [EOL] assertTrue(result instanceof LocationPath); [EOL] LocationPath locationPathResult = (LocationPath) result; [EOL] assertTrue(locationPathResult.isAbsolute()); [EOL] assertEquals(steps.length, locationPathResult.getSteps().length); [EOL] }
public void testLocationPathWithAbsoluteFalse() { [EOL] boolean absolute = false; [EOL] Object[] steps = new Object[] { /* steps initialization */ }; [EOL] Object result = locationPath(absolute, steps); [EOL] assertTrue(result instanceof LocationPath); [EOL] LocationPath locationPathResult = (LocationPath) result; [EOL] assertFalse(locationPathResult.isAbsolute()); [EOL] assertEquals(steps.length, locationPathResult.getSteps().length); [EOL] }
public Object processingInstructionTest(String instruction) { [EOL] return new ProcessingInstructionTest(instruction); [EOL] }
public void testIsNameAttributeTest_NotInstanceOfLocationPath() { [EOL] Expression arg = mock(Expression.class); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_StepsNotEqualOne() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] when(arg.getSteps()).thenReturn(new Step[2]); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_AxisNotAttribute() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NotInstanceOfNodeNameTest() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeTest); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_NodeNameNotEqualQNameName() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(new QName("differentName")); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertFalse(result); [EOL] }
public void testIsNameAttributeTest_ValidCase() { [EOL] LocationPath arg = mock(LocationPath.class); [EOL] Step[] steps = new Step[] { mock(Step.class) }; [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(arg.getSteps()).thenReturn(steps); [EOL] when(steps[0].getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(steps[0].getNodeTest()).thenReturn(nodeNameTest); [EOL] when(nodeNameTest.getNodeName()).thenReturn(QNAME_NAME); [EOL] boolean result = isNameAttributeTest(arg); [EOL] assertTrue(result); [EOL] }
public void testExpressionPathWithNonNullValues() { [EOL] Expression mockExpression = mock(Expression.class); [EOL] Expression[] mockPredicates = new Expression[]{mock(Expression.class)}; [EOL] Step[] mockSteps = new Step[]{mock(Step.class)}; [EOL] ExpressionPath expressionPath = new ExpressionPath(mockExpression, mockPredicates, mockSteps); [EOL] assertNotNull(expressionPath); [EOL] }
public void testExpressionPathWithNullValues() { [EOL] ExpressionPath expressionPath = new ExpressionPath(null, null, null); [EOL] assertNotNull(expressionPath); [EOL] }
public void testToStringWithCoreOperationExpression() { [EOL] setupWithCoreOperationExpression(); [EOL] String result = instance.toString(); [EOL] assertTrue("Result should start with '(' and end with ')'", result.startsWith("(") && result.endsWith(")")); [EOL] } [EOL] public void testToStringWithExpressionPath() { [EOL] setupWithExpressionPath(); [EOL] String result = instance.toString(); [EOL] assertTrue("Result should start with '(' and end with ')'", result.startsWith("(") && result.endsWith(")")); [EOL] } [EOL] public void testToStringWithLocationPath() { [EOL] setupWithLocationPath(); [EOL] String result = instance.toString(); [EOL] assertTrue("Result should start with '(' and end with ')'", result.startsWith("(") && result.endsWith(")")); [EOL] } [EOL] public void testToStringWithOtherExpression() { [EOL] setupWithOtherExpression(); [EOL] String result = instance.toString(); [EOL] assertFalse("Result should not contain '(' or ')'", result.contains("(") || result.contains(")")); [EOL] } [EOL] public void testToStringWithPredicates() { [EOL] setupWithPredicates(); [EOL] String result = instance.toString(); [EOL] assertTrue("Result should contain predicates formatted with square brackets", result.matches(".*\\[.*\\].*")); [EOL] } [EOL] public void testToStringWithSteps() { [EOL] setupWithSteps(); [EOL] String result = instance.toString(); [EOL] assertTrue("Result should contain steps formatted with slashes", result.matches(".*/.*/.*")); [EOL] } [EOL] public void testToStringWithNoPredicatesOrSteps() { [EOL] setupWithNoPredicatesOrSteps(); [EOL] String result = instance.toString(); [EOL] assertFalse("Result should not contain square brackets or slashes", result.contains("[") || result.contains("]") || result.contains("/")); [EOL] }
public void testGetPropertyNamesWithClassProperty() { [EOL] DynaBean dynaBean = createMockDynaBeanWithClassProperty(); [EOL] String[] result = dynaBean.getPropertyNames(); [EOL] for (String propertyName : result) { [EOL] assertNotEquals("class", propertyName); [EOL] } [EOL] } [EOL] public void testGetPropertyNamesWithoutClassProperty() { [EOL] DynaBean dynaBean = createMockDynaBeanWithoutClassProperty(); [EOL] String[] result = dynaBean.getPropertyNames(); [EOL] String[] expectedProperties = getExpectedPropertiesWithoutClass(); [EOL] assertArrayEquals(expectedProperties, result); [EOL] }
public void testGetPropertyNamesWhenNamesNotNull() { [EOL] DynaBean dynaBean = createMockDynaBeanWithInitializedNames(); [EOL] String[] result = dynaBean.getPropertyNames(); [EOL] String[] expectedNames = getPreInitializedNames(); [EOL] assertSame(expectedNames, result); [EOL] }
public void testGetPropertyIndexWhenUnspecified() { [EOL] this.propertyIndex = UNSPECIFIED_PROPERTY; [EOL] this.name = "testName"; [EOL] String[] mockNames = {"otherName", "testName"}; [EOL] int result = getPropertyIndex(); [EOL] assertEquals("The property index should be updated to the index of 'testName'", 1, result); [EOL] assertNull("The name field should be set to null after finding the property index", name); [EOL] }
public void testGetPropertyIndexWhenSpecified() { [EOL] this.propertyIndex = 2; // Some specified index [EOL] this.name = "testName"; [EOL] int result = getPropertyIndex(); [EOL] assertEquals("The property index should be the one already specified", 2, result); [EOL] }
public void testGetImmediateNodeWithWildcardName() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("*"); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithWholeCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("validPropertyName"); [EOL] jxPath.setIndex(JxPath.WHOLE_COLLECTION); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndValidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(validIndex); // validIndex should be a valid index within the bounds of the property [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAtIndex, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndInvalidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(invalidIndex); // invalidIndex should be out of bounds of the property [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndIllegalArgumentException() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(indexThatCausesIllegalArgumentException); // indexThatCausesIllegalArgumentException should cause IllegalArgumentException [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAfterException, result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndNonZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("nonIndexedPropertyName"); [EOL] jxPath.setIndex(nonZeroIndex); // nonZeroIndex should be any index other than 0 [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("nonIndexedPropertyName"); [EOL] jxPath.setIndex(0); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueForNonIndexedProperty, result); [EOL] }
public void testComputeValueLessThan() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression leftExpr = mock(Expression.class); [EOL] Expression rightExpr = mock(Expression.class); [EOL] when(leftExpr.computeValue(context)).thenReturn(5.0); [EOL] when(rightExpr.computeValue(context)).thenReturn(10.0); [EOL] Expression[] args = {leftExpr, rightExpr}; [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testComputeValueNotLessThan() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] Expression leftExpr = mock(Expression.class); [EOL] Expression rightExpr = mock(Expression.class); [EOL] when(leftExpr.computeValue(context)).thenReturn(10.0); [EOL] when(rightExpr.computeValue(context)).thenReturn(5.0); [EOL] Expression[] args = {leftExpr, rightExpr}; [EOL] Object result = computeValue(context); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testToStringWithAxisChild() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_CHILD); [EOL] when(nodeTest.toString()).thenReturn("testNode"); [EOL] when(getPredicates()).thenReturn(null); [EOL] String result = toString(); [EOL] assertEquals("testNode", result); [EOL] }
public void testToStringWithAxisAttribute() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_ATTRIBUTE); [EOL] when(nodeTest.toString()).thenReturn("testNode"); [EOL] when(getPredicates()).thenReturn(null); [EOL] String result = toString(); [EOL] assertEquals("@testNode", result); [EOL] }
public void testToStringWithAxisSelfAndNodeTypeNode() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_SELF); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] when(nodeTest).thenReturn(nodeTypeTest); [EOL] when(getPredicates()).thenReturn(null); [EOL] String result = toString(); [EOL] assertEquals(".", result); [EOL] }
public void testToStringWithAxisParentAndNodeTypeNode() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_PARENT); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] when(nodeTest).thenReturn(nodeTypeTest); [EOL] when(getPredicates()).thenReturn(null); [EOL] String result = toString(); [EOL] assertEquals("..", result); [EOL] }
public void testToStringWithAxisDescendantOrSelfAndNodeTypeNodeAndNoPredicates() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_DESCENDANT_OR_SELF); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] when(nodeTest).thenReturn(nodeTypeTest); [EOL] when(getPredicates()).thenReturn(new Expression[0]); [EOL] String result = toString(); [EOL] assertEquals("", result); [EOL] }
public void testToStringWithOtherAxis() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_FOLLOWING); // Assuming AXIS_FOLLOWING is a valid axis constant [EOL] when(axisToString(Compiler.AXIS_FOLLOWING)).thenReturn("following"); [EOL] when(nodeTest.toString()).thenReturn("testNode"); [EOL] when(getPredicates()).thenReturn(null); [EOL] String result = toString(); [EOL] assertEquals("following::testNode", result); [EOL] }
public void testToStringWithPredicates() { [EOL] when(getAxis()).thenReturn(Compiler.AXIS_FOLLOWING); [EOL] when(axisToString(Compiler.AXIS_FOLLOWING)).thenReturn("following"); [EOL] when(nodeTest.toString()).thenReturn("testNode"); [EOL] Expression predicateOne = mock(Expression.class); [EOL] Expression predicateTwo = mock(Expression.class); [EOL] when(predicateOne.toString()).thenReturn("predicate1"); [EOL] when(predicateTwo.toString()).thenReturn("predicate2"); [EOL] when(getPredicates()).thenReturn(new Expression[]{predicateOne, predicateTwo}); [EOL] String result = toString(); [EOL] assertEquals("following::testNode[predicate1][predicate2]", result); [EOL] }
public void testAxisToStringSelf() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_SELF); [EOL] assertEquals("self", result); [EOL] } [EOL] public void testAxisToStringChild() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_CHILD); [EOL] assertEquals("child", result); [EOL] } [EOL] public void testAxisToStringParent() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_PARENT); [EOL] assertEquals("parent", result); [EOL] } [EOL] public void testAxisToStringAncestor() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_ANCESTOR); [EOL] assertEquals("ancestor", result); [EOL] } [EOL] public void testAxisToStringAttribute() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_ATTRIBUTE); [EOL] assertEquals("attribute", result); [EOL] } [EOL] public void testAxisToStringNamespace() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_NAMESPACE); [EOL] assertEquals("namespace", result); [EOL] } [EOL] public void testAxisToStringPreceding() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_PRECEDING); [EOL] assertEquals("preceding", result); [EOL] } [EOL] public void testAxisToStringFollowing() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_FOLLOWING); [EOL] assertEquals("following", result); [EOL] } [EOL] public void testAxisToStringDescendant() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_DESCENDANT); [EOL] assertEquals("descendant", result); [EOL] } [EOL] public void testAxisToStringAncestorOrSelf() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_ANCESTOR_OR_SELF); [EOL] assertEquals("ancestor-or-self", result); [EOL] } [EOL] public void testAxisToStringFollowingSibling() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_FOLLOWING_SIBLING); [EOL] assertEquals("following-sibling", result); [EOL] } [EOL] public void testAxisToStringPrecedingSibling() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_PRECEDING_SIBLING); [EOL] assertEquals("preceding-sibling", result); [EOL] } [EOL] public void testAxisToStringDescendantOrSelf() { [EOL] String result = YourClass.axisToString(Compiler.AXIS_DESCENDANT_OR_SELF); [EOL] assertEquals("descendant-or-self", result); [EOL] } [EOL] public void testAxisToStringUnknown() { [EOL] String result = YourClass.axisToString(-1); [EOL] assertEquals("UNKNOWN", result); [EOL] }
public void testGetNamespaceURIWithNullPrefixAndNoPointerNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String prefix = null; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceURIWithValidPrefixAndNoPointerNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.registerNamespace("prefix", "http://example.com/"); [EOL] String prefix = "prefix"; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://example.com/", result); [EOL] }
public void testGetNamespaceURIWithNullPrefixAndPointerButNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Pointer pointer = mock(Pointer.class); [EOL] when(pointer.getNamespaceURI(null)).thenReturn("http://pointer.com/"); [EOL] context.setPointer(pointer); [EOL] String prefix = null; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://pointer.com/", result); [EOL] }
public void testGetNamespaceURIWithValidPrefixAndPointerButNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Pointer pointer = mock(Pointer.class); [EOL] when(pointer.getNamespaceURI("prefix")).thenReturn("http://pointer.com/"); [EOL] context.setPointer(pointer); [EOL] context.registerNamespace("prefix", "http://example.com/"); [EOL] String prefix = "prefix"; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://example.com/", result); [EOL] }
public void testGetNamespaceURIWithNullPrefixPointerAndParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] parentContext.registerNamespace("prefix", "http://parent.com/"); [EOL] JXPathContext context = JXPathContext.newContext(parentContext); [EOL] Pointer pointer = mock(Pointer.class); [EOL] when(pointer.getNamespaceURI(null)).thenReturn(null); [EOL] context.setPointer(pointer); [EOL] String prefix = null; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://parent.com/", result); [EOL] }
public void testGetNamespaceURIWithValidPrefixPointerAndParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] parentContext.registerNamespace("prefix", "http://parent.com/"); [EOL] JXPathContext context = JXPathContext.newContext(parentContext); [EOL] Pointer pointer = mock(Pointer.class); [EOL] when(pointer.getNamespaceURI("prefix")).thenReturn(null); [EOL] context.setPointer(pointer); [EOL] context.registerNamespace("prefix", "http://example.com/"); [EOL] String prefix = "prefix"; [EOL] String result = context.getNamespaceURI(prefix); [EOL] assertEquals("http://example.com/", result); [EOL] }
public void testGetPrefixWithNullReverseMapAndNonNullNamespaceIterator() { [EOL] setupWithNullReverseMapAndNonNullNamespaceIterator(); [EOL] String namespaceURI = "http://example.com/namespace"; [EOL] String expectedPrefix = "ex"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertEquals(expectedPrefix, actualPrefix); [EOL] }
public void testGetPrefixWithNullReverseMapAndNullNamespaceIterator() { [EOL] setupWithNullReverseMapAndNullNamespaceIterator(); [EOL] String namespaceURI = "http://example.com/namespace"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertNull(actualPrefix); [EOL] }
public void testGetPrefixWithNonNullReverseMap() { [EOL] setupWithNonNullReverseMap(); [EOL] String namespaceURI = "http://example.com/namespace"; [EOL] String expectedPrefix = "ex"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertEquals(expectedPrefix, actualPrefix); [EOL] }
public void testGetPrefixWithNullPrefixInReverseMap() { [EOL] setupWithNullPrefixInReverseMap(); [EOL] String namespaceURI = "http://example.com/namespace"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertNull(actualPrefix); [EOL] }
public void testGetPrefixWithParentNonNull() { [EOL] setupWithParentNonNull(); [EOL] String namespaceURI = "http://example.com/namespace"; [EOL] String expectedPrefix = "ex"; [EOL] String actualPrefix = instance.getPrefix(namespaceURI); [EOL] assertEquals(expectedPrefix, actualPrefix); [EOL] }
public void testSetIdentityManagerWithNonNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] IdentityManager idManager = new IdentityManager(); [EOL] context.setIdentityManager(idManager); [EOL] assertEquals("IdentityManager should be set", idManager, context.getIdentityManager()); [EOL] }
public void testSetIdentityManagerWithNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setIdentityManager(null); [EOL] assertNull("IdentityManager should be null", context.getIdentityManager()); [EOL] }
public void testGetIdentityManagerWithNonNullIdManager() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] IdentityManager expectedIdManager = new IdentityManager(); [EOL] context.setIdManager(expectedIdManager); [EOL] IdentityManager actualIdManager = context.getIdentityManager(); [EOL] assertEquals("Expected the non-null idManager to be returned", expectedIdManager, actualIdManager); [EOL] }
public void testGetIdentityManagerWithNullIdManagerAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] IdentityManager expectedIdManager = new IdentityManager(); [EOL] parentContext.setIdManager(expectedIdManager); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext, new Object()); [EOL] childContext.setIdManager(null); [EOL] IdentityManager actualIdManager = childContext.getIdentityManager(); [EOL] assertEquals("Expected the idManager from the parent context to be returned", expectedIdManager, actualIdManager); [EOL] }
public void testGetIdentityManagerWithNullIdManagerAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setIdManager(null); [EOL] context.setParentContext(null); [EOL] IdentityManager actualIdManager = context.getIdentityManager(); [EOL] assertNull("Expected null since both idManager and parentContext are null", actualIdManager); [EOL] }
public void testGetPointerByIDWithNonNullManager() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] IdentityManager manager = Mockito.mock(IdentityManager.class); [EOL] Pointer pointer = Mockito.mock(Pointer.class); [EOL] Mockito.when(manager.getPointerByID(context, "testID")).thenReturn(pointer); [EOL] Mockito.when(context.getIdentityManager()).thenReturn(manager); [EOL] Pointer result = context.getPointerByID("testID"); [EOL] assertNotNull(result); [EOL] assertEquals(pointer, result); [EOL] }
public void testGetPointerByIDWithNullManager() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Mockito.when(context.getIdentityManager()).thenReturn(null); [EOL] try { [EOL] context.getPointerByID("testID"); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Cannot find an element by ID - no IdentityManager has been specified", e.getMessage()); [EOL] } [EOL] }
public void testMethodFunctionWithAccessibleMethod() { [EOL] Method accessibleMethod = MyClass.class.getMethod("accessibleMethod", null); [EOL] MethodFunction methodFunction = new MethodFunction(accessibleMethod); [EOL] assertNotNull(methodFunction); [EOL] assertEquals(accessibleMethod, methodFunction.method); [EOL] } [EOL] public void testMethodFunctionWithInaccessibleMethod() { [EOL] Method inaccessibleMethod = MyClass.class.getDeclaredMethod("inaccessibleMethod", null); [EOL] MethodFunction methodFunction = new MethodFunction(inaccessibleMethod); [EOL] assertNotNull(methodFunction); [EOL] assertNotEquals(inaccessibleMethod, methodFunction.method); [EOL] assertTrue(Modifier.isPublic(methodFunction.method.getModifiers())); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL] try { [EOL] Object target; [EOL] Object[] args; [EOL] if (Modifier.isStatic(method.getModifiers())) { [EOL] target = null; [EOL] if (parameters == null) { [EOL] parameters = EMPTY_ARRAY; [EOL] } [EOL] int pi = 0; [EOL] Class[] types = method.getParameterTypes(); [EOL] if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL] pi = 1; [EOL] } [EOL] args = new Object[parameters.length + pi]; [EOL] if (pi == 1) { [EOL] args[0] = context; [EOL] } [EOL] for (int i = 0; i < parameters.length; i++) { [EOL] args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL] } [EOL] } else { [EOL] int pi = 0; [EOL] Class[] types = method.getParameterTypes(); [EOL] if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL] pi = 1; [EOL] } [EOL] target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); [EOL] args = new Object[parameters.length - 1 + pi]; [EOL] if (pi == 1) { [EOL] args[0] = context; [EOL] } [EOL] for (int i = 1; i < parameters.length; i++) { [EOL] args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); [EOL] } [EOL] } [EOL] return method.invoke(target, args); [EOL] } catch (Throwable ex) { [EOL] if (ex instanceof InvocationTargetException) { [EOL] ex = ((InvocationTargetException) ex).getTargetException(); [EOL] } [EOL] throw new JXPathInvalidAccessException("Cannot invoke " + method, ex); [EOL] } [EOL] }
public void testBeanAttributeIteratorWithNullPrefixAndNullName() { [EOL] QName name = new QName(null, null); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertFalse(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithNullPrefixAndWildcardName() { [EOL] QName name = new QName(null, "*"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertFalse(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithXmlPrefixAndLangName() { [EOL] QName name = new QName("xml", "lang"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertTrue(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithXmlPrefixAndWildcardName() { [EOL] QName name = new QName("xml", "*"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertTrue(iterator.includeXmlLang); [EOL] }
public void testBeanAttributeIteratorWithNonXmlPrefixAndNonLangName() { [EOL] QName name = new QName("nonXml", "nonLang"); [EOL] PropertyOwnerPointer parent = mock(PropertyOwnerPointer.class); [EOL] BeanAttributeIterator iterator = new BeanAttributeIterator(parent, name); [EOL] assertFalse(iterator.includeXmlLang); [EOL] }
public void testGetNodePointer_IncludeXmlLangTrue_PositionOne() { [EOL] YourTestClass instance = new YourTestClass(); [EOL] instance.includeXmlLang = true; [EOL] instance.position = 1; [EOL] instance.parent = new ParentClass(); // Assuming ParentClass exists and is appropriate [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertTrue(result instanceof LangAttributePointer); [EOL] }
public void testGetNodePointer_IncludeXmlLangFalse() { [EOL] YourTestClass instance = new YourTestClass(); [EOL] instance.includeXmlLang = false; [EOL] instance.position = 1; // or any other value that is not relevant when includeXmlLang is false [EOL] instance.parent = new ParentClass(); // Assuming ParentClass exists and is appropriate [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertTrue(result instanceof ExpectedSuperClassNodePointer); [EOL] }
public void testGetNodePointer_IncludeXmlLangTrue_NotPositionOne() { [EOL] YourTestClass instance = new YourTestClass(); [EOL] instance.includeXmlLang = true; [EOL] instance.position = 2; // Any value other than 1 [EOL] instance.parent = new ParentClass(); // Assuming ParentClass exists and is appropriate [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertTrue(result instanceof ExpectedSuperClassNodePointer); [EOL] }
public void testSetPositionWithIncludeXmlLangTrueAndPositionOne() { [EOL] instance.includeXmlLang = true; [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue("setPosition should return true when includeXmlLang is true and position is 1", result); [EOL] }
public void testSetPositionWithIncludeXmlLangTrueAndPositionNotOne() { [EOL] instance.includeXmlLang = true; [EOL] boolean result = instance.setPosition(2); [EOL] assertTrue("setPosition should return true when includeXmlLang is true and position is not 1", result); [EOL] }
public void testSetPositionWithIncludeXmlLangFalse() { [EOL] instance.includeXmlLang = false; [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue("setPosition should return true when includeXmlLang is false", result); [EOL] }
public void testSearchForPathWithNonNullPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testSearchForPathWithNullPointerAndSimpleSteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(false); [EOL] steps = new Step[] { /* steps setup with simple steps */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithComplexStep() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(false); [EOL] steps = new Step[] { /* steps setup with at least one complex step */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialPointerAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer partialPointer = mock(Pointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(true).thenReturn(true); // hasNext returns true twice [EOL] when(context.next()).thenReturn(partialPointer); [EOL] steps = new Step[] { /* steps setup with simple steps */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialNodePointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] NodePointer partialNodePointer = mock(NodePointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(true).thenReturn(false); // hasNext returns true once [EOL] when(context.next()).thenReturn(partialNodePointer); [EOL] steps = new Step[] { /* steps setup with simple steps */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] }
private EvalContext buildContextChain(EvalContext context, int stepCount, boolean createInitialContext) { [EOL] if (createInitialContext) { [EOL] context = new InitialContext(context); [EOL] } [EOL] if (steps.length == 0) { [EOL] return context; [EOL] } [EOL] for (int i = 0; i < stepCount; i++) { [EOL] context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest()); [EOL] Expression[] predicates = steps[i].getPredicates(); [EOL] if (predicates != null) { [EOL] for (int j = 0; j < predicates.length; j++) { [EOL] if (j != 0) { [EOL] context = new UnionContext(context, new EvalContext[] { context }); [EOL] } [EOL] context = new PredicateContext(context, predicates[j]); [EOL] } [EOL] } [EOL] } [EOL] return context; [EOL] }
public void testCreateContextForStepWithNodeNameTestAndNonNullNamespace() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] JXPathContext mockJXPathContext = mock(JXPathContext.class); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName qname = new QName("prefix", "localName"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(qname); [EOL] when(mockContext.getJXPathContext()).thenReturn(mockJXPathContext); [EOL] when(mockJXPathContext.getNamespaceURI("prefix")).thenReturn("namespaceURI"); [EOL] EvalContext result = createContextForStep(mockContext, Compiler.AXIS_CHILD, nodeNameTest); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ChildContext); [EOL] }
public void testCreateContextForStepWithNodeNameTestAndNullNamespace() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] JXPathContext mockJXPathContext = mock(JXPathContext.class); [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName qname = new QName("prefix", "localName"); [EOL] when(nodeNameTest.getNodeName()).thenReturn(qname); [EOL] when(mockContext.getJXPathContext()).thenReturn(mockJXPathContext); [EOL] when(mockJXPathContext.getNamespaceURI("prefix")).thenReturn(null); [EOL] when(mockJXPathContext.getDefaultNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] EvalContext result = createContextForStep(mockContext, Compiler.AXIS_CHILD, nodeNameTest); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ChildContext); [EOL] }
public void testCreateContextForStepWithNonNodeNameTest() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] EvalContext result = createContextForStep(mockContext, Compiler.AXIS_CHILD, nodeTest); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ChildContext); [EOL] }
public void testCreateContextForStepWithDifferentAxis() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] EvalContext resultAncestor = createContextForStep(mockContext, Compiler.AXIS_ANCESTOR, nodeTest); [EOL] EvalContext resultAncestorOrSelf = createContextForStep(mockContext, Compiler.AXIS_ANCESTOR_OR_SELF, nodeTest); [EOL] EvalContext resultAttribute = createContextForStep(mockContext, Compiler.AXIS_ATTRIBUTE, nodeTest); [EOL] assertTrue(resultAncestor instanceof AncestorContext); [EOL] assertTrue(resultAncestorOrSelf instanceof AncestorContext); [EOL] assertTrue(resultAttribute instanceof AttributeContext); [EOL] }
public void testCreateContextForStepWithInvalidAxis() { [EOL] EvalContext mockContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] EvalContext result = createContextForStep(mockContext, -1, nodeTest); [EOL] assertNull(result); [EOL] }
public void testVariablePointerWithName() { [EOL] QName testName = new QName("testNamespace", "testLocalPart"); [EOL] VariablePointer variablePointer = new VariablePointer(testName); [EOL] assertNotNull(variablePointer); [EOL] assertEquals("testNamespace", variablePointer.getName().getNamespaceURI()); [EOL] assertEquals("testLocalPart", variablePointer.getName().getLocalPart()); [EOL] assertFalse(variablePointer.isActual()); [EOL] }
public void testCreatePathWithActualTrue() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NodePointer testNodePointer = new TestNodePointer(true); [EOL] NodePointer result = testNodePointer.createPath(context); [EOL] assertSame("Expected the same NodePointer instance when 'actual' is true", testNodePointer, result); [EOL] }
public void testCreatePathWithActualFalseAndFactoryDeclaresVariable() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NodePointer testNodePointer = new TestNodePointer(false); [EOL] AbstractFactory factory = new TestAbstractFactory(true); [EOL] testNodePointer.setAbstractFactory(factory); [EOL] NodePointer result = testNodePointer.createPath(context); [EOL] assertSame("Expected the same NodePointer instance when factory declares the variable", testNodePointer, result); [EOL] }
public void testCreatePathWithActualFalseAndFactoryDoesNotDeclareVariable() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NodePointer testNodePointer = new TestNodePointer(false); [EOL] AbstractFactory factory = new TestAbstractFactory(false); [EOL] testNodePointer.setAbstractFactory(factory); [EOL] try { [EOL] testNodePointer.createPath(context); [EOL] fail("Expected JXPathAbstractFactoryException when factory cannot declare variable"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] assertEquals("Expected correct exception message", [EOL] "Factory cannot define variable '" + testNodePointer.getName() + "' for path: " + testNodePointer.asPath(), [EOL] e.getMessage()); [EOL] } [EOL] }
public void testCreateChildWithNonActualPointerAndNonZeroIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] int index = 1; // Non-zero index [EOL] NodePointer testPointer = mock(NodePointer.class); [EOL] when(testPointer.isActual()).thenReturn(false); [EOL] when(testPointer.createCollection(context, index)).thenReturn(new Object()); [EOL] when(testPointer.getName()).thenReturn(name); [EOL] AbstractFactory factory = mock(AbstractFactory.class); [EOL] when(testPointer.getAbstractFactory(context)).thenReturn(factory); [EOL] when(factory.createObject(context, testPointer, new Object(), name.toString(), index)).thenReturn(false); [EOL] try { [EOL] testPointer.createChild(context, name, index); [EOL] fail("Expected JXPathAbstractFactoryException"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] } [EOL] }
public void testCreateChildWithActualPointerAndZeroIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] int index = 0; // Zero index [EOL] NodePointer testPointer = mock(NodePointer.class); [EOL] when(testPointer.isActual()).thenReturn(true); [EOL] when(testPointer.createCollection(context, index)).thenReturn(new Object()); [EOL] when(testPointer.getName()).thenReturn(name); [EOL] NodePointer result = testPointer.createChild(context, name, index); [EOL] assertSame("Expected the same NodePointer", testPointer, result); [EOL] }
public void testCreateChildWithActualPointerAndWholeCollectionIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] int index = NodePointer.WHOLE_COLLECTION; // WHOLE_COLLECTION index [EOL] NodePointer testPointer = mock(NodePointer.class); [EOL] when(testPointer.isActual()).thenReturn(true); [EOL] when(testPointer.createCollection(context, index)).thenReturn(new Object()); [EOL] when(testPointer.getName()).thenReturn(name); [EOL] NodePointer result = testPointer.createChild(context, name, index); [EOL] assertSame("Expected the same NodePointer", testPointer, result); [EOL] }
public void testCreateChildWithNonActualPointerAndZeroIndexSuccess() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] int index = 0; // Zero index [EOL] NodePointer testPointer = mock(NodePointer.class); [EOL] when(testPointer.isActual()).thenReturn(false); [EOL] when(testPointer.createCollection(context, index)).thenReturn(new Object()); [EOL] when(testPointer.getName()).thenReturn(name); [EOL] AbstractFactory factory = mock(AbstractFactory.class); [EOL] when(testPointer.getAbstractFactory(context)).thenReturn(factory); [EOL] when(factory.createObject(context, testPointer, new Object(), name.toString(), index)).thenReturn(true); [EOL] NodePointer clonedPointer = mock(NodePointer.class); [EOL] when(testPointer.clone()).thenReturn(clonedPointer); [EOL] NodePointer result = testPointer.createChild(context, name, index); [EOL] assertSame("Expected a clone of the NodePointer", clonedPointer, result); [EOL] verify(clonedPointer).setIndex(index); [EOL] }
public void testCreateChildWithValidIndexAndValue() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer testNodePointer = new TestNodePointer(); [EOL] NodePointer clonedNodePointer = (NodePointer) testNodePointer.clone(); [EOL] when(testNodePointer.createChild(context, name, index, value)).thenCallRealMethod(); [EOL] when(testNodePointer.createCollection(context, index)).thenReturn(new ArrayList<>()); [EOL] when(testNodePointer.clone()).thenReturn(clonedNodePointer); [EOL] NodePointer result = testNodePointer.createChild(context, name, index, value); [EOL] assertNotNull(result); [EOL] assertEquals(index, result.getIndex()); [EOL] assertEquals(clonedNodePointer, result); [EOL] }
public void testCreateChildWithInvalidIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] QName name = new QName("test"); [EOL] int index = -1; // Assuming that the createCollection method handles invalid index [EOL] Object value = new Object(); [EOL] NodePointer testNodePointer = new TestNodePointer(); [EOL] when(testNodePointer.createChild(context, name, index, value)).thenCallRealMethod(); [EOL] when(testNodePointer.createCollection(context, index)).thenReturn(null); // Assuming null is returned for invalid index [EOL] NodePointer result = testNodePointer.createChild(context, name, index, value); [EOL] assertNull(result); [EOL] }
public void testCreateCollectionWithNullBaseValue() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] when(getBaseValue()).thenReturn(null); [EOL] try { [EOL] createCollection(context, 1); [EOL] fail("JXPathAbstractFactoryException expected"); [EOL] } catch (JXPathAbstractFactoryException e) { [EOL] assertEquals("Factory did not assign a collection to variable '" + name + "' for path: " + asPath(), e.getMessage()); [EOL] } [EOL] }
public void testCreateCollectionWithNegativeIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] when(getBaseValue()).thenReturn(new Object()); [EOL] try { [EOL] createCollection(context, -1); [EOL] fail("JXPathInvalidAccessException expected"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] assertEquals("Index is less than 1: " + asPath(), e.getMessage()); [EOL] } [EOL] }
public void testCreateCollectionWithWholeCollectionIndex() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object expectedCollection = new Object(); [EOL] when(getBaseValue()).thenReturn(expectedCollection); [EOL] Object result = createCollection(context, WHOLE_COLLECTION); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testCreateCollectionWithIndexGreaterThanLength() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] Object baseValue = new Object(); [EOL] int index = 10; [EOL] when(getBaseValue()).thenReturn(baseValue); [EOL] when(getLength()).thenReturn(5); [EOL] Object expandedCollection = new Object(); [EOL] when(ValueUtils.expandCollection(baseValue, index + 1)).thenReturn(expandedCollection); [EOL] Object result = createCollection(context, index); [EOL] assertSame(expandedCollection, result); [EOL] verify(variables).declareVariable(name.toString(), expandedCollection); [EOL] }
public void testAsPathWithActualTrueAndIndexWholeCollection() { [EOL] final int WHOLE_COLLECTION = -1; // Example value, replace with the actual value from the codebase [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setActual(true); [EOL] context.setIndex(WHOLE_COLLECTION); [EOL] context.setName("testNode"); [EOL] String result = context.asPath(); [EOL] assertEquals("$testNode", result); [EOL] }
public void testAsPathWithActualFalseAndIndexNotWholeCollection() { [EOL] final int WHOLE_COLLECTION = -1; // Example value, replace with the actual value from the codebase [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setActual(false); [EOL] context.setIndex(1); // Any index that is not WHOLE_COLLECTION [EOL] context.setName("testNode"); [EOL] String result = context.asPath(); [EOL] assertEquals("$testNode[2]", result); [EOL] }
public void testAsPathWithActualTrueIndexNotWholeCollectionAndNodeNull() { [EOL] final int WHOLE_COLLECTION = -1; // Example value, replace with the actual value from the codebase [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setActual(true); [EOL] context.setIndex(1); // Any index that is not WHOLE_COLLECTION [EOL] context.setName("testNode"); [EOL] context.setNode(null); // Assuming getNode() can be set to null [EOL] String result = context.asPath(); [EOL] assertEquals("$testNode[2]", result); [EOL] }
public void testAsPathWithActualTrueIndexNotWholeCollectionAndIsCollectionTrue() { [EOL] final int WHOLE_COLLECTION = -1; // Example value, replace with the actual value from the codebase [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setActual(true); [EOL] context.setIndex(1); // Any index that is not WHOLE_COLLECTION [EOL] context.setName("testNode"); [EOL] context.setCollection(true); // Assuming isCollection() can be set to true [EOL] String result = context.asPath(); [EOL] assertEquals("$testNode[2]", result); [EOL] }
public void testAsPathWithActualTrueIndexWholeCollectionAndNodeNotNullAndIsCollectionFalse() { [EOL] final int WHOLE_COLLECTION = -1; // Example value, replace with the actual value from the codebase [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setActual(true); [EOL] context.setIndex(WHOLE_COLLECTION); [EOL] context.setName("testNode"); [EOL] context.setNode(new Object()); // Assuming getNode() can be set to a non-null value [EOL] context.setCollection(false); // Assuming isCollection() can be set to false [EOL] String result = context.asPath(); [EOL] assertEquals("$testNode", result); [EOL] }
public void testGetAbstractFactoryWithNonNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] AbstractFactory expectedFactory = new AbstractFactory() { [EOL] }; [EOL] context.setFactory(expectedFactory); [EOL] AbstractFactory actualFactory = getAbstractFactory(context); [EOL] assertEquals("Expected factory should be returned", expectedFactory, actualFactory); [EOL] }
public void testGetAbstractFactoryWithNullFactory() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFactory(null); [EOL] try { [EOL] getAbstractFactory(context); [EOL] fail("JXPathException should be thrown when factory is null"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Factory is not set on the JXPathContext - cannot create path: " + context.asPath(), e.getMessage()); [EOL] } [EOL] }
public void testNodeWithNullTest() { [EOL] boolean result = testNode(null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndContainer() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndNullNodeName() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(this.getName()).thenReturn(null); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndDifferentPrefixes() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testPrefix", "testName"); [EOL] QName nodeName = new QName("nodePrefix", "nodeName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.getNamespaceURI("testPrefix")).thenReturn("testNS"); [EOL] when(this.getNamespaceURI("nodePrefix")).thenReturn("nodeNS"); [EOL] when(this.equalStrings("testPrefix", "nodePrefix")).thenReturn(false); [EOL] when(this.equalStrings("testNS", "nodeNS")).thenReturn(false); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeNameTestAndWildcard() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.isWildcard()).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndEqualNames() { [EOL] NodeNameTest nodeNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testPrefix", "testName"); [EOL] QName nodeName = new QName("testPrefix", "testName"); [EOL] when(this.isContainer()).thenReturn(false); [EOL] when(nodeNameTest.getNodeName()).thenReturn(testName); [EOL] when(this.getName()).thenReturn(nodeName); [EOL] when(this.equalStrings("testPrefix", "testPrefix")).thenReturn(true); [EOL] boolean result = testNode(nodeNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestAndNodeTypeNode() { [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] when(this.isNode()).thenReturn(true); [EOL] boolean result = testNode(nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestAndNotNodeTypeNode() { [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_OTHER); [EOL] boolean result = testNode(nodeTypeTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithUnsupportedTestType() { [EOL] NodeTest test = mock(NodeTest.class); [EOL] boolean result = testNode(test); [EOL] assertFalse(result); [EOL] }
public void testGetLocale_WithNullLocaleAndNonNullParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext context = JXPathContext.newContext(parentContext); [EOL] Locale expectedLocale = Locale.ENGLISH; [EOL] parentContext.setLocale(expectedLocale); [EOL] Locale locale = context.getLocale(); [EOL] assertSame("Locale should be the same as parent's locale", expectedLocale, locale); [EOL] }
public void testGetLocale_WithNullLocaleAndNullParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(null); [EOL] Locale locale = context.getLocale(); [EOL] assertNull("Locale should be null when not set and no parent", locale); [EOL] }
public void testGetLocale_WithNonNullLocale() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Locale expectedLocale = Locale.ENGLISH; [EOL] context.setLocale(expectedLocale); [EOL] Locale locale = context.getLocale(); [EOL] assertSame("Locale should be the one that was set", expectedLocale, locale); [EOL] }
public void testIsLanguageWithMatchingLanguage() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "US")); [EOL] boolean result = context.isLanguage("en"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsLanguageWithNonMatchingLanguage() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "US")); [EOL] boolean result = context.isLanguage("fr"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLanguageWithDifferentCase() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "US")); [EOL] boolean result = context.isLanguage("EN"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsLanguageWithSubtag() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "GB")); [EOL] boolean result = context.isLanguage("en-GB"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsLanguageWithNonMatchingSubtag() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "GB")); [EOL] boolean result = context.isLanguage("en-US"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLanguageWithEmptyString() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "US")); [EOL] boolean result = context.isLanguage(""); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLanguageWithNull() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLocale(new Locale("en", "US")); [EOL] boolean result = context.isLanguage(null); [EOL] assertFalse(result); [EOL] }
public void testChildIteratorWithNonNullValuePointerAndDifferentFromThis() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeTest mockNodeTest = Mockito.mock(NodeTest.class); [EOL] NodePointer startWith = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getValuePointer()).thenReturn(mockNodePointer); [EOL] Mockito.when(mockNodePointer.childIterator(mockNodeTest, true, startWith)).thenReturn(Mockito.mock(NodeIterator.class)); [EOL] NodeIterator result = mockNodePointer.childIterator(mockNodeTest, true, startWith); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNullValuePointer() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeTest mockNodeTest = Mockito.mock(NodeTest.class); [EOL] NodePointer startWith = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getValuePointer()).thenReturn(null); [EOL] NodeIterator result = mockNodePointer.childIterator(mockNodeTest, false, startWith); [EOL] assertNull(result); [EOL] }
public void testChildIteratorWithValuePointerSameAsThis() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeTest mockNodeTest = Mockito.mock(NodeTest.class); [EOL] NodePointer startWith = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getValuePointer()).thenReturn(mockNodePointer); [EOL] NodeIterator result = mockNodePointer.childIterator(mockNodeTest, false, startWith); [EOL] assertNull(result); [EOL] }
public void testGetPointerByIDWithValidID() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String validID = "validID"; [EOL] Pointer pointer = new Pointer() { /* Mock implementation */ }; [EOL] context.getPointerByID(validID); // Assume this method is stubbed to return the mock pointer [EOL] Pointer result = getPointerByID(context, validID); [EOL] assertNotNull(result); [EOL] assertEquals(pointer, result); [EOL] }
public void testGetPointerByIDWithInvalidID() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String invalidID = "invalidID"; [EOL] context.getPointerByID(invalidID); // Assume this method is stubbed to return null [EOL] Pointer result = getPointerByID(context, invalidID); [EOL] assertNull(result); [EOL] }
public void testGetPointerByIDWithNullID() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Pointer result = getPointerByID(context, null); [EOL] assertNull(result); [EOL] }
public void testGetPointerByIDWithNullContext() { [EOL] try { [EOL] getPointerByID(null, "someID"); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAsPathWithParentContainer() { [EOL] Parent parentMock = mock(Parent.class); [EOL] when(parentMock.isContainer()).thenReturn(true); [EOL] when(parentMock.asPath()).thenReturn("/parentPath"); [EOL] MyClass instance = new MyClass(parentMock, false, "name", WHOLE_COLLECTION); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath", result); [EOL] }
public void testAsPathWithParentNonContainerNoAttributeNoCollection() { [EOL] Parent parentMock = mock(Parent.class); [EOL] when(parentMock.isContainer()).thenReturn(false); [EOL] when(parentMock.asPath()).thenReturn("/parentPath"); [EOL] MyClass instance = new MyClass(parentMock, false, "name", WHOLE_COLLECTION); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/name", result); [EOL] }
public void testAsPathWithParentNonContainerAttributeNoCollection() { [EOL] Parent parentMock = mock(Parent.class); [EOL] when(parentMock.isContainer()).thenReturn(false); [EOL] when(parentMock.asPath()).thenReturn("/parentPath"); [EOL] MyClass instance = new MyClass(parentMock, true, "name", WHOLE_COLLECTION); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/@name", result); [EOL] }
public void testAsPathWithParentNonContainerAttributeCollection() { [EOL] Parent parentMock = mock(Parent.class); [EOL] when(parentMock.isContainer()).thenReturn(false); [EOL] when(parentMock.asPath()).thenReturn("/parentPath"); [EOL] MyClass instance = new MyClass(parentMock, true, "name", 1); [EOL] when(instance.isCollection()).thenReturn(true); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parentPath/@name[2]", result); [EOL] }
public void testAsPathWithNoParentNoAttributeNoCollection() { [EOL] MyClass instance = new MyClass(null, false, "name", WHOLE_COLLECTION); [EOL] String result = instance.asPath(); [EOL] assertEquals("/name", result); [EOL] }
public void testAsPathWithNoParentAttributeNoCollection() { [EOL] MyClass instance = new MyClass(null, true, "name", WHOLE_COLLECTION); [EOL] String result = instance.asPath(); [EOL] assertEquals("/@name", result); [EOL] }
public void testAsPathWithNoParentAttributeCollection() { [EOL] MyClass instance = new MyClass(null, true, "name", 1); [EOL] when(instance.isCollection()).thenReturn(true); [EOL] String result = instance.asPath(); [EOL] assertEquals("/@name[2]", result); [EOL] }
public void testCollectionNodeIteratorWithNonNullValues() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] NodePointer mockStartWith = mock(NodePointer.class); [EOL] CollectionNodeIterator iterator = new CollectionNodeIterator(mockPointer, false, mockStartWith); [EOL] assertNotNull(iterator); [EOL] assertEquals(mockPointer, iterator.pointer); [EOL] assertFalse(iterator.reverse); [EOL] assertEquals(mockStartWith, iterator.startWith); [EOL] }
public void testCollectionNodeIteratorWithReverseTrue() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] NodePointer mockStartWith = mock(NodePointer.class); [EOL] CollectionNodeIterator iterator = new CollectionNodeIterator(mockPointer, true, mockStartWith); [EOL] assertNotNull(iterator); [EOL] assertEquals(mockPointer, iterator.pointer); [EOL] assertTrue(iterator.reverse); [EOL] assertEquals(mockStartWith, iterator.startWith); [EOL] }
public void testCollectionNodeIteratorWithNullStartWith() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] CollectionNodeIterator iterator = new CollectionNodeIterator(mockPointer, false, null); [EOL] assertNotNull(iterator); [EOL] assertEquals(mockPointer, iterator.pointer); [EOL] assertFalse(iterator.reverse); [EOL] assertNull(iterator.startWith); [EOL] }
public void testSetPositionBelowRange() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] boolean result = jxPath.setPosition(0); [EOL] assertFalse(result); [EOL] } [EOL] public void testSetPositionAboveRange() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.prepare(); // Assuming prepare() populates the collection [EOL] boolean result = jxPath.setPosition(jxPath.collection.size() + 1); [EOL] assertFalse(result); [EOL] } [EOL] public void testSetPositionWithinRange() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.prepare(); // Assuming prepare() populates the collection [EOL] boolean result = jxPath.setPosition(1); [EOL] assertTrue(result); [EOL] assertEquals(1, jxPath.position); [EOL] }
public void testSetPositionWithNullCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] boolean result = jxPath.setPosition(1); [EOL] assertTrue(result); [EOL] assertEquals(1, jxPath.position); [EOL] }
public void testGetNodePointerAtPositionZero() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 0; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointerAtPositivePosition() { [EOL] YourClass instance = new YourClass(); [EOL] instance.position = 1; // Assuming collection has at least one element [EOL] instance.collection = new ArrayList(); [EOL] NodePointer expectedPointer = new NodePointer(); [EOL] instance.collection.add(expectedPointer); [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertSame(expectedPointer, result); [EOL] }
public void testPrepareWithEmptyPointer() { [EOL] pointer = new NodePointerMock(); // Assuming NodePointerMock is a mock implementation of NodePointer [EOL] reverse = false; [EOL] startWith = null; [EOL] prepare(); [EOL] assertTrue("The collection should be empty", collection.isEmpty()); [EOL] }
public void testPrepareWithNonEmptyPointerNonReversed() { [EOL] pointer = new NodePointerMock(new NodeMock(), 2); // Assuming NodePointerMock is a mock implementation of NodePointer with a NodeMock that has 2 children [EOL] reverse = false; [EOL] startWith = null; [EOL] prepare(); [EOL] assertEquals("The collection should have 2 elements", 2, collection.size()); [EOL] }
public void testPrepareWithNonEmptyPointerReversed() { [EOL] pointer = new NodePointerMock(new NodeMock(), 2); // Assuming NodePointerMock is a mock implementation of NodePointer with a NodeMock that has 2 children [EOL] reverse = true; [EOL] startWith = null; [EOL] prepare(); [EOL] assertEquals("The collection should have 2 elements", 2, collection.size()); [EOL] assertEquals("The first element should be the last child", expectedLastChild, collection.get(0)); [EOL] }
public void testPrepareWithStartWithValid() { [EOL] pointer = new NodePointerMock(new NodeMock(), 3); // Assuming NodePointerMock is a mock implementation of NodePointer with a NodeMock that has 3 children [EOL] reverse = false; [EOL] NodePointerMock startWithMock = new NodePointerMock(); // Assuming NodePointerMock is a mock implementation of NodePointer [EOL] startWith = startWithMock; [EOL] collection.add(startWithMock); // Manually add the startWith pointer to the collection [EOL] prepare(); [EOL] assertEquals("The collection should have 1 element", 1, collection.size()); [EOL] assertTrue("The collection should contain the startWith element", collection.contains(startWith)); [EOL] }
public void testPrepareWithStartWithInvalid() { [EOL] pointer = new NodePointerMock(new NodeMock(), 3); // Assuming NodePointerMock is a mock implementation of NodePointer with a NodeMock that has 3 children [EOL] reverse = false; [EOL] startWith = new NodePointerMock(); // Assuming NodePointerMock is a mock implementation of NodePointer [EOL] try { [EOL] prepare(); [EOL] fail("An JXPathException should have been thrown"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetIndexedPropertyLengthWithReadMethod() { [EOL] Object object = new MyObjectWithReadMethod(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(MyObjectWithReadMethod.class.getMethod("getReadMethod")); [EOL] int length = MyClass.getIndexedPropertyLength(object, pd); [EOL] assertEquals("Expected length did not match", MyObjectWithReadMethod.EXPECTED_LENGTH, length); [EOL] }
public void testGetIndexedPropertyLengthWithIndexedReadMethod() { [EOL] Object object = new MyObjectWithIndexedReadMethod(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] when(pd.getIndexedReadMethod()).thenReturn(MyObjectWithIndexedReadMethod.class.getMethod("getIndexedReadMethod", int.class)); [EOL] int length = MyClass.getIndexedPropertyLength(object, pd); [EOL] assertEquals("Expected length did not match", MyObjectWithIndexedReadMethod.EXPECTED_LENGTH, length); [EOL] }
public void testGetIndexedPropertyLengthThrowsExceptionForNoReadMethod() { [EOL] Object object = new Object(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] when(pd.getIndexedReadMethod()).thenReturn(null); [EOL] try { [EOL] MyClass.getIndexedPropertyLength(object, pd); [EOL] fail("JXPathException expected for no read method"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetIndexedPropertyLengthThrowsExceptionForInvalidLength() { [EOL] Object object = new MyObjectWithInvalidLength(); [EOL] IndexedPropertyDescriptor pd = mock(IndexedPropertyDescriptor.class); [EOL] when(pd.getReadMethod()).thenReturn(null); [EOL] when(pd.getIndexedReadMethod()).thenReturn(MyObjectWithInvalidLength.class.getMethod("getIndexedReadMethod", int.class)); [EOL] try { [EOL] MyClass.getIndexedPropertyLength(object, pd); [EOL] fail("JXPathException expected for invalid length"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetLengthWithNull() { [EOL] int result = getLength(null); [EOL] assertEquals(0, result); [EOL] }
public void testGetLengthWithArray() { [EOL] int[] array = new int[] {1, 2, 3}; [EOL] int result = getLength(array); [EOL] assertEquals(3, result); [EOL] }
public void testGetLengthWithCollection() { [EOL] Collection<Integer> collection = new ArrayList<>(); [EOL] collection.add(1); [EOL] collection.add(2); [EOL] int result = getLength(collection); [EOL] assertEquals(2, result); [EOL] }
public void testGetLengthWithNonCollectionObject() { [EOL] Object obj = new Object(); [EOL] int result = getLength(obj); [EOL] assertEquals(1, result); [EOL] }
public void testExpandCollectionWithNull() { [EOL] Object result = JXPath.expandCollection(null, 10); [EOL] assertNull("Expanding a null collection should return null", result); [EOL] }
public void testExpandCollectionWithArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] int newSize = 5; [EOL] Object result = JXPath.expandCollection(array, newSize); [EOL] assertNotNull("Expanding an array should not return null", result); [EOL] assertTrue("Result should be an array", result.getClass().isArray()); [EOL] assertEquals("Expanded array length should match the specified size", newSize, Array.getLength(result)); [EOL] }
public void testExpandCollectionWithCollection() { [EOL] Collection<Integer> collection = new ArrayList<>(Arrays.asList(1, 2, 3)); [EOL] int newSize = 5; [EOL] Object result = JXPath.expandCollection(collection, newSize); [EOL] assertNotNull("Expanding a collection should not return null", result); [EOL] assertTrue("Result should be a Collection", result instanceof Collection); [EOL] assertEquals("Expanded collection size should match the specified size", newSize, ((Collection) result).size()); [EOL] }
public void testExpandCollectionWithInvalidType() { [EOL] try { [EOL] Object invalidType = new Object(); [EOL] JXPath.expandCollection(invalidType, 10); [EOL] fail("Expanding an object that is neither an array nor a collection should throw an exception"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetValueWithNonContainer() { [EOL] Object expected = new Object(); [EOL] Object actual = ClassName.getValue(expected); [EOL] assertSame(expected, actual); [EOL] }
public void testGetValueWithContainer() { [EOL] Container container = mock(Container.class); [EOL] Object innerValue = new Object(); [EOL] when(container.getValue()).thenReturn(innerValue); [EOL] Object actual = ClassName.getValue(container); [EOL] assertSame(innerValue, actual); [EOL] }
public void testGetValueWithNestedContainers() { [EOL] Container innerContainer = mock(Container.class); [EOL] Container outerContainer = mock(Container.class); [EOL] Object innerMostValue = new Object(); [EOL] when(innerContainer.getValue()).thenReturn(innerMostValue); [EOL] when(outerContainer.getValue()).thenReturn(innerContainer); [EOL] Object actual = ClassName.getValue(outerContainer); [EOL] assertSame(innerMostValue, actual); [EOL] }
public void testCreateNodePointerWithDocument() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate [EOL] Object bean = org.w3c.dom.Document; // Assuming this is a valid Document instance [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] }
public void testCreateNodePointerWithElement() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate [EOL] Object bean = org.w3c.dom.Element; // Assuming this is a valid Element instance [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] }
public void testCreateNodePointerWithOtherObject() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate [EOL] Object bean = new Object(); // A generic Object that is neither Document nor Element [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public void testIsContainer() { [EOL] Container container = new Container(); [EOL] boolean result = container.isContainer(); [EOL] assert result : "The method should return true"; [EOL] }
```java [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL] switch(pos) { [EOL] case 0: [EOL] if ((active1 & 0xc0000L) != 0L) [EOL] return 10; [EOL] if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 1: [EOL] if ((active0 & 0x8000008000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 1; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 2: [EOL] if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 2; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 3: [EOL] if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL] if (jjmatchedPos != 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 4: [EOL] if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 5: [EOL] if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL] if (jjmatchedPos != 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 6: [EOL] if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 6; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 7: [EOL] if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x802000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 8: [EOL] if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] if (jjmatchedPos != 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 9: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 10: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 10; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 11: [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 11; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 12: [EOL] if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 12; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 13: [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 13; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 14: [EOL] if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x1000f00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 14; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 15: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xf00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 16: [EOL] if ((active0 & 0xe00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 17: [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 18: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 18; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 19: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 19; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [
private final int jjStartNfaWithStates_0(int pos, int kind, int state) { [EOL] jjmatchedKind = kind; [EOL] jjmatchedPos = pos; [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] return pos + 1; [EOL] } [EOL] return jjMoveNfa_0(state, pos + 1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }];
private final int jjMoveStringLiteralDfa0_0() { [EOL] switch(curChar) { [EOL] case 33: [EOL] return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL] case 36: [EOL] return jjStopAtPos(0, 17); [EOL] case 40: [EOL] return jjStopAtPos(0, 80); [EOL] case 41: [EOL] return jjStopAtPos(0, 81); [EOL] case 42: [EOL] return jjStopAtPos(0, 88); [EOL] case 43: [EOL] return jjStopAtPos(0, 9); [EOL] case 44: [EOL] return jjStopAtPos(0, 87); [EOL] case 45: [EOL] return jjStopAtPos(0, 10); [EOL] case 46: [EOL] jjmatchedKind = 82; [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL] case 47: [EOL] jjmatchedKind = 6; [EOL] return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL] case 58: [EOL] return jjStopAtPos(0, 79); [EOL] case 60: [EOL] jjmatchedKind = 13; [EOL] return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL] case 61: [EOL] return jjStopAtPos(0, 11); [EOL] case 62: [EOL] jjmatchedKind = 15; [EOL] return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL] case 64: [EOL] return jjStopAtPos(0, 86); [EOL] case 91: [EOL] return jjStopAtPos(0, 84); [EOL] case 93: [EOL] return jjStopAtPos(0, 85); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL] case 107: [EOL] return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL] case 124: [EOL] return jjStopAtPos(0, 8); [EOL] default: [EOL] return jjMoveNfa_0(0, 0); [EOL] } [EOL] }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(0, active0, active1); [EOL] return 1; [EOL] } [EOL] switch(curChar) { [EOL] case 46: [EOL] if ((active1 & 0x80000L) != 0L) [EOL] return jjStopAtPos(1, 83); [EOL] break; [EOL] case 47: [EOL] if ((active0 & 0x80L) != 0L) [EOL] return jjStopAtPos(1, 7); [EOL] break; [EOL] case 61: [EOL] if ((active0 & 0x1000L) != 0L) [EOL] return jjStopAtPos(1, 12); [EOL] else if ((active0 & 0x4000L) != 0L) [EOL] return jjStopAtPos(1, 14); [EOL] else if ((active0 & 0x10000L) != 0L) [EOL] return jjStopAtPos(1, 16); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL] case 100: [EOL] if ((active0 & 0x8000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 51, 12); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL] case 104: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL] case 114: [EOL] if ((active0 & 0x8000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 27, 12); [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(0, active0, active1); [EOL] }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(0, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(1, active0, active1); [EOL] return 2; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL] case 100: [EOL] if ((active0 & 0x10000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 28, 12); [EOL] else if ((active0 & 0x20000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 29, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL] case 109: [EOL] if ((active1 & 0x200L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 73, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL] case 116: [EOL] if ((active1 & 0x8L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 67, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL] case 118: [EOL] if ((active0 & 0x40000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 30, 12); [EOL] break; [EOL] case 120: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL] case 121: [EOL] if ((active0 & 0x10000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 52, 12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(1, active0, active1); [EOL] }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(1, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(2, active0, active1); [EOL] return 3; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x80000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 31, 12); [EOL] else if ((active0 & 0x80000000000000L) != 0L) { [EOL] jjmatchedKind = 55; [EOL] jjmatchedPos = 3; [EOL] } else if ((active1 & 0x10L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 68, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x80L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 71, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL] case 108: [EOL] if ((active1 & 0x40L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 70, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL] case 116: [EOL] if ((active0 & 0x100000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 32, 12); [EOL] else if ((active0 & 0x1000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 48, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(2, active0, active1); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(3, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(4, active0, active1); [EOL] return 5; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x800000000L) != 0L) [EOL] return jjStopAtPos(5, 35); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active0 & 0x100000000000000L) != 0L) { [EOL] jjmatchedKind = 56; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x100L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 72, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 57, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(4, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(4, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(5, active0, active1); [EOL] return 6; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL] case 58: [EOL] if ((active0 & 0x1000000000L) != 0L) [EOL] return jjStopAtPos(6, 36); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x800L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 75, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL] case 110: [EOL] if ((active1 & 0x4L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 66, 12); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 33, 12); [EOL] break; [EOL] case 117: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); long[] jjbitVec0; long[] jjbitVec2; long[] jjbitVec3; long[] jjbitVec4; long[] jjbitVec5; long[] jjbitVec6; long[] jjbitVec7; long[] jjbitVec8; long[] jjbitVec9; long[] jjbitVec10; long[] jjbitVec11; long[] jjbitVec12; long[] jjbitVec13; long[] jjbitVec14; long[] jjbitVec15; long[] jjbitVec16; long[] jjbitVec17; long[] jjbitVec18; long[] jjbitVec19; long[] jjbitVec20; long[] jjbitVec21; long[] jjbitVec22; long[] jjbitVec23; long[] jjbitVec24; long[] jjbitVec25; long[] jjbitVec26; long[] jjbitVec27; long[] jjbitVec28; long[] jjbitVec29; long[] jjbitVec30; long[] jjbitVec31; long[] jjbitVec32; long[] jjbitVec33; long[] jjbitVec34; long[] jjbitVec35; long[] jjbitVec36; long[] jjbitVec37; long[] jjbitVec38; long[] jjbitVec39; long[] jjbitVec40; long[] jjbitVec41; int[] jjnextStates; String[] jjstrLiteralImages; String[] lexStateNames; long[] jjtoToken; long[] jjtoSkip;
```java [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(5, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(6, active0, active1); [EOL] return 7; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x2000000000L) != 0L) [EOL] return jjStopAtPos(7, 37); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 110: [EOL] if ((active0 & 0x2000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 49, 12); [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL] case 115: [EOL] if ((active0 & 0x800000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 59, 12); [EOL] break; [EOL] case 116: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 122: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\
```java [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(6, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(7, active0, active1); [EOL] return 8; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x2L) != 0L) [EOL] return jjStartNfaWithStates_0(8, 65, 12); [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL] case 103: [EOL] if ((active0 & 0x4000000000000000L) != 0L) { [EOL] jjmatchedKind = 62; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55
```java [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(7, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(8, active0, active1); [EOL] return 9; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL] case 58: [EOL] if ((active0 & 0x4000000000L) != 0L) [EOL] return jjStopAtPos(9, 38); [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(9, 53, 12); [EOL] break; [EOL] case 103: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\
```java [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(8, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(9, active0, active1); [EOL] return 10; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x8000000000L) != 0L) [EOL] return jjStopAtPos(10, 39); [EOL] else if ((active0 & 0x10000000000L) != 0L) [EOL] return jjStopAtPos(10, 40); [EOL] else if ((active0 & 0x20000000000L) != 0L) [EOL] return jjStopAtPos(10, 41); [EOL] else if ((active0 & 0x40000000000L) != 0L) [EOL] return jjStopAtPos(10, 42); [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(10, 58, 12); [EOL] break; [EOL] case 114: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(9, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163
```java [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(9, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(10, active0, active1); [EOL] return 11; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x80000000000L) != 0L) [EOL] return jjStopAtPos(11, 43); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(10, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\
```java [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(10, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(11, active0, active1); [EOL] return 12; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x8000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 63, 12); [EOL] break; [EOL] case 105: [EOL] if ((active0 & 0x40000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 54, 12); [EOL] break; [EOL] case 110: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x2000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 77, 12); [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(11, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\
```java [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(11, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(12, active0, active1); [EOL] return 13; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(12, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\
```java [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(12, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(13, active0, active1); [EOL] return 14; [EOL] } [EOL] switch(curChar) { [EOL] case 101: [EOL] if ((active1 & 0x1L) != 0L) [EOL] return jjStartNfaWithStates_0(14, 64, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active0 & 0x2000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(14, 61, 12); [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(13, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\
```java [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(13, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(14, active0, 0L); [EOL] return 15; [EOL] } [EOL] switch(curChar) { [EOL] case 101: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(15, 60, 12); [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(14, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\
```java [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(14, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(15, active0, 0L); [EOL] return 16; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(15, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154
```java [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(15, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(16, active0, 0L); [EOL] return 17; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x100000000000L) != 0L) [EOL] return jjStopAtPos(17, 44); [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(16, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156
```java [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(16, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(17, active0, 0L); [EOL] return 18; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x200000000000L) != 0L) [EOL] return jjStopAtPos(18, 45); [EOL] else if ((active0 & 0x400000000000L) != 0L) [EOL] return jjStopAtPos(18, 46); [EOL] return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(17, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147",
private final int jjMoveStringLiteralDfa19_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(17, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(18, active0, 0L); [EOL] return 19; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x800000000000L) != 0L) [EOL] return jjStopAtPos(19, 47); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa20_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(18, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); long[] jjbitVec0; long[] jjbitVec2; long[] jjbitVec3; long[] jjbitVec4; long[] jjbitVec5; long[] jjbitVec6; long[] jjbitVec7; long[] jjbitVec8; long[] jjbitVec9; long[] jjbitVec10; long[] jjbitVec11; long[] jjbitVec12; long[] jjbitVec13; long[] jjbitVec14; long[] jjbitVec15; long[] jjbitVec16; long[] jjbitVec17; long[] jjbitVec18; long[] jjbitVec19; long[] jjbitVec20; long[] jjbitVec21; long[] jjbitVec22; long[] jjbitVec23; long[] jjbitVec24; long[] jjbitVec25; long[] jjbitVec26; long[] jjbitVec27; long[] jjbitVec28; long[] jjbitVec29; long[] jjbitVec30; long[] jjbitVec31; long[] jjbitVec32; long[] jjbitVec33; long[] jjbitVec34; long[] jjbitVec35; long[] jjbitVec36; long[] jjbitVec37; long[] jjbitVec38; long[] jjbitVec39; long[] jjbitVec40; long[] jjbitVec41; int[] jjnextStates; String[] jjstrLiteralImages; String[] lexStateNames; long[] jjtoToken; long[] jjtoSkip;
private final int jjMoveStringLiteralDfa20_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(18, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(19, active0, 0L); [EOL] return 20; [EOL] } [EOL] switch(curChar) { [EOL] case 111: [EOL] return jjMoveStringLiteralDfa21_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(19, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); public final int jjMoveStringLiteralDfa16_0(long old0, long active0); public final int jjMoveStringLiteralDfa17_0(long old0, long active0); public final int jjMoveStringLiteralDfa18_0(long old0, long active0); public final int jjMoveStringLiteralDfa19_0(long old0, long active0); public final int jjMoveStringLiteralDfa20_0(long old0, long active0); public final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); long[] jjbitVec0; long[] jjbitVec2; long[] jjbitVec3; long[] jjbitVec4; long[] jjbitVec5; long[] jjbitVec6; long[] jjbitVec7; long[] jjbitVec8; long[] jjbitVec9; long[] jjbitVec10; long[] jjbitVec11; long[] jjbitVec12; long[] jjbitVec13; long[] jjbitVec14; long[] jjbitVec15; long[] jjbitVec16; long[] jjbitVec17; long[] jjbitVec18; long[] jjbitVec19; long[] jjbitVec20; long[] jjbitVec21; long[] jjbitVec22; long[] jjbitVec23; long[] jjbitVec24; long[] jjbitVec25; long[] jjbitVec26; long[] jjbitVec27; long[] jjbitVec28; long[] jjbitVec29; long[] jjbitVec30; long[] jjbitVec31; long[] jjbitVec32; long[] jjbitVec33; long[] jjbitVec34; long[] jjbitVec35; long[] jjbitVec36; long[] jjbitVec37; long[] jjbitVec38; long[] jjbitVec39; long[] jjbitVec40; long[] jjbitVec41; int[] jjnextStates; String[] jjstrLiteralImages; String[] lexStateNames; long[] jjtoToken; long[] jjtoSkip;
```java [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(19, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(20, active0, 0L); [EOL] return 21; [EOL] } [EOL] switch(curChar) { [EOL] case 110: [EOL] if ((active0 & 0x400000000L) != 0L) [EOL] return jjStartNfaWithStates_0(21, 34, 12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(20, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }
private final void jjAddStates(int start, int end) { [EOL] do { [EOL] jjstateSet[jjnewStateCnt++] = jjnextStates[start]; [EOL] } while (start++ != end); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "/", "//", "|", "+", "-", "=", "!=", "<", "<=", ">", ">=", ",", null, null, null, null, null, null, null, null, null, "or", "and", "mod", "div", "node", "text", "comment", "processing-instruction", "self::", "child::", "parent::", "ancestor::", "attribute::", "namespace::", "preceding::", "following::", "descendant::", "ancestor-or-self::", "following-sibling::", "preceding-sibling::", "descendant-or-self::", "last", "position", "count", "id", "key", "local-name", "namespace-uri", "name", "string", "concat", "starts-with", "contains", "substring-before", "substring-after", "substring", "string-length", "normalize-space", "translate", "boolean", "not", "true", "false", "null", "lang", "number", "sum", "floor", "ceiling", "round", "format-number", null, ":", "(", ")", ".", "..", "[", "]", "@", ",", "*" }; [EOL] String[] lexStateNames={ "DEFAULT" }; [EOL] long[] jjtoToken={ 0xfffffffff817ffc1L, 0x1ffffffL }; [EOL] long[] jjtoSkip={ 0x3eL, 0x0L };
private final int jjMoveNfa_0(int startState, int curPos) { [EOL] int[] nextStates; [EOL] int startsAt = 0; [EOL] jjnewStateCnt = 13; [EOL] int i = 1; [EOL] jjstateSet[0] = startState; [EOL] int j, kind = 0x7fffffff; [EOL] for (; ; ) { [EOL] if (++jjround == 0x7fffffff) [EOL] ReInitRounds(); [EOL] if (curChar < 64) { [EOL] long l = 1L << curChar; [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if ((0x3ff000000000000L & l) != 0L) { [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] } else if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] else if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] else if (curChar == 34) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 1: [EOL] if ((0xfffffffbffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 2: [EOL] if (curChar == 34 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 3: [EOL] if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 4: [EOL] if ((0xffffff7fffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 5: [EOL] if (curChar == 39 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 6: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] break; [EOL] case 7: [EOL] if (curChar != 46) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 8: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 9: [EOL] if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 10: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 12: [EOL] if ((0x3ff600000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjstateSet[jjnewStateCnt++] = 12; [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else if (curChar < 128) { [EOL] long l = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] case 12: [EOL] if ((0x7fffffe87fffffeL & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] jjAddStates(2, 3); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else { [EOL] int hiByte = (int) (curChar >> 8); [EOL] int i1 = hiByte >> 6; [EOL] long l1 = 1L << (hiByte & 077); [EOL] int i2 = (curChar & 0xff) >> 6; [EOL] long l2 = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(2, 3); [EOL] break; [EOL] case 12: [EOL] if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } [EOL] if (kind != 0x7fffffff) { [EOL] jjmatchedKind = kind; [EOL] jjmatchedPos = curPos; [EOL] kind = 0x7fffffff; [EOL] } [EOL] ++curPos; [EOL] if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL] return curPos; [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] return curPos; [EOL] } [EOL] } [EOL] }
public void testDOMNodePointerWithNonNullNodeAndLocaleAndId() { [EOL] Node node = mock(Node.class); [EOL] Locale locale = new Locale("en"); [EOL] String id = "testId"; [EOL] DOMNodePointer pointer = new DOMNodePointer(node, locale, id); [EOL] assertNotNull(pointer); [EOL] assertEquals(node, pointer.node); [EOL] assertEquals(locale, pointer.getLocale()); [EOL] assertEquals(id, pointer.id); [EOL] }
public void testDOMNodePointerWithNullNodeAndLocaleAndId() { [EOL] Locale locale = new Locale("en"); [EOL] String id = "testId"; [EOL] DOMNodePointer pointer = new DOMNodePointer(null, locale, id); [EOL] assertNotNull(pointer); [EOL] assertNull(pointer.node); [EOL] assertEquals(locale, pointer.getLocale()); [EOL] assertEquals(id, pointer.id); [EOL] }
public void testNodeWithNullTest() { [EOL] Node node = mock(Node.class); [EOL] boolean result = testNode(node, null); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] QName testName = new QName("testName"); [EOL] when(testNameTest.getNodeName()).thenReturn(testName); [EOL] when(testNameTest.isWildcard()).thenReturn(false); [EOL] when(testNameTest.getNamespaceURI()).thenReturn("testNamespace"); [EOL] when(DOMNodePointer.getLocalName(node)).thenReturn("testName"); [EOL] when(DOMNodePointer.getNamespaceURI(node)).thenReturn("testNamespace"); [EOL] boolean result = testNode(node, testNameTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeNameTestAndNonElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeNameTest testNameTest = mock(NodeNameTest.class); [EOL] boolean result = testNode(node, testNameTest); [EOL] assertFalse(result); [EOL] }
public void testNodeWithNodeTypeTestElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestDocumentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestTextNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestCommentNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.COMMENT_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithNodeTypeTestPINode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class); [EOL] when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_PI); [EOL] boolean result = testNode(node, nodeTypeTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithProcessingInstructionTest() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("testTarget"); [EOL] boolean result = testNode(node, piTest); [EOL] assertTrue(result); [EOL] }
public void testNodeWithMismatchedProcessingInstructionTest() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class); [EOL] when(piTest.getTarget()).thenReturn("testTarget"); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("differentTarget"); [EOL] boolean result = testNode(node, piTest); [EOL] assertFalse(result); [EOL] }
public void testGetNameForElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(DOMNodePointer.getPrefix(node)).thenReturn("namespace"); [EOL] when(DOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(node, null); [EOL] QName result = domNodePointer.getName(); [EOL] assertEquals("namespace", result.getNamespaceURI()); [EOL] assertEquals("localName", result.getLocalPart()); [EOL] }
public void testGetNameForProcessingInstructionNode() { [EOL] Node node = mock(ProcessingInstruction.class); [EOL] when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("target"); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(node, null); [EOL] QName result = domNodePointer.getName(); [EOL] assertNull(result.getNamespaceURI()); [EOL] assertEquals("target", result.getLocalPart()); [EOL] }
public void testGetNameForOtherNodeTypes() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] DOMNodePointer domNodePointer = new DOMNodePointer(node, null); [EOL] QName result = domNodePointer.getName(); [EOL] assertNull(result.getNamespaceURI()); [EOL] assertNull(result.getLocalPart()); [EOL] }
public void testGetNamespaceURIWithNullPrefix() { [EOL] String result = instance.getNamespaceURI(null); [EOL] assertEquals("Expected default namespace URI", expectedDefaultNamespaceURI, result); [EOL] } [EOL] public void testGetNamespaceURIWithEmptyPrefix() { [EOL] String result = instance.getNamespaceURI(""); [EOL] assertEquals("Expected default namespace URI", expectedDefaultNamespaceURI, result); [EOL] }
public void testGetNamespaceURIWithXMLPrefix() { [EOL] String result = instance.getNamespaceURI("xml"); [EOL] assertEquals("Expected XML namespace URI", XML_NAMESPACE_URI, result); [EOL] }
public void testGetNamespaceURIWithXMLNSPrefix() { [EOL] String result = instance.getNamespaceURI("xmlns"); [EOL] assertEquals("Expected XMLNS namespace URI", XMLNS_NAMESPACE_URI, result); [EOL] }
public void testGetNamespaceURINotPredefinedButPresent() { [EOL] String result = instance.getNamespaceURI("myPrefix"); [EOL] assertEquals("Expected namespace URI from map", "myNamespaceURI", result); [EOL] }
public void testGetNamespaceURINotPredefinedAndNotPresent() { [EOL] String result = instance.getNamespaceURI("unknownPrefix"); [EOL] assertEquals("Expected unknown namespace", NodePointer.UNKNOWN_NAMESPACE, result); [EOL] }
public void testGetNamespaceURIWithUnknownNamespace() { [EOL] String result = instance.getNamespaceURI("unknownPrefix"); [EOL] assertNull("Expected null for unknown namespace", result); [EOL] }
public void testGetLanguage_ElementNodeWithLangAttribute() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] Element element = mock(Element.class); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] when((Element) node).thenReturn(element); [EOL] when(element.getAttribute("xml:lang")).thenReturn("en"); [EOL] String language = getLanguage(); [EOL] assertEquals("en", language); [EOL] }
public void testGetLanguage_ElementNodeWithoutLangAttribute() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] Element element = mock(Element.class); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] when((Element) node).thenReturn(element); [EOL] when(element.getAttribute("xml:lang")).thenReturn(""); [EOL] String language = getLanguage(); [EOL] assertNull(language); [EOL] }
public void testGetLanguage_NonElementNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(node.getParentNode()).thenReturn(null); [EOL] String language = getLanguage(); [EOL] assertNull(language); [EOL] }
public void testGetLanguage_ElementNodeWithLangInParent() { [EOL] Node childNode = mock(Node.class); [EOL] Node parentNode = mock(Node.class); [EOL] when(childNode.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(parentNode.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(childNode.getParentNode()).thenReturn(parentNode); [EOL] when(parentNode.getParentNode()).thenReturn(null); [EOL] Element parentElement = mock(Element.class); [EOL] when((Element) parentNode).thenReturn(parentElement); [EOL] when(parentElement.getAttribute("xml:lang")).thenReturn("fr"); [EOL] String language = getLanguage(); [EOL] assertEquals("fr", language); [EOL] }
public void testAsPathWithNonNullId() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setId("testId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id('testId')", result); [EOL] }
public void testAsPathWithNullIdAndNonNullParent() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.startsWith("id('parentId')/")); [EOL] }
public void testAsPathWithElementNodeAndDefaultNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] DOMNodePointer parent = mock(DOMNodePointer.class); [EOL] when(parent.asPath()).thenReturn("/"); [EOL] when(parent instanceof DOMNodePointer).thenReturn(true); [EOL] instance.setParent(parent); [EOL] NamespaceResolver nsResolver = mock(NamespaceResolver.class); [EOL] when(nsResolver.getDefaultNamespaceURI()).thenReturn("defaultNamespace"); [EOL] when(instance.getNamespaceURI()).thenReturn("defaultNamespace"); [EOL] when(instance.getNamespaceResolver()).thenReturn(nsResolver); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/localName[1]")); [EOL] }
public void testAsPathWithTextNode() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertEquals("/text()[1]", result); [EOL] }
public void testAsPathWithProcessingInstructionNode() { [EOL] YourClass instance = new YourClass(); [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(pi.getTarget()).thenReturn("target"); [EOL] instance.setNode(pi); [EOL] String result = instance.asPath(); [EOL] assertEquals("/processing-instruction('target')[1]", result); [EOL] }
public void testAsPathWithDocumentNode() { [EOL] YourClass instance = new YourClass(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertEquals("", result); [EOL] }
public void testEscapeWithSingleQuote() { [EOL] String input = "test'string"; [EOL] String expected = "test&apostring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithDoubleQuote() { [EOL] String input = "test\"string"; [EOL] String expected = "test&quotstring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithBothQuotes() { [EOL] String input = "test'str\"ing"; [EOL] String expected = "test&apostring&quoting"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testEscapeWithoutQuotes() { [EOL] String input = "teststring"; [EOL] String expected = "teststring"; [EOL] String result = escape(input); [EOL] assertEquals(expected, result); [EOL] }
public void testGetRelativePositionOfElementWithNoPreviousSiblings() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(null); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionOfElement(); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfElementWithPreviousSiblings() { [EOL] Node node = mock(Node.class); [EOL] Node prevSiblingElement = mock(Node.class); [EOL] Node prevSiblingNonElement = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(prevSiblingNonElement).thenReturn(prevSiblingElement).thenReturn(null); [EOL] when(prevSiblingNonElement.getPreviousSibling()).thenReturn(prevSiblingElement); [EOL] when(prevSiblingElement.getPreviousSibling()).thenReturn(null); [EOL] when(prevSiblingNonElement.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] when(prevSiblingElement.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionOfElement(); [EOL] assertEquals(2, position); [EOL] }
public void testGetRelativePositionOfPINodeIsNull() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(null); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionOfPI("target"); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfPINodeIsNotPI() { [EOL] Node node = mock(Node.class); [EOL] Node previousSibling = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(previousSibling); [EOL] when(previousSibling.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(previousSibling.getPreviousSibling()).thenReturn(null); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionOfPI("target"); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionOfPIMatchingPI() { [EOL] Node node = mock(Node.class); [EOL] Node piNode = mock(ProcessingInstruction.class); [EOL] Node previousSibling = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(previousSibling); [EOL] when(previousSibling.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) previousSibling).getTarget()).thenReturn("target"); [EOL] when(previousSibling.getPreviousSibling()).thenReturn(piNode); [EOL] when(piNode.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) piNode).getTarget()).thenReturn("target"); [EOL] when(piNode.getPreviousSibling()).thenReturn(null); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionOfPI("target"); [EOL] assertEquals(3, position); [EOL] }
public void testGetRelativePositionOfPINonMatchingPI() { [EOL] Node node = mock(Node.class); [EOL] Node piNode = mock(ProcessingInstruction.class); [EOL] Node previousSibling = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(previousSibling); [EOL] when(previousSibling.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) previousSibling).getTarget()).thenReturn("notTarget"); [EOL] when(previousSibling.getPreviousSibling()).thenReturn(piNode); [EOL] when(piNode.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(((ProcessingInstruction) piNode).getTarget()).thenReturn("target"); [EOL] when(piNode.getPreviousSibling()).thenReturn(null); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionOfPI("target"); [EOL] assertEquals(2, position); [EOL] }
public void testGetPointerByIDWithDocumentNode() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] String id = "testId"; [EOL] Node node = mock(Node.class); [EOL] Document document = mock(Document.class); [EOL] Element element = mock(Element.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] when((Document) node).thenReturn(document); [EOL] when(document.getElementById(id)).thenReturn(element); [EOL] DOMNodePointer expectedPointer = new DOMNodePointer(element, getLocale(), id); [EOL] Pointer resultPointer = getPointerByID(context, id); [EOL] assertEquals(expectedPointer, resultPointer); [EOL] }
public void testGetPointerByIDWithNonDocumentNode() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] String id = "testId"; [EOL] Node node = mock(Node.class); [EOL] Document document = mock(Document.class); [EOL] Element element = mock(Element.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getOwnerDocument()).thenReturn(document); [EOL] when(document.getElementById(id)).thenReturn(element); [EOL] DOMNodePointer expectedPointer = new DOMNodePointer(element, getLocale(), id); [EOL] Pointer resultPointer = getPointerByID(context, id); [EOL] assertEquals(expectedPointer, resultPointer); [EOL] }
public void testGetPointerByIDWithNullElement() { [EOL] JXPathContext context = mock(JXPathContext.class); [EOL] String id = "testId"; [EOL] Node node = mock(Node.class); [EOL] Document document = mock(Document.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getOwnerDocument()).thenReturn(document); [EOL] when(document.getElementById(id)).thenReturn(null); [EOL] NullPointer expectedPointer = new NullPointer(getLocale(), id); [EOL] Pointer resultPointer = getPointerByID(context, id); [EOL] assertEquals(expectedPointer, resultPointer); [EOL] }
public void testGetFunctionWithDifferentNamespace() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction("http://different.com", name, parameters); [EOL] assertNull(result); [EOL] }
public void testGetFunctionWithNullParameters() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Function result = getFunction(namespace, name, null); [EOL] assertNotNull(result); [EOL] }
public void testGetFunctionWithNewNameAndConstructorFound() { [EOL] String namespace = "http://example.com"; [EOL] String name = "new"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ConstructorFunction); [EOL] }
public void testGetFunctionWithNewNameAndConstructorNotFound() { [EOL] String namespace = "http://example.com"; [EOL] String name = "new"; [EOL] Object[] parameters = new Object[]{"nonExistentConstructor"}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testGetFunctionWithExistingStaticMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] }
public void testGetFunctionWithNonStaticMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "instanceMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] }
public void testGetFunctionWithNonExistentMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "nonExistentMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testExtensionFunctionWithValidArguments() { [EOL] QName functionName = new QName("testFunction"); [EOL] Expression[] args = new Expression[] { mock(Expression.class) }; [EOL] ExtensionFunction extensionFunction = new ExtensionFunction(functionName, args); [EOL] assertNotNull(extensionFunction); [EOL] assertEquals(functionName, extensionFunction.getFunctionName()); [EOL] assertArrayEquals(args, extensionFunction.getArguments()); [EOL] }
public void testExtensionFunctionWithNullFunctionName() { [EOL] Expression[] args = new Expression[] { mock(Expression.class) }; [EOL] try { [EOL] ExtensionFunction extensionFunction = new ExtensionFunction(null, args); [EOL] fail("Expected IllegalArgumentException for null functionName"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testExtensionFunctionWithNullArguments() { [EOL] QName functionName = new QName("testFunction"); [EOL] try { [EOL] ExtensionFunction extensionFunction = new ExtensionFunction(functionName, null); [EOL] fail("Expected IllegalArgumentException for null args"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testComputeValueWithNullArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getFunction(anyString(), any())).thenReturn(mock(Function.class)); [EOL] Object result = computeValue(context); [EOL] assertNull(result); [EOL] }
public void testComputeValueWithNonNullArgs() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] Function function = mock(Function.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getFunction(anyString(), any())).thenReturn(function); [EOL] when(function.invoke(any(EvalContext.class), any())).thenReturn(new Object()); [EOL] Object result = computeValue(context); [EOL] assertNotNull(result); [EOL] }
public void testComputeValueFunctionNotFound() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getFunction(anyString(), any())).thenReturn(null); [EOL] try { [EOL] computeValue(context); [EOL] fail("JXPathFunctionNotFoundException expected"); [EOL] } catch (JXPathFunctionNotFoundException e) { [EOL] } [EOL] }
public void testLookupStaticMethodWithNullParameters() { [EOL] Method result = MyClass.lookupStaticMethod(MyTargetClass.class, "staticMethodName", null); [EOL] assertNull("Expected null result because no parameters are provided", result); [EOL] }
public void testLookupStaticMethodWithExactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = new Object[] { "param1", Integer.valueOf(10) }; [EOL] Method result = MyClass.lookupStaticMethod(MyTargetClass.class, "staticMethodName", parameters); [EOL] assertNotNull("Expected non-null result for exact match", result); [EOL] assertTrue("Expected method to be static", Modifier.isStatic(result.getModifiers())); [EOL] assertEquals("Expected method name to match", "staticMethodName", result.getName()); [EOL] }
public void testLookupStaticMethodWithInexactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = new Object[] { "param1", null }; [EOL] Method result = MyClass.lookupStaticMethod(MyTargetClass.class, "staticMethodName", parameters); [EOL] assertNotNull("Expected non-null result for inexact match", result); [EOL] assertTrue("Expected method to be static", Modifier.isStatic(result.getModifiers())); [EOL] assertEquals("Expected method name to match", "staticMethodName", result.getName()); [EOL] }
public void testLookupStaticMethodWithAmbiguousMatch() { [EOL] Object[] parameters = new Object[] { "param1", new Object() }; [EOL] try { [EOL] MyClass.lookupStaticMethod(MyTargetClass.class, "ambiguousMethodName", parameters); [EOL] fail("Expected JXPathException for ambiguous match"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testLookupStaticMethodWithNoMatch() { [EOL] Object[] parameters = new Object[] { new Object(), new Object() }; [EOL] Method result = MyClass.lookupStaticMethod(MyTargetClass.class, "nonExistingMethodName", parameters); [EOL] assertNull("Expected null result for no match", result); [EOL] }
public void testLookupMethodWithNullParameters() { [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", null); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithEmptyParameters() { [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", new Object[]{}); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithNullFirstParameter() { [EOL] Object[] parameters = {null, "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithNoMatch() { [EOL] Object[] parameters = {new Object(), "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithExactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = {"test", "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] Method expected = String.class.getMethod("valueOf", String.class); [EOL] assertEquals(expected, result); [EOL] }
public void testLookupMethodWithInexactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = {new Integer(123), "test"}; [EOL] Method result = YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] Method expected = String.class.getMethod("valueOf", Object.class); [EOL] assertEquals(expected, result); [EOL] }
public void testLookupMethodWithAmbiguousMatch() { [EOL] Object[] parameters = {new Double(123.45), "test"}; [EOL] try { [EOL] YourClass.lookupMethod(String.class, "valueOf", parameters); [EOL] fail("Expected JXPathException for ambiguous method call"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testMatchParameterTypesWithExpressionContextFirst() { [EOL] Class[] types = new Class[] {ExpressionContext.class, String.class}; [EOL] Object[] parameters = new Object[] {"test"}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchParameterTypesWithoutExpressionContextFirst() { [EOL] Class[] types = new Class[] {String.class}; [EOL] Object[] parameters = new Object[] {"test"}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchParameterTypesWithMismatchingLengths() { [EOL] Class[] types = new Class[] {String.class, Integer.class}; [EOL] Object[] parameters = new Object[] {"test"}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchParameterTypesWithNullParameters() { [EOL] Class[] types = new Class[] {String.class}; [EOL] Object[] parameters = null; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchParameterTypesWithNoMatch() { [EOL] Class[] types = new Class[] {String.class}; [EOL] Object[] parameters = new Object[] {new Object()}; [EOL] int result = matchParameterTypes(types, parameters); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchTypeWithNullObject() { [EOL] int result = matchType(String.class, null); [EOL] assertEquals(APPROXIMATE_MATCH, result); [EOL] }
public void testMatchTypeWithExactMatch() { [EOL] int result = matchType(String.class, "test"); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchTypeWithAssignableMatch() { [EOL] int result = matchType(Object.class, "test"); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchTypeWithNoMatch() { [EOL] int result = matchType(Integer.class, "test"); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testMatchTypeWithApproximateMatch() { [EOL] int result = matchType(List.class, new ArrayList()); [EOL] when(TypeUtils.canConvert(any(), eq(List.class))).thenReturn(true); [EOL] assertEquals(APPROXIMATE_MATCH, result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorIsNull() { [EOL] setPosition(0); [EOL] setIterator(null); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorHasNonNullPointer() { [EOL] setPosition(0); [EOL] setIteratorWithNonNullNodePointer(); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsNotZero() { [EOL] setPosition(1); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNotNull(result); [EOL] }
public void testCreateNodePointerWithNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Node bean = mock(Node.class); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodePointer); [EOL] }
public void testCreateNodePointerWithNonNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object bean = new Object(); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public void testCollectionPointerWithNullCollection() { [EOL] Locale testLocale = new Locale("en", "US"); [EOL] CollectionPointer collectionPointer = new CollectionPointer(null, testLocale); [EOL] assertNull("Expected collection to be null", collectionPointer.getCollection()); [EOL] assertEquals("Expected locale to be the same as the one passed in constructor", testLocale, collectionPointer.getLocale()); [EOL] }
public void testCollectionPointerWithNonNullCollection() { [EOL] Locale testLocale = new Locale("en", "US"); [EOL] List<String> testCollection = new ArrayList<>(); [EOL] CollectionPointer collectionPointer = new CollectionPointer(testCollection, testLocale); [EOL] assertNotNull("Expected collection to be non-null", collectionPointer.getCollection()); [EOL] assertEquals("Expected collection to be the same as the one passed in constructor", testCollection, collectionPointer.getCollection()); [EOL] assertEquals("Expected locale to be the same as the one passed in constructor", testLocale, collectionPointer.getLocale()); [EOL] }
public void testCollectionPointerWithNonNullParentAndCollection() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Object collection = new ArrayList(); [EOL] CollectionPointer collectionPointer = new CollectionPointer(parent, collection); [EOL] assertNotNull(collectionPointer); [EOL] assertSame(parent, collectionPointer.getParent()); [EOL] assertSame(collection, collectionPointer.getCollection()); [EOL] }
public void testCollectionPointerWithNullParent() { [EOL] Object collection = new ArrayList(); [EOL] CollectionPointer collectionPointer = new CollectionPointer(null, collection); [EOL] assertNotNull(collectionPointer); [EOL] assertNull(collectionPointer.getParent()); [EOL] assertSame(collection, collectionPointer.getCollection()); [EOL] }
public void testCollectionPointerWithNullCollection() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] CollectionPointer collectionPointer = new CollectionPointer(parent, null); [EOL] assertNotNull(collectionPointer); [EOL] assertSame(parent, collectionPointer.getParent()); [EOL] assertNull(collectionPointer.getCollection()); [EOL] }
public void testGetNameReturnsNull() { [EOL] MyClass instance = new MyClass(); [EOL] QName result = instance.getName(); [EOL] assertNull(result); [EOL] }
public Object getBaseValue() { [EOL] return collection; [EOL] }
public int testGetLength_BaseValueNull() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] int expectedLength = 0; [EOL] int actualLength = context.getLength(); [EOL] assertEquals(expectedLength, actualLength); [EOL] }
public int testGetLength_BaseValueNonNull() { [EOL] Object baseValue = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(baseValue); [EOL] int expectedLength = ValueUtils.getLength(baseValue); [EOL] int actualLength = context.getLength(); [EOL] assertEquals(expectedLength, actualLength); [EOL] }
public void testGetImmediateNodeWithIndexNotWholeCollection() { [EOL] int index = 1; // Assuming WHOLE_COLLECTION is a constant not equal to 1 [EOL] Object collection = new Object(); // Replace with actual collection initialization [EOL] YourObjectUnderTest objUnderTest = new YourObjectUnderTest(index, collection); [EOL] Object result = objUnderTest.getImmediateNode(); [EOL] Object expectedValue = ValueUtils.getValue(collection, index); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetImmediateNodeWithIndexWholeCollection() { [EOL] int index = WHOLE_COLLECTION; // Assuming WHOLE_COLLECTION is a known constant [EOL] Object collection = new Object(); // Replace with actual collection initialization [EOL] YourObjectUnderTest objUnderTest = new YourObjectUnderTest(index, collection); [EOL] Object result = objUnderTest.getImmediateNode(); [EOL] Object expectedValue = ValueUtils.getValue(collection); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testSetValueWithWholeCollection() { [EOL] int WHOLE_COLLECTION = -1; // Assuming this is a constant defined somewhere [EOL] int index = WHOLE_COLLECTION; [EOL] Object value = new Object(); [EOL] CollectionParent parent = mock(CollectionParent.class); [EOL] Collection collection = null; // Assuming collection is not needed for WHOLE_COLLECTION [EOL] MyClass myClass = new MyClass(parent, collection, index); [EOL] myClass.setValue(value); [EOL] verify(parent).setValue(value); [EOL] }
public void testSetValueWithSpecificIndex() { [EOL] int index = 1; // Assuming this is a valid index [EOL] Object value = new Object(); [EOL] CollectionParent parent = mock(CollectionParent.class); [EOL] Collection collection = mock(Collection.class); // Assuming we need a mock collection [EOL] MyClass myClass = new MyClass(parent, collection, index); [EOL] myClass.setValue(value); [EOL] verify(collection).setValue(index, value); [EOL] }
public void testSetIndex() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(5); [EOL] assertNull(instance.valuePointer); [EOL] }
public void testGetValuePointerWhenValuePointerIsNullAndIndexIsWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = null; [EOL] instance.index = YourClassUnderTest.WHOLE_COLLECTION; [EOL] NodePointer result = instance.getValuePointer(); [EOL] assertEquals(instance, result); [EOL] }
public void testGetValuePointerWhenValuePointerIsNullAndIndexIsNotWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = null; [EOL] instance.index = 1; // Assuming 1 is not the constant WHOLE_COLLECTION [EOL] Object immediateNode = new Object(); // Replace with actual object or mock [EOL] QName name = new QName("test"); // Replace with actual QName or mock [EOL] when(instance.getImmediateNode()).thenReturn(immediateNode); [EOL] when(instance.getName()).thenReturn(name); [EOL] NodePointer result = instance.getValuePointer(); [EOL] assertNotNull(result); [EOL] assertNotEquals(instance, result); // Ensure it's not pointing to 'this' [EOL] }
public void testGetValuePointerWhenValuePointerIsNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] NodePointer expectedPointer = new NodePointer(); // Replace with actual NodePointer or mock [EOL] instance.valuePointer = expectedPointer; [EOL] NodePointer result = instance.getValuePointer(); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testCreatePathWithIndexLessThanLength() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = new ConcreteNodePointer(); // Assuming ConcreteNodePointer extends NodePointer [EOL] nodePointer.setBaseValue(Arrays.asList(1, 2, 3)); [EOL] nodePointer.setIndex(5); [EOL] NodePointer result = nodePointer.createPath(context); [EOL] assertSame("Expected the same NodePointer instance", nodePointer, result); [EOL] int expandedSize = ValueUtils.getLength(nodePointer.getBaseValue()); [EOL] assertTrue("Expected collection to be expanded", expandedSize > 5); [EOL] }
public void testCreatePathWithIndexEqualToLength() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = new ConcreteNodePointer(); // Assuming ConcreteNodePointer extends NodePointer [EOL] nodePointer.setBaseValue(Arrays.asList(1, 2, 3, 4, 5)); [EOL] nodePointer.setIndex(4); [EOL] NodePointer result = nodePointer.createPath(context); [EOL] assertSame("Expected the same NodePointer instance", nodePointer, result); [EOL] int size = ValueUtils.getLength(nodePointer.getBaseValue()); [EOL] assertEquals("Expected collection size to remain the same", 5, size); [EOL] }
public void testCreatePathWithIndexGreaterThanLength() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = new ConcreteNodePointer(); // Assuming ConcreteNodePointer extends NodePointer [EOL] nodePointer.setBaseValue(Arrays.asList(1, 2, 3, 4, 5, 6)); [EOL] nodePointer.setIndex(3); [EOL] NodePointer result = nodePointer.createPath(context); [EOL] assertSame("Expected the same NodePointer instance", nodePointer, result); [EOL] int size = ValueUtils.getLength(nodePointer.getBaseValue()); [EOL] assertEquals("Expected collection size to remain the same", 6, size); [EOL] }
public void testCreatePathWithNullContext() { [EOL] try { [EOL] NodePointer nodePointer = createPath(null, new Object()); [EOL] fail("Should have thrown IllegalArgumentException for null context"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreatePathWithNonNullContextAndNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = createPath(context, null); [EOL] assertNotNull("NodePointer should not be null", nodePointer); [EOL] assertNull("Value of NodePointer should be null", nodePointer.getValue()); [EOL] }
public void testCreatePathWithNonNullContextAndNonNullValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = createPath(context, value); [EOL] assertNotNull("NodePointer should not be null", nodePointer); [EOL] assertEquals("Value of NodePointer should be the same as set", value, nodePointer.getValue()); [EOL] }
public void testCreateChildWithValidIndexAndValue() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = new QName("testNamespace", "testName"); [EOL] int index = 1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new NodePointerTestImpl(); [EOL] NodePointer result = nodePointer.createChild(context, name, index, value); [EOL] assertNotNull(result); [EOL] assertEquals(index, result.getIndex()); [EOL] assertNotNull(result.getValue()); [EOL] }
public void testCreateChildWithNegativeIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] QName name = new QName("testNamespace", "testName"); [EOL] int index = -1; [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new NodePointerTestImpl(); [EOL] NodePointer result = nodePointer.createChild(context, name, index, value); [EOL] assertNotNull(result); [EOL] assertEquals(NodePointer.WHOLE_COLLECTION, result.getIndex()); [EOL] assertNotNull(result.getValue()); [EOL] }
public void testChildIteratorWithWholeCollection() { [EOL] NodePointer nodePointer = createNodePointerWithWholeCollectionIndex(); [EOL] NodeTest test = createNodeTest(); [EOL] boolean reverse = false; [EOL] NodePointer startWith = createNodePointer(); [EOL] NodeIterator result = nodePointer.childIterator(test, reverse, startWith); [EOL] assertTrue(result instanceof CollectionChildNodeIterator); [EOL] }
public void testChildIteratorWithValuePointer() { [EOL] NodePointer nodePointer = createNodePointerWithNonWholeCollectionIndex(); [EOL] NodeTest test = createNodeTest(); [EOL] boolean reverse = true; [EOL] NodePointer startWith = createNodePointer(); [EOL] NodeIterator result = nodePointer.childIterator(test, reverse, startWith); [EOL] assertNotNull(result); [EOL] }
public void testTestNodeWithNullAndWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.WHOLE_COLLECTION; [EOL] NodeTest test = null; [EOL] boolean result = instance.testNode(test); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeNameTestAndWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.WHOLE_COLLECTION; [EOL] NodeTest test = new NodeNameTest(); [EOL] boolean result = instance.testNode(test); [EOL] assertFalse(result); [EOL] }
public void testTestNodeWithNodeTypeTestAndNodeTypeNodeAndWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.WHOLE_COLLECTION; [EOL] NodeTypeTest test = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] boolean result = instance.testNode(test); [EOL] assertTrue(result); [EOL] }
public void testTestNodeWithNodeTypeTestAndDifferentNodeTypeAndWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.WHOLE_COLLECTION; [EOL] NodeTypeTest test = new NodeTypeTest(Compiler.DIFFERENT_NODE_TYPE); [EOL] boolean result = instance.testNode(test); [EOL] assertFalse(result); [EOL] }
public void testTestNodeWithIndexNotWholeCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.index = YourClass.NOT_WHOLE_COLLECTION; // This should be a value different from WHOLE_COLLECTION [EOL] NodeTest test = anyNodeTest(); // This should be a stub or mock of NodeTest [EOL] ValuePointer valuePointer = mock(ValuePointer.class); [EOL] when(instance.getValuePointer()).thenReturn(valuePointer); [EOL] when(valuePointer.testNode(test)).thenReturn(true); // or false depending on what you want to test [EOL] boolean result = instance.testNode(test); [EOL] assertEquals(valuePointer.testNode(test), result); [EOL] }
public void testCollectionChildNodeIteratorWithNonNullValues() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] NodeTest mockTest = mock(NodeTest.class); [EOL] NodePointer mockStartWith = mock(NodePointer.class); [EOL] boolean reverse = false; [EOL] CollectionChildNodeIterator iterator = new CollectionChildNodeIterator(mockPointer, mockTest, reverse, mockStartWith); [EOL] assertNotNull(iterator); [EOL] assertEquals(mockTest, iterator.test); [EOL] assertEquals(mockPointer, iterator.getPointer()); [EOL] assertEquals(reverse, iterator.isReverse()); [EOL] assertEquals(mockStartWith, iterator.getStartWith()); [EOL] }
public void testCollectionChildNodeIteratorWithReverseTrue() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] NodeTest mockTest = mock(NodeTest.class); [EOL] NodePointer mockStartWith = mock(NodePointer.class); [EOL] boolean reverse = true; [EOL] CollectionChildNodeIterator iterator = new CollectionChildNodeIterator(mockPointer, mockTest, reverse, mockStartWith); [EOL] assertNotNull(iterator); [EOL] assertEquals(reverse, iterator.isReverse()); [EOL] }
public void testCollectionChildNodeIteratorWithNullStartWith() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] NodeTest mockTest = mock(NodeTest.class); [EOL] boolean reverse = false; [EOL] CollectionChildNodeIterator iterator = new CollectionChildNodeIterator(mockPointer, mockTest, reverse, null); [EOL] assertNotNull(iterator); [EOL] assertNull(iterator.getStartWith()); [EOL] }
public void testGetElementNodeIteratorWithNonNullElementPointer() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeIterator expectedIterator = Mockito.mock(NodeIterator.class); [EOL] Mockito.when(mockNodePointer.childIterator(Mockito.any(), Mockito.eq(false), Mockito.isNull())).thenReturn(expectedIterator); [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JxPath jxPath = new JxPath(context); [EOL] NodeIterator result = jxPath.getElementNodeIterator(mockNodePointer); [EOL] assertNotNull("NodeIterator should not be null", result); [EOL] assertSame("The returned NodeIterator is not the expected one", expectedIterator, result); [EOL] }
protected boolean isSymmetric() { [EOL] return true; [EOL] }
public void testGetPointerWithEvalContextResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
public void testGetPointerWithNodePointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
public void testGetPointerWithNonActualNodePointerAndLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
public void testGetPointerWithNonActualNodePointerAndNotLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] try { [EOL] context.getPointer("some/xpath", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetPointerWithNonPointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] Object nonPointerResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nonPointerResult); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
private NodePointer getAbsoluteRootPointer() { [EOL] return (NodePointer) rootPointer; [EOL] }
public void testGetAbsoluteRootContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] EvalContext evalContext = context.getAbsoluteRootContext(); [EOL] assertNotNull("EvalContext should not be null", evalContext); [EOL] assertTrue("Should return instance of InitialContext", evalContext instanceof InitialContext); [EOL] }
public void testGetNamespaceURIWithValidPrefix() { [EOL] NamespaceResolver resolver = new NamespaceResolver(); [EOL] resolver.addNamespace("prefix", "http://example.com/namespace"); [EOL] JXPathContext context = JXPathContext.newContext(resolver); [EOL] String uri = context.getNamespaceURI("prefix"); [EOL] assertEquals("http://example.com/namespace", uri); [EOL] }
public void testGetNamespaceURIWithInvalidPrefix() { [EOL] NamespaceResolver resolver = new NamespaceResolver(); [EOL] resolver.addNamespace("prefix", "http://example.com/namespace"); [EOL] JXPathContext context = JXPathContext.newContext(resolver); [EOL] String uri = context.getNamespaceURI("invalid"); [EOL] assertNull(uri); [EOL] }
public void testGetNamespaceURIWithNullPrefix() { [EOL] NamespaceResolver resolver = new NamespaceResolver(); [EOL] resolver.addNamespace("prefix", "http://example.com/namespace"); [EOL] JXPathContext context = JXPathContext.newContext(resolver); [EOL] String uri = context.getNamespaceURI(null); [EOL] assertNull(uri); [EOL] }
public void testGetDefaultNamespaceURI_WithNonNullDefaultNamespaceURI() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setDefaultNamespaceURI("http://example.com/namespace"); [EOL] String result = context.getDefaultNamespaceURI(); [EOL] assertEquals("http://example.com/namespace", result); [EOL] }
public void testGetDefaultNamespaceURI_WithNullDefaultNamespaceURIAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] parentContext.setDefaultNamespaceURI("http://parent.com/namespace"); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] String result = childContext.getDefaultNamespaceURI(); [EOL] assertEquals("http://parent.com/namespace", result); [EOL] }
public void testGetDefaultNamespaceURI_WithNullDefaultNamespaceURIAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String result = context.getDefaultNamespaceURI(); [EOL] assertNull(result); [EOL] }
public void testRegisterDefaultNamespace() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.registerDefaultNamespace("http://example.com"); [EOL] assertEquals("http://example.com", context.getDefaultNamespaceURI()); [EOL] }
public void testNodeSetContextWithNonNullParentContextAndNodeSet() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeSet nodeSet = mock(NodeSet.class); [EOL] NodeSetContext nodeSetContext = new NodeSetContext(parentContext, nodeSet); [EOL] assertNotNull(nodeSetContext); [EOL] assertSame(parentContext, nodeSetContext.getParentContext()); [EOL] assertSame(nodeSet, nodeSetContext.getNodeSet()); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionFails() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodeSet nodeSet = new NodeSet(); [EOL] context.getVariables().declareVariable("nodeSet", nodeSet); [EOL] NodePointerTestable pointer = new NodePointerTestable(context, nodeSet); [EOL] pointer.setPosition(0); [EOL] pointer.setSetPositionReturnValue(false); // Mocking setPosition to return false [EOL] NodePointer result = pointer.getCurrentNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodeSet nodeSet = new NodeSet(); [EOL] context.getVariables().declareVariable("nodeSet", nodeSet); [EOL] NodePointerTestable pointer = new NodePointerTestable(context, nodeSet); [EOL] pointer.setPosition(0); [EOL] pointer.setSetPositionReturnValue(true); // Mocking setPosition to return true [EOL] nodeSet.getPointers().add(new NodePointerDummy()); // Add a dummy NodePointer to the NodeSet [EOL] NodePointer result = pointer.getCurrentNodePointer(); [EOL] assertNotNull(result); [EOL] assertSame(nodeSet.getPointers().get(0), result); [EOL] }
public void testGetCurrentNodePointer_PositionIsNotZero() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodeSet nodeSet = new NodeSet(); [EOL] context.getVariables().declareVariable("nodeSet", nodeSet); [EOL] NodePointerTestable pointer = new NodePointerTestable(context, nodeSet); [EOL] pointer.setPosition(2); // Set position to a non-zero value [EOL] NodePointerDummy expectedPointer = new NodePointerDummy(); [EOL] nodeSet.getPointers().add(new NodePointerDummy()); // Add a dummy NodePointer to the NodeSet [EOL] nodeSet.getPointers().add(expectedPointer); // Add the expected NodePointer at position 1 (index 0) [EOL] NodePointer result = pointer.getCurrentNodePointer(); [EOL] assertNotNull(result); [EOL] assertSame(expectedPointer, result); [EOL] }
public void testSetPositionWithinRange() { [EOL] int positionWithinRange = 1; // Assuming the range starts at 1 and there's at least one pointer [EOL] boolean result = setPosition(positionWithinRange); [EOL] assert result == true : "Position within range should return true"; [EOL] }
public void testSetPositionBelowRange() { [EOL] int positionBelowRange = 0; // Below the valid range [EOL] boolean result = setPosition(positionBelowRange); [EOL] assert result == false : "Position below range should return false"; [EOL] }
public void testSetPositionAboveRange() { [EOL] int size = nodeSet.getPointers().size(); [EOL] int positionAboveRange = size + 1; // Above the valid range [EOL] boolean result = setPosition(positionAboveRange); [EOL] assert result == false : "Position above range should return false"; [EOL] }
public void testNextSet_WhenNotStarted() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] boolean result = context.nextSet(); [EOL] assertTrue(result); [EOL] assertFalse(context.nextSet()); [EOL] }
public void testNextSet_WhenAlreadyStarted() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.nextSet(); // first call to start [EOL] boolean result = context.nextSet(); [EOL] assertFalse(result); [EOL] }
public boolean nextNode() { [EOL] return setPosition(position + 1); [EOL] }
public void testCoreOperationUnionWithEmptyArgs() { [EOL] Expression[] args = new Expression[0]; [EOL] CoreOperationUnion operationUnion = new CoreOperationUnion(args); [EOL] assertNotNull(operationUnion); [EOL] }
public void testCoreOperationUnionWithSingleArg() { [EOL] Expression[] args = new Expression[1]; [EOL] args[0] = mock(Expression.class); [EOL] CoreOperationUnion operationUnion = new CoreOperationUnion(args); [EOL] assertNotNull(operationUnion); [EOL] assertEquals(1, operationUnion.getArguments().length); [EOL] }
public void testCoreOperationUnionWithMultipleArgs() { [EOL] Expression[] args = { mock(Expression.class), mock(Expression.class) }; [EOL] CoreOperationUnion operationUnion = new CoreOperationUnion(args); [EOL] assertNotNull(operationUnion); [EOL] assertEquals(2, operationUnion.getArguments().length); [EOL] }
public void testGetSymbol() { [EOL] MyClass myClass = new MyClass(); [EOL] String symbol = myClass.getSymbol(); [EOL] assertEquals("|", symbol); [EOL] }
public void testJDOMNodeIteratorWithDocumentNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Document document = mock(Document.class); [EOL] when(parent.getNode()).thenReturn(document); [EOL] when(document.getContent()).thenReturn(new ArrayList()); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, null); [EOL] assertNotNull(iterator); [EOL] assertEquals(document.getContent(), iterator.children); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorWithElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Element element = mock(Element.class); [EOL] when(parent.getNode()).thenReturn(element); [EOL] when(element.getContent()).thenReturn(new ArrayList()); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, null); [EOL] assertNotNull(iterator); [EOL] assertEquals(element.getContent(), iterator.children); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorWithNonDocumentOrElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] Object nonDocumentOrElementNode = new Object(); [EOL] when(parent.getNode()).thenReturn(nonDocumentOrElementNode); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, null); [EOL] assertNotNull(iterator); [EOL] assertEquals(Collections.EMPTY_LIST, iterator.children); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorWithStartWithNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] Node startWithNode = mock(Node.class); [EOL] when(startWith.getNode()).thenReturn(startWithNode); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, false, startWith); [EOL] assertNotNull(iterator); [EOL] assertEquals(startWithNode, iterator.child); [EOL] assertFalse(iterator.reverse); [EOL] }
public void testJDOMNodeIteratorReverseTrue() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] JDOMNodeIterator iterator = new JDOMNodeIterator(parent, nodeTest, true, null); [EOL] assertNotNull(iterator); [EOL] assertTrue(iterator.reverse); [EOL] }
public void testNextWithReverseFalseAndPositionOneAndChildNotNull() { [EOL] position = 0; [EOL] reverse = false; [EOL] child = mockChildObject; // Assuming mockChildObject is a valid object for the test [EOL] children.add(mockChildObject); [EOL] children.add(otherChildObject); // Assuming otherChildObject is another valid object [EOL] boolean result = next(); [EOL] assertTrue("Expected next() to return true when there is a valid child", result); [EOL] assertEquals("Expected index to be set to the position of child + 1", children.indexOf(mockChildObject) + 1, index); [EOL] }
public void testNextWithReverseFalseAndPositionGreaterThanOne() { [EOL] position = 2; [EOL] reverse = false; [EOL] children.add(mockChildObject); // Assuming mockChildObject is a valid object for the test [EOL] children.add(otherChildObject); // Assuming otherChildObject is another valid object [EOL] boolean result = next(); [EOL] assertFalse("Expected next() to return false when no more children pass the test", result); [EOL] assertEquals("Expected index to be incremented", 3, index); [EOL] }
public void testNextWithReverseTrueAndPositionOneAndChildNotNull() { [EOL] position = 0; [EOL] reverse = true; [EOL] child = mockChildObject; // Assuming mockChildObject is a valid object for the test [EOL] children.add(otherChildObject); // Assuming otherChildObject is another valid object [EOL] children.add(mockChildObject); [EOL] boolean result = next(); [EOL] assertTrue("Expected next() to return true when there is a valid child", result); [EOL] assertEquals("Expected index to be set to the position of child - 1", children.indexOf(mockChildObject) - 1, index); [EOL] }
public void testNextWithReverseTrueAndPositionGreaterThanOne() { [EOL] position = 2; [EOL] reverse = true; [EOL] children.add(otherChildObject); // Assuming otherChildObject is another valid object [EOL] children.add(mockChildObject); // Assuming mockChildObject is a valid object for the test [EOL] boolean result = next(); [EOL] assertFalse("Expected next() to return false when no more children pass the test", result); [EOL] assertEquals("Expected index to be decremented", children.size() - 3, index); [EOL] }
