public DateTimeFieldType getFieldType(int index) { [EOL]     return getField(index, getChronology()).getType(); [EOL] }
public DateTimeFieldType getFieldType(int index) { [EOL]     return getField(index, getChronology()).getType(); [EOL] }
protected int indexOfSupported(DateTimeFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return index; [EOL] }
protected int indexOfSupported(DateTimeFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return index; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof ReadablePartial == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePartial other = (ReadablePartial) partial; [EOL]     if (size() != other.size()) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public int hashCode() { [EOL]     int total = 157; [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         total = 23 * total + getValue(i); [EOL]         total = 23 * total + getFieldType(i).hashCode(); [EOL]     } [EOL]     total += getChronology().hashCode(); [EOL]     return total; [EOL] }
public int hashCode() { [EOL]     int total = 157; [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         total = 23 * total + getValue(i); [EOL]         total = 23 * total + getFieldType(i).hashCode(); [EOL]     } [EOL]     total += getChronology().hashCode(); [EOL]     return total; [EOL] }
public int hashCode() { [EOL]     int total = 157; [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         total = 23 * total + getValue(i); [EOL]         total = 23 * total + getFieldType(i).hashCode(); [EOL]     } [EOL]     total += getChronology().hashCode(); [EOL]     return total; [EOL] }
public int compareTo(ReadablePartial other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (size() != other.size()) { [EOL]         throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) != other.getFieldType(i)) { [EOL]             throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]         } [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) > other.getValue(i)) { [EOL]             return 1; [EOL]         } [EOL]         if (getValue(i) < other.getValue(i)) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public boolean isBefore(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) < 0; [EOL] }
public boolean isBefore(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) < 0; [EOL] }
public boolean isBefore(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) < 0; [EOL] }
public boolean isEqual(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) == 0; [EOL] }
public String toString(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public String toString(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public YearMonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withYear(int year) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().year().set(this, YEAR, newValues, year); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withYear(int year) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().year().set(this, YEAR, newValues, year); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withMonthOfYear(int monthOfYear) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         chrono = ((ReadablePartial) object).getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         chrono = ((ReadablePartial) object).getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public Period(ReadableInstant startInstant, ReadableInstant endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public Period(ReadableInstant startInstant, ReadableDuration duration) { [EOL]     super(startInstant, duration, null); [EOL] }
public Period(Object period, PeriodType type) { [EOL]     super(period, type, null); [EOL] }
public Period(Object period, PeriodType type) { [EOL]     super(period, type, null); [EOL] }
public Period toPeriod() { [EOL]     return this; [EOL] }
public Period withField(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.setFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withField(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.setFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period plus(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE)); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plus(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE)); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE)); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Seconds toStandardSeconds() { [EOL]     checkYearsAndMonths("Seconds"); [EOL]     long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     seconds = FieldUtils.safeAdd(seconds, getSeconds()); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE)); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR)); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY)); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK)); [EOL]     return Seconds.seconds(FieldUtils.safeToInt(seconds)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     checkYearsAndMonths("Seconds"); [EOL]     long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     seconds = FieldUtils.safeAdd(seconds, getSeconds()); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE)); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR)); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY)); [EOL]     seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK)); [EOL]     return Seconds.seconds(FieldUtils.safeToInt(seconds)); [EOL] }
public Duration toStandardDuration() { [EOL]     checkYearsAndMonths("Duration"); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     return new Duration(millis); [EOL] }
public Duration toStandardDuration() { [EOL]     checkYearsAndMonths("Duration"); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     return new Duration(millis); [EOL] }
public Duration toStandardDuration() { [EOL]     checkYearsAndMonths("Duration"); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     return new Duration(millis); [EOL] }
private void checkYearsAndMonths(String destintionType) { [EOL]     if (getMonths() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length"); [EOL]     } [EOL]     if (getYears() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length"); [EOL]     } [EOL] }
private void checkYearsAndMonths(String destintionType) { [EOL]     if (getMonths() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length"); [EOL]     } [EOL]     if (getYears() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length"); [EOL]     } [EOL] }
private void checkYearsAndMonths(String destintionType) { [EOL]     if (getMonths() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length"); [EOL]     } [EOL]     if (getYears() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length"); [EOL]     } [EOL] }
int getYear(long instant) { [EOL]     long millisIslamic = instant - MILLIS_YEAR_1; [EOL]     long cycles = millisIslamic / MILLIS_PER_CYCLE; [EOL]     long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE; [EOL]     int year = (int) ((cycles * CYCLE) + 1L); [EOL]     long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     while (cycleRemainder >= yearMillis) { [EOL]         cycleRemainder -= yearMillis; [EOL]         yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long millisIslamic = instant - MILLIS_YEAR_1; [EOL]     long cycles = millisIslamic / MILLIS_PER_CYCLE; [EOL]     long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE; [EOL]     int year = (int) ((cycles * CYCLE) + 1L); [EOL]     long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     while (cycleRemainder >= yearMillis) { [EOL]         cycleRemainder -= yearMillis; [EOL]         yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long millisIslamic = instant - MILLIS_YEAR_1; [EOL]     long cycles = millisIslamic / MILLIS_PER_CYCLE; [EOL]     long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE; [EOL]     int year = (int) ((cycles * CYCLE) + 1L); [EOL]     long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     while (cycleRemainder >= yearMillis) { [EOL]         cycleRemainder -= yearMillis; [EOL]         yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long millisIslamic = instant - MILLIS_YEAR_1; [EOL]     long cycles = millisIslamic / MILLIS_PER_CYCLE; [EOL]     long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE; [EOL]     int year = (int) ((cycles * CYCLE) + 1L); [EOL]     long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     while (cycleRemainder >= yearMillis) { [EOL]         cycleRemainder -= yearMillis; [EOL]         yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long millisIslamic = instant - MILLIS_YEAR_1; [EOL]     long cycles = millisIslamic / MILLIS_PER_CYCLE; [EOL]     long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE; [EOL]     int year = (int) ((cycles * CYCLE) + 1L); [EOL]     long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     while (cycleRemainder >= yearMillis) { [EOL]         cycleRemainder -= yearMillis; [EOL]         yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return year; [EOL] }
int getDayOfMonth(long millis) { [EOL]     int doy = getDayOfYear(millis) - 1; [EOL]     if (doy == 354) { [EOL]         return 30; [EOL]     } [EOL]     return (doy % MONTH_PAIR_LENGTH) % LONG_MONTH_LENGTH + 1; [EOL] }
boolean isLeapYear(int year) { [EOL]     return iLeapYears.isLeapYear(year); [EOL] }
boolean isLeapYear(int year) { [EOL]     return iLeapYears.isLeapYear(year); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY); [EOL]     if (doyZeroBased == 354) { [EOL]         return 12; [EOL]     } [EOL]     return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY); [EOL]     if (doyZeroBased == 354) { [EOL]         return 12; [EOL]     } [EOL]     return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY); [EOL]     if (doyZeroBased == 354) { [EOL]         return 12; [EOL]     } [EOL]     return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1; [EOL] }
boolean isLeapYear(int year) { [EOL]     int key = 1 << (year % 30); [EOL]     return ((pattern & key) > 0); [EOL] }
boolean isLeapYear(int year) { [EOL]     int key = 1 << (year % 30); [EOL]     return ((pattern & key) > 0); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
protected void assemble(Fields fields) { [EOL]     Object[] params = (Object[]) getParam(); [EOL]     JulianChronology julian = (JulianChronology) params[0]; [EOL]     GregorianChronology gregorian = (GregorianChronology) params[1]; [EOL]     Instant cutoverInstant = (Instant) params[2]; [EOL]     iCutoverMillis = cutoverInstant.getMillis(); [EOL]     iJulianChronology = julian; [EOL]     iGregorianChronology = gregorian; [EOL]     iCutoverInstant = cutoverInstant; [EOL]     if (getBase() != null) { [EOL]         return; [EOL]     } [EOL]     if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis); [EOL]     fields.copyFieldsFrom(gregorian); [EOL]     if (gregorian.millisOfDay().get(iCutoverMillis) == 0) { [EOL]         fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis); [EOL]         fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis); [EOL]         fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis); [EOL]         fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis); [EOL]         fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis); [EOL]         fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis); [EOL]         fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis); [EOL]         fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis); [EOL]         fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis); [EOL]         fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(), fields.clockhourOfHalfday, iCutoverMillis); [EOL]         fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis); [EOL]     } [EOL]     { [EOL]         fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis); [EOL]     } [EOL]     { [EOL]         fields.year = new ImpreciseCutoverField(julian.year(), fields.year, iCutoverMillis); [EOL]         fields.years = fields.year.getDurationField(); [EOL]         fields.yearOfEra = new ImpreciseCutoverField(julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis); [EOL]         fields.centuryOfEra = new ImpreciseCutoverField(julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis); [EOL]         fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]         fields.yearOfCentury = new ImpreciseCutoverField(julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis); [EOL]         fields.monthOfYear = new ImpreciseCutoverField(julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]         fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, null, iCutoverMillis, true); [EOL]         fields.weekyears = fields.weekyear.getDurationField(); [EOL]         fields.weekyearOfCentury = new ImpreciseCutoverField(julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis); [EOL]     } [EOL]     { [EOL]         long cutover = gregorian.year().roundCeiling(iCutoverMillis); [EOL]         fields.dayOfYear = new CutoverField(julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false); [EOL]     } [EOL]     { [EOL]         long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis); [EOL]         fields.weekOfWeekyear = new CutoverField(julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true); [EOL]     } [EOL]     { [EOL]         CutoverField cf = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis); [EOL]         cf.iRangeDurationField = fields.months; [EOL]         fields.dayOfMonth = cf; [EOL]     } [EOL] }
long julianToGregorianByWeekyear(long instant) { [EOL]     return convertByWeekyear(instant, iJulianChronology, iGregorianChronology); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return iGregorianField.getAsText(fieldValue, locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return iGregorianField.getAsShortText(fieldValue, locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return iGregorianField.getAsShortText(fieldValue, locale); [EOL] }
protected long julianToGregorian(long instant) { [EOL]     if (iConvertByWeekyear) { [EOL]         return julianToGregorianByWeekyear(instant); [EOL]     } else { [EOL]         return julianToGregorianByYear(instant); [EOL]     } [EOL] }
protected long julianToGregorian(long instant) { [EOL]     if (iConvertByWeekyear) { [EOL]         return julianToGregorianByWeekyear(instant); [EOL]     } else { [EOL]         return julianToGregorianByYear(instant); [EOL]     } [EOL] }
public long add(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.add(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 if (iConvertByWeekyear) { [EOL]                     int wyear = iGregorianChronology.weekyear().get(instant); [EOL]                     if (wyear <= 0) { [EOL]                         instant = iGregorianChronology.weekyear().add(instant, -1); [EOL]                     } [EOL]                 } else { [EOL]                     int year = iGregorianChronology.year().get(instant); [EOL]                     if (year <= 0) { [EOL]                         instant = iGregorianChronology.year().add(instant, -1); [EOL]                     } [EOL]                 } [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.add(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long add(long instant, long value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.add(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 if (iConvertByWeekyear) { [EOL]                     int wyear = iGregorianChronology.weekyear().get(instant); [EOL]                     if (wyear <= 0) { [EOL]                         instant = iGregorianChronology.weekyear().add(instant, -1); [EOL]                     } [EOL]                 } else { [EOL]                     int year = iGregorianChronology.year().get(instant); [EOL]                     if (year <= 0) { [EOL]                         instant = iGregorianChronology.year().add(instant, -1); [EOL]                     } [EOL]                 } [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.add(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long add(long instant, long value) { [EOL]     return iField.add(instant, value); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     return DateTimeUtils.getChronology(chrono); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     return DateTimeUtils.getChronology(chrono); [EOL] }
public int get(long millis) { [EOL]     int value = super.get(millis); [EOL]     if (value < iSkip) { [EOL]         value++; [EOL]     } [EOL]     return value; [EOL] }
public int get(long millis) { [EOL]     int value = super.get(millis); [EOL]     if (value < iSkip) { [EOL]         value++; [EOL]     } [EOL]     return value; [EOL] }
public int get(long millis) { [EOL]     int value = super.get(millis); [EOL]     if (value < iSkip) { [EOL]         value++; [EOL]     } [EOL]     return value; [EOL] }
public PeriodFormatterBuilder() { [EOL]     clear(); [EOL] }
public PeriodPrinter toPrinter() { [EOL]     if (iNotPrinter) { [EOL]         return null; [EOL]     } [EOL]     return toFormatter().getPrinter(); [EOL] }
public PeriodPrinter toPrinter() { [EOL]     if (iNotPrinter) { [EOL]         return null; [EOL]     } [EOL]     return toFormatter().getPrinter(); [EOL] }
public PeriodParser toParser() { [EOL]     if (iNotParser) { [EOL]         return null; [EOL]     } [EOL]     return toFormatter().getParser(); [EOL] }
public PeriodParser toParser() { [EOL]     if (iNotParser) { [EOL]         return null; [EOL]     } [EOL]     return toFormatter().getParser(); [EOL] }
public void clear() { [EOL]     iMinPrintedDigits = 1; [EOL]     iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; [EOL]     iMaxParsedDigits = 10; [EOL]     iRejectSignedValues = false; [EOL]     iPrefix = null; [EOL]     if (iElementPairs == null) { [EOL]         iElementPairs = new ArrayList<Object>(); [EOL]     } else { [EOL]         iElementPairs.clear(); [EOL]     } [EOL]     iNotPrinter = false; [EOL]     iNotParser = false; [EOL]     iFieldFormatters = new FieldFormatter[10]; [EOL] }
public void clear() { [EOL]     iMinPrintedDigits = 1; [EOL]     iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; [EOL]     iMaxParsedDigits = 10; [EOL]     iRejectSignedValues = false; [EOL]     iPrefix = null; [EOL]     if (iElementPairs == null) { [EOL]         iElementPairs = new ArrayList<Object>(); [EOL]     } else { [EOL]         iElementPairs.clear(); [EOL]     } [EOL]     iNotPrinter = false; [EOL]     iNotParser = false; [EOL]     iFieldFormatters = new FieldFormatter[10]; [EOL] }
public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) { [EOL]     if (printer == null && parser == null) { [EOL]         throw new IllegalArgumentException("No printer or parser supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(printer, parser); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     clearPrefix(); [EOL]     Literal literal = new Literal(text); [EOL]     append0(literal, literal); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     clearPrefix(); [EOL]     Literal literal = new Literal(text); [EOL]     append0(literal, literal); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder printZeroIfSupported() { [EOL]     iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendPrefix(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendPrefix(new SimpleAffix(text)); [EOL] }
public PeriodFormatterBuilder appendPrefix(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendPrefix(new SimpleAffix(text)); [EOL] }
public PeriodFormatterBuilder appendPrefix(String singularText, String pluralText) { [EOL]     if (singularText == null || pluralText == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendPrefix(new PluralAffix(singularText, pluralText)); [EOL] }
public PeriodFormatterBuilder appendWeeks() { [EOL]     appendField(WEEKS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSecondsWithMillis() { [EOL]     appendField(SECONDS_MILLIS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendMillis() { [EOL]     appendField(MILLIS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendMillis3Digit() { [EOL]     appendField(7, 3); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) { [EOL]     return appendSeparator(text, finalText, variants, true, true); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) { [EOL]     return appendSeparator(text, finalText, variants, true, true); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) { [EOL]     return appendSeparator(text, finalText, variants, true, true); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) { [EOL]     return appendSeparator(text, finalText, variants, true, true); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) { [EOL]     return appendSeparator(text, finalText, variants, true, true); [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
public void printTo(Writer out, int value) throws IOException { [EOL]     out.write(iText); [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(out, value); [EOL]     } [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.writeUnpaddedInteger(out, value); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             out.write('.'); [EOL]             FormatUtils.writePaddedInteger(out, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(out, value); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(out, value); [EOL]     } [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.writeUnpaddedInteger(out, value); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             out.write('.'); [EOL]             FormatUtils.writePaddedInteger(out, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(out, value); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(out, value); [EOL]     } [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.writeUnpaddedInteger(out, value); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             out.write('.'); [EOL]             FormatUtils.writePaddedInteger(out, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(out, value); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(out, value); [EOL]     } [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.writeUnpaddedInteger(out, value); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             out.write('.'); [EOL]             FormatUtils.writePaddedInteger(out, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(out, value); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(out, value); [EOL]     } [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.writeUnpaddedInteger(out, value); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             out.write('.'); [EOL]             FormatUtils.writePaddedInteger(out, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(out, value); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(out, value); [EOL]     } [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.writeUnpaddedInteger(out, value); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             out.write('.'); [EOL]             FormatUtils.writePaddedInteger(out, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(out, value); [EOL]     } [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
Literal(String text) { [EOL]     iText = text; [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     out.write(iText); [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     if (periodStr.regionMatches(true, position, iText, 0, iText.length())) { [EOL]         return position + iText.length(); [EOL]     } [EOL]     return ~position; [EOL] }
Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { [EOL]     iText = text; [EOL]     iFinalText = finalText; [EOL]     if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { [EOL]         iParsedForms = new String[] { text }; [EOL]     } else { [EOL]         TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); [EOL]         parsedSet.add(text); [EOL]         parsedSet.add(finalText); [EOL]         if (variants != null) { [EOL]             for (int i = variants.length; --i >= 0; ) { [EOL]                 parsedSet.add(variants[i]); [EOL]             } [EOL]         } [EOL]         ArrayList<String> parsedList = new ArrayList<String>(parsedSet); [EOL]         Collections.reverse(parsedList); [EOL]         iParsedForms = parsedList.toArray(new String[parsedList.size()]); [EOL]     } [EOL]     iBeforePrinter = beforePrinter; [EOL]     iBeforeParser = beforeParser; [EOL]     iUseBefore = useBefore; [EOL]     iUseAfter = useAfter; [EOL] }
Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { [EOL]     iText = text; [EOL]     iFinalText = finalText; [EOL]     if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { [EOL]         iParsedForms = new String[] { text }; [EOL]     } else { [EOL]         TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); [EOL]         parsedSet.add(text); [EOL]         parsedSet.add(finalText); [EOL]         if (variants != null) { [EOL]             for (int i = variants.length; --i >= 0; ) { [EOL]                 parsedSet.add(variants[i]); [EOL]             } [EOL]         } [EOL]         ArrayList<String> parsedList = new ArrayList<String>(parsedSet); [EOL]         Collections.reverse(parsedList); [EOL]         iParsedForms = parsedList.toArray(new String[parsedList.size()]); [EOL]     } [EOL]     iBeforePrinter = beforePrinter; [EOL]     iBeforeParser = beforeParser; [EOL]     iUseBefore = useBefore; [EOL]     iUseAfter = useAfter; [EOL] }
Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { [EOL]     iText = text; [EOL]     iFinalText = finalText; [EOL]     if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { [EOL]         iParsedForms = new String[] { text }; [EOL]     } else { [EOL]         TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); [EOL]         parsedSet.add(text); [EOL]         parsedSet.add(finalText); [EOL]         if (variants != null) { [EOL]             for (int i = variants.length; --i >= 0; ) { [EOL]                 parsedSet.add(variants[i]); [EOL]             } [EOL]         } [EOL]         ArrayList<String> parsedList = new ArrayList<String>(parsedSet); [EOL]         Collections.reverse(parsedList); [EOL]         iParsedForms = parsedList.toArray(new String[parsedList.size()]); [EOL]     } [EOL]     iBeforePrinter = beforePrinter; [EOL]     iBeforeParser = beforeParser; [EOL]     iUseBefore = useBefore; [EOL]     iUseAfter = useAfter; [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(out, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     out.write(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 out.write(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         out.write(iText); [EOL]     } [EOL]     after.printTo(out, period, locale); [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(out, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     out.write(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 out.write(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         out.write(iText); [EOL]     } [EOL]     after.printTo(out, period, locale); [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(out, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     out.write(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 out.write(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         out.write(iText); [EOL]     } [EOL]     after.printTo(out, period, locale); [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(out, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     out.write(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 out.write(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         out.write(iText); [EOL]     } [EOL]     after.printTo(out, period, locale); [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(out, period, locale); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(out, period, locale); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { [EOL]     PeriodPrinter[] printers = iPrinters; [EOL]     int len = printers.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         printers[i].printTo(out, period, locale); [EOL]     } [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     return set(instant, get(instant) + years); [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     return set(instant, get(instant) + years); [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     return set(instant, get(instant) + years); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public long roundFloor(long instant) { [EOL]     instant = iChronology.weekOfWeekyear().roundFloor(instant); [EOL]     int wow = iChronology.getWeekOfWeekyear(instant); [EOL]     if (wow > 1) { [EOL]         instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     instant = iChronology.weekOfWeekyear().roundFloor(instant); [EOL]     int wow = iChronology.getWeekOfWeekyear(instant); [EOL]     if (wow > 1) { [EOL]         instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1); [EOL]     } [EOL]     return instant; [EOL] }
public static DateTimeFormatter forStyle(String style) { [EOL]     return createFormatterForStyle(style); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter shortDateTime() { [EOL]     return createFormatterForStyleIndex(SHORT, SHORT); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter mediumDateTime() { [EOL]     return createFormatterForStyleIndex(MEDIUM, MEDIUM); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     int length = pattern.length(); [EOL]     int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         String token = parseToken(pattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 builder.appendEraText(); [EOL]                 break; [EOL]             case 'C': [EOL]                 builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]                 if (tokenLen == 2) { [EOL]                     boolean lenientParse = true; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             lenientParse = false; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL]                             break; [EOL]                         case 'y': [EOL]                         case 'Y': [EOL]                         default: [EOL]                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL]                             break; [EOL]                     } [EOL]                 } else { [EOL]                     int maxDigits = 9; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             maxDigits = tokenLen; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendWeekyear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'y': [EOL]                             builder.appendYear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'Y': [EOL]                             builder.appendYearOfEra(tokenLen, maxDigits); [EOL]                             break; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 3) { [EOL]                     if (tokenLen >= 4) { [EOL]                         builder.appendMonthOfYearText(); [EOL]                     } else { [EOL]                         builder.appendMonthOfYearShortText(); [EOL]                     } [EOL]                 } else { [EOL]                     builder.appendMonthOfYear(tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 builder.appendDayOfMonth(tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 builder.appendHalfdayOfDayText(); [EOL]                 break; [EOL]             case 'h': [EOL]                 builder.appendClockhourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'H': [EOL]                 builder.appendHourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'k': [EOL]                 builder.appendClockhourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'K': [EOL]                 builder.appendHourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 builder.appendMinuteOfHour(tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 builder.appendSecondOfMinute(tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'e': [EOL]                 builder.appendDayOfWeek(tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendDayOfWeekText(); [EOL]                 } else { [EOL]                     builder.appendDayOfWeekShortText(); [EOL]                 } [EOL]                 break; [EOL]             case 'D': [EOL]                 builder.appendDayOfYear(tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 builder.appendWeekOfWeekyear(tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendTimeZoneName(); [EOL]                 } else { [EOL]                     builder.appendTimeZoneShortName(null); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL]                 } else if (tokenLen == 2) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL]                 } else { [EOL]                     builder.appendTimeZoneId(); [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     builder.appendLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     builder.appendLiteral(new String(sub)); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) { [EOL]     int index = ((dateStyle << 2) + dateStyle) + timeStyle; [EOL]     if (index >= STYLE_CACHE.length) { [EOL]         return createDateTimeFormatter(dateStyle, timeStyle); [EOL]     } [EOL]     DateTimeFormatter f = null; [EOL]     synchronized (STYLE_CACHE) { [EOL]         f = STYLE_CACHE[index]; [EOL]         if (f == null) { [EOL]             f = createDateTimeFormatter(dateStyle, timeStyle); [EOL]             STYLE_CACHE[index] = f; [EOL]         } [EOL]     } [EOL]     return f; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL]     int type = DATETIME; [EOL]     if (dateStyle == NONE) { [EOL]         type = TIME; [EOL]     } else if (timeStyle == NONE) { [EOL]         type = DATE; [EOL]     } [EOL]     StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL]     return new DateTimeFormatter(llf, llf); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL]     int type = DATETIME; [EOL]     if (dateStyle == NONE) { [EOL]         type = TIME; [EOL]     } else if (timeStyle == NONE) { [EOL]         type = DATE; [EOL]     } [EOL]     StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL]     return new DateTimeFormatter(llf, llf); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL]     int type = DATETIME; [EOL]     if (dateStyle == NONE) { [EOL]         type = TIME; [EOL]     } else if (timeStyle == NONE) { [EOL]         type = DATE; [EOL]     } [EOL]     StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL]     return new DateTimeFormatter(llf, llf); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
StyleFormatter(int dateStyle, int timeStyle, int type) { [EOL]     super(); [EOL]     iDateStyle = dateStyle; [EOL]     iTimeStyle = timeStyle; [EOL]     iType = type; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public int estimatePrintedLength() { [EOL]     return 40; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     DateTimePrinter p = getFormatter(locale).getPrinter(); [EOL]     p.printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); [EOL]     return p.parseInto(bucket, text, position); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private DateTimeFormatter getFormatter(Locale locale) { [EOL]     locale = (locale == null ? Locale.getDefault() : locale); [EOL]     String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString(); [EOL]     DateTimeFormatter f = null; [EOL]     synchronized (cCache) { [EOL]         f = cCache.get(key); [EOL]         if (f == null) { [EOL]             String pattern = getPattern(locale); [EOL]             f = DateTimeFormat.forPattern(pattern); [EOL]             cCache.put(key, f); [EOL]         } [EOL]     } [EOL]     return f; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
String getPattern(Locale locale) { [EOL]     DateFormat f = null; [EOL]     switch(iType) { [EOL]         case DATE: [EOL]             f = DateFormat.getDateInstance(iDateStyle, locale); [EOL]             break; [EOL]         case TIME: [EOL]             f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL]             break; [EOL]         case DATETIME: [EOL]             f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL]             break; [EOL]     } [EOL]     if (f instanceof SimpleDateFormat == false) { [EOL]         throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL]     } [EOL]     return ((SimpleDateFormat) f).toPattern(); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
@FromString [EOL] public static Duration parse(String str) { [EOL]     return new Duration(str); [EOL] }
@FromString [EOL] public static Duration parse(String str) { [EOL]     return new Duration(str); [EOL] }
public static Duration standardMinutes(long minutes) { [EOL]     if (minutes == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE)); [EOL] }
public static Duration standardMinutes(long minutes) { [EOL]     if (minutes == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE)); [EOL] }
public static Duration standardMinutes(long minutes) { [EOL]     if (minutes == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE)); [EOL] }
public Duration(long duration) { [EOL]     super(duration); [EOL] }
public long getStandardHours() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_HOUR; [EOL] }
public long getStandardHours() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_HOUR; [EOL] }
public long getStandardMinutes() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE; [EOL] }
public long getStandardMinutes() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE; [EOL] }
public long getStandardMinutes() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE; [EOL] }
public Hours toStandardHours() { [EOL]     long hours = getStandardHours(); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     long hours = getStandardHours(); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Hours toStandardHours() { [EOL]     long hours = getStandardHours(); [EOL]     return Hours.hours(FieldUtils.safeToInt(hours)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     long minutes = getStandardMinutes(); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     long minutes = getStandardMinutes(); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     long minutes = getStandardMinutes(); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Duration withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(durationToAdd, scalar); [EOL]     long duration = FieldUtils.safeAdd(getMillis(), add); [EOL]     return new Duration(duration); [EOL] }
public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public Duration minus(long amount) { [EOL]     return withDurationAdded(amount, -1); [EOL] }
public Duration minus(long amount) { [EOL]     return withDurationAdded(amount, -1); [EOL] }
public Duration minus(long amount) { [EOL]     return withDurationAdded(amount, -1); [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value == 0) { [EOL]         value = getMaximumValue(); [EOL]     } [EOL]     return value; [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value == 0) { [EOL]         value = getMaximumValue(); [EOL]     } [EOL]     return value; [EOL] }
public long set(long instant, int value) { [EOL]     int max = getMaximumValue(); [EOL]     FieldUtils.verifyValueBounds(this, value, 1, max); [EOL]     if (value == max) { [EOL]         value = 0; [EOL]     } [EOL]     return getWrappedField().set(instant, value); [EOL] }
public long set(long instant, int value) { [EOL]     int max = getMaximumValue(); [EOL]     FieldUtils.verifyValueBounds(this, value, 1, max); [EOL]     if (value == max) { [EOL]         value = 0; [EOL]     } [EOL]     return getWrappedField().set(instant, value); [EOL] }
public long set(long instant, int value) { [EOL]     int max = getMaximumValue(); [EOL]     FieldUtils.verifyValueBounds(this, value, 1, max); [EOL]     if (value == max) { [EOL]         value = 0; [EOL]     } [EOL]     return getWrappedField().set(instant, value); [EOL] }
public long roundFloor(long instant) { [EOL]     return getWrappedField().roundFloor(instant); [EOL] }
public static DateTimeZone readFrom(InputStream in, String id) throws IOException { [EOL]     if (in instanceof DataInput) { [EOL]         return readFrom((DataInput) in, id); [EOL]     } else { [EOL]         return readFrom((DataInput) new DataInputStream(in), id); [EOL]     } [EOL] }
public static DateTimeZone readFrom(InputStream in, String id) throws IOException { [EOL]     if (in instanceof DataInput) { [EOL]         return readFrom((DataInput) in, id); [EOL]     } else { [EOL]         return readFrom((DataInput) new DataInputStream(in), id); [EOL]     } [EOL] }
public static DateTimeZone readFrom(DataInput in, String id) throws IOException { [EOL]     switch(in.readUnsignedByte()) { [EOL]         case 'F': [EOL]             DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in)); [EOL]             if (fixed.equals(DateTimeZone.UTC)) { [EOL]                 fixed = DateTimeZone.UTC; [EOL]             } [EOL]             return fixed; [EOL]         case 'C': [EOL]             return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id)); [EOL]         case 'P': [EOL]             return PrecalculatedZone.readFrom(in, id); [EOL]         default: [EOL]             throw new IOException("Invalid encoding"); [EOL]     } [EOL] }
public static DateTimeZone readFrom(DataInput in, String id) throws IOException { [EOL]     switch(in.readUnsignedByte()) { [EOL]         case 'F': [EOL]             DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in)); [EOL]             if (fixed.equals(DateTimeZone.UTC)) { [EOL]                 fixed = DateTimeZone.UTC; [EOL]             } [EOL]             return fixed; [EOL]         case 'C': [EOL]             return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id)); [EOL]         case 'P': [EOL]             return PrecalculatedZone.readFrom(in, id); [EOL]         default: [EOL]             throw new IOException("Invalid encoding"); [EOL]     } [EOL] }
public static DateTimeZone readFrom(DataInput in, String id) throws IOException { [EOL]     switch(in.readUnsignedByte()) { [EOL]         case 'F': [EOL]             DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in)); [EOL]             if (fixed.equals(DateTimeZone.UTC)) { [EOL]                 fixed = DateTimeZone.UTC; [EOL]             } [EOL]             return fixed; [EOL]         case 'C': [EOL]             return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id)); [EOL]         case 'P': [EOL]             return PrecalculatedZone.readFrom(in, id); [EOL]         default: [EOL]             throw new IOException("Invalid encoding"); [EOL]     } [EOL] }
public static DateTimeZone readFrom(DataInput in, String id) throws IOException { [EOL]     switch(in.readUnsignedByte()) { [EOL]         case 'F': [EOL]             DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in)); [EOL]             if (fixed.equals(DateTimeZone.UTC)) { [EOL]                 fixed = DateTimeZone.UTC; [EOL]             } [EOL]             return fixed; [EOL]         case 'C': [EOL]             return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id)); [EOL]         case 'P': [EOL]             return PrecalculatedZone.readFrom(in, id); [EOL]         default: [EOL]             throw new IOException("Invalid encoding"); [EOL]     } [EOL] }
static long readMillis(DataInput in) throws IOException { [EOL]     int v = in.readUnsignedByte(); [EOL]     switch(v >> 6) { [EOL]         case 0: [EOL]         default: [EOL]             v = (v << (32 - 6)) >> (32 - 6); [EOL]             return v * (30 * 60000L); [EOL]         case 1: [EOL]             v = (v << (32 - 6)) >> (32 - 30); [EOL]             v |= (in.readUnsignedByte()) << 16; [EOL]             v |= (in.readUnsignedByte()) << 8; [EOL]             v |= (in.readUnsignedByte()); [EOL]             return v * 60000L; [EOL]         case 2: [EOL]             long w = (((long) v) << (64 - 6)) >> (64 - 38); [EOL]             w |= (in.readUnsignedByte()) << 24; [EOL]             w |= (in.readUnsignedByte()) << 16; [EOL]             w |= (in.readUnsignedByte()) << 8; [EOL]             w |= (in.readUnsignedByte()); [EOL]             return w * 1000L; [EOL]         case 3: [EOL]             return in.readLong(); [EOL]     } [EOL] }
static long readMillis(DataInput in) throws IOException { [EOL]     int v = in.readUnsignedByte(); [EOL]     switch(v >> 6) { [EOL]         case 0: [EOL]         default: [EOL]             v = (v << (32 - 6)) >> (32 - 6); [EOL]             return v * (30 * 60000L); [EOL]         case 1: [EOL]             v = (v << (32 - 6)) >> (32 - 30); [EOL]             v |= (in.readUnsignedByte()) << 16; [EOL]             v |= (in.readUnsignedByte()) << 8; [EOL]             v |= (in.readUnsignedByte()); [EOL]             return v * 60000L; [EOL]         case 2: [EOL]             long w = (((long) v) << (64 - 6)) >> (64 - 38); [EOL]             w |= (in.readUnsignedByte()) << 24; [EOL]             w |= (in.readUnsignedByte()) << 16; [EOL]             w |= (in.readUnsignedByte()) << 8; [EOL]             w |= (in.readUnsignedByte()); [EOL]             return w * 1000L; [EOL]         case 3: [EOL]             return in.readLong(); [EOL]     } [EOL] }
static long readMillis(DataInput in) throws IOException { [EOL]     int v = in.readUnsignedByte(); [EOL]     switch(v >> 6) { [EOL]         case 0: [EOL]         default: [EOL]             v = (v << (32 - 6)) >> (32 - 6); [EOL]             return v * (30 * 60000L); [EOL]         case 1: [EOL]             v = (v << (32 - 6)) >> (32 - 30); [EOL]             v |= (in.readUnsignedByte()) << 16; [EOL]             v |= (in.readUnsignedByte()) << 8; [EOL]             v |= (in.readUnsignedByte()); [EOL]             return v * 60000L; [EOL]         case 2: [EOL]             long w = (((long) v) << (64 - 6)) >> (64 - 38); [EOL]             w |= (in.readUnsignedByte()) << 24; [EOL]             w |= (in.readUnsignedByte()) << 16; [EOL]             w |= (in.readUnsignedByte()) << 8; [EOL]             w |= (in.readUnsignedByte()); [EOL]             return w * 1000L; [EOL]         case 3: [EOL]             return in.readLong(); [EOL]     } [EOL] }
static long readMillis(DataInput in) throws IOException { [EOL]     int v = in.readUnsignedByte(); [EOL]     switch(v >> 6) { [EOL]         case 0: [EOL]         default: [EOL]             v = (v << (32 - 6)) >> (32 - 6); [EOL]             return v * (30 * 60000L); [EOL]         case 1: [EOL]             v = (v << (32 - 6)) >> (32 - 30); [EOL]             v |= (in.readUnsignedByte()) << 16; [EOL]             v |= (in.readUnsignedByte()) << 8; [EOL]             v |= (in.readUnsignedByte()); [EOL]             return v * 60000L; [EOL]         case 2: [EOL]             long w = (((long) v) << (64 - 6)) >> (64 - 38); [EOL]             w |= (in.readUnsignedByte()) << 24; [EOL]             w |= (in.readUnsignedByte()) << 16; [EOL]             w |= (in.readUnsignedByte()) << 8; [EOL]             w |= (in.readUnsignedByte()); [EOL]             return w * 1000L; [EOL]         case 3: [EOL]             return in.readLong(); [EOL]     } [EOL] }
static OfYear readFrom(DataInput in) throws IOException { [EOL]     return new OfYear((char) in.readUnsignedByte(), (int) in.readUnsignedByte(), (int) in.readByte(), (int) in.readUnsignedByte(), in.readBoolean(), (int) readMillis(in)); [EOL] }
static OfYear readFrom(DataInput in) throws IOException { [EOL]     return new OfYear((char) in.readUnsignedByte(), (int) in.readUnsignedByte(), (int) in.readByte(), (int) in.readUnsignedByte(), in.readBoolean(), (int) readMillis(in)); [EOL] }
static Recurrence readFrom(DataInput in) throws IOException { [EOL]     return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int) readMillis(in)); [EOL] }
static Recurrence readFrom(DataInput in) throws IOException { [EOL]     return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int) readMillis(in)); [EOL] }
static DSTZone readFrom(DataInput in, String id) throws IOException { [EOL]     return new DSTZone(id, (int) readMillis(in), Recurrence.readFrom(in), Recurrence.readFrom(in)); [EOL] }
static PrecalculatedZone readFrom(DataInput in, String id) throws IOException { [EOL]     int poolSize = in.readUnsignedShort(); [EOL]     String[] pool = new String[poolSize]; [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         pool[i] = in.readUTF(); [EOL]     } [EOL]     int size = in.readInt(); [EOL]     long[] transitions = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         transitions[i] = readMillis(in); [EOL]         wallOffsets[i] = (int) readMillis(in); [EOL]         standardOffsets[i] = (int) readMillis(in); [EOL]         try { [EOL]             int index; [EOL]             if (poolSize < 256) { [EOL]                 index = in.readUnsignedByte(); [EOL]             } else { [EOL]                 index = in.readUnsignedShort(); [EOL]             } [EOL]             nameKeys[i] = pool[index]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IOException("Invalid encoding"); [EOL]         } [EOL]     } [EOL]     DSTZone tailZone = null; [EOL]     if (in.readBoolean()) { [EOL]         tailZone = DSTZone.readFrom(in, id); [EOL]     } [EOL]     return new PrecalculatedZone(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] }
static PrecalculatedZone readFrom(DataInput in, String id) throws IOException { [EOL]     int poolSize = in.readUnsignedShort(); [EOL]     String[] pool = new String[poolSize]; [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         pool[i] = in.readUTF(); [EOL]     } [EOL]     int size = in.readInt(); [EOL]     long[] transitions = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         transitions[i] = readMillis(in); [EOL]         wallOffsets[i] = (int) readMillis(in); [EOL]         standardOffsets[i] = (int) readMillis(in); [EOL]         try { [EOL]             int index; [EOL]             if (poolSize < 256) { [EOL]                 index = in.readUnsignedByte(); [EOL]             } else { [EOL]                 index = in.readUnsignedShort(); [EOL]             } [EOL]             nameKeys[i] = pool[index]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IOException("Invalid encoding"); [EOL]         } [EOL]     } [EOL]     DSTZone tailZone = null; [EOL]     if (in.readBoolean()) { [EOL]         tailZone = DSTZone.readFrom(in, id); [EOL]     } [EOL]     return new PrecalculatedZone(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] }
static PrecalculatedZone readFrom(DataInput in, String id) throws IOException { [EOL]     int poolSize = in.readUnsignedShort(); [EOL]     String[] pool = new String[poolSize]; [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         pool[i] = in.readUTF(); [EOL]     } [EOL]     int size = in.readInt(); [EOL]     long[] transitions = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         transitions[i] = readMillis(in); [EOL]         wallOffsets[i] = (int) readMillis(in); [EOL]         standardOffsets[i] = (int) readMillis(in); [EOL]         try { [EOL]             int index; [EOL]             if (poolSize < 256) { [EOL]                 index = in.readUnsignedByte(); [EOL]             } else { [EOL]                 index = in.readUnsignedShort(); [EOL]             } [EOL]             nameKeys[i] = pool[index]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IOException("Invalid encoding"); [EOL]         } [EOL]     } [EOL]     DSTZone tailZone = null; [EOL]     if (in.readBoolean()) { [EOL]         tailZone = DSTZone.readFrom(in, id); [EOL]     } [EOL]     return new PrecalculatedZone(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] }
static PrecalculatedZone readFrom(DataInput in, String id) throws IOException { [EOL]     int poolSize = in.readUnsignedShort(); [EOL]     String[] pool = new String[poolSize]; [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         pool[i] = in.readUTF(); [EOL]     } [EOL]     int size = in.readInt(); [EOL]     long[] transitions = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         transitions[i] = readMillis(in); [EOL]         wallOffsets[i] = (int) readMillis(in); [EOL]         standardOffsets[i] = (int) readMillis(in); [EOL]         try { [EOL]             int index; [EOL]             if (poolSize < 256) { [EOL]                 index = in.readUnsignedByte(); [EOL]             } else { [EOL]                 index = in.readUnsignedShort(); [EOL]             } [EOL]             nameKeys[i] = pool[index]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IOException("Invalid encoding"); [EOL]         } [EOL]     } [EOL]     DSTZone tailZone = null; [EOL]     if (in.readBoolean()) { [EOL]         tailZone = DSTZone.readFrom(in, id); [EOL]     } [EOL]     return new PrecalculatedZone(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] }
public boolean isFixed() { [EOL]     return false; [EOL] }
public static CachedDateTimeZone forZone(DateTimeZone zone) { [EOL]     if (zone instanceof CachedDateTimeZone) { [EOL]         return (CachedDateTimeZone) zone; [EOL]     } [EOL]     return new CachedDateTimeZone(zone); [EOL] }
public static CachedDateTimeZone forZone(DateTimeZone zone) { [EOL]     if (zone instanceof CachedDateTimeZone) { [EOL]         return (CachedDateTimeZone) zone; [EOL]     } [EOL]     return new CachedDateTimeZone(zone); [EOL] }
private CachedDateTimeZone(DateTimeZone zone) { [EOL]     super(zone.getID()); [EOL]     iZone = zone; [EOL] }
public boolean isFixed() { [EOL]     return iZone.isFixed(); [EOL] }
public boolean isFixed() { [EOL]     return iZone.isFixed(); [EOL] }
public int getOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iOffset == Integer.MIN_VALUE) { [EOL]             iOffset = iZoneRef.getOffset(iPeriodStart); [EOL]         } [EOL]         return iOffset; [EOL]     } [EOL]     return iNextInfo.getOffset(millis); [EOL] }
public int getOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iOffset == Integer.MIN_VALUE) { [EOL]             iOffset = iZoneRef.getOffset(iPeriodStart); [EOL]         } [EOL]         return iOffset; [EOL]     } [EOL]     return iNextInfo.getOffset(millis); [EOL] }
public int getOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iOffset == Integer.MIN_VALUE) { [EOL]             iOffset = iZoneRef.getOffset(iPeriodStart); [EOL]         } [EOL]         return iOffset; [EOL]     } [EOL]     return iNextInfo.getOffset(millis); [EOL] }
public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) { [EOL]     super(field, type); [EOL]     if (scalar == 0 || scalar == 1) { [EOL]         throw new IllegalArgumentException("The scalar must not be 0 or 1"); [EOL]     } [EOL]     iScalar = scalar; [EOL] }
public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) { [EOL]     super(field, type); [EOL]     if (scalar == 0 || scalar == 1) { [EOL]         throw new IllegalArgumentException("The scalar must not be 0 or 1"); [EOL]     } [EOL]     iScalar = scalar; [EOL] }
public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) { [EOL]     super(field, type); [EOL]     if (scalar == 0 || scalar == 1) { [EOL]         throw new IllegalArgumentException("The scalar must not be 0 or 1"); [EOL]     } [EOL]     iScalar = scalar; [EOL] }
public long getMillis(int value) { [EOL]     long scaled = ((long) value) * ((long) iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(int value) { [EOL]     long scaled = ((long) value) * ((long) iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(int value) { [EOL]     long scaled = ((long) value) * ((long) iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(int value, long instant) { [EOL]     long scaled = ((long) value) * ((long) iScalar); [EOL]     return getWrappedField().getMillis(scaled, instant); [EOL] }
public int hashCode() { [EOL]     long scalar = iScalar; [EOL]     int hash = (int) (scalar ^ (scalar >>> 32)); [EOL]     hash += getType().hashCode(); [EOL]     hash += getWrappedField().hashCode(); [EOL]     return hash; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
protected BaseDurationField(DurationFieldType type) { [EOL]     super(); [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The type must not be null"); [EOL]     } [EOL]     iType = type; [EOL] }
protected BaseDurationField(DurationFieldType type) { [EOL]     super(); [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The type must not be null"); [EOL]     } [EOL]     iType = type; [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     Date date = (Date) object; [EOL]     return date.getTime(); [EOL] }
public Class<?> getSupportedType() { [EOL]     return Date.class; [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months monthsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.months()); [EOL]     return Months.months(amount); [EOL] }
public static Months monthsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.months()); [EOL]     return Months.months(amount); [EOL] }
public static Months monthsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int months = chrono.months().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Months.months(months); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Months.months(amount); [EOL] }
public static Months monthsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int months = chrono.months().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Months.months(months); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Months.months(amount); [EOL] }
public static Months monthsIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Months.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months()); [EOL]     return Months.months(amount); [EOL] }
public static Months monthsIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Months.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months()); [EOL]     return Months.months(amount); [EOL] }
public Months negated() { [EOL]     return Months.months(FieldUtils.safeNegate(getValue())); [EOL] }
public Months negated() { [EOL]     return Months.months(FieldUtils.safeNegate(getValue())); [EOL] }
public Months negated() { [EOL]     return Months.months(FieldUtils.safeNegate(getValue())); [EOL] }
public Months negated() { [EOL]     return Months.months(FieldUtils.safeNegate(getValue())); [EOL] }
public boolean isGreaterThan(Months other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public Interval(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public Interval(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public Interval(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public Interval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Interval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Interval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Interval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Interval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Interval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(start, duration); [EOL] }
public Interval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(start, duration); [EOL] }
public Interval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(start, duration); [EOL] }
public Interval(ReadableDuration duration, ReadableInstant end) { [EOL]     super(duration, end); [EOL] }
public Interval(ReadableDuration duration, ReadableInstant end) { [EOL]     super(duration, end); [EOL] }
public Interval(ReadableDuration duration, ReadableInstant end) { [EOL]     super(duration, end); [EOL] }
public Interval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(start, period); [EOL] }
public Interval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(start, period); [EOL] }
public Interval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(period, end); [EOL] }
public Interval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(period, end); [EOL] }
public Interval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(period, end); [EOL] }
public Interval toInterval() { [EOL]     return this; [EOL] }
public Interval withEndMillis(long endInstant) { [EOL]     if (endInstant == getEndMillis()) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(getStartMillis(), endInstant, getChronology()); [EOL] }
public Interval withPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationBeforeEnd(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(period, endMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationBeforeEnd(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(period, endMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
YearMonth(YearMonth partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonth newYearMonth = new YearMonth(this, newChronology); [EOL]         newChronology.validate(newYearMonth, getValues()); [EOL]         return newYearMonth; [EOL]     } [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonth newYearMonth = new YearMonth(this, newChronology); [EOL]         newChronology.validate(newYearMonth, getValues()); [EOL]         return newYearMonth; [EOL]     } [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth addToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public final DateTimeFieldType getType() { [EOL]     return iType; [EOL] }
public String getAsText(long instant, Locale locale) { [EOL]     return getAsText(get(instant), locale); [EOL] }
public final String getAsText(long instant) { [EOL]     return getAsText(instant, null); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return Integer.toString(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return Integer.toString(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return Integer.toString(fieldValue); [EOL] }
public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) { [EOL]     return getAsShortText(fieldValue, locale); [EOL] }
public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) { [EOL]     return getAsShortText(fieldValue, locale); [EOL] }
public final String getAsShortText(ReadablePartial partial, Locale locale) { [EOL]     return getAsShortText(partial, partial.get(getType()), locale); [EOL] }
public final String getAsShortText(ReadablePartial partial, Locale locale) { [EOL]     return getAsShortText(partial, partial.get(getType()), locale); [EOL] }
public final String getAsShortText(ReadablePartial partial, Locale locale) { [EOL]     return getAsShortText(partial, partial.get(getType()), locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return getAsText(fieldValue, locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return getAsText(fieldValue, locale); [EOL] }
public long add(long instant, long value) { [EOL]     return getDurationField().add(instant, value); [EOL] }
public final long set(long instant, String text) { [EOL]     return set(instant, text, null); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     try { [EOL]         return Integer.parseInt(text); [EOL]     } catch (NumberFormatException ex) { [EOL]         throw new IllegalFieldValueException(getType(), text); [EOL]     } [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     try { [EOL]         return Integer.parseInt(text); [EOL]     } catch (NumberFormatException ex) { [EOL]         throw new IllegalFieldValueException(getType(), text); [EOL]     } [EOL] }
public int getMinimumValue(long instant) { [EOL]     return getMinimumValue(); [EOL] }
public long roundHalfCeiling(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffToCeiling <= diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         return floor; [EOL]     } [EOL] }
public long roundHalfCeiling(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffToCeiling <= diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         return floor; [EOL]     } [EOL] }
public long roundHalfCeiling(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffToCeiling <= diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         return floor; [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writePaddedInteger(Writer out, int value, int size) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 out.write('0'); [EOL]             } [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             out.write('0'); [EOL]         } [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writeUnpaddedInteger(Writer out, int value) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writeUnpaddedInteger(Writer out, int value) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writeUnpaddedInteger(Writer out, int value) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writeUnpaddedInteger(Writer out, int value) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static void writeUnpaddedInteger(Writer out, int value) throws IOException { [EOL]     if (value < 0) { [EOL]         out.write('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             out.write("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         out.write(value + '0'); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         out.write(d + '0'); [EOL]         out.write(value - (d << 3) - (d << 1) + '0'); [EOL]     } else { [EOL]         out.write(Integer.toString(value)); [EOL]     } [EOL] }
public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     JulianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         JulianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new JulianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new JulianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] }
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] }
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] }
long getAverageMillisPerYear() { [EOL]     return MILLIS_PER_YEAR; [EOL] }
long getAverageMillisPerMonth() { [EOL]     return MILLIS_PER_MONTH; [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]     } [EOL] }
public static synchronized BuddhistChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     BuddhistChronology chrono; [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null); [EOL]             DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]             chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), ""); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized BuddhistChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     BuddhistChronology chrono; [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null); [EOL]             DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]             chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), ""); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
private BuddhistChronology(Chronology base, Object param) { [EOL]     super(base, param); [EOL] }
public String toString() { [EOL]     String str = "BuddhistChronology"; [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         str = str + '[' + zone.getID() + ']'; [EOL]     } [EOL]     return str; [EOL] }
public String toString() { [EOL]     String str = "BuddhistChronology"; [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         str = str + '[' + zone.getID() + ']'; [EOL]     } [EOL]     return str; [EOL] }
BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) { [EOL]     super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth()); [EOL]     iChronology = chronology; [EOL]     iMax = iChronology.getMaxMonth(); [EOL]     iLeapMonth = leapMonth; [EOL] }
BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) { [EOL]     super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth()); [EOL]     iChronology = chronology; [EOL]     iMax = iChronology.getMaxMonth(); [EOL]     iLeapMonth = leapMonth; [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public DurationField getLeapDurationField() { [EOL]     return iChronology.days(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.year()) { [EOL]             int year = values[i]; [EOL]             return iChronology.getDaysInYear(year); [EOL]         } [EOL]     } [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.year()) { [EOL]             int year = values[i]; [EOL]             return iChronology.getDaysInYear(year); [EOL]         } [EOL]     } [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.year()) { [EOL]             int year = values[i]; [EOL]             return iChronology.getDaysInYear(year); [EOL]         } [EOL]     } [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public static int safeNegate(int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("Integer.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return -value; [EOL] }
public static int safeNegate(int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("Integer.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return -value; [EOL] }
public static int safeNegate(int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("Integer.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return -value; [EOL] }
public static int safeNegate(int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("Integer.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return -value; [EOL] }
public static long safeMultiply(long val1, int val2) { [EOL]     switch(val2) { [EOL]         case -1: [EOL]             if (val1 == Long.MIN_VALUE) { [EOL]                 throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]             } [EOL]             return -val1; [EOL]         case 0: [EOL]             return 0L; [EOL]         case 1: [EOL]             return val1; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, int val2) { [EOL]     switch(val2) { [EOL]         case -1: [EOL]             if (val1 == Long.MIN_VALUE) { [EOL]                 throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]             } [EOL]             return -val1; [EOL]         case 0: [EOL]             return 0L; [EOL]         case 1: [EOL]             return val1; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, int val2) { [EOL]     switch(val2) { [EOL]         case -1: [EOL]             if (val1 == Long.MIN_VALUE) { [EOL]                 throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]             } [EOL]             return -val1; [EOL]         case 0: [EOL]             return 0L; [EOL]         case 1: [EOL]             return val1; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, int val2) { [EOL]     switch(val2) { [EOL]         case -1: [EOL]             if (val1 == Long.MIN_VALUE) { [EOL]                 throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]             } [EOL]             return -val1; [EOL]         case 0: [EOL]             return 0L; [EOL]         case 1: [EOL]             return val1; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, int val2) { [EOL]     switch(val2) { [EOL]         case -1: [EOL]             if (val1 == Long.MIN_VALUE) { [EOL]                 throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]             } [EOL]             return -val1; [EOL]         case 0: [EOL]             return 0L; [EOL]         case 1: [EOL]             return val1; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, int val2) { [EOL]     switch(val2) { [EOL]         case -1: [EOL]             if (val1 == Long.MIN_VALUE) { [EOL]                 throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]             } [EOL]             return -val1; [EOL]         case 0: [EOL]             return 0L; [EOL]         case 1: [EOL]             return val1; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static int getWrappedValue(int currentValue, int wrapValue, int minValue, int maxValue) { [EOL]     return getWrappedValue(currentValue + wrapValue, minValue, maxValue); [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter getIntervalConverter(Object object) { [EOL]     IntervalConverter converter = (IntervalConverter) iIntervalConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No interval converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public IntervalConverter getIntervalConverter(Object object) { [EOL]     IntervalConverter converter = (IntervalConverter) iIntervalConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No interval converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public int getMinimumValue() { [EOL]     return iField.getMinimumValue(); [EOL] }
private Object readResolve() { [EOL]     return getInstance(iLowerLimit, iUpperLimit); [EOL] }
protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) { [EOL]     if (period == null) { [EOL]         return 0; [EOL]     } [EOL]     Chronology iso = ISOChronology.getInstanceUTC(); [EOL]     long duration = 0L; [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         int value = period.getValue(i); [EOL]         if (value != 0) { [EOL]             DurationField field = period.getFieldType(i).getField(iso); [EOL]             if (field.isPrecise() == false) { [EOL]                 throw new IllegalArgumentException("Cannot convert period to duration as " + field.getName() + " is not precise in the period " + period); [EOL]             } [EOL]             duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value)); [EOL]         } [EOL]     } [EOL]     return FieldUtils.safeToInt(duration / millisPerUnit); [EOL] }
public Chronology withUTC() { [EOL]     if (iWithUTC == null) { [EOL]         if (getZone() == DateTimeZone.UTC) { [EOL]             iWithUTC = this; [EOL]         } else { [EOL]             iWithUTC = StrictChronology.getInstance(getBase().withUTC()); [EOL]         } [EOL]     } [EOL]     return iWithUTC; [EOL] }
public Chronology withUTC() { [EOL]     if (iWithUTC == null) { [EOL]         if (getZone() == DateTimeZone.UTC) { [EOL]             iWithUTC = this; [EOL]         } else { [EOL]             iWithUTC = StrictChronology.getInstance(getBase().withUTC()); [EOL]         } [EOL]     } [EOL]     return iWithUTC; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StrictChronology == false) { [EOL]         return false; [EOL]     } [EOL]     StrictChronology chrono = (StrictChronology) obj; [EOL]     return getBase().equals(chrono.getBase()); [EOL] }
public int hashCode() { [EOL]     return 352831696 + getBase().hashCode() * 7; [EOL] }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
private Seconds(int seconds) { [EOL]     super(seconds); [EOL] }
private Object readResolve() { [EOL]     return Seconds.seconds(getValue()); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE); [EOL] }
public Duration toStandardDuration() { [EOL]     long seconds = getValue(); [EOL]     return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND); [EOL] }
public Duration toStandardDuration() { [EOL]     long seconds = getValue(); [EOL]     return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND); [EOL] }
public Duration toStandardDuration() { [EOL]     long seconds = getValue(); [EOL]     return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND); [EOL] }
public Seconds plus(Seconds seconds) { [EOL]     if (seconds == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(seconds.getValue()); [EOL] }
public Seconds plus(Seconds seconds) { [EOL]     if (seconds == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(seconds.getValue()); [EOL] }
public Seconds multipliedBy(int scalar) { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Seconds multipliedBy(int scalar) { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Seconds multipliedBy(int scalar) { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Seconds multipliedBy(int scalar) { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Seconds dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Seconds.seconds(getValue() / divisor); [EOL] }
public Seconds dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Seconds.seconds(getValue() / divisor); [EOL] }
public Seconds dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Seconds.seconds(getValue() / divisor); [EOL] }
public Seconds dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Seconds.seconds(getValue() / divisor); [EOL] }
public Seconds negated() { [EOL]     return Seconds.seconds(FieldUtils.safeNegate(getValue())); [EOL] }
public Seconds negated() { [EOL]     return Seconds.seconds(FieldUtils.safeNegate(getValue())); [EOL] }
public Seconds negated() { [EOL]     return Seconds.seconds(FieldUtils.safeNegate(getValue())); [EOL] }
public boolean isGreaterThan(Seconds other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
protected void assemble(Fields fields) { [EOL]     HashMap<Object, Object> converted = new HashMap<Object, Object>(); [EOL]     fields.eras = convertField(fields.eras, converted); [EOL]     fields.centuries = convertField(fields.centuries, converted); [EOL]     fields.years = convertField(fields.years, converted); [EOL]     fields.months = convertField(fields.months, converted); [EOL]     fields.weekyears = convertField(fields.weekyears, converted); [EOL]     fields.weeks = convertField(fields.weeks, converted); [EOL]     fields.days = convertField(fields.days, converted); [EOL]     fields.halfdays = convertField(fields.halfdays, converted); [EOL]     fields.hours = convertField(fields.hours, converted); [EOL]     fields.minutes = convertField(fields.minutes, converted); [EOL]     fields.seconds = convertField(fields.seconds, converted); [EOL]     fields.millis = convertField(fields.millis, converted); [EOL]     fields.year = convertField(fields.year, converted); [EOL]     fields.yearOfEra = convertField(fields.yearOfEra, converted); [EOL]     fields.yearOfCentury = convertField(fields.yearOfCentury, converted); [EOL]     fields.centuryOfEra = convertField(fields.centuryOfEra, converted); [EOL]     fields.era = convertField(fields.era, converted); [EOL]     fields.dayOfWeek = convertField(fields.dayOfWeek, converted); [EOL]     fields.dayOfMonth = convertField(fields.dayOfMonth, converted); [EOL]     fields.dayOfYear = convertField(fields.dayOfYear, converted); [EOL]     fields.monthOfYear = convertField(fields.monthOfYear, converted); [EOL]     fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); [EOL]     fields.weekyear = convertField(fields.weekyear, converted); [EOL]     fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); [EOL]     fields.millisOfSecond = convertField(fields.millisOfSecond, converted); [EOL]     fields.millisOfDay = convertField(fields.millisOfDay, converted); [EOL]     fields.secondOfMinute = convertField(fields.secondOfMinute, converted); [EOL]     fields.secondOfDay = convertField(fields.secondOfDay, converted); [EOL]     fields.minuteOfHour = convertField(fields.minuteOfHour, converted); [EOL]     fields.minuteOfDay = convertField(fields.minuteOfDay, converted); [EOL]     fields.hourOfDay = convertField(fields.hourOfDay, converted); [EOL]     fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); [EOL]     fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); [EOL]     fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); [EOL]     fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     LimitDurationField limitField = new LimitDurationField(field); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     LimitDurationField limitField = new LimitDurationField(field); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     LimitDurationField limitField = new LimitDurationField(field); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     LimitDurationField limitField = new LimitDurationField(field); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     LimitDateTimeField limitField = new LimitDateTimeField(field, convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     LimitDateTimeField limitField = new LimitDateTimeField(field, convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     LimitDateTimeField limitField = new LimitDateTimeField(field, convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     LimitDateTimeField limitField = new LimitDateTimeField(field, convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, limitField); [EOL]     return limitField; [EOL] }
LimitDurationField(DurationField field) { [EOL]     super(field, field.getType()); [EOL] }
LimitDurationField(DurationField field) { [EOL]     super(field, field.getType()); [EOL] }
LimitDateTimeField(DateTimeField field, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { [EOL]     super(field, field.getType()); [EOL]     iDurationField = durationField; [EOL]     iRangeDurationField = rangeDurationField; [EOL]     iLeapDurationField = leapDurationField; [EOL] }
public String getAsText(long instant, Locale locale) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getAsText(instant, locale); [EOL] }
public final DurationField getDurationField() { [EOL]     return iDurationField; [EOL] }
public final DurationField getRangeDurationField() { [EOL]     return iRangeDurationField; [EOL] }
public boolean isLeap(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().isLeap(instant); [EOL] }
public boolean isLeap(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().isLeap(instant); [EOL] }
public final DurationField getLeapDurationField() { [EOL]     return iLeapDurationField; [EOL] }
public int getMaximumValue(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getMaximumValue(instant); [EOL] }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] }
public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) { [EOL]     super(type); [EOL]     iUnitMillis = unitMillis; [EOL]     iDurationField = new LinkedDurationField(type.getDurationType()); [EOL] }
LinkedDurationField(DurationFieldType type) { [EOL]     super(type); [EOL] }
public long getUnitMillis() { [EOL]     return iUnitMillis; [EOL] }
public Weeks minus(Weeks weeks) { [EOL]     if (weeks == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(weeks.getValue()); [EOL] }
public Weeks minus(Weeks weeks) { [EOL]     if (weeks == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(weeks.getValue()); [EOL] }
public Weeks dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Weeks.weeks(getValue() / divisor); [EOL] }
public Weeks dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Weeks.weeks(getValue() / divisor); [EOL] }
public Weeks dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Weeks.weeks(getValue() / divisor); [EOL] }
public Weeks dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Weeks.weeks(getValue() / divisor); [EOL] }
public boolean isLessThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Weeks other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text); [EOL] }
public DateTime(Chronology chronology) { [EOL]     super(chronology); [EOL] }
public DateTime(Chronology chronology) { [EOL]     super(chronology); [EOL] }
public DateTime(long instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateTime(long instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public DateTime toDateTime() { [EOL]     return this; [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime plus(long duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public DateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
@Deprecated [EOL] public YearMonthDay toYearMonthDay() { [EOL]     return new YearMonthDay(getMillis(), getChronology()); [EOL] }
@Deprecated [EOL] public TimeOfDay toTimeOfDay() { [EOL]     return new TimeOfDay(getMillis(), getChronology()); [EOL] }
public Property yearOfCentury() { [EOL]     return new Property(this, getChronology().yearOfCentury()); [EOL] }
public Property weekyear() { [EOL]     return new Property(this, getChronology().weekyear()); [EOL] }
public Property dayOfYear() { [EOL]     return new Property(this, getChronology().dayOfYear()); [EOL] }
public DateTimeField getField() { [EOL]     return iField; [EOL] }
protected long getMillis() { [EOL]     return iInstant.getMillis(); [EOL] }
public DateTime getDateTime() { [EOL]     return iInstant; [EOL] }
public DateTime addToCopy(int value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateTime addToCopy(int value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateTime addToCopy(int value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateTime roundCeilingCopy() { [EOL]     return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis())); [EOL] }
public void printTo(Writer out, ReadablePeriod period) throws IOException { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     getPrinter().printTo(out, period, iLocale); [EOL] }
public void printTo(Writer out, ReadablePeriod period) throws IOException { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     getPrinter().printTo(out, period, iLocale); [EOL] }
public void printTo(Writer out, ReadablePeriod period) throws IOException { [EOL]     checkPrinter(); [EOL]     checkPeriod(period); [EOL]     getPrinter().printTo(out, period, iLocale); [EOL] }
private void checkPeriod(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         throw new IllegalArgumentException("Period must not be null"); [EOL]     } [EOL] }
private void checkPeriod(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         throw new IllegalArgumentException("Period must not be null"); [EOL]     } [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position) { [EOL]     checkParser(); [EOL]     checkPeriod(period); [EOL]     return getParser().parseInto(period, text, position, iLocale); [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position) { [EOL]     checkParser(); [EOL]     checkPeriod(period); [EOL]     return getParser().parseInto(period, text, position, iLocale); [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position) { [EOL]     checkParser(); [EOL]     checkPeriod(period); [EOL]     return getParser().parseInto(period, text, position, iLocale); [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position) { [EOL]     checkParser(); [EOL]     checkPeriod(period); [EOL]     return getParser().parseInto(period, text, position, iLocale); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public Partial(DateTimeFieldType type, int value) { [EOL]     this(type, value, null); [EOL] }
public Partial(DateTimeFieldType type, int value) { [EOL]     this(type, value, null); [EOL] }
public Partial(DateTimeFieldType type, int value, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     iTypes = new DateTimeFieldType[] { type }; [EOL]     iValues = new int[] { value }; [EOL]     chronology.validate(this, iValues); [EOL] }
public Partial(DateTimeFieldType type, int value, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     iTypes = new DateTimeFieldType[] { type }; [EOL]     iValues = new int[] { value }; [EOL]     chronology.validate(this, iValues); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(ReadablePartial partial) { [EOL]     super(); [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC(); [EOL]     iTypes = new DateTimeFieldType[partial.size()]; [EOL]     iValues = new int[partial.size()]; [EOL]     for (int i = 0; i < partial.size(); i++) { [EOL]         iTypes[i] = partial.getFieldType(i); [EOL]         iValues[i] = partial.getValue(i); [EOL]     } [EOL] }
public Partial(ReadablePartial partial) { [EOL]     super(); [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC(); [EOL]     iTypes = new DateTimeFieldType[partial.size()]; [EOL]     iValues = new int[partial.size()]; [EOL]     for (int i = 0; i < partial.size(); i++) { [EOL]         iTypes[i] = partial.getFieldType(i); [EOL]         iValues[i] = partial.getValue(i); [EOL]     } [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd); [EOL]     return new Partial(iPartial, newValues); [EOL] }
protected void setMillis(long duration) { [EOL]     iMillis = duration; [EOL] }
public Interval toIntervalFrom(ReadableInstant startInstant) { [EOL]     return new Interval(startInstant, this); [EOL] }
public Interval toIntervalFrom(ReadableInstant startInstant) { [EOL]     return new Interval(startInstant, this); [EOL] }
public Years minus(int years) { [EOL]     return plus(FieldUtils.safeNegate(years)); [EOL] }
public Years minus(int years) { [EOL]     return plus(FieldUtils.safeNegate(years)); [EOL] }
public Years minus(int years) { [EOL]     return plus(FieldUtils.safeNegate(years)); [EOL] }
public Years dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(getValue() / divisor); [EOL] }
public Years dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(getValue() / divisor); [EOL] }
public Years dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(getValue() / divisor); [EOL] }
public Years dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Years.years(getValue() / divisor); [EOL] }
public static Instant now() { [EOL]     return new Instant(); [EOL] }
public Instant(long instant) { [EOL]     super(); [EOL]     iMillis = instant; [EOL] }
public Instant(long instant) { [EOL]     super(); [EOL]     iMillis = instant; [EOL] }
public Instant(long instant) { [EOL]     super(); [EOL]     iMillis = instant; [EOL] }
public Instant minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public Instant minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public Instant minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public long getMillis() { [EOL]     return iMillis; [EOL] }
public Chronology getChronology() { [EOL]     return ISOChronology.getInstanceUTC(); [EOL] }
public DateTime toDateTime() { [EOL]     return new DateTime(getMillis(), ISOChronology.getInstance()); [EOL] }
public static LocalDate fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDate((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] }
public static LocalDate fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDate((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] }
public static LocalDate fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDate((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
public LocalDate(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public LocalDate(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getLocalMillis(); [EOL]     Chronology chrono = getChronology(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         long value = FieldUtils.safeMultiply(period.getValue(i), scalar); [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         if (isSupported(type)) { [EOL]             instant = type.getField(chrono).add(instant, value); [EOL]         } [EOL]     } [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getLocalMillis(); [EOL]     Chronology chrono = getChronology(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         long value = FieldUtils.safeMultiply(period.getValue(i), scalar); [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         if (isSupported(type)) { [EOL]             instant = type.getField(chrono).add(instant, value); [EOL]         } [EOL]     } [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getLocalMillis(); [EOL]     Chronology chrono = getChronology(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         long value = FieldUtils.safeMultiply(period.getValue(i), scalar); [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         if (isSupported(type)) { [EOL]             instant = type.getField(chrono).add(instant, value); [EOL]         } [EOL]     } [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getLocalMillis(); [EOL]     Chronology chrono = getChronology(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         long value = FieldUtils.safeMultiply(period.getValue(i), scalar); [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         if (isSupported(type)) { [EOL]             instant = type.getField(chrono).add(instant, value); [EOL]         } [EOL]     } [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public Property dayOfMonth() { [EOL]     return new Property(this, getChronology().dayOfMonth()); [EOL] }
Property(LocalDate instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
Property(LocalDate instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
Property(LocalDate instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
public LocalDate setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDate setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDate setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalDate setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public int getMinimumValue() { [EOL]     return DateTimeConstants.BCE; [EOL] }
public int getMaximumValue() { [EOL]     return DateTimeConstants.CE; [EOL] }
public static PeriodType yearMonthDayTime() { [EOL]     PeriodType type = cYMDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 }); [EOL]         cYMDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearMonthDayTime() { [EOL]     PeriodType type = cYMDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 }); [EOL]         cYMDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearMonthDay() { [EOL]     PeriodType type = cYMD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 }); [EOL]         cYMD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearMonthDay() { [EOL]     PeriodType type = cYMD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 }); [EOL]         cYMD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearWeekDay() { [EOL]     PeriodType type = cYWD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearWeekDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days() }, new int[] { 0, -1, 1, 2, -1, -1, -1, -1 }); [EOL]         cYWD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearDayTime() { [EOL]     PeriodType type = cYDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 }); [EOL]         cYDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearDayTime() { [EOL]     PeriodType type = cYDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 }); [EOL]         cYDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearDay() { [EOL]     PeriodType type = cYD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 }); [EOL]         cYD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearDay() { [EOL]     PeriodType type = cYD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 }); [EOL]         cYD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType dayTime() { [EOL]     PeriodType type = cDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("DayTime", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 }); [EOL]         cDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType time() { [EOL]     PeriodType type = cTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Time", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 }); [EOL]         cTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType time() { [EOL]     PeriodType type = cTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Time", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 }); [EOL]         cTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType years() { [EOL]     PeriodType type = cYears; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Years", new DurationFieldType[] { DurationFieldType.years() }, new int[] { 0, -1, -1, -1, -1, -1, -1, -1 }); [EOL]         cYears = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType hours() { [EOL]     PeriodType type = cHours; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Hours", new DurationFieldType[] { DurationFieldType.hours() }, new int[] { -1, -1, -1, -1, 0, -1, -1, -1 }); [EOL]         cHours = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType minutes() { [EOL]     PeriodType type = cMinutes; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Minutes", new DurationFieldType[] { DurationFieldType.minutes() }, new int[] { -1, -1, -1, -1, -1, 0, -1, -1 }); [EOL]         cMinutes = type; [EOL]     } [EOL]     return type; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     return (indexOf(type) >= 0); [EOL] }
public PeriodType withMinutesRemoved() { [EOL]     return withFieldRemoved(5, "NoMinutes"); [EOL] }
public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException { [EOL]     if (millisProvider == null) { [EOL]         throw new IllegalArgumentException("The MillisProvider must not be null"); [EOL]     } [EOL]     checkPermission(); [EOL]     cMillisProvider = millisProvider; [EOL] }
public static final Chronology getIntervalChronology(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     Chronology chrono = interval.getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getIntervalChronology(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     Chronology chrono = interval.getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getIntervalChronology(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     Chronology chrono = interval.getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final DateTimeZone getZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         return DateTimeZone.getDefault(); [EOL]     } [EOL]     return zone; [EOL] }
public static final DateTimeZone getZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         return DateTimeZone.getDefault(); [EOL]     } [EOL]     return zone; [EOL] }
protected BaseInterval(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getChronology(chrono); [EOL]     checkInterval(startInstant, endInstant); [EOL]     iStartMillis = startInstant; [EOL]     iEndMillis = endInstant; [EOL] }
protected BaseInterval(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getChronology(chrono); [EOL]     checkInterval(startInstant, endInstant); [EOL]     iStartMillis = startInstant; [EOL]     iEndMillis = endInstant; [EOL] }
protected BaseInterval(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getChronology(chrono); [EOL]     checkInterval(startInstant, endInstant); [EOL]     iStartMillis = startInstant; [EOL]     iEndMillis = endInstant; [EOL] }
protected BaseInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == null && end == null) { [EOL]         iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis(); [EOL]         iChronology = ISOChronology.getInstance(); [EOL]     } else { [EOL]         iChronology = DateTimeUtils.getInstantChronology(start); [EOL]         iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]         iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]         checkInterval(iStartMillis, iEndMillis); [EOL]     } [EOL] }
protected BaseInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == null && end == null) { [EOL]         iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis(); [EOL]         iChronology = ISOChronology.getInstance(); [EOL]     } else { [EOL]         iChronology = DateTimeUtils.getInstantChronology(start); [EOL]         iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]         iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]         checkInterval(iStartMillis, iEndMillis); [EOL]     } [EOL] }
protected BaseInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == null && end == null) { [EOL]         iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis(); [EOL]         iChronology = ISOChronology.getInstance(); [EOL]     } else { [EOL]         iChronology = DateTimeUtils.getInstantChronology(start); [EOL]         iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]         iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]         checkInterval(iStartMillis, iEndMillis); [EOL]     } [EOL] }
protected BaseInterval(ReadableDuration duration, ReadableInstant end) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getInstantChronology(end); [EOL]     iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis); [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
public Chronology getChronology() { [EOL]     return iChronology; [EOL] }
public static Provider getProvider() { [EOL]     return cProvider; [EOL] }
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] }
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] }
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] }
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] }
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
public static NameProvider getNameProvider() { [EOL]     return cNameProvider; [EOL] }
public static void setNameProvider(NameProvider nameProvider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider")); [EOL]     } [EOL]     setNameProvider0(nameProvider); [EOL] }
public static void setNameProvider(NameProvider nameProvider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider")); [EOL]     } [EOL]     setNameProvider0(nameProvider); [EOL] }
public static void setNameProvider(NameProvider nameProvider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider")); [EOL]     } [EOL]     setNameProvider0(nameProvider); [EOL] }
private static void setNameProvider0(NameProvider nameProvider) { [EOL]     if (nameProvider == null) { [EOL]         nameProvider = getDefaultNameProvider(); [EOL]     } [EOL]     cNameProvider = nameProvider; [EOL] }
private static void setNameProvider0(NameProvider nameProvider) { [EOL]     if (nameProvider == null) { [EOL]         nameProvider = getDefaultNameProvider(); [EOL]     } [EOL]     cNameProvider = nameProvider; [EOL] }
private static NameProvider getDefaultNameProvider() { [EOL]     NameProvider nameProvider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (nameProvider == null) { [EOL]         nameProvider = new DefaultNameProvider(); [EOL]     } [EOL]     return nameProvider; [EOL] }
private static NameProvider getDefaultNameProvider() { [EOL]     NameProvider nameProvider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (nameProvider == null) { [EOL]         nameProvider = new DefaultNameProvider(); [EOL]     } [EOL]     return nameProvider; [EOL] }
private static NameProvider getDefaultNameProvider() { [EOL]     NameProvider nameProvider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (nameProvider == null) { [EOL]         nameProvider = new DefaultNameProvider(); [EOL]     } [EOL]     return nameProvider; [EOL] }
public final String getShortName(long instant) { [EOL]     return getShortName(instant, null); [EOL] }
public String getShortName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getShortName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] }
public final String getName(long instant) { [EOL]     return getName(instant, null); [EOL] }
public String getName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] }
public String getName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] }
public String getName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] }
public String getName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public String toString() { [EOL]     return getID(); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj != null && getClass() == obj.getClass()) { [EOL]         BasicChronology chrono = (BasicChronology) obj; [EOL]         return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public int hashCode() { [EOL]     return getClass().getName().hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek(); [EOL] }
public int hashCode() { [EOL]     return getClass().getName().hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek(); [EOL] }
public int hashCode() { [EOL]     return getClass().getName().hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek(); [EOL] }
protected void assemble(Fields fields) { [EOL]     fields.millis = cMillisField; [EOL]     fields.seconds = cSecondsField; [EOL]     fields.minutes = cMinutesField; [EOL]     fields.hours = cHoursField; [EOL]     fields.halfdays = cHalfdaysField; [EOL]     fields.days = cDaysField; [EOL]     fields.weeks = cWeeksField; [EOL]     fields.millisOfSecond = cMillisOfSecondField; [EOL]     fields.millisOfDay = cMillisOfDayField; [EOL]     fields.secondOfMinute = cSecondOfMinuteField; [EOL]     fields.secondOfDay = cSecondOfDayField; [EOL]     fields.minuteOfHour = cMinuteOfHourField; [EOL]     fields.minuteOfDay = cMinuteOfDayField; [EOL]     fields.hourOfDay = cHourOfDayField; [EOL]     fields.hourOfHalfday = cHourOfHalfdayField; [EOL]     fields.clockhourOfDay = cClockhourOfDayField; [EOL]     fields.clockhourOfHalfday = cClockhourOfHalfdayField; [EOL]     fields.halfdayOfDay = cHalfdayOfDayField; [EOL]     fields.year = new BasicYearDateTimeField(this); [EOL]     fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this); [EOL]     DateTimeField field = new OffsetDateTimeField(fields.yearOfEra, 99); [EOL]     fields.centuryOfEra = new DividedDateTimeField(field, DateTimeFieldType.centuryOfEra(), 100); [EOL]     fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]     field = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra); [EOL]     fields.yearOfCentury = new OffsetDateTimeField(field, DateTimeFieldType.yearOfCentury(), 1); [EOL]     fields.era = new GJEraDateTimeField(this); [EOL]     fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days); [EOL]     fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days); [EOL]     fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days); [EOL]     fields.monthOfYear = new GJMonthOfYearDateTimeField(this); [EOL]     fields.weekyear = new BasicWeekyearDateTimeField(this); [EOL]     fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks); [EOL]     field = new RemainderDateTimeField(fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100); [EOL]     fields.weekyearOfCentury = new OffsetDateTimeField(field, DateTimeFieldType.weekyearOfCentury(), 1); [EOL]     fields.years = fields.year.getDurationField(); [EOL]     fields.months = fields.monthOfYear.getDurationField(); [EOL]     fields.weekyears = fields.weekyear.getDurationField(); [EOL] }
int getWeeksInYear(int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK); [EOL] }
int getWeeksInYear(int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK); [EOL] }
long getFirstWeekOfYearMillis(int year) { [EOL]     long jan1millis = getYearMillis(year); [EOL]     int jan1dayOfWeek = getDayOfWeek(jan1millis); [EOL]     if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) { [EOL]         return jan1millis + (8 - jan1dayOfWeek) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         return jan1millis - (jan1dayOfWeek - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     } [EOL] }
long getFirstWeekOfYearMillis(int year) { [EOL]     long jan1millis = getYearMillis(year); [EOL]     int jan1dayOfWeek = getDayOfWeek(jan1millis); [EOL]     if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) { [EOL]         return jan1millis + (8 - jan1dayOfWeek) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         return jan1millis - (jan1dayOfWeek - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     } [EOL] }
int getWeekyear(long instant) { [EOL]     int year = getYear(instant); [EOL]     int week = getWeekOfWeekyear(instant, year); [EOL]     if (week == 1) { [EOL]         return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); [EOL]     } else if (week > 51) { [EOL]         return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     } else { [EOL]         return year; [EOL]     } [EOL] }
int getWeekyear(long instant) { [EOL]     int year = getYear(instant); [EOL]     int week = getWeekOfWeekyear(instant, year); [EOL]     if (week == 1) { [EOL]         return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); [EOL]     } else if (week > 51) { [EOL]         return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     } else { [EOL]         return year; [EOL]     } [EOL] }
int getWeekyear(long instant) { [EOL]     int year = getYear(instant); [EOL]     int week = getWeekOfWeekyear(instant, year); [EOL]     if (week == 1) { [EOL]         return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); [EOL]     } else if (week > 51) { [EOL]         return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     } else { [EOL]         return year; [EOL]     } [EOL] }
int getWeekOfWeekyear(long instant) { [EOL]     return getWeekOfWeekyear(instant, getYear(instant)); [EOL] }
int getWeekOfWeekyear(long instant) { [EOL]     return getWeekOfWeekyear(instant, getYear(instant)); [EOL] }
int getWeekOfWeekyear(long instant) { [EOL]     return getWeekOfWeekyear(instant, getYear(instant)); [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getDayOfWeek(long instant) { [EOL]     long daysSince19700101; [EOL]     if (instant >= 0) { [EOL]         daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; [EOL]         if (daysSince19700101 < -3) { [EOL]             return 7 + (int) ((daysSince19700101 + 4) % 7); [EOL]         } [EOL]     } [EOL]     return 1 + (int) ((daysSince19700101 + 3) % 7); [EOL] }
int getDayOfWeek(long instant) { [EOL]     long daysSince19700101; [EOL]     if (instant >= 0) { [EOL]         daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; [EOL]         if (daysSince19700101 < -3) { [EOL]             return 7 + (int) ((daysSince19700101 + 4) % 7); [EOL]         } [EOL]     } [EOL]     return 1 + (int) ((daysSince19700101 + 3) % 7); [EOL] }
int getDayOfWeek(long instant) { [EOL]     long daysSince19700101; [EOL]     if (instant >= 0) { [EOL]         daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; [EOL]         if (daysSince19700101 < -3) { [EOL]             return 7 + (int) ((daysSince19700101 + 4) % 7); [EOL]         } [EOL]     } [EOL]     return 1 + (int) ((daysSince19700101 + 3) % 7); [EOL] }
private YearInfo getYearInfo(int year) { [EOL]     YearInfo info = iYearInfoCache[year & CACHE_MASK]; [EOL]     if (info == null || info.iYear != year) { [EOL]         info = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL]         iYearInfoCache[year & CACHE_MASK] = info; [EOL]     } [EOL]     return info; [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue); [EOL] }
YearInfo(int year, long firstDayMillis) { [EOL]     iYear = year; [EOL]     iFirstDayMillis = firstDayMillis; [EOL] }
protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     if (startInstant == null && endInstant == null) { [EOL]         iType = type; [EOL]         iValues = new int[size()]; [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL]         Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public Duration toDurationFrom(ReadableInstant startInstant) { [EOL]     long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(startInstant); [EOL]     long endMillis = chrono.add(this, startMillis, 1); [EOL]     return new Duration(startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void mergePeriod(ReadablePeriod period) { [EOL]     if (period != null) { [EOL]         setValues(mergePeriodInto(getValues(), period)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected int[] mergePeriodInto(int[] values, ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         int value = period.getValue(i); [EOL]         checkAndUpdate(type, values, value); [EOL]     } [EOL]     return values; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected int[] addPeriodInto(int[] values, ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         int value = period.getValue(i); [EOL]         if (value != 0) { [EOL]             int index = indexOf(type); [EOL]             if (index == -1) { [EOL]                 throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL]             } else { [EOL]                 values[index] = FieldUtils.safeAdd(getValue(index), value); [EOL]             } [EOL]         } [EOL]     } [EOL]     return values; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) { [EOL]     if (strictISO) { [EOL]         throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]     } [EOL] }
private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) { [EOL]     if (strictISO) { [EOL]         throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]     } [EOL] }
public static DateTimeFormatter dateTimeParser() { [EOL]     return Constants.dtp; [EOL] }
public static DateTimeFormatter timeNoMillis() { [EOL]     return Constants.tx; [EOL] }
public static DateTimeFormatter ordinalDateTime() { [EOL]     return Constants.odt; [EOL] }
public static DateTimeFormatter weekDateTime() { [EOL]     return Constants.wdt; [EOL] }
public static DateTimeFormatter basicDate() { [EOL]     return Constants.bd; [EOL] }
public static DateTimeFormatter basicWeekDate() { [EOL]     return Constants.bwd; [EOL] }
public static DateTimeFormatter hour() { [EOL]     return Constants.hde; [EOL] }
public static DateTimeFormatter dateHour() { [EOL]     return Constants.dh; [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes standardMinutesIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     return Minutes.minutes(amount); [EOL] }
public static Minutes standardMinutesIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     return Minutes.minutes(amount); [EOL] }
public static Minutes standardMinutesIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     return Minutes.minutes(amount); [EOL] }
private Object readResolve() { [EOL]     return Minutes.minutes(getValue()); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR); [EOL] }
public int getMinutes() { [EOL]     return getValue(); [EOL] }
public Minutes plus(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes)); [EOL] }
public Minutes plus(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes)); [EOL] }
public Minutes plus(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes)); [EOL] }
public Minutes plus(Minutes minutes) { [EOL]     if (minutes == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(minutes.getValue()); [EOL] }
public Minutes plus(Minutes minutes) { [EOL]     if (minutes == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(minutes.getValue()); [EOL] }
public Minutes minus(int minutes) { [EOL]     return plus(FieldUtils.safeNegate(minutes)); [EOL] }
public Minutes minus(int minutes) { [EOL]     return plus(FieldUtils.safeNegate(minutes)); [EOL] }
public Minutes minus(int minutes) { [EOL]     return plus(FieldUtils.safeNegate(minutes)); [EOL] }
public Minutes minus(int minutes) { [EOL]     return plus(FieldUtils.safeNegate(minutes)); [EOL] }
public Minutes minus(int minutes) { [EOL]     return plus(FieldUtils.safeNegate(minutes)); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "M"; [EOL] }
static int parseMonth(String str) { [EOL]     DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear(); [EOL]     return field.get(field.set(0, str, Locale.ENGLISH)); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static int parseDayOfWeek(String str) { [EOL]     DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek(); [EOL]     return field.get(field.set(0, str, Locale.ENGLISH)); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
static char parseZoneChar(char c) { [EOL]     switch(c) { [EOL]         case 's': [EOL]         case 'S': [EOL]             return 's'; [EOL]         case 'u': [EOL]         case 'U': [EOL]         case 'g': [EOL]         case 'G': [EOL]         case 'z': [EOL]         case 'Z': [EOL]             return 'u'; [EOL]         case 'w': [EOL]         case 'W': [EOL]         default: [EOL]             return 'w'; [EOL]     } [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
DateTimeOfYear(StringTokenizer st) { [EOL]     int month = 1; [EOL]     int day = 1; [EOL]     int dayOfWeek = 0; [EOL]     int millis = 0; [EOL]     boolean advance = false; [EOL]     char zoneChar = 'w'; [EOL]     if (st.hasMoreTokens()) { [EOL]         month = parseMonth(st.nextToken()); [EOL]         if (st.hasMoreTokens()) { [EOL]             String str = st.nextToken(); [EOL]             if (str.startsWith("last")) { [EOL]                 day = -1; [EOL]                 dayOfWeek = parseDayOfWeek(str.substring(4)); [EOL]                 advance = false; [EOL]             } else { [EOL]                 try { [EOL]                     day = Integer.parseInt(str); [EOL]                     dayOfWeek = 0; [EOL]                     advance = false; [EOL]                 } catch (NumberFormatException e) { [EOL]                     int index = str.indexOf(">="); [EOL]                     if (index > 0) { [EOL]                         day = Integer.parseInt(str.substring(index + 2)); [EOL]                         dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL]                         advance = true; [EOL]                     } else { [EOL]                         index = str.indexOf("<="); [EOL]                         if (index > 0) { [EOL]                             day = Integer.parseInt(str.substring(index + 2)); [EOL]                             dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL]                             advance = false; [EOL]                         } else { [EOL]                             throw new IllegalArgumentException(str); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (st.hasMoreTokens()) { [EOL]                 str = st.nextToken(); [EOL]                 zoneChar = parseZoneChar(str.charAt(str.length() - 1)); [EOL]                 if (str.equals("24:00")) { [EOL]                     LocalDate date = (day == -1 ? new LocalDate(2001, month, 1).plusMonths(1) : new LocalDate(2001, month, day).plusDays(1)); [EOL]                     advance = (day != -1); [EOL]                     month = date.getMonthOfYear(); [EOL]                     day = date.getDayOfMonth(); [EOL]                     dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1; [EOL]                 } else { [EOL]                     millis = parseTime(str); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     iMonthOfYear = month; [EOL]     iDayOfMonth = day; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvanceDayOfWeek = advance; [EOL]     iMillisOfDay = millis; [EOL]     iZoneChar = zoneChar; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public BaseDateTime(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public BaseDateTime(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public BaseDateTime(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public BaseDateTime(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public BaseDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone)); [EOL] }
public BaseDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone)); [EOL] }
protected long checkInstant(long instant, Chronology chronology) { [EOL]     return instant; [EOL] }
protected void setMillis(long instant) { [EOL]     iMillis = checkInstant(instant, iChronology); [EOL] }
public String getNameKey(long instant) { [EOL]     return iNameKey; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     return iWallOffset; [EOL] }
public boolean isFixed() { [EOL]     return true; [EOL] }
public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) { [EOL]     ReadableDuration dur = (ReadableDuration) object; [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     long duration = dur.getMillis(); [EOL]     int[] values = chrono.get(writablePeriod, duration); [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         writablePeriod.setValue(i, values[i]); [EOL]     } [EOL] }
public Class<?> getSupportedType() { [EOL]     return ReadableDuration.class; [EOL] }
protected DateTimeConstants() { [EOL] }
public String getName() { [EOL]     return getField().getName(); [EOL] }
public String getName() { [EOL]     return getField().getName(); [EOL] }
public int get() { [EOL]     return getField().get(getMillis()); [EOL] }
public int get() { [EOL]     return getField().get(getMillis()); [EOL] }
public String getAsString() { [EOL]     return Integer.toString(get()); [EOL] }
public String getAsText() { [EOL]     return getAsText(null); [EOL] }
public String getAsText(Locale locale) { [EOL]     return getField().getAsText(getMillis(), locale); [EOL] }
public String getAsText(Locale locale) { [EOL]     return getField().getAsText(getMillis(), locale); [EOL] }
public String getAsShortText() { [EOL]     return getAsShortText(null); [EOL] }
public String getAsShortText(Locale locale) { [EOL]     return getField().getAsShortText(getMillis(), locale); [EOL] }
public String getAsShortText(Locale locale) { [EOL]     return getField().getAsShortText(getMillis(), locale); [EOL] }
public DurationField getDurationField() { [EOL]     return getField().getDurationField(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return getField().getRangeDurationField(); [EOL] }
public boolean isLeap() { [EOL]     return getField().isLeap(getMillis()); [EOL] }
public int getLeapAmount() { [EOL]     return getField().getLeapAmount(getMillis()); [EOL] }
public DurationField getLeapDurationField() { [EOL]     return getField().getLeapDurationField(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return getField().getMaximumTextLength(locale); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return getField().getMaximumShortTextLength(locale); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return getField().getMaximumShortTextLength(locale); [EOL] }
public String toString() { [EOL]     return "Property[" + getName() + "]"; [EOL] }
public static synchronized UnsupportedDateTimeField getInstance(DateTimeFieldType type, DurationField durationField) { [EOL]     UnsupportedDateTimeField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]         if (field != null && field.getDurationField() != durationField) { [EOL]             field = null; [EOL]         } [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDateTimeField(type, durationField); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public static synchronized UnsupportedDateTimeField getInstance(DateTimeFieldType type, DurationField durationField) { [EOL]     UnsupportedDateTimeField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]         if (field != null && field.getDurationField() != durationField) { [EOL]             field = null; [EOL]         } [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDateTimeField(type, durationField); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public static synchronized UnsupportedDateTimeField getInstance(DateTimeFieldType type, DurationField durationField) { [EOL]     UnsupportedDateTimeField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]         if (field != null && field.getDurationField() != durationField) { [EOL]             field = null; [EOL]         } [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDateTimeField(type, durationField); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public DateTimeFieldType getType() { [EOL]     return iType; [EOL] }
public boolean isSupported() { [EOL]     return false; [EOL] }
public boolean isLenient() { [EOL]     return false; [EOL] }
public DurationField getDurationField() { [EOL]     return iDurationField; [EOL] }
public PreciseDateTimeField(DateTimeFieldType type, DurationField unit, DurationField range) { [EOL]     super(type, unit); [EOL]     if (!range.isPrecise()) { [EOL]         throw new IllegalArgumentException("Range duration field must be precise"); [EOL]     } [EOL]     long rangeMillis = range.getUnitMillis(); [EOL]     iRange = (int) (rangeMillis / getUnitMillis()); [EOL]     if (iRange < 2) { [EOL]         throw new IllegalArgumentException("The effective range must be at least 2"); [EOL]     } [EOL]     iRangeField = range; [EOL] }
public PreciseDateTimeField(DateTimeFieldType type, DurationField unit, DurationField range) { [EOL]     super(type, unit); [EOL]     if (!range.isPrecise()) { [EOL]         throw new IllegalArgumentException("Range duration field must be precise"); [EOL]     } [EOL]     long rangeMillis = range.getUnitMillis(); [EOL]     iRange = (int) (rangeMillis / getUnitMillis()); [EOL]     if (iRange < 2) { [EOL]         throw new IllegalArgumentException("The effective range must be at least 2"); [EOL]     } [EOL]     iRangeField = range; [EOL] }
public PreciseDateTimeField(DateTimeFieldType type, DurationField unit, DurationField range) { [EOL]     super(type, unit); [EOL]     if (!range.isPrecise()) { [EOL]         throw new IllegalArgumentException("Range duration field must be precise"); [EOL]     } [EOL]     long rangeMillis = range.getUnitMillis(); [EOL]     iRange = (int) (rangeMillis / getUnitMillis()); [EOL]     if (iRange < 2) { [EOL]         throw new IllegalArgumentException("The effective range must be at least 2"); [EOL]     } [EOL]     iRangeField = range; [EOL] }
public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     base = base.withUTC(); [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("UTC chronology must not be null"); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("DateTimeZone must not be null"); [EOL]     } [EOL]     return new ZonedChronology(base, zone); [EOL] }
public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     base = base.withUTC(); [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("UTC chronology must not be null"); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("DateTimeZone must not be null"); [EOL]     } [EOL]     return new ZonedChronology(base, zone); [EOL] }
public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     base = base.withUTC(); [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("UTC chronology must not be null"); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("DateTimeZone must not be null"); [EOL]     } [EOL]     return new ZonedChronology(base, zone); [EOL] }
static boolean useTimeArithmetic(DurationField field) { [EOL]     return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; [EOL] }
static boolean useTimeArithmetic(DurationField field) { [EOL]     return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; [EOL] }
static boolean useTimeArithmetic(DurationField field) { [EOL]     return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; [EOL] }
private ZonedChronology(Chronology base, DateTimeZone zone) { [EOL]     super(base, zone); [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DurationField) converted.get(field); [EOL]     } [EOL]     ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { [EOL]     if (field == null || !field.isSupported()) { [EOL]         return field; [EOL]     } [EOL]     if (converted.containsKey(field)) { [EOL]         return (DateTimeField) converted.get(field); [EOL]     } [EOL]     ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); [EOL]     converted.put(field, zonedField); [EOL]     return zonedField; [EOL] }
ZonedDurationField(DurationField field, DateTimeZone zone) { [EOL]     super(field.getType()); [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iField = field; [EOL]     iTimeField = useTimeArithmetic(field); [EOL]     iZone = zone; [EOL] }
ZonedDurationField(DurationField field, DateTimeZone zone) { [EOL]     super(field.getType()); [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iField = field; [EOL]     iTimeField = useTimeArithmetic(field); [EOL]     iZone = zone; [EOL] }
public boolean isPrecise() { [EOL]     return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); [EOL] }
public boolean isPrecise() { [EOL]     return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); [EOL] }
public boolean isPrecise() { [EOL]     return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); [EOL] }
public boolean isPrecise() { [EOL]     return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); [EOL] }
public long getUnitMillis() { [EOL]     return iField.getUnitMillis(); [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDurationField) { [EOL]         ZonedDurationField other = (ZonedDurationField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDurationField) { [EOL]         ZonedDurationField other = (ZonedDurationField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDurationField) { [EOL]         ZonedDurationField other = (ZonedDurationField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDurationField) { [EOL]         ZonedDurationField other = (ZonedDurationField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDurationField) { [EOL]         ZonedDurationField other = (ZonedDurationField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDurationField) { [EOL]         ZonedDurationField other = (ZonedDurationField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone); [EOL]     } [EOL]     return false; [EOL] }
ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { [EOL]     super(field.getType()); [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iField = field; [EOL]     iZone = zone; [EOL]     iDurationField = durationField; [EOL]     iTimeField = useTimeArithmetic(durationField); [EOL]     iRangeDurationField = rangeDurationField; [EOL]     iLeapDurationField = leapDurationField; [EOL] }
ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { [EOL]     super(field.getType()); [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iField = field; [EOL]     iZone = zone; [EOL]     iDurationField = durationField; [EOL]     iTimeField = useTimeArithmetic(durationField); [EOL]     iRangeDurationField = rangeDurationField; [EOL]     iLeapDurationField = leapDurationField; [EOL] }
public String getAsText(long instant, Locale locale) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getAsText(localInstant, locale); [EOL] }
public String getAsText(long instant, Locale locale) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getAsText(localInstant, locale); [EOL] }
public String getAsShortText(long instant, Locale locale) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getAsShortText(localInstant, locale); [EOL] }
public String getAsShortText(long instant, Locale locale) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getAsShortText(localInstant, locale); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     localInstant = iField.set(localInstant, text, locale); [EOL]     return iZone.convertLocalToUTC(localInstant, false, instant); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     localInstant = iField.set(localInstant, text, locale); [EOL]     return iZone.convertLocalToUTC(localInstant, false, instant); [EOL] }
public boolean isLeap(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.isLeap(localInstant); [EOL] }
public int getLeapAmount(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getLeapAmount(localInstant); [EOL] }
public int getLeapAmount(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getLeapAmount(localInstant); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return iField.getMaximumTextLength(locale); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return iField.getMaximumShortTextLength(locale); [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDateTimeField) { [EOL]         ZonedDateTimeField other = (ZonedDateTimeField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone) && iDurationField.equals(other.iDurationField) && iRangeDurationField.equals(other.iRangeDurationField); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDateTimeField) { [EOL]         ZonedDateTimeField other = (ZonedDateTimeField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone) && iDurationField.equals(other.iDurationField) && iRangeDurationField.equals(other.iRangeDurationField); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDateTimeField) { [EOL]         ZonedDateTimeField other = (ZonedDateTimeField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone) && iDurationField.equals(other.iDurationField) && iRangeDurationField.equals(other.iRangeDurationField); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ZonedDateTimeField) { [EOL]         ZonedDateTimeField other = (ZonedDateTimeField) obj; [EOL]         return iField.equals(other.iField) && iZone.equals(other.iZone) && iDurationField.equals(other.iDurationField) && iRangeDurationField.equals(other.iRangeDurationField); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return iField.hashCode() ^ iZone.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return iField.hashCode() ^ iZone.hashCode(); [EOL] }
GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) { [EOL]     super(DateTimeFieldType.dayOfWeek(), days); [EOL]     iChronology = chronology; [EOL] }
GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) { [EOL]     super(DateTimeFieldType.dayOfWeek(), days); [EOL]     iChronology = chronology; [EOL] }
public int get(long instant) { [EOL]     return iChronology.getDayOfWeek(instant); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text); [EOL] }
protected int convertText(String text, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text); [EOL] }
public IllegalFieldValueException(DurationFieldType fieldType, Number value, Number lowerBound, Number upperBound) { [EOL]     super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null)); [EOL]     iDateTimeFieldType = null; [EOL]     iDurationFieldType = fieldType; [EOL]     iFieldName = fieldType.getName(); [EOL]     iNumberValue = value; [EOL]     iStringValue = null; [EOL]     iLowerBound = lowerBound; [EOL]     iUpperBound = upperBound; [EOL]     iMessage = super.getMessage(); [EOL] }
public IllegalFieldValueException(DurationFieldType fieldType, Number value, Number lowerBound, Number upperBound) { [EOL]     super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null)); [EOL]     iDateTimeFieldType = null; [EOL]     iDurationFieldType = fieldType; [EOL]     iFieldName = fieldType.getName(); [EOL]     iNumberValue = value; [EOL]     iStringValue = null; [EOL]     iLowerBound = lowerBound; [EOL]     iUpperBound = upperBound; [EOL]     iMessage = super.getMessage(); [EOL] }
public IllegalFieldValueException(DurationFieldType fieldType, String value) { [EOL]     super(createMessage(fieldType.getName(), value)); [EOL]     iDateTimeFieldType = null; [EOL]     iDurationFieldType = fieldType; [EOL]     iFieldName = fieldType.getName(); [EOL]     iStringValue = value; [EOL]     iNumberValue = null; [EOL]     iLowerBound = null; [EOL]     iUpperBound = null; [EOL]     iMessage = super.getMessage(); [EOL] }
public IllegalFieldValueException(String fieldName, String value) { [EOL]     super(createMessage(fieldName, value)); [EOL]     iDateTimeFieldType = null; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldName; [EOL]     iStringValue = value; [EOL]     iNumberValue = null; [EOL]     iLowerBound = null; [EOL]     iUpperBound = null; [EOL]     iMessage = super.getMessage(); [EOL] }
public LocalTime(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     chronology = chronology.withUTC(); [EOL]     iLocalMillis = chronology.millisOfDay().get(localMillis); [EOL]     iChronology = chronology; [EOL] }
public LocalTime(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     chronology = chronology.withUTC(); [EOL]     iLocalMillis = chronology.millisOfDay().get(localMillis); [EOL]     iChronology = chronology; [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC()); [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     long instant = chronology.getDateTimeMillis(0L, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     iChronology = chronology; [EOL]     iLocalMillis = instant; [EOL] }
public LocalTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     long instant = chronology.getDateTimeMillis(0L, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     iChronology = chronology; [EOL]     iLocalMillis = instant; [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return getChronology().hourOfDay().get(getLocalMillis()); [EOL]         case MINUTE_OF_HOUR: [EOL]             return getChronology().minuteOfHour().get(getLocalMillis()); [EOL]         case SECOND_OF_MINUTE: [EOL]             return getChronology().secondOfMinute().get(getLocalMillis()); [EOL]         case MILLIS_OF_SECOND: [EOL]             return getChronology().millisOfSecond().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
protected long getLocalMillis() { [EOL]     return iLocalMillis; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
LocalTime withLocalMillis(long newMillis) { [EOL]     return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology())); [EOL] }
LocalTime withLocalMillis(long newMillis) { [EOL]     return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology())); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getLocalMillis(), scalar); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getLocalMillis(), scalar); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getLocalMillis(), scalar); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public LocalTime plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public LocalTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public int getHourOfDay() { [EOL]     return getChronology().hourOfDay().get(getLocalMillis()); [EOL] }
public int getMinuteOfHour() { [EOL]     return getChronology().minuteOfHour().get(getLocalMillis()); [EOL] }
public int getSecondOfMinute() { [EOL]     return getChronology().secondOfMinute().get(getLocalMillis()); [EOL] }
public int getMillisOfSecond() { [EOL]     return getChronology().millisOfSecond().get(getLocalMillis()); [EOL] }
public LocalTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalTime withMinuteOfHour(int minute) { [EOL]     return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); [EOL] }
public LocalTime withMinuteOfHour(int minute) { [EOL]     return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); [EOL] }
public LocalTime withMinuteOfHour(int minute) { [EOL]     return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); [EOL] }
public LocalTime withSecondOfMinute(int second) { [EOL]     return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); [EOL] }
public LocalTime withSecondOfMinute(int second) { [EOL]     return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); [EOL] }
public LocalTime withSecondOfMinute(int second) { [EOL]     return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); [EOL] }
public LocalTime withSecondOfMinute(int second) { [EOL]     return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); [EOL] }
public LocalTime withSecondOfMinute(int second) { [EOL]     return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); [EOL] }
public LocalTime withMillisOfSecond(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); [EOL] }
public LocalTime withMillisOfSecond(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); [EOL] }
public LocalTime withMillisOfSecond(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); [EOL] }
public LocalTime withMillisOfDay(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); [EOL] }
public LocalTime withMillisOfDay(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); [EOL] }
public LocalTime withMillisOfDay(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); [EOL] }
public Property millisOfDay() { [EOL]     return new Property(this, getChronology().millisOfDay()); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return ISODateTimeFormat.time().print(this); [EOL] }
protected Chronology getChronology() { [EOL]     return iInstant.getChronology(); [EOL] }
public LocalTime addCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime addCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime addCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public SkipDateTimeField(Chronology chronology, DateTimeField field) { [EOL]     this(chronology, field, 0); [EOL] }
public SkipDateTimeField(Chronology chronology, DateTimeField field) { [EOL]     this(chronology, field, 0); [EOL] }
public SkipDateTimeField(Chronology chronology, DateTimeField field) { [EOL]     this(chronology, field, 0); [EOL] }
public static DurationFieldType halfdays() { [EOL]     return HALFDAYS_TYPE; [EOL] }
public static DurationFieldType years() { [EOL]     return YEARS_TYPE; [EOL] }
public static DurationFieldType centuries() { [EOL]     return CENTURIES_TYPE; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (1 << iOrdinal); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (1 << iOrdinal); [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { [EOL]     UnsupportedDurationField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDurationField(type); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { [EOL]     UnsupportedDurationField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDurationField(type); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
private UnsupportedDurationField(DurationFieldType type) { [EOL]     iType = type; [EOL] }
public int compareTo(DurationField durationField) { [EOL]     return 0; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof UnsupportedDurationField) { [EOL]         UnsupportedDurationField other = (UnsupportedDurationField) obj; [EOL]         if (other.getName() == null) { [EOL]             return (getName() == null); [EOL]         } [EOL]         return (other.getName().equals(getName())); [EOL]     } [EOL]     return false; [EOL] }
public static MutableDateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new MutableDateTime(chronology); [EOL] }
public static MutableDateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new MutableDateTime(chronology); [EOL] }
@FromString [EOL] public static MutableDateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
public static MutableDateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toMutableDateTime(); [EOL] }
public static MutableDateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toMutableDateTime(); [EOL] }
public static MutableDateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toMutableDateTime(); [EOL] }
public MutableDateTime() { [EOL]     super(); [EOL] }
public MutableDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] }
public DateTimeField getRoundingField() { [EOL]     return iRoundingField; [EOL] }
public int getRoundingMode() { [EOL]     return iRoundingMode; [EOL] }
public void setRounding(DateTimeField field) { [EOL]     setRounding(field, MutableDateTime.ROUND_FLOOR); [EOL] }
public void setRounding(DateTimeField field) { [EOL]     setRounding(field, MutableDateTime.ROUND_FLOOR); [EOL] }
public void setRounding(DateTimeField field, int mode) { [EOL]     if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { [EOL]         throw new IllegalArgumentException("Illegal rounding mode: " + mode); [EOL]     } [EOL]     iRoundingField = (mode == ROUND_NONE ? null : field); [EOL]     iRoundingMode = (field == null ? ROUND_NONE : mode); [EOL]     setMillis(getMillis()); [EOL] }
public void setRounding(DateTimeField field, int mode) { [EOL]     if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { [EOL]         throw new IllegalArgumentException("Illegal rounding mode: " + mode); [EOL]     } [EOL]     iRoundingField = (mode == ROUND_NONE ? null : field); [EOL]     iRoundingMode = (field == null ? ROUND_NONE : mode); [EOL]     setMillis(getMillis()); [EOL] }
public void setRounding(DateTimeField field, int mode) { [EOL]     if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { [EOL]         throw new IllegalArgumentException("Illegal rounding mode: " + mode); [EOL]     } [EOL]     iRoundingField = (mode == ROUND_NONE ? null : field); [EOL]     iRoundingMode = (field == null ? ROUND_NONE : mode); [EOL]     setMillis(getMillis()); [EOL] }
public void setRounding(DateTimeField field, int mode) { [EOL]     if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { [EOL]         throw new IllegalArgumentException("Illegal rounding mode: " + mode); [EOL]     } [EOL]     iRoundingField = (mode == ROUND_NONE ? null : field); [EOL]     iRoundingMode = (field == null ? ROUND_NONE : mode); [EOL]     setMillis(getMillis()); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void setYear(final int year) { [EOL]     setMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public void setYear(final int year) { [EOL]     setMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public void setYear(final int year) { [EOL]     setMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public void addWeekyears(final int weekyears) { [EOL]     if (weekyears != 0) { [EOL]         setMillis(getChronology().weekyears().add(getMillis(), weekyears)); [EOL]     } [EOL] }
public void addWeekyears(final int weekyears) { [EOL]     if (weekyears != 0) { [EOL]         setMillis(getChronology().weekyears().add(getMillis(), weekyears)); [EOL]     } [EOL] }
public void addWeekyears(final int weekyears) { [EOL]     if (weekyears != 0) { [EOL]         setMillis(getChronology().weekyears().add(getMillis(), weekyears)); [EOL]     } [EOL] }
public void addMonths(final int months) { [EOL]     if (months != 0) { [EOL]         setMillis(getChronology().months().add(getMillis(), months)); [EOL]     } [EOL] }
public void addMonths(final int months) { [EOL]     if (months != 0) { [EOL]         setMillis(getChronology().months().add(getMillis(), months)); [EOL]     } [EOL] }
public void addMonths(final int months) { [EOL]     if (months != 0) { [EOL]         setMillis(getChronology().months().add(getMillis(), months)); [EOL]     } [EOL] }
public void addWeeks(final int weeks) { [EOL]     if (weeks != 0) { [EOL]         setMillis(getChronology().weeks().add(getMillis(), weeks)); [EOL]     } [EOL] }
public void addWeeks(final int weeks) { [EOL]     if (weeks != 0) { [EOL]         setMillis(getChronology().weeks().add(getMillis(), weeks)); [EOL]     } [EOL] }
public void addWeeks(final int weeks) { [EOL]     if (weeks != 0) { [EOL]         setMillis(getChronology().weeks().add(getMillis(), weeks)); [EOL]     } [EOL] }
public void setHourOfDay(final int hourOfDay) { [EOL]     setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); [EOL] }
public void setHourOfDay(final int hourOfDay) { [EOL]     setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); [EOL] }
public void setHourOfDay(final int hourOfDay) { [EOL]     setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); [EOL] }
public void setTime(final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { [EOL]     long instant = getChronology().getDateTimeMillis(getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     setMillis(instant); [EOL] }
public Property year() { [EOL]     return new Property(this, getChronology().year()); [EOL] }
public Property dayOfWeek() { [EOL]     return new Property(this, getChronology().dayOfWeek()); [EOL] }
public Property millisOfSecond() { [EOL]     return new Property(this, getChronology().millisOfSecond()); [EOL] }
public MutableDateTime set(int value) { [EOL]     iInstant.setMillis(getField().set(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime set(int value) { [EOL]     iInstant.setMillis(getField().set(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
@FromString [EOL] public static Hours parseHours(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Hours.hours(p.getHours()); [EOL] }
@FromString [EOL] public static Hours parseHours(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Hours.hours(p.getHours()); [EOL] }
@FromString [EOL] public static Hours parseHours(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Hours.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Hours.hours(p.getHours()); [EOL] }
public Hours plus(Hours hours) { [EOL]     if (hours == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(hours.getValue()); [EOL] }
public Hours plus(Hours hours) { [EOL]     if (hours == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(hours.getValue()); [EOL] }
public Hours negated() { [EOL]     return Hours.hours(FieldUtils.safeNegate(getValue())); [EOL] }
public Hours negated() { [EOL]     return Hours.hours(FieldUtils.safeNegate(getValue())); [EOL] }
public Hours negated() { [EOL]     return Hours.hours(FieldUtils.safeNegate(getValue())); [EOL] }
public Hours negated() { [EOL]     return Hours.hours(FieldUtils.safeNegate(getValue())); [EOL] }
public Hours negated() { [EOL]     return Hours.hours(FieldUtils.safeNegate(getValue())); [EOL] }
public boolean isLessThan(Hours other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
ConverterSet(Converter[] converters) { [EOL]     iConverters = converters; [EOL]     iSelectEntries = new Entry[1 << 4]; [EOL] }
ConverterSet(Converter[] converters) { [EOL]     iConverters = converters; [EOL]     iSelectEntries = new Entry[1 << 4]; [EOL] }
ConverterSet(Converter[] converters) { [EOL]     iConverters = converters; [EOL]     iSelectEntries = new Entry[1 << 4]; [EOL] }
Converter select(Class<?> type) throws IllegalStateException { [EOL]     Entry[] entries = iSelectEntries; [EOL]     int length = entries.length; [EOL]     int index = type == null ? 0 : type.hashCode() & (length - 1); [EOL]     Entry e; [EOL]     while ((e = entries[index]) != null) { [EOL]         if (e.iType == type) { [EOL]             return e.iConverter; [EOL]         } [EOL]         if (++index >= length) { [EOL]             index = 0; [EOL]         } [EOL]     } [EOL]     Converter converter = selectSlow(this, type); [EOL]     e = new Entry(type, converter); [EOL]     entries = (Entry[]) entries.clone(); [EOL]     entries[index] = e; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (entries[i] == null) { [EOL]             iSelectEntries = entries; [EOL]             return converter; [EOL]         } [EOL]     } [EOL]     int newLength = length << 1; [EOL]     Entry[] newEntries = new Entry[newLength]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         e = entries[i]; [EOL]         type = e.iType; [EOL]         index = type == null ? 0 : type.hashCode() & (newLength - 1); [EOL]         while (newEntries[index] != null) { [EOL]             if (++index >= newLength) { [EOL]                 index = 0; [EOL]             } [EOL]         } [EOL]         newEntries[index] = e; [EOL]     } [EOL]     iSelectEntries = newEntries; [EOL]     return converter; [EOL] }
Converter select(Class<?> type) throws IllegalStateException { [EOL]     Entry[] entries = iSelectEntries; [EOL]     int length = entries.length; [EOL]     int index = type == null ? 0 : type.hashCode() & (length - 1); [EOL]     Entry e; [EOL]     while ((e = entries[index]) != null) { [EOL]         if (e.iType == type) { [EOL]             return e.iConverter; [EOL]         } [EOL]         if (++index >= length) { [EOL]             index = 0; [EOL]         } [EOL]     } [EOL]     Converter converter = selectSlow(this, type); [EOL]     e = new Entry(type, converter); [EOL]     entries = (Entry[]) entries.clone(); [EOL]     entries[index] = e; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (entries[i] == null) { [EOL]             iSelectEntries = entries; [EOL]             return converter; [EOL]         } [EOL]     } [EOL]     int newLength = length << 1; [EOL]     Entry[] newEntries = new Entry[newLength]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         e = entries[i]; [EOL]         type = e.iType; [EOL]         index = type == null ? 0 : type.hashCode() & (newLength - 1); [EOL]         while (newEntries[index] != null) { [EOL]             if (++index >= newLength) { [EOL]                 index = 0; [EOL]             } [EOL]         } [EOL]         newEntries[index] = e; [EOL]     } [EOL]     iSelectEntries = newEntries; [EOL]     return converter; [EOL] }
Converter select(Class<?> type) throws IllegalStateException { [EOL]     Entry[] entries = iSelectEntries; [EOL]     int length = entries.length; [EOL]     int index = type == null ? 0 : type.hashCode() & (length - 1); [EOL]     Entry e; [EOL]     while ((e = entries[index]) != null) { [EOL]         if (e.iType == type) { [EOL]             return e.iConverter; [EOL]         } [EOL]         if (++index >= length) { [EOL]             index = 0; [EOL]         } [EOL]     } [EOL]     Converter converter = selectSlow(this, type); [EOL]     e = new Entry(type, converter); [EOL]     entries = (Entry[]) entries.clone(); [EOL]     entries[index] = e; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (entries[i] == null) { [EOL]             iSelectEntries = entries; [EOL]             return converter; [EOL]         } [EOL]     } [EOL]     int newLength = length << 1; [EOL]     Entry[] newEntries = new Entry[newLength]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         e = entries[i]; [EOL]         type = e.iType; [EOL]         index = type == null ? 0 : type.hashCode() & (newLength - 1); [EOL]         while (newEntries[index] != null) { [EOL]             if (++index >= newLength) { [EOL]                 index = 0; [EOL]             } [EOL]         } [EOL]         newEntries[index] = e; [EOL]     } [EOL]     iSelectEntries = newEntries; [EOL]     return converter; [EOL] }
Converter select(Class<?> type) throws IllegalStateException { [EOL]     Entry[] entries = iSelectEntries; [EOL]     int length = entries.length; [EOL]     int index = type == null ? 0 : type.hashCode() & (length - 1); [EOL]     Entry e; [EOL]     while ((e = entries[index]) != null) { [EOL]         if (e.iType == type) { [EOL]             return e.iConverter; [EOL]         } [EOL]         if (++index >= length) { [EOL]             index = 0; [EOL]         } [EOL]     } [EOL]     Converter converter = selectSlow(this, type); [EOL]     e = new Entry(type, converter); [EOL]     entries = (Entry[]) entries.clone(); [EOL]     entries[index] = e; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (entries[i] == null) { [EOL]             iSelectEntries = entries; [EOL]             return converter; [EOL]         } [EOL]     } [EOL]     int newLength = length << 1; [EOL]     Entry[] newEntries = new Entry[newLength]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         e = entries[i]; [EOL]         type = e.iType; [EOL]         index = type == null ? 0 : type.hashCode() & (newLength - 1); [EOL]         while (newEntries[index] != null) { [EOL]             if (++index >= newLength) { [EOL]                 index = 0; [EOL]             } [EOL]         } [EOL]         newEntries[index] = e; [EOL]     } [EOL]     iSelectEntries = newEntries; [EOL]     return converter; [EOL] }
int size() { [EOL]     return iConverters.length; [EOL] }
int size() { [EOL]     return iConverters.length; [EOL] }
ConverterSet remove(final int index, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     if (index >= length) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = converters[index]; [EOL]     } [EOL]     Converter[] copy = new Converter[length - 1]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (i != index) { [EOL]             copy[j++] = converters[i]; [EOL]         } [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet remove(final int index, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     if (index >= length) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = converters[index]; [EOL]     } [EOL]     Converter[] copy = new Converter[length - 1]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (i != index) { [EOL]             copy[j++] = converters[i]; [EOL]         } [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet remove(final int index, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     if (index >= length) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = converters[index]; [EOL]     } [EOL]     Converter[] copy = new Converter[length - 1]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (i != index) { [EOL]             copy[j++] = converters[i]; [EOL]         } [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
Entry(Class<?> type, Converter converter) { [EOL]     iType = type; [EOL]     iConverter = converter; [EOL] }
public DateTimeFormatter toFormatter() { [EOL]     Object f = getFormatter(); [EOL]     DateTimePrinter printer = null; [EOL]     if (isPrinter(f)) { [EOL]         printer = (DateTimePrinter) f; [EOL]     } [EOL]     DateTimeParser parser = null; [EOL]     if (isParser(f)) { [EOL]         parser = (DateTimeParser) f; [EOL]     } [EOL]     if (printer != null || parser != null) { [EOL]         return new DateTimeFormatter(printer, parser); [EOL]     } [EOL]     throw new UnsupportedOperationException("Both printing and parsing not supported"); [EOL] }
public DateTimeFormatter toFormatter() { [EOL]     Object f = getFormatter(); [EOL]     DateTimePrinter printer = null; [EOL]     if (isPrinter(f)) { [EOL]         printer = (DateTimePrinter) f; [EOL]     } [EOL]     DateTimeParser parser = null; [EOL]     if (isParser(f)) { [EOL]         parser = (DateTimeParser) f; [EOL]     } [EOL]     if (printer != null || parser != null) { [EOL]         return new DateTimeFormatter(printer, parser); [EOL]     } [EOL]     throw new UnsupportedOperationException("Both printing and parsing not supported"); [EOL] }
public DateTimeFormatter toFormatter() { [EOL]     Object f = getFormatter(); [EOL]     DateTimePrinter printer = null; [EOL]     if (isPrinter(f)) { [EOL]         printer = (DateTimePrinter) f; [EOL]     } [EOL]     DateTimeParser parser = null; [EOL]     if (isParser(f)) { [EOL]         parser = (DateTimeParser) f; [EOL]     } [EOL]     if (printer != null || parser != null) { [EOL]         return new DateTimeFormatter(printer, parser); [EOL]     } [EOL]     throw new UnsupportedOperationException("Both printing and parsing not supported"); [EOL] }
public DateTimeFormatter toFormatter() { [EOL]     Object f = getFormatter(); [EOL]     DateTimePrinter printer = null; [EOL]     if (isPrinter(f)) { [EOL]         printer = (DateTimePrinter) f; [EOL]     } [EOL]     DateTimeParser parser = null; [EOL]     if (isParser(f)) { [EOL]         parser = (DateTimeParser) f; [EOL]     } [EOL]     if (printer != null || parser != null) { [EOL]         return new DateTimeFormatter(printer, parser); [EOL]     } [EOL]     throw new UnsupportedOperationException("Both printing and parsing not supported"); [EOL] }
public DateTimeFormatterBuilder append(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         throw new IllegalArgumentException("No formatter supplied"); [EOL]     } [EOL]     return append0(formatter.getPrinter(), formatter.getParser()); [EOL] }
public DateTimeFormatterBuilder append(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         throw new IllegalArgumentException("No formatter supplied"); [EOL]     } [EOL]     return append0(formatter.getPrinter(), formatter.getParser()); [EOL] }
public DateTimeFormatterBuilder append(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     return append0(null, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     return append0(null, parser); [EOL] }
private DateTimeFormatterBuilder append0(DateTimePrinter printer, DateTimeParser parser) { [EOL]     iFormatter = null; [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     return this; [EOL] }
private DateTimeFormatterBuilder append0(DateTimePrinter printer, DateTimeParser parser) { [EOL]     iFormatter = null; [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     return this; [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     return append0(new TextField(fieldType, true)); [EOL] }
public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     return append0(new TextField(fieldType, true)); [EOL] }
public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5); [EOL] }
public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5); [EOL] }
public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5); [EOL] }
public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1); [EOL] }
public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) { [EOL]     return appendTwoDigitYear(pivot, false); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) { [EOL]     return appendTwoDigitYear(pivot, false); [EOL] }
public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendHalfdayOfDayText() { [EOL]     return appendText(DateTimeFieldType.halfdayOfDay()); [EOL] }
public DateTimeFormatterBuilder appendMonthOfYearShortText() { [EOL]     return appendShortText(DateTimeFieldType.monthOfYear()); [EOL] }
public DateTimeFormatterBuilder appendEraText() { [EOL]     return appendText(DateTimeFieldType.era()); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] }
private boolean isParser(Object f) { [EOL]     if (f instanceof DateTimeParser) { [EOL]         if (f instanceof Composite) { [EOL]             return ((Composite) f).isParser(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(iValue); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.appendUnpaddedInteger(buf, field.get(instant)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.appendUnpaddedInteger(buf, field.get(instant)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits); [EOL]     } catch (RuntimeException e) { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             printUnknownString(out, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             printUnknownString(out, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             printUnknownString(out, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             printUnknownString(out, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     try { [EOL]         out.write(print(instant, chrono, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     try { [EOL]         out.write(print(instant, chrono, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     zeroOffset: if (iZeroOffsetParseText != null) { [EOL]         if (iZeroOffsetParseText.length() == 0) { [EOL]             if (limit > 0) { [EOL]                 char c = text.charAt(position); [EOL]                 if (c == '-' || c == '+') { [EOL]                     break zeroOffset; [EOL]                 } [EOL]             } [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position; [EOL]         } [EOL]         if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position + iZeroOffsetParseText.length(); [EOL]         } [EOL]     } [EOL]     if (limit <= 1) { [EOL]         return ~position; [EOL]     } [EOL]     boolean negative; [EOL]     char c = text.charAt(position); [EOL]     if (c == '-') { [EOL]         negative = true; [EOL]     } else if (c == '+') { [EOL]         negative = false; [EOL]     } else { [EOL]         return ~position; [EOL]     } [EOL]     limit--; [EOL]     position++; [EOL]     if (digitCount(text, position, 2) < 2) { [EOL]         return ~position; [EOL]     } [EOL]     int offset; [EOL]     int hours = FormatUtils.parseTwoDigits(text, position); [EOL]     if (hours > 23) { [EOL]         return ~position; [EOL]     } [EOL]     offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     limit -= 2; [EOL]     position += 2; [EOL]     parse: { [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         boolean expectSeparators; [EOL]         c = text.charAt(position); [EOL]         if (c == ':') { [EOL]             expectSeparators = true; [EOL]             limit--; [EOL]             position++; [EOL]         } else if (c >= '0' && c <= '9') { [EOL]             expectSeparators = false; [EOL]         } else { [EOL]             break parse; [EOL]         } [EOL]         int count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int minutes = FormatUtils.parseTwoDigits(text, position); [EOL]         if (minutes > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != ':') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int seconds = FormatUtils.parseTwoDigits(text, position); [EOL]         if (seconds > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 3); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 1) { [EOL]             return ~position; [EOL]         } [EOL]         offset += (text.charAt(position++) - '0') * 100; [EOL]         if (count > 1) { [EOL]             offset += (text.charAt(position++) - '0') * 10; [EOL]             if (count > 2) { [EOL]                 offset += text.charAt(position++) - '0'; [EOL]             } [EOL]         } [EOL]     } [EOL]     bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     String str = text.substring(position); [EOL]     String best = null; [EOL]     for (String id : ALL_IDS) { [EOL]         if (str.startsWith(id)) { [EOL]             if (best == null || id.length() > best.length()) { [EOL]                 best = id; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (best != null) { [EOL]         bucket.setZone(DateTimeZone.forID(best)); [EOL]         return position + best.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] }
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, partial, locale); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, partial, locale); [EOL]     } [EOL] }
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, partial, locale); [EOL]     } [EOL] }
public static TimeOfDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new TimeOfDay(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public static TimeOfDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new TimeOfDay(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public static TimeOfDay fromMillisOfDay(long millisOfDay) { [EOL]     return fromMillisOfDay(millisOfDay, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     chrono = chrono.withUTC(); [EOL]     return new TimeOfDay(millisOfDay, chrono); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     chrono = chrono.withUTC(); [EOL]     return new TimeOfDay(millisOfDay, chrono); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(new int[] { hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond }, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int size() { [EOL]     return 4; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).addWrapPartial(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).addWrapPartial(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).addWrapPartial(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).addWrapPartial(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMinutes(int minutes) { [EOL]     return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusMinutes(int minutes) { [EOL]     return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public LocalTime toLocalTime() { [EOL]     return new LocalTime(getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), getChronology()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getHourOfDay() { [EOL]     return getValue(HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMinuteOfHour() { [EOL]     return getValue(MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getSecondOfMinute() { [EOL]     return getValue(SECOND_OF_MINUTE); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int getMillisOfSecond() { [EOL]     return getValue(MILLIS_OF_SECOND); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property minuteOfHour() { [EOL]     return new Property(this, MINUTE_OF_HOUR); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property secondOfMinute() { [EOL]     return new Property(this, SECOND_OF_MINUTE); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public String toString() { [EOL]     return ISODateTimeFormat.tTime().print(this); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
Property(TimeOfDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iTimeOfDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
Property(TimeOfDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iTimeOfDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
Property(TimeOfDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iTimeOfDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeField getField() { [EOL]     return iTimeOfDay.getField(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
protected ReadablePartial getReadablePartial() { [EOL]     return iTimeOfDay; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(int value) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(int value) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(int value) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(int value) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int get(long instant) { [EOL]     int year = getWrappedField().get(instant); [EOL]     return year < 0 ? -year : year; [EOL] }
public boolean contains(long millisInstant) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (millisInstant >= thisStart && millisInstant < thisEnd); [EOL] }
public boolean contains(long millisInstant) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (millisInstant >= thisStart && millisInstant < thisEnd); [EOL] }
public boolean contains(long millisInstant) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (millisInstant >= thisStart && millisInstant < thisEnd); [EOL] }
public boolean contains(long millisInstant) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (millisInstant >= thisStart && millisInstant < thisEnd); [EOL] }
public boolean contains(long millisInstant) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (millisInstant >= thisStart && millisInstant < thisEnd); [EOL] }
public boolean containsNow() { [EOL]     return contains(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean contains(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     return contains(instant.getMillis()); [EOL] }
public boolean contains(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     return contains(instant.getMillis()); [EOL] }
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] }
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] }
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     if (size() != other.size()) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public MutablePeriod(int hours, int minutes, int seconds, int millis) { [EOL]     super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard()); [EOL] }
public MutablePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard()); [EOL] }
public MutablePeriod(long duration, Chronology chronology) { [EOL]     super(duration, null, chronology); [EOL] }
public MutablePeriod(long duration, Chronology chronology) { [EOL]     super(duration, null, chronology); [EOL] }
public MutablePeriod(long startInstant, long endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type, null); [EOL] }
public MutablePeriod(long startInstant, long endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type, null); [EOL] }
public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(startInstant, endInstant, type, chrono); [EOL] }
public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(startInstant, endInstant, type, chrono); [EOL] }
public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(startInstant, endInstant, type, chrono); [EOL] }
public void setPeriod(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         setPeriod(0L); [EOL]     } else { [EOL]         Chronology chrono = DateTimeUtils.getChronology(interval.getChronology()); [EOL]         setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono); [EOL]     } [EOL] }
public void setPeriod(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         setPeriod(0L); [EOL]     } else { [EOL]         Chronology chrono = DateTimeUtils.getChronology(interval.getChronology()); [EOL]         setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono); [EOL]     } [EOL] }
public void setPeriod(long startInstant, long endInstant, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     setValues(chrono.get(this, startInstant, endInstant)); [EOL] }
public void setPeriod(long startInstant, long endInstant, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     setValues(chrono.get(this, startInstant, endInstant)); [EOL] }
public void setPeriod(ReadableDuration duration) { [EOL]     setPeriod(duration, null); [EOL] }
public void setPeriod(ReadableDuration duration) { [EOL]     setPeriod(duration, null); [EOL] }
public void setPeriod(ReadableDuration duration, Chronology chrono) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setPeriod(durationMillis, chrono); [EOL] }
public void setPeriod(ReadableDuration duration, Chronology chrono) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setPeriod(durationMillis, chrono); [EOL] }
public void setPeriod(ReadableDuration duration, Chronology chrono) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setPeriod(durationMillis, chrono); [EOL] }
public void add(DurationFieldType field, int value) { [EOL]     super.addField(field, value); [EOL] }
public int getHours() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX); [EOL] }
public void setMonths(int months) { [EOL]     super.setField(DurationFieldType.months(), months); [EOL] }
public void setMonths(int months) { [EOL]     super.setField(DurationFieldType.months(), months); [EOL] }
public void setMonths(int months) { [EOL]     super.setField(DurationFieldType.months(), months); [EOL] }
public void setDays(int days) { [EOL]     super.setField(DurationFieldType.days(), days); [EOL] }
public void setDays(int days) { [EOL]     super.setField(DurationFieldType.days(), days); [EOL] }
public void setDays(int days) { [EOL]     super.setField(DurationFieldType.days(), days); [EOL] }
public void setHours(int hours) { [EOL]     super.setField(DurationFieldType.hours(), hours); [EOL] }
public void setHours(int hours) { [EOL]     super.setField(DurationFieldType.hours(), hours); [EOL] }
public void setMinutes(int minutes) { [EOL]     super.setField(DurationFieldType.minutes(), minutes); [EOL] }
public void setMinutes(int minutes) { [EOL]     super.setField(DurationFieldType.minutes(), minutes); [EOL] }
public void setSeconds(int seconds) { [EOL]     super.setField(DurationFieldType.seconds(), seconds); [EOL] }
public void setSeconds(int seconds) { [EOL]     super.setField(DurationFieldType.seconds(), seconds); [EOL] }
public void setSeconds(int seconds) { [EOL]     super.setField(DurationFieldType.seconds(), seconds); [EOL] }
public void setSeconds(int seconds) { [EOL]     super.setField(DurationFieldType.seconds(), seconds); [EOL] }
public void addSeconds(int seconds) { [EOL]     super.addField(DurationFieldType.seconds(), seconds); [EOL] }
public void addSeconds(int seconds) { [EOL]     super.addField(DurationFieldType.seconds(), seconds); [EOL] }
public void addSeconds(int seconds) { [EOL]     super.addField(DurationFieldType.seconds(), seconds); [EOL] }
public void setMillis(int millis) { [EOL]     super.setField(DurationFieldType.millis(), millis); [EOL] }
public void setMillis(int millis) { [EOL]     super.setField(DurationFieldType.millis(), millis); [EOL] }
public MutablePeriod copy() { [EOL]     return (MutablePeriod) clone(); [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         throw new InternalError("Clone error"); [EOL]     } [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         throw new InternalError("Clone error"); [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant - instant % iUnitMillis; [EOL]     } else { [EOL]         instant += 1; [EOL]         return instant - instant % iUnitMillis - iUnitMillis; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant - instant % iUnitMillis; [EOL]     } else { [EOL]         instant += 1; [EOL]         return instant - instant % iUnitMillis - iUnitMillis; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant - instant % iUnitMillis; [EOL]     } else { [EOL]         instant += 1; [EOL]         return instant - instant % iUnitMillis - iUnitMillis; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant - instant % iUnitMillis; [EOL]     } else { [EOL]         instant += 1; [EOL]         return instant - instant % iUnitMillis - iUnitMillis; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
BasicYearDateTimeField(BasicChronology chronology) { [EOL]     super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear()); [EOL]     iChronology = chronology; [EOL] }
public DurationField getRangeDurationField() { [EOL]     return null; [EOL] }
public boolean isLeap(long instant) { [EOL]     return iChronology.isLeapYear(get(instant)); [EOL] }
public boolean isLeap(long instant) { [EOL]     return iChronology.isLeapYear(get(instant)); [EOL] }
public int getLeapAmount(long instant) { [EOL]     if (iChronology.isLeapYear(get(instant))) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int getLeapAmount(long instant) { [EOL]     if (iChronology.isLeapYear(get(instant))) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public long roundCeiling(long instant) { [EOL]     int year = get(instant); [EOL]     long yearStartMillis = iChronology.getYearMillis(year); [EOL]     if (instant != yearStartMillis) { [EOL]         instant = iChronology.getYearMillis(year + 1); [EOL]     } [EOL]     return instant; [EOL] }
public long roundCeiling(long instant) { [EOL]     int year = get(instant); [EOL]     long yearStartMillis = iChronology.getYearMillis(year); [EOL]     if (instant != yearStartMillis) { [EOL]         instant = iChronology.getYearMillis(year + 1); [EOL]     } [EOL]     return instant; [EOL] }
public int compareTo(SavedField obj) { [EOL]     DateTimeField other = obj.iField; [EOL]     int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField()); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return compareReverse(iField.getDurationField(), other.getDurationField()); [EOL] }
public int compareTo(SavedField obj) { [EOL]     DateTimeField other = obj.iField; [EOL]     int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField()); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return compareReverse(iField.getDurationField(), other.getDurationField()); [EOL] }
public OffsetDateTimeField(DateTimeField field, int offset) { [EOL]     this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL] }
public OffsetDateTimeField(DateTimeField field, int offset) { [EOL]     this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) { [EOL]     this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) { [EOL]     this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) { [EOL]     this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset, int minValue, int maxValue) { [EOL]     super(field, type); [EOL]     if (offset == 0) { [EOL]         throw new IllegalArgumentException("The offset cannot be zero"); [EOL]     } [EOL]     iOffset = offset; [EOL]     if (minValue < (field.getMinimumValue() + offset)) { [EOL]         iMin = field.getMinimumValue() + offset; [EOL]     } else { [EOL]         iMin = minValue; [EOL]     } [EOL]     if (maxValue > (field.getMaximumValue() + offset)) { [EOL]         iMax = field.getMaximumValue() + offset; [EOL]     } else { [EOL]         iMax = maxValue; [EOL]     } [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset, int minValue, int maxValue) { [EOL]     super(field, type); [EOL]     if (offset == 0) { [EOL]         throw new IllegalArgumentException("The offset cannot be zero"); [EOL]     } [EOL]     iOffset = offset; [EOL]     if (minValue < (field.getMinimumValue() + offset)) { [EOL]         iMin = field.getMinimumValue() + offset; [EOL]     } else { [EOL]         iMin = minValue; [EOL]     } [EOL]     if (maxValue > (field.getMaximumValue() + offset)) { [EOL]         iMax = field.getMaximumValue() + offset; [EOL]     } else { [EOL]         iMax = maxValue; [EOL]     } [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset, int minValue, int maxValue) { [EOL]     super(field, type); [EOL]     if (offset == 0) { [EOL]         throw new IllegalArgumentException("The offset cannot be zero"); [EOL]     } [EOL]     iOffset = offset; [EOL]     if (minValue < (field.getMinimumValue() + offset)) { [EOL]         iMin = field.getMinimumValue() + offset; [EOL]     } else { [EOL]         iMin = minValue; [EOL]     } [EOL]     if (maxValue > (field.getMaximumValue() + offset)) { [EOL]         iMax = field.getMaximumValue() + offset; [EOL]     } else { [EOL]         iMax = maxValue; [EOL]     } [EOL] }
public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset, int minValue, int maxValue) { [EOL]     super(field, type); [EOL]     if (offset == 0) { [EOL]         throw new IllegalArgumentException("The offset cannot be zero"); [EOL]     } [EOL]     iOffset = offset; [EOL]     if (minValue < (field.getMinimumValue() + offset)) { [EOL]         iMin = field.getMinimumValue() + offset; [EOL]     } else { [EOL]         iMin = minValue; [EOL]     } [EOL]     if (maxValue > (field.getMaximumValue() + offset)) { [EOL]         iMax = field.getMaximumValue() + offset; [EOL]     } else { [EOL]         iMax = maxValue; [EOL]     } [EOL] }
public int get(long instant) { [EOL]     return super.get(instant) + iOffset; [EOL] }
public boolean isLeap(long instant) { [EOL]     return getWrappedField().isLeap(instant); [EOL] }
public int getLeapAmount(long instant) { [EOL]     return getWrappedField().getLeapAmount(instant); [EOL] }
public DurationField getLeapDurationField() { [EOL]     return getWrappedField().getLeapDurationField(); [EOL] }
public int getMinimumValue() { [EOL]     return iMin; [EOL] }
public int getMaximumValue() { [EOL]     return iMax; [EOL] }
public long roundHalfEven(long instant) { [EOL]     return getWrappedField().roundHalfEven(instant); [EOL] }
public long roundFloor(long instant) { [EOL]     return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY) - 3 * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public long roundFloor(long instant) { [EOL]     return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY) - 3 * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public int getMaximumValue() { [EOL]     return 53; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) { [EOL]             int weekyear = values[i]; [EOL]             return iChronology.getWeeksInYear(weekyear); [EOL]         } [EOL]     } [EOL]     return 53; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) { [EOL]             int weekyear = values[i]; [EOL]             return iChronology.getWeeksInYear(weekyear); [EOL]         } [EOL]     } [EOL]     return 53; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) { [EOL]             int weekyear = values[i]; [EOL]             return iChronology.getWeeksInYear(weekyear); [EOL]         } [EOL]     } [EOL]     return 53; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 6) == 6) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 6) == 6) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 6) == 6) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
private void setFields() { [EOL]     Fields fields = new Fields(); [EOL]     if (iBase != null) { [EOL]         fields.copyFieldsFrom(iBase); [EOL]     } [EOL]     assemble(fields); [EOL]     { [EOL]         DurationField f; [EOL]         iMillis = (f = fields.millis) != null ? f : super.millis(); [EOL]         iSeconds = (f = fields.seconds) != null ? f : super.seconds(); [EOL]         iMinutes = (f = fields.minutes) != null ? f : super.minutes(); [EOL]         iHours = (f = fields.hours) != null ? f : super.hours(); [EOL]         iHalfdays = (f = fields.halfdays) != null ? f : super.halfdays(); [EOL]         iDays = (f = fields.days) != null ? f : super.days(); [EOL]         iWeeks = (f = fields.weeks) != null ? f : super.weeks(); [EOL]         iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears(); [EOL]         iMonths = (f = fields.months) != null ? f : super.months(); [EOL]         iYears = (f = fields.years) != null ? f : super.years(); [EOL]         iCenturies = (f = fields.centuries) != null ? f : super.centuries(); [EOL]         iEras = (f = fields.eras) != null ? f : super.eras(); [EOL]     } [EOL]     { [EOL]         DateTimeField f; [EOL]         iMillisOfSecond = (f = fields.millisOfSecond) != null ? f : super.millisOfSecond(); [EOL]         iMillisOfDay = (f = fields.millisOfDay) != null ? f : super.millisOfDay(); [EOL]         iSecondOfMinute = (f = fields.secondOfMinute) != null ? f : super.secondOfMinute(); [EOL]         iSecondOfDay = (f = fields.secondOfDay) != null ? f : super.secondOfDay(); [EOL]         iMinuteOfHour = (f = fields.minuteOfHour) != null ? f : super.minuteOfHour(); [EOL]         iMinuteOfDay = (f = fields.minuteOfDay) != null ? f : super.minuteOfDay(); [EOL]         iHourOfDay = (f = fields.hourOfDay) != null ? f : super.hourOfDay(); [EOL]         iClockhourOfDay = (f = fields.clockhourOfDay) != null ? f : super.clockhourOfDay(); [EOL]         iHourOfHalfday = (f = fields.hourOfHalfday) != null ? f : super.hourOfHalfday(); [EOL]         iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday(); [EOL]         iHalfdayOfDay = (f = fields.halfdayOfDay) != null ? f : super.halfdayOfDay(); [EOL]         iDayOfWeek = (f = fields.dayOfWeek) != null ? f : super.dayOfWeek(); [EOL]         iDayOfMonth = (f = fields.dayOfMonth) != null ? f : super.dayOfMonth(); [EOL]         iDayOfYear = (f = fields.dayOfYear) != null ? f : super.dayOfYear(); [EOL]         iWeekOfWeekyear = (f = fields.weekOfWeekyear) != null ? f : super.weekOfWeekyear(); [EOL]         iWeekyear = (f = fields.weekyear) != null ? f : super.weekyear(); [EOL]         iWeekyearOfCentury = (f = fields.weekyearOfCentury) != null ? f : super.weekyearOfCentury(); [EOL]         iMonthOfYear = (f = fields.monthOfYear) != null ? f : super.monthOfYear(); [EOL]         iYear = (f = fields.year) != null ? f : super.year(); [EOL]         iYearOfEra = (f = fields.yearOfEra) != null ? f : super.yearOfEra(); [EOL]         iYearOfCentury = (f = fields.yearOfCentury) != null ? f : super.yearOfCentury(); [EOL]         iCenturyOfEra = (f = fields.centuryOfEra) != null ? f : super.centuryOfEra(); [EOL]         iEra = (f = fields.era) != null ? f : super.era(); [EOL]     } [EOL]     int flags; [EOL]     if (iBase == null) { [EOL]         flags = 0; [EOL]     } else { [EOL]         flags = ((iHourOfDay == iBase.hourOfDay() && iMinuteOfHour == iBase.minuteOfHour() && iSecondOfMinute == iBase.secondOfMinute() && iMillisOfSecond == iBase.millisOfSecond()) ? 1 : 0) | ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) | ((iYear == iBase.year() && iMonthOfYear == iBase.monthOfYear() && iDayOfMonth == iBase.dayOfMonth()) ? 4 : 0); [EOL]     } [EOL]     iBaseFlags = flags; [EOL] }
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL]     in.defaultReadObject(); [EOL]     setFields(); [EOL] }
public static Days daysIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Days.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days()); [EOL]     return Days.days(amount); [EOL] }
public static Days daysIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Days.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days()); [EOL]     return Days.days(amount); [EOL] }
public Days minus(int days) { [EOL]     return plus(FieldUtils.safeNegate(days)); [EOL] }
public Days minus(int days) { [EOL]     return plus(FieldUtils.safeNegate(days)); [EOL] }
public Days minus(int days) { [EOL]     return plus(FieldUtils.safeNegate(days)); [EOL] }
public Days minus(Days days) { [EOL]     if (days == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(days.getValue()); [EOL] }
public Days minus(Days days) { [EOL]     if (days == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(days.getValue()); [EOL] }
public static MonthDay now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new MonthDay(zone); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay() { [EOL]     super(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
private Object readResolve() { [EOL]     if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) { [EOL]         return new MonthDay(this, getChronology().withUTC()); [EOL]     } [EOL]     return this; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
private Object readResolve() { [EOL]     if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) { [EOL]         return new MonthDay(this, getChronology().withUTC()); [EOL]     } [EOL]     return this; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         MonthDay newMonthDay = new MonthDay(this, newChronology); [EOL]         newChronology.validate(newMonthDay, getValues()); [EOL]         return newMonthDay; [EOL]     } [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         MonthDay newMonthDay = new MonthDay(this, newChronology); [EOL]         newChronology.validate(newMonthDay, getValues()); [EOL]         return newMonthDay; [EOL]     } [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay getMonthDay() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(int value) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, value); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(int value) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, value); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public LocalDateTime(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     iLocalMillis = localMillis; [EOL]     iChronology = chronology.withUTC(); [EOL] }
public LocalDateTime(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     iLocalMillis = localMillis; [EOL]     iChronology = chronology.withUTC(); [EOL] }
public LocalDateTime(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalDateTime(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalDateTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public LocalDate toLocalDate() { [EOL]     return new LocalDate(getLocalMillis(), getChronology()); [EOL] }
public Date toDate(final TimeZone timeZone) { [EOL]     final Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.clear(); [EOL]     calendar.set(getYear(), getMonthOfYear() - 1, getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); [EOL]     Date date = calendar.getTime(); [EOL]     date.setTime(date.getTime() + getMillisOfSecond()); [EOL]     return correctDstTransition(date, timeZone); [EOL] }
LocalDateTime withLocalMillis(long newMillis) { [EOL]     return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology())); [EOL] }
LocalDateTime withLocalMillis(long newMillis) { [EOL]     return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology())); [EOL] }
public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public Property monthOfYear() { [EOL]     return new Property(this, getChronology().monthOfYear()); [EOL] }
Property(LocalDateTime instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
public LocalDateTime addToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime addToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime addToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono != null) { [EOL]         return chrono; [EOL]     } [EOL]     Calendar cal = (Calendar) object; [EOL]     DateTimeZone zone = null; [EOL]     try { [EOL]         zone = DateTimeZone.forTimeZone(cal.getTimeZone()); [EOL]     } catch (IllegalArgumentException ex) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     return getChronology(cal, zone); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono != null) { [EOL]         return chrono; [EOL]     } [EOL]     Calendar cal = (Calendar) object; [EOL]     DateTimeZone zone = null; [EOL]     try { [EOL]         zone = DateTimeZone.forTimeZone(cal.getTimeZone()); [EOL]     } catch (IllegalArgumentException ex) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     return getChronology(cal, zone); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono != null) { [EOL]         return chrono; [EOL]     } [EOL]     Calendar cal = (Calendar) object; [EOL]     DateTimeZone zone = null; [EOL]     try { [EOL]         zone = DateTimeZone.forTimeZone(cal.getTimeZone()); [EOL]     } catch (IllegalArgumentException ex) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     return getChronology(cal, zone); [EOL] }
public DecoratedDurationField(DurationField field, DurationFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public DecoratedDurationField(DurationField field, DurationFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public DecoratedDurationField(DurationField field, DurationFieldType type) { [EOL]     super(type); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!field.isSupported()) { [EOL]         throw new IllegalArgumentException("The field must be supported"); [EOL]     } [EOL]     iField = field; [EOL] }
public DateTimePrinter getPrinter() { [EOL]     return iPrinter; [EOL] }
public DateTimeParser getParser() { [EOL]     return iParser; [EOL] }
public Chronology getChronology() { [EOL]     return iChrono; [EOL] }
public DateTimeFormatter withZoneUTC() { [EOL]     return withZone(DateTimeZone.UTC); [EOL] }
public void printTo(Writer out, ReadableInstant instant) throws IOException { [EOL]     long millis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(instant); [EOL]     printTo(out, millis, chrono); [EOL] }
public void printTo(Writer out, ReadableInstant instant) throws IOException { [EOL]     long millis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(instant); [EOL]     printTo(out, millis, chrono); [EOL] }
public void printTo(StringBuffer buf, long instant) { [EOL]     printTo(buf, instant, null); [EOL] }
public void printTo(Writer out, long instant) throws IOException { [EOL]     printTo(out, instant, null); [EOL] }
public void printTo(Writer out, long instant) throws IOException { [EOL]     printTo(out, instant, null); [EOL] }
public void printTo(Writer out, ReadablePartial partial) throws IOException { [EOL]     DateTimePrinter printer = requirePrinter(); [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     printer.printTo(out, partial, iLocale); [EOL] }
public void printTo(Writer out, ReadablePartial partial) throws IOException { [EOL]     DateTimePrinter printer = requirePrinter(); [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The partial must not be null"); [EOL]     } [EOL]     printer.printTo(out, partial, iLocale); [EOL] }
public String print(long instant) { [EOL]     StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength()); [EOL]     printTo(buf, instant); [EOL]     return buf.toString(); [EOL] }
public String print(long instant) { [EOL]     StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength()); [EOL]     printTo(buf, instant); [EOL]     return buf.toString(); [EOL] }
private void printTo(Writer buf, long instant, Chronology chrono) throws IOException { [EOL]     DateTimePrinter printer = requirePrinter(); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeZone zone = chrono.getZone(); [EOL]     int offset = zone.getOffset(instant); [EOL]     long adjustedInstant = instant + offset; [EOL]     if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) { [EOL]         zone = DateTimeZone.UTC; [EOL]         offset = 0; [EOL]         adjustedInstant = instant; [EOL]     } [EOL]     printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale); [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutableDateTime parseMutableDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             MutableDateTime dt = new MutableDateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt.setZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public String getName() { [EOL]     return "millis"; [EOL] }
public final boolean isPrecise() { [EOL]     return true; [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public long getMillis(int value) { [EOL]     return value; [EOL] }
public long getMillis(int value) { [EOL]     return value; [EOL] }
public long getMillis(int value) { [EOL]     return value; [EOL] }
public long getMillis(long value) { [EOL]     return value; [EOL] }
public long add(long instant, int value) { [EOL]     return FieldUtils.safeAdd(instant, value); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeSubtract(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeSubtract(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeSubtract(minuendInstant, subtrahendInstant); [EOL] }
public int hashCode() { [EOL]     return (int) getUnitMillis(); [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public Period toPeriod() { [EOL]     return new Period(getMillis()); [EOL] }
public int compareTo(ReadableDuration other) { [EOL]     long thisMillis = this.getMillis(); [EOL]     long otherMillis = other.getMillis(); [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } [EOL]     if (thisMillis > otherMillis) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(ReadableDuration other) { [EOL]     long thisMillis = this.getMillis(); [EOL]     long otherMillis = other.getMillis(); [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } [EOL]     if (thisMillis > otherMillis) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(ReadableDuration other) { [EOL]     long thisMillis = this.getMillis(); [EOL]     long otherMillis = other.getMillis(); [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } [EOL]     if (thisMillis > otherMillis) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public boolean isEqual(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) == 0; [EOL] }
public boolean isEqual(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) == 0; [EOL] }
public boolean isEqual(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) == 0; [EOL] }
public boolean isShorterThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) < 0; [EOL] }
public boolean isShorterThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) < 0; [EOL] }
public boolean isShorterThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) < 0; [EOL] }
public boolean isShorterThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) < 0; [EOL] }
public long subtract(long instant, int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         return subtract(instant, (long) value); [EOL]     } [EOL]     return add(instant, -value); [EOL] }
public long subtract(long instant, int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         return subtract(instant, (long) value); [EOL]     } [EOL]     return add(instant, -value); [EOL] }
public long subtract(long instant, int value) { [EOL]     if (value == Integer.MIN_VALUE) { [EOL]         return subtract(instant, (long) value); [EOL]     } [EOL]     return add(instant, -value); [EOL] }
public long subtract(long instant, long value) { [EOL]     if (value == Long.MIN_VALUE) { [EOL]         throw new ArithmeticException("Long.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return add(instant, -value); [EOL] }
public long subtract(long instant, long value) { [EOL]     if (value == Long.MIN_VALUE) { [EOL]         throw new ArithmeticException("Long.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return add(instant, -value); [EOL] }
public long subtract(long instant, long value) { [EOL]     if (value == Long.MIN_VALUE) { [EOL]         throw new ArithmeticException("Long.MIN_VALUE cannot be negated"); [EOL]     } [EOL]     return add(instant, -value); [EOL] }
public DefaultNameProvider() { [EOL] }
public String getShortName(Locale locale, String id, String nameKey) { [EOL]     String[] nameSet = getNameSet(locale, id, nameKey); [EOL]     return nameSet == null ? null : nameSet[0]; [EOL] }
public String getShortName(Locale locale, String id, String nameKey) { [EOL]     String[] nameSet = getNameSet(locale, id, nameKey); [EOL]     return nameSet == null ? null : nameSet[0]; [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
public String monthOfYearValueToShortText(int value) { [EOL]     return iShortMonths[value]; [EOL] }
public String monthOfYearValueToShortText(int value) { [EOL]     return iShortMonths[value]; [EOL] }
public String monthOfYearValueToShortText(int value) { [EOL]     return iShortMonths[value]; [EOL] }
public String monthOfYearValueToShortText(int value) { [EOL]     return iShortMonths[value]; [EOL] }
public String monthOfYearValueToShortText(int value) { [EOL]     return iShortMonths[value]; [EOL] }
public int monthOfYearTextToValue(String text) { [EOL]     Integer month = iParseMonths.get(text); [EOL]     if (month != null) { [EOL]         return month.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.monthOfYear(), text); [EOL] }
public int monthOfYearTextToValue(String text) { [EOL]     Integer month = iParseMonths.get(text); [EOL]     if (month != null) { [EOL]         return month.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.monthOfYear(), text); [EOL] }
public int getDayOfWeekMaxShortTextLength() { [EOL]     return iMaxShortDayOfWeekLength; [EOL] }
public String halfdayValueToText(int value) { [EOL]     return iHalfday[value]; [EOL] }
public String halfdayValueToText(int value) { [EOL]     return iHalfday[value]; [EOL] }
public String halfdayValueToText(int value) { [EOL]     return iHalfday[value]; [EOL] }
public int halfdayTextToValue(String text) { [EOL]     String[] halfday = iHalfday; [EOL]     for (int i = halfday.length; --i >= 0; ) { [EOL]         if (halfday[i].equalsIgnoreCase(text)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.halfdayOfDay(), text); [EOL] }
public int getHalfdayMaxTextLength() { [EOL]     return iMaxHalfdayLength; [EOL] }
public DateTime toDateTime(DateTimeZone zone) { [EOL]     Chronology chrono = DateTimeUtils.getChronology(getChronology()); [EOL]     chrono = chrono.withZone(zone); [EOL]     return new DateTime(getMillis(), chrono); [EOL] }
public DateTime toDateTime(DateTimeZone zone) { [EOL]     Chronology chrono = DateTimeUtils.getChronology(getChronology()); [EOL]     chrono = chrono.withZone(zone); [EOL]     return new DateTime(getMillis(), chrono); [EOL] }
public MutableDateTime toMutableDateTime(Chronology chronology) { [EOL]     return new MutableDateTime(getMillis(), chronology); [EOL] }
public MutableDateTime toMutableDateTime(Chronology chronology) { [EOL]     return new MutableDateTime(getMillis(), chronology); [EOL] }
public Date toDate() { [EOL]     return new Date(getMillis()); [EOL] }
public MutableInterval() { [EOL]     super(0L, 0L, null); [EOL] }
public MutableInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public MutableInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public MutableInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public MutableInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public MutableInterval(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public MutableInterval(Object interval) { [EOL]     super(interval, null); [EOL] }
public MutableInterval(Object interval) { [EOL]     super(interval, null); [EOL] }
public MutableInterval copy() { [EOL]     return (MutableInterval) clone(); [EOL] }
public static DateMidnight now() { [EOL]     return new DateMidnight(); [EOL] }
public static DateMidnight now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new DateMidnight(chronology); [EOL] }
public static DateMidnight now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new DateMidnight(chronology); [EOL] }
public DateMidnight(DateTimeZone zone) { [EOL]     super(zone); [EOL] }
public DateMidnight(DateTimeZone zone) { [EOL]     super(zone); [EOL] }
public DateMidnight(Chronology chronology) { [EOL]     super(chronology); [EOL] }
public DateMidnight(Chronology chronology) { [EOL]     super(chronology); [EOL] }
public DateMidnight(int year, int monthOfYear, int dayOfMonth) { [EOL]     super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0); [EOL] }
public DateMidnight(int year, int monthOfYear, int dayOfMonth) { [EOL]     super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0); [EOL] }
public DateMidnight plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public Property yearOfEra() { [EOL]     return new Property(this, getChronology().yearOfEra()); [EOL] }
Property(DateMidnight instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
public DateMidnight setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateMidnight setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateMidnight setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateMidnight setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public DateMidnight setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public DateMidnight roundHalfCeilingCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis())); [EOL] }
protected BasePartial() { [EOL]     this(DateTimeUtils.currentTimeMillis(), null); [EOL] }
protected BasePartial(BasePartial base, int[] values) { [EOL]     super(); [EOL]     iChronology = base.iChronology; [EOL]     iValues = values; [EOL] }
protected BasePartial(BasePartial base, Chronology chrono) { [EOL]     super(); [EOL]     iChronology = chrono.withUTC(); [EOL]     iValues = base.iValues; [EOL] }
protected BasePartial(BasePartial base, Chronology chrono) { [EOL]     super(); [EOL]     iChronology = chrono.withUTC(); [EOL]     iValues = base.iValues; [EOL] }
public int[] getValues() { [EOL]     return (int[]) iValues.clone(); [EOL] }
