public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) { [EOL]     Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF); [EOL]     Type type = f.getGenericType(); [EOL]     Type actualType = getActualType(type, typeDefiningF, classDefiningF); [EOL]     return new TypeInfo(actualType); [EOL] }
public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) { [EOL]     Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF); [EOL]     Type type = f.getGenericType(); [EOL]     Type actualType = getActualType(type, typeDefiningF, classDefiningF); [EOL]     return new TypeInfo(actualType); [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type getActualType(Type typeToEvaluate, Type parentType, Class<?> rawParentClass) { [EOL]     if (typeToEvaluate instanceof Class<?>) { [EOL]         return typeToEvaluate; [EOL]     } else if (typeToEvaluate instanceof ParameterizedType) { [EOL]         ParameterizedType castedType = (ParameterizedType) typeToEvaluate; [EOL]         Type owner = castedType.getOwnerType(); [EOL]         Type[] actualTypeParameters = extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass); [EOL]         Type rawType = castedType.getRawType(); [EOL]         return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner); [EOL]     } else if (typeToEvaluate instanceof GenericArrayType) { [EOL]         GenericArrayType castedType = (GenericArrayType) typeToEvaluate; [EOL]         Type componentType = castedType.getGenericComponentType(); [EOL]         Type actualType = getActualType(componentType, parentType, rawParentClass); [EOL]         if (componentType.equals(actualType)) { [EOL]             return castedType; [EOL]         } [EOL]         return actualType instanceof Class<?> ? TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType)) : new GenericArrayTypeImpl(actualType); [EOL]     } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]         if (parentType instanceof ParameterizedType) { [EOL]             TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate; [EOL]             TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters(); [EOL]             ParameterizedType objParameterizedType = (ParameterizedType) parentType; [EOL]             int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable); [EOL]             Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments(); [EOL]             return actualTypeArguments[indexOfActualTypeArgument]; [EOL]         } else if (typeToEvaluate instanceof TypeVariable<?>) { [EOL]             Type theSearchedType = null; [EOL]             do { [EOL]                 theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate); [EOL]             } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>)); [EOL]             if (theSearchedType != null) { [EOL]                 return theSearchedType; [EOL]             } [EOL]         } [EOL]         throw new UnsupportedOperationException("Expecting parameterized type, got " + parentType + ".\n Are you missing the use of TypeToken idiom?\n See " + "http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"); [EOL]     } else if (typeToEvaluate instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) typeToEvaluate; [EOL]         return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + typeToEvaluate + "\' is not a Class, " + "ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."); [EOL]     } [EOL] }
private static Type[] extractRealTypes(Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) { [EOL]     Preconditions.checkNotNull(actualTypeArguments); [EOL]     Type[] retTypes = new Type[actualTypeArguments.length]; [EOL]     for (int i = 0; i < actualTypeArguments.length; ++i) { [EOL]         retTypes[i] = getActualType(actualTypeArguments[i], parentType, rawParentClass); [EOL]     } [EOL]     return retTypes; [EOL] }
private static Type[] extractRealTypes(Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) { [EOL]     Preconditions.checkNotNull(actualTypeArguments); [EOL]     Type[] retTypes = new Type[actualTypeArguments.length]; [EOL]     for (int i = 0; i < actualTypeArguments.length; ++i) { [EOL]         retTypes[i] = getActualType(actualTypeArguments[i], parentType, rawParentClass); [EOL]     } [EOL]     return retTypes; [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object array = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public JsonWriter(Writer out) { [EOL]     if (out == null) { [EOL]         throw new NullPointerException("out == null"); [EOL]     } [EOL]     this.out = out; [EOL] }
public JsonWriter(Writer out) { [EOL]     if (out == null) { [EOL]         throw new NullPointerException("out == null"); [EOL]     } [EOL]     this.out = out; [EOL] }
public JsonWriter beginArray() throws IOException { [EOL]     return open(JsonScope.EMPTY_ARRAY, "["); [EOL] }
public JsonWriter endArray() throws IOException { [EOL]     return close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] }
public JsonWriter endArray() throws IOException { [EOL]     return close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] }
private JsonWriter open(JsonScope empty, String openBracket) throws IOException { [EOL]     beforeValue(true); [EOL]     stack.add(empty); [EOL]     out.write(openBracket); [EOL]     return this; [EOL] }
private JsonWriter open(JsonScope empty, String openBracket) throws IOException { [EOL]     beforeValue(true); [EOL]     stack.add(empty); [EOL]     out.write(openBracket); [EOL]     return this; [EOL] }
private JsonWriter open(JsonScope empty, String openBracket) throws IOException { [EOL]     beforeValue(true); [EOL]     stack.add(empty); [EOL]     out.write(openBracket); [EOL]     return this; [EOL] }
private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context != nonempty && context != empty) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     stack.remove(stack.size() - 1); [EOL]     if (context == nonempty) { [EOL]         newline(); [EOL]     } [EOL]     out.write(closeBracket); [EOL]     return this; [EOL] }
private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context != nonempty && context != empty) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     stack.remove(stack.size() - 1); [EOL]     if (context == nonempty) { [EOL]         newline(); [EOL]     } [EOL]     out.write(closeBracket); [EOL]     return this; [EOL] }
private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context != nonempty && context != empty) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     stack.remove(stack.size() - 1); [EOL]     if (context == nonempty) { [EOL]         newline(); [EOL]     } [EOL]     out.write(closeBracket); [EOL]     return this; [EOL] }
private JsonScope peek() { [EOL]     return stack.get(stack.size() - 1); [EOL] }
private void replaceTop(JsonScope topOfStack) { [EOL]     stack.set(stack.size() - 1, topOfStack); [EOL] }
private void replaceTop(JsonScope topOfStack) { [EOL]     stack.set(stack.size() - 1, topOfStack); [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
public JsonWriter value(Number value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     String string = value.toString(); [EOL]     if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(string); [EOL]     return this; [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void string(String value) throws IOException { [EOL]     out.write("\""); [EOL]     for (int i = 0, length = value.length(); i < length; i++) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '"': [EOL]             case '\\': [EOL]                 out.write('\\'); [EOL]                 out.write(c); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.write("\\t"); [EOL]                 break; [EOL]             case '\b': [EOL]                 out.write("\\b"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.write("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.write("\\r"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.write("\\f"); [EOL]                 break; [EOL]             case '<': [EOL]             case '>': [EOL]             case '&': [EOL]             case '=': [EOL]             case '\'': [EOL]                 if (htmlSafe) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (c <= 0x1F) { [EOL]                     out.write(String.format("\\u%04x", (int) c)); [EOL]                 } else { [EOL]                     out.write(c); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.write("\""); [EOL] }
private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] }
private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] }
private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (int modifier : modifiers) { [EOL]         if (f.hasModifier(modifier)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (int modifier : modifiers) { [EOL]         if (f.hasModifier(modifier)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public JsonReader(Reader in) { [EOL]     if (in == null) { [EOL]         throw new NullPointerException("in == null"); [EOL]     } [EOL]     this.in = in; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public JsonReader(Reader in) { [EOL]     if (in == null) { [EOL]         throw new NullPointerException("in == null"); [EOL]     } [EOL]     this.in = in; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public long nextLong() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a long but was " + peek()); [EOL]     } [EOL]     long result; [EOL]     try { [EOL]         result = Long.parseLong(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (long) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public long nextLong() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a long but was " + peek()); [EOL]     } [EOL]     long result; [EOL]     try { [EOL]         result = Long.parseLong(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (long) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public long nextLong() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a long but was " + peek()); [EOL]     } [EOL]     long result; [EOL]     try { [EOL]         result = Long.parseLong(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (long) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public long nextLong() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a long but was " + peek()); [EOL]     } [EOL]     long result; [EOL]     try { [EOL]         result = Long.parseLong(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (long) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public long nextLong() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a long but was " + peek()); [EOL]     } [EOL]     long result; [EOL]     try { [EOL]         result = Long.parseLong(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (long) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public int nextInt() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected an int but was " + peek()); [EOL]     } [EOL]     int result; [EOL]     try { [EOL]         result = Integer.parseInt(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (int) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public int nextInt() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected an int but was " + peek()); [EOL]     } [EOL]     int result; [EOL]     try { [EOL]         result = Integer.parseInt(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (int) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public int nextInt() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected an int but was " + peek()); [EOL]     } [EOL]     int result; [EOL]     try { [EOL]         result = Integer.parseInt(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (int) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public int nextInt() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected an int but was " + peek()); [EOL]     } [EOL]     int result; [EOL]     try { [EOL]         result = Integer.parseInt(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (int) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public int nextInt() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected an int but was " + peek()); [EOL]     } [EOL]     int result; [EOL]     try { [EOL]         result = Integer.parseInt(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (int) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextString(char quote) throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             if (c == quote) { [EOL]                 if (skipping) { [EOL]                     return "skipped!"; [EOL]                 } else if (builder == null) { [EOL]                     return new String(buffer, start, pos - start - 1); [EOL]                 } else { [EOL]                     builder.append(buffer, start, pos - start - 1); [EOL]                     return builder.toString(); [EOL]                 } [EOL]             } else if (c == '\\') { [EOL]                 if (builder == null) { [EOL]                     builder = new StringBuilder(); [EOL]                 } [EOL]                 builder.append(buffer, start, pos - start - 1); [EOL]                 builder.append(readEscapeCharacter()); [EOL]                 start = pos; [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     throw syntaxError("Unterminated string"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextLiteral() throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             switch(c) { [EOL]                 case '/': [EOL]                 case '\\': [EOL]                 case ';': [EOL]                 case '#': [EOL]                 case '=': [EOL]                     checkLenient(); [EOL]                 case '{': [EOL]                 case '}': [EOL]                 case '[': [EOL]                 case ']': [EOL]                 case ':': [EOL]                 case ',': [EOL]                 case ' ': [EOL]                 case '\t': [EOL]                 case '\f': [EOL]                 case '\r': [EOL]                 case '\n': [EOL]                     pos--; [EOL]                     if (skipping) { [EOL]                         return "skipped!"; [EOL]                     } else if (builder == null) { [EOL]                         return new String(buffer, start, pos - start); [EOL]                     } else { [EOL]                         builder.append(buffer, start, pos - start); [EOL]                         return builder.toString(); [EOL]                     } [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     return builder.toString(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonElement jsonChild = jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object child = visitChildAsObject(typeOfF, jsonChild); [EOL]             f.set(obj, child); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonElement jsonChild = jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object child = visitChildAsObject(typeOfF, jsonChild); [EOL]             f.set(obj, child); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonElement jsonChild = jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object child = visitChildAsObject(typeOfF, jsonChild); [EOL]             f.set(obj, child); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonElement jsonChild = jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object child = visitChildAsObject(typeOfF, jsonChild); [EOL]             f.set(obj, child); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void visitPrimitive(Object primitive) { [EOL]     if (!json.isJsonPrimitive()) { [EOL]         throw new JsonParseException("Type information is unavailable, and the target object is not a primitive: " + json); [EOL]     } [EOL]     JsonPrimitive prim = json.getAsJsonPrimitive(); [EOL]     target = (T) prim.getAsObject(); [EOL] }
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) { [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     DefaultTypeAdapters.DoubleSerializer doubleSerializer = new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Double.class, doubleSerializer); [EOL]     serializers.registerIfAbsent(double.class, doubleSerializer); [EOL]     DefaultTypeAdapters.FloatSerializer floatSerializer = new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Float.class, floatSerializer); [EOL]     serializers.registerIfAbsent(float.class, floatSerializer); [EOL]     DefaultTypeAdapters.LongSerializer longSerializer = new DefaultTypeAdapters.LongSerializer(longSerializationPolicy); [EOL]     serializers.registerIfAbsent(Long.class, longSerializer); [EOL]     serializers.registerIfAbsent(long.class, longSerializer); [EOL]     serializers.registerIfAbsent(DEFAULT_SERIALIZERS); [EOL]     return serializers; [EOL] }
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) { [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     DefaultTypeAdapters.DoubleSerializer doubleSerializer = new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Double.class, doubleSerializer); [EOL]     serializers.registerIfAbsent(double.class, doubleSerializer); [EOL]     DefaultTypeAdapters.FloatSerializer floatSerializer = new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Float.class, floatSerializer); [EOL]     serializers.registerIfAbsent(float.class, floatSerializer); [EOL]     DefaultTypeAdapters.LongSerializer longSerializer = new DefaultTypeAdapters.LongSerializer(longSerializationPolicy); [EOL]     serializers.registerIfAbsent(Long.class, longSerializer); [EOL]     serializers.registerIfAbsent(long.class, longSerializer); [EOL]     serializers.registerIfAbsent(DEFAULT_SERIALIZERS); [EOL]     return serializers; [EOL] }
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) { [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     DefaultTypeAdapters.DoubleSerializer doubleSerializer = new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Double.class, doubleSerializer); [EOL]     serializers.registerIfAbsent(double.class, doubleSerializer); [EOL]     DefaultTypeAdapters.FloatSerializer floatSerializer = new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Float.class, floatSerializer); [EOL]     serializers.registerIfAbsent(float.class, floatSerializer); [EOL]     DefaultTypeAdapters.LongSerializer longSerializer = new DefaultTypeAdapters.LongSerializer(longSerializationPolicy); [EOL]     serializers.registerIfAbsent(Long.class, longSerializer); [EOL]     serializers.registerIfAbsent(long.class, longSerializer); [EOL]     serializers.registerIfAbsent(DEFAULT_SERIALIZERS); [EOL]     return serializers; [EOL] }
static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() { [EOL]     return DEFAULT_DESERIALIZERS; [EOL] }
static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() { [EOL]     return DEFAULT_INSTANCE_CREATORS; [EOL] }
public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new Time(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new Time(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new Time(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonObject obj = json.getAsJsonObject(); [EOL]     int year = obj.get(YEAR).getAsInt(); [EOL]     int month = obj.get(MONTH).getAsInt(); [EOL]     int dayOfMonth = obj.get(DAY_OF_MONTH).getAsInt(); [EOL]     int hourOfDay = obj.get(HOUR_OF_DAY).getAsInt(); [EOL]     int minute = obj.get(MINUTE).getAsInt(); [EOL]     int second = obj.get(SECOND).getAsInt(); [EOL]     return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); [EOL] }
public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toASCIIString()); [EOL] }
public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toASCIIString()); [EOL] }
public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URI(json.getAsString()); [EOL]     } catch (URISyntaxException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URI(json.getAsString()); [EOL]     } catch (URISyntaxException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] }
public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] }
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }
private LongSerializer(LongSerializationPolicy longSerializationPolicy) { [EOL]     this.longSerializationPolicy = longSerializationPolicy; [EOL] }
FloatSerializer(boolean serializeSpecialDoubleValues) { [EOL]     this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues; [EOL] }
FloatSerializer(boolean serializeSpecialDoubleValues) { [EOL]     this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues; [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsFloat(); [EOL] }
public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsFloat(); [EOL] }
public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsFloat(); [EOL] }
DoubleSerializer(boolean serializeSpecialDoubleValues) { [EOL]     this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues; [EOL] }
DoubleSerializer(boolean serializeSpecialDoubleValues) { [EOL]     this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues; [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.serialize(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.serialize(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.serialize(); [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected T constructTarget() { [EOL]     TypeInfo typeInfo = new TypeInfo(targetType); [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     if (typeInfo.isArray()) { [EOL]         TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(targetType); [EOL]         return (T) objectConstructor.constructArray(arrayTypeInfo.getSecondLevelType(), jsonArray.size()); [EOL]     } [EOL]     return (T) objectConstructor.construct(typeInfo.getRawClass()); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected T constructTarget() { [EOL]     TypeInfo typeInfo = new TypeInfo(targetType); [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     if (typeInfo.isArray()) { [EOL]         TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(targetType); [EOL]         return (T) objectConstructor.constructArray(arrayTypeInfo.getSecondLevelType(), jsonArray.size()); [EOL]     } [EOL]     return (T) objectConstructor.construct(typeInfo.getRawClass()); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected T constructTarget() { [EOL]     TypeInfo typeInfo = new TypeInfo(targetType); [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     if (typeInfo.isArray()) { [EOL]         TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(targetType); [EOL]         return (T) objectConstructor.constructArray(arrayTypeInfo.getSecondLevelType(), jsonArray.size()); [EOL]     } [EOL]     return (T) objectConstructor.construct(typeInfo.getRawClass()); [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     if (!json.isJsonArray()) { [EOL]         throw new JsonParseException("Expecting array found: " + json); [EOL]     } [EOL]     JsonArray jsonArray = json.getAsJsonArray(); [EOL]     TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     for (int i = 0; i < jsonArray.size(); i++) { [EOL]         JsonElement jsonChild = jsonArray.get(i); [EOL]         Object child; [EOL]         if (jsonChild == null || jsonChild.isJsonNull()) { [EOL]             child = null; [EOL]         } else if (jsonChild instanceof JsonObject) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild); [EOL]         } else if (jsonChild instanceof JsonArray) { [EOL]             child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray()); [EOL]         } else if (jsonChild instanceof JsonPrimitive) { [EOL]             child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild.getAsJsonPrimitive()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         Array.set(array, i, child); [EOL]     } [EOL] }
public void visitPrimitive(Object primitive) { [EOL]     throw new JsonParseException("Type information is unavailable, and the target is not a primitive: " + json); [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('['); [EOL]     boolean first = true; [EOL]     for (JsonElement element : elements) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         element.toString(sb, escaper); [EOL]     } [EOL]     sb.append(']'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('['); [EOL]     boolean first = true; [EOL]     for (JsonElement element : elements) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         element.toString(sb, escaper); [EOL]     } [EOL]     sb.append(']'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('['); [EOL]     boolean first = true; [EOL]     for (JsonElement element : elements) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         element.toString(sb, escaper); [EOL]     } [EOL]     sb.append(']'); [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public JsonElement next() throws JsonParseException { [EOL]     if (!hasNext()) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return Streams.parse(parser); [EOL]     } catch (StackOverflowError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (OutOfMemoryError e) { [EOL]         throw new JsonParseException("Failed parsing JSON source to Json", e); [EOL]     } catch (JsonParseException e) { [EOL]         throw e.getCause() instanceof EOFException ? new NoSuchElementException() : e; [EOL]     } [EOL] }
public boolean hasNext() { [EOL]     synchronized (lock) { [EOL]         try { [EOL]             return parser.peek() != JsonToken.END_DOCUMENT; [EOL]         } catch (MalformedJsonException e) { [EOL]             throw new JsonSyntaxException(e); [EOL]         } catch (IOException e) { [EOL]             throw new JsonIOException(e); [EOL]         } [EOL]     } [EOL] }
public boolean hasNext() { [EOL]     synchronized (lock) { [EOL]         try { [EOL]             return parser.peek() != JsonToken.END_DOCUMENT; [EOL]         } catch (MalformedJsonException e) { [EOL]             throw new JsonSyntaxException(e); [EOL]         } catch (IOException e) { [EOL]             throw new JsonIOException(e); [EOL]         } [EOL]     } [EOL] }
public boolean hasNext() { [EOL]     synchronized (lock) { [EOL]         try { [EOL]             return parser.peek() != JsonToken.END_DOCUMENT; [EOL]         } catch (MalformedJsonException e) { [EOL]             throw new JsonSyntaxException(e); [EOL]         } catch (IOException e) { [EOL]             throw new JsonIOException(e); [EOL]         } [EOL]     } [EOL] }
public boolean hasNext() { [EOL]     synchronized (lock) { [EOL]         try { [EOL]             return parser.peek() != JsonToken.END_DOCUMENT; [EOL]         } catch (MalformedJsonException e) { [EOL]             throw new JsonSyntaxException(e); [EOL]         } catch (IOException e) { [EOL]             throw new JsonIOException(e); [EOL]         } [EOL]     } [EOL] }
public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first); [EOL]     if (index >= 0) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", pair.first); [EOL]         typeHierarchyList.remove(index); [EOL]     } [EOL]     index = getIndexOfAnOverriddenHandler(pair.first); [EOL]     if (index >= 0) { [EOL]         throw new IllegalArgumentException("The specified type handler for type " + pair.first + " hides the previously registered type hierarchy handler for " + typeHierarchyList.get(index).first + ". Gson does not allow this."); [EOL]     } [EOL]     typeHierarchyList.add(0, pair); [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public JsonSyntaxException(Throwable cause) { [EOL]     super(cause); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof ParameterizedType)) { [EOL]         return false; [EOL]     } [EOL]     ParameterizedType that = (ParameterizedType) o; [EOL]     if (this == that) { [EOL]         return true; [EOL]     } [EOL]     Type thatOwner = that.getOwnerType(); [EOL]     Type thatRawType = that.getRawType(); [EOL]     return (owner == null ? thatOwner == null : owner.equals(thatOwner)) && (rawType == null ? thatRawType == null : rawType.equals(thatRawType)) && Arrays.equals(actualTypeArguments, that.getActualTypeArguments()); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof ParameterizedType)) { [EOL]         return false; [EOL]     } [EOL]     ParameterizedType that = (ParameterizedType) o; [EOL]     if (this == that) { [EOL]         return true; [EOL]     } [EOL]     Type thatOwner = that.getOwnerType(); [EOL]     Type thatRawType = that.getRawType(); [EOL]     return (owner == null ? thatOwner == null : owner.equals(thatOwner)) && (rawType == null ? thatRawType == null : rawType.equals(thatRawType)) && Arrays.equals(actualTypeArguments, that.getActualTypeArguments()); [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> wrapWithArray(Class<?> rawClass) { [EOL]     return Array.newInstance(rawClass, 0).getClass(); [EOL] }
static Class<?> wrapWithArray(Class<?> rawClass) { [EOL]     return Array.newInstance(rawClass, 0).getClass(); [EOL] }
public JsonElement toJsonTree(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return toJsonTree(src, src.getClass()); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public JsonElement toJsonTree(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return toJsonTree(src, src.getClass()); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public JsonElement toJsonTree(Object src, Type typeOfSrc) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonSerializationContextDefault context = new JsonSerializationContextDefault(createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers); [EOL]     return context.serialize(src, typeOfSrc, true); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public JsonElement toJsonTree(Object src, Type typeOfSrc) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonSerializationContextDefault context = new JsonSerializationContextDefault(createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers); [EOL]     return context.serialize(src, typeOfSrc, true); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(Object src) { [EOL]     if (src == null) { [EOL]         return serializeNulls ? NULL_STRING : ""; [EOL]     } [EOL]     return toJson(src, src.getClass()); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(Object src) { [EOL]     if (src == null) { [EOL]         return serializeNulls ? NULL_STRING : ""; [EOL]     } [EOL]     return toJson(src, src.getClass()); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(Object src) { [EOL]     if (src == null) { [EOL]         return serializeNulls ? NULL_STRING : ""; [EOL]     } [EOL]     return toJson(src, src.getClass()); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(Object src, Type typeOfSrc) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(toJsonTree(src, typeOfSrc), writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(Object src, Type typeOfSrc) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(toJsonTree(src, typeOfSrc), writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(Object src, Type typeOfSrc) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(toJsonTree(src, typeOfSrc), writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Type typeOfSrc, JsonWriter writer) { [EOL]     toJson(toJsonTree(src, typeOfSrc), writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Type typeOfSrc, JsonWriter writer) { [EOL]     toJson(toJsonTree(src, typeOfSrc), writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(JsonElement jsonElement, Appendable writer) { [EOL]     try { [EOL]         if (generateNonExecutableJson) { [EOL]             writer.append(JSON_NON_EXECUTABLE_PREFIX); [EOL]         } [EOL]         JsonWriter jsonWriter = new JsonWriter(Streams.writerForAppendable(writer)); [EOL]         if (prettyPrinting) { [EOL]             jsonWriter.setIndent("  "); [EOL]         } [EOL]         toJson(jsonElement, jsonWriter); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(JsonElement jsonElement, Appendable writer) { [EOL]     try { [EOL]         if (generateNonExecutableJson) { [EOL]             writer.append(JSON_NON_EXECUTABLE_PREFIX); [EOL]         } [EOL]         JsonWriter jsonWriter = new JsonWriter(Streams.writerForAppendable(writer)); [EOL]         if (prettyPrinting) { [EOL]             jsonWriter.setIndent("  "); [EOL]         } [EOL]         toJson(jsonElement, jsonWriter); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(JsonElement jsonElement, Appendable writer) { [EOL]     try { [EOL]         if (generateNonExecutableJson) { [EOL]             writer.append(JSON_NON_EXECUTABLE_PREFIX); [EOL]         } [EOL]         JsonWriter jsonWriter = new JsonWriter(Streams.writerForAppendable(writer)); [EOL]         if (prettyPrinting) { [EOL]             jsonWriter.setIndent("  "); [EOL]         } [EOL]         toJson(jsonElement, jsonWriter); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(JsonElement jsonElement, Appendable writer) { [EOL]     try { [EOL]         if (generateNonExecutableJson) { [EOL]             writer.append(JSON_NON_EXECUTABLE_PREFIX); [EOL]         } [EOL]         JsonWriter jsonWriter = new JsonWriter(Streams.writerForAppendable(writer)); [EOL]         if (prettyPrinting) { [EOL]             jsonWriter.setIndent("  "); [EOL]         } [EOL]         toJson(jsonElement, jsonWriter); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(JsonElement jsonElement, JsonWriter writer) { [EOL]     boolean oldLenient = writer.isLenient(); [EOL]     writer.setLenient(true); [EOL]     boolean oldHtmlSafe = writer.isHtmlSafe(); [EOL]     writer.setHtmlSafe(htmlSafe); [EOL]     try { [EOL]         Streams.write(jsonElement, serializeNulls, writer); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } finally { [EOL]         writer.setLenient(oldLenient); [EOL]         writer.setHtmlSafe(oldHtmlSafe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) { [EOL]     Preconditions.checkNotNull(strategies); [EOL]     this.strategies = strategies; [EOL] }
public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) { [EOL]     Preconditions.checkNotNull(strategies); [EOL]     this.strategies = strategies; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         if (strategy.shouldSkipField(f)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         if (strategy.shouldSkipField(f)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         if (strategy.shouldSkipField(f)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         if (strategy.shouldSkipField(f)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         if (strategy.shouldSkipClass(clazz)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         if (strategy.shouldSkipClass(clazz)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
static JsonNull createJsonNull() { [EOL]     return INSTANCE; [EOL] }
public JsonParseException(Throwable cause) { [EOL]     super(cause); [EOL] }
final Object visitChildAsObject(Type childType, JsonElement jsonChild) { [EOL]     JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL]     return visitChild(childType, childVisitor); [EOL] }
final Object visitChildAsObject(Type childType, JsonElement jsonChild) { [EOL]     JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL]     return visitChild(childType, childVisitor); [EOL] }
final Object visitChildAsObject(Type childType, JsonElement jsonChild) { [EOL]     JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL]     return visitChild(childType, childVisitor); [EOL] }
final Object visitChildAsObject(Type childType, JsonElement jsonChild) { [EOL]     JsonDeserializationVisitor<?> childVisitor = new JsonObjectDeserializationVisitor<Object>(jsonChild, childType, factory, objectConstructor, deserializers, context); [EOL]     return visitChild(childType, childVisitor); [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
private boolean isPrimitiveOrString(Object objectToVisit) { [EOL]     Class<?> realClazz = objectToVisit.getClass(); [EOL]     return realClazz == Object.class || realClazz == String.class || Primitives.unwrap(realClazz).isPrimitive(); [EOL] }
private boolean isPrimitiveOrString(Object objectToVisit) { [EOL]     Class<?> realClazz = objectToVisit.getClass(); [EOL]     return realClazz == Object.class || realClazz == String.class || Primitives.unwrap(realClazz).isPrimitive(); [EOL] }
private boolean isPrimitiveOrString(Object objectToVisit) { [EOL]     Class<?> realClazz = objectToVisit.getClass(); [EOL]     return realClazz == Object.class || realClazz == String.class || Primitives.unwrap(realClazz).isPrimitive(); [EOL] }
private boolean isPrimitiveOrString(Object objectToVisit) { [EOL]     Class<?> realClazz = objectToVisit.getClass(); [EOL]     return realClazz == Object.class || realClazz == String.class || Primitives.unwrap(realClazz).isPrimitive(); [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public GsonBuilder disableInnerClassSerialization() { [EOL]     serializeInnerClasses = false; [EOL]     return this; [EOL] }
public GsonBuilder disableHtmlEscaping() { [EOL]     this.escapeHtmlChars = false; [EOL]     return this; [EOL] }
public GsonBuilder setDateFormat(String pattern) { [EOL]     this.datePattern = pattern; [EOL]     return this; [EOL] }
public GsonBuilder setDateFormat(String pattern) { [EOL]     this.datePattern = pattern; [EOL]     return this; [EOL] }
public GsonBuilder setDateFormat(int style) { [EOL]     this.dateStyle = style; [EOL]     this.datePattern = null; [EOL]     return this; [EOL] }
public GsonBuilder setDateFormat(int style) { [EOL]     this.dateStyle = style; [EOL]     this.datePattern = null; [EOL]     return this; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
public Gson create() { [EOL]     List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>(exclusionStrategies); [EOL]     serializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     deserializationStrategies.add(modifierBasedExclusionStrategy); [EOL]     if (!serializeInnerClasses) { [EOL]         serializationStrategies.add(innerClassExclusionStrategy); [EOL]         deserializationStrategies.add(innerClassExclusionStrategy); [EOL]     } [EOL]     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) { [EOL]         serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]         deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter)); [EOL]     } [EOL]     if (excludeFieldsWithoutExposeAnnotation) { [EOL]         serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy); [EOL]         deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy); [EOL]     } [EOL]     ExclusionStrategy serializationExclusionStrategy = new DisjunctionExclusionStrategy(serializationStrategies); [EOL]     ExclusionStrategy deserializationExclusionStrategy = new DisjunctionExclusionStrategy(deserializationStrategies); [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf(); [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf(); [EOL]     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, customSerializers, customDeserializers); [EOL]     customSerializers.registerIfAbsent(DefaultTypeAdapters.getDefaultSerializers(serializeSpecialFloatingPointValues, longSerializationPolicy)); [EOL]     customDeserializers.registerIfAbsent(DefaultTypeAdapters.getDefaultDeserializers()); [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators = instanceCreators.copyOf(); [EOL]     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.getDefaultInstanceCreators()); [EOL]     customSerializers.makeUnmodifiable(); [EOL]     customDeserializers.makeUnmodifiable(); [EOL]     instanceCreators.makeUnmodifiable(); [EOL]     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators); [EOL]     Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting); [EOL]     return gson; [EOL] }
private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) { [EOL]     DefaultDateTypeAdapter dateTypeAdapter = null; [EOL]     if (datePattern != null && !"".equals(datePattern.trim())) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(datePattern); [EOL]     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle); [EOL]     } [EOL]     if (dateTypeAdapter != null) { [EOL]         if (!serializers.hasSpecificHandlerFor(Date.class)) { [EOL]             serializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]         if (!deserializers.hasSpecificHandlerFor(Date.class)) { [EOL]             deserializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]     } [EOL] }
private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) { [EOL]     DefaultDateTypeAdapter dateTypeAdapter = null; [EOL]     if (datePattern != null && !"".equals(datePattern.trim())) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(datePattern); [EOL]     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle); [EOL]     } [EOL]     if (dateTypeAdapter != null) { [EOL]         if (!serializers.hasSpecificHandlerFor(Date.class)) { [EOL]             serializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]         if (!deserializers.hasSpecificHandlerFor(Date.class)) { [EOL]             deserializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]     } [EOL] }
private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) { [EOL]     DefaultDateTypeAdapter dateTypeAdapter = null; [EOL]     if (datePattern != null && !"".equals(datePattern.trim())) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(datePattern); [EOL]     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) { [EOL]         dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle); [EOL]     } [EOL]     if (dateTypeAdapter != null) { [EOL]         if (!serializers.hasSpecificHandlerFor(Date.class)) { [EOL]             serializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]         if (!deserializers.hasSpecificHandlerFor(Date.class)) { [EOL]             deserializers.register(Date.class, dateTypeAdapter); [EOL]         } [EOL]     } [EOL] }
private boolean isValidUntil(Until annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion <= version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidUntil(Until annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion <= version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidUntil(Until annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion <= version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
TypeInfo(Type actualType) { [EOL]     this.actualType = actualType; [EOL]     rawClass = TypeUtils.toRawClass(actualType); [EOL] }
TypeInfo(Type actualType) { [EOL]     this.actualType = actualType; [EOL]     rawClass = TypeUtils.toRawClass(actualType); [EOL] }
TypeInfo(Type actualType) { [EOL]     this.actualType = actualType; [EOL]     rawClass = TypeUtils.toRawClass(actualType); [EOL] }
TypeInfo(Type actualType) { [EOL]     this.actualType = actualType; [EOL]     rawClass = TypeUtils.toRawClass(actualType); [EOL] }
public final Type getActualType() { [EOL]     return actualType; [EOL] }
public final Class<?> getRawClass() { [EOL]     return rawClass; [EOL] }
public final boolean isArray() { [EOL]     return TypeUtils.isArray(rawClass); [EOL] }
public final boolean isArray() { [EOL]     return TypeUtils.isArray(rawClass); [EOL] }
public final boolean isEnum() { [EOL]     return rawClass.isEnum(); [EOL] }
public final boolean isEnum() { [EOL]     return rawClass.isEnum(); [EOL] }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     return value instanceof BigInteger ? (BigInteger) value : new BigInteger(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     return value instanceof BigInteger ? (BigInteger) value : new BigInteger(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     return value instanceof BigInteger ? (BigInteger) value : new BigInteger(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     return value instanceof BigInteger ? (BigInteger) value : new BigInteger(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     return value instanceof BigInteger ? (BigInteger) value : new BigInteger(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public float getAsFloat() { [EOL]     return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public float getAsFloat() { [EOL]     return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public float getAsFloat() { [EOL]     return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public float getAsFloat() { [EOL]     return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public long getAsLong() { [EOL]     return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public long getAsLong() { [EOL]     return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public long getAsLong() { [EOL]     return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public long getAsLong() { [EOL]     return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public short getAsShort() { [EOL]     return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public short getAsShort() { [EOL]     return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public short getAsShort() { [EOL]     return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public short getAsShort() { [EOL]     return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public short getAsShort() { [EOL]     return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public byte getAsByte() { [EOL]     return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public byte getAsByte() { [EOL]     return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public byte getAsByte() { [EOL]     return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public byte getAsByte() { [EOL]     return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isIntegral(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isFloatingPoint(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigDecimal || number instanceof Double || number instanceof Float; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.deserialize(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.deserialize(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     Expose annotation = f.getAnnotation(Expose.class); [EOL]     if (annotation == null) { [EOL]         return true; [EOL]     } [EOL]     return !annotation.deserialize(); [EOL] }
@Override [EOL] public String toString() { [EOL]     try { [EOL]         StringBuilder sb = new StringBuilder(); [EOL]         toString(sb, BASIC_ESCAPER); [EOL]         return sb.toString(); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     try { [EOL]         StringBuilder sb = new StringBuilder(); [EOL]         toString(sb, BASIC_ESCAPER); [EOL]         return sb.toString(); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return isInnerClass(f.getDeclaredClass()); [EOL] }
private boolean isInnerClass(Class<?> clazz) { [EOL]     return clazz.isMemberClass() && !isStatic(clazz); [EOL] }
private boolean isStatic(Class<?> clazz) { [EOL]     return (clazz.getModifiers() & Modifier.STATIC) != 0; [EOL] }
private boolean isStatic(Class<?> clazz) { [EOL]     return (clazz.getModifiers() & Modifier.STATIC) != 0; [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
public String validate(String fieldName) { [EOL]     Preconditions.checkNotNull(fieldName); [EOL]     Preconditions.checkArgument(!"".equals(fieldName.trim())); [EOL]     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName); [EOL]     if (!matcher.matches()) { [EOL]         throw new IllegalArgumentException(fieldName + " is not a valid JSON field name."); [EOL]     } [EOL]     return fieldName; [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
