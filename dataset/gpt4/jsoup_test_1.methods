public Node removeAttr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     attributes.remove(attributeKey); [EOL]     return this; [EOL] }
public Node removeAttr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     attributes.remove(attributeKey); [EOL]     return this; [EOL] }
public Node removeAttr(String attributeKey) { [EOL]     Validate.notNull(attributeKey); [EOL]     attributes.remove(attributeKey); [EOL]     return this; [EOL] }
public void remove() { [EOL]     Validate.notNull(parentNode); [EOL]     parentNode.removeChild(this); [EOL] }
public void remove() { [EOL]     Validate.notNull(parentNode); [EOL]     parentNode.removeChild(this); [EOL] }
protected void removeChild(Node out) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     int index = indexInList(out, childNodes); [EOL]     childNodes.remove(index); [EOL]     out.parentNode = null; [EOL] }
protected void removeChild(Node out) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     int index = indexInList(out, childNodes); [EOL]     childNodes.remove(index); [EOL]     out.parentNode = null; [EOL] }
protected void removeChild(Node out) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     int index = indexInList(out, childNodes); [EOL]     childNodes.remove(index); [EOL]     out.parentNode = null; [EOL] }
public Elements attr(String attributeKey, String attributeValue) { [EOL]     for (Element element : contents) { [EOL]         element.attr(attributeKey, attributeValue); [EOL]     } [EOL]     return this; [EOL] }
public Elements attr(String attributeKey, String attributeValue) { [EOL]     for (Element element : contents) { [EOL]         element.attr(attributeKey, attributeValue); [EOL]     } [EOL]     return this; [EOL] }
public Elements attr(String attributeKey, String attributeValue) { [EOL]     for (Element element : contents) { [EOL]         element.attr(attributeKey, attributeValue); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeAttr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         element.removeAttr(attributeKey); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeAttr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         element.removeAttr(attributeKey); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeAttr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         element.removeAttr(attributeKey); [EOL]     } [EOL]     return this; [EOL] }
public Elements addClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.addClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements addClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.addClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements addClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.addClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.removeClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.removeClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.removeClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.removeClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements removeClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.removeClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements toggleClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.toggleClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements toggleClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.toggleClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements toggleClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.toggleClass(className); [EOL]     } [EOL]     return this; [EOL] }
public Elements toggleClass(String className) { [EOL]     for (Element element : contents) { [EOL]         element.toggleClass(className); [EOL]     } [EOL]     return this; [EOL] }
public boolean hasClass(String className) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasClass(className)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean hasClass(String className) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasClass(className)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(Object o) { [EOL]     return contents.contains(o); [EOL] }
public boolean contains(Object o) { [EOL]     return contents.contains(o); [EOL] }
public boolean contains(Object o) { [EOL]     return contents.contains(o); [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
@Override [EOL] public String outerHtml() { [EOL]     return super.html(); [EOL] }
private Elements select() { [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchesAny(combinators)) { [EOL]         elements.add(root); [EOL]         combinator(tq.consume().toString()); [EOL]     } else { [EOL]         addElements(findElements()); [EOL]     } [EOL]     while (!tq.isEmpty()) { [EOL]         boolean seenWhite = tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(",")) { [EOL]             while (!tq.isEmpty()) { [EOL]                 String subQuery = tq.chompTo(","); [EOL]                 elements.addAll(select(subQuery, root)); [EOL]             } [EOL]         } else if (tq.matchesAny(combinators)) { [EOL]             combinator(tq.consume().toString()); [EOL]         } else if (seenWhite) { [EOL]             combinator(" "); [EOL]         } else { [EOL]             Elements candidates = findElements(); [EOL]             intersectElements(filterForSelf(elements, candidates)); [EOL]         } [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public Integer elementSiblingIndex() { [EOL]     if (parent() == null) [EOL]         return 0; [EOL]     return indexInList(this, parent().children()); [EOL] }
public Integer elementSiblingIndex() { [EOL]     if (parent() == null) [EOL]         return 0; [EOL]     return indexInList(this, parent().children()); [EOL] }
public Element getElementById(String id) { [EOL]     Validate.notEmpty(id); [EOL]     Elements elements = Collector.collect(new Evaluator.Id(id), this); [EOL]     if (elements.size() > 0) [EOL]         return elements.get(0); [EOL]     else [EOL]         return null; [EOL] }
public Element getElementById(String id) { [EOL]     Validate.notEmpty(id); [EOL]     Elements elements = Collector.collect(new Evaluator.Id(id), this); [EOL]     if (elements.size() > 0) [EOL]         return elements.get(0); [EOL]     else [EOL]         return null; [EOL] }
public Element getElementById(String id) { [EOL]     Validate.notEmpty(id); [EOL]     Elements elements = Collector.collect(new Evaluator.Id(id), this); [EOL]     if (elements.size() > 0) [EOL]         return elements.get(0); [EOL]     else [EOL]         return null; [EOL] }
public String text() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     text(sb); [EOL]     return sb.toString().trim(); [EOL] }
public String text() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     text(sb); [EOL]     return sb.toString().trim(); [EOL] }
public String text() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     text(sb); [EOL]     return sb.toString().trim(); [EOL] }
public String text() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     text(sb); [EOL]     return sb.toString().trim(); [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
public Element text(String text) { [EOL]     Validate.notNull(text); [EOL]     empty(); [EOL]     TextNode textNode = new TextNode(text, baseUri); [EOL]     appendChild(textNode); [EOL]     return this; [EOL] }
public Element text(String text) { [EOL]     Validate.notNull(text); [EOL]     empty(); [EOL]     TextNode textNode = new TextNode(text, baseUri); [EOL]     appendChild(textNode); [EOL]     return this; [EOL] }
public Element text(String text) { [EOL]     Validate.notNull(text); [EOL]     empty(); [EOL]     TextNode textNode = new TextNode(text, baseUri); [EOL]     appendChild(textNode); [EOL]     return this; [EOL] }
public String className() { [EOL]     return attributes.hasKey("class") ? attributes.get("class") : ""; [EOL] }
public String className() { [EOL]     return attributes.hasKey("class") ? attributes.get("class") : ""; [EOL] }
public Set<String> classNames() { [EOL]     if (classNames == null) { [EOL]         String[] names = className().split("\\s+"); [EOL]         classNames = new LinkedHashSet<String>(Arrays.asList(names)); [EOL]     } [EOL]     return classNames; [EOL] }
public Set<String> classNames() { [EOL]     if (classNames == null) { [EOL]         String[] names = className().split("\\s+"); [EOL]         classNames = new LinkedHashSet<String>(Arrays.asList(names)); [EOL]     } [EOL]     return classNames; [EOL] }
public Set<String> classNames() { [EOL]     if (classNames == null) { [EOL]         String[] names = className().split("\\s+"); [EOL]         classNames = new LinkedHashSet<String>(Arrays.asList(names)); [EOL]     } [EOL]     return classNames; [EOL] }
public Set<String> classNames() { [EOL]     if (classNames == null) { [EOL]         String[] names = className().split("\\s+"); [EOL]         classNames = new LinkedHashSet<String>(Arrays.asList(names)); [EOL]     } [EOL]     return classNames; [EOL] }
public Element classNames(Set<String> classNames) { [EOL]     Validate.notNull(classNames); [EOL]     attributes.put("class", StringUtils.join(classNames, " ")); [EOL]     return this; [EOL] }
public Element classNames(Set<String> classNames) { [EOL]     Validate.notNull(classNames); [EOL]     attributes.put("class", StringUtils.join(classNames, " ")); [EOL]     return this; [EOL] }
public Element classNames(Set<String> classNames) { [EOL]     Validate.notNull(classNames); [EOL]     attributes.put("class", StringUtils.join(classNames, " ")); [EOL]     return this; [EOL] }
public boolean hasClass(String className) { [EOL]     return classNames().contains(className); [EOL] }
public boolean hasClass(String className) { [EOL]     return classNames().contains(className); [EOL] }
public boolean hasClass(String className) { [EOL]     return classNames().contains(className); [EOL] }
public Element addClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     classes.add(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element addClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     classes.add(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element removeClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     classes.remove(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element removeClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     classes.remove(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element removeClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     classes.remove(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element toggleClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     if (classes.contains(className)) [EOL]         classes.remove(className); [EOL]     else [EOL]         classes.add(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element toggleClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     if (classes.contains(className)) [EOL]         classes.remove(className); [EOL]     else [EOL]         classes.add(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element toggleClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     if (classes.contains(className)) [EOL]         classes.remove(className); [EOL]     else [EOL]         classes.add(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
public Element toggleClass(String className) { [EOL]     Validate.notNull(className); [EOL]     Set<String> classes = classNames(); [EOL]     if (classes.contains(className)) [EOL]         classes.remove(className); [EOL]     else [EOL]         classes.add(className); [EOL]     classNames(classes); [EOL]     return this; [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private void parseComment() { [EOL]     tq.consume("<!--"); [EOL]     String data = tq.chompTo("->"); [EOL]     if (data.endsWith("-")) [EOL]         data = data.substring(0, data.length() - 1); [EOL]     Comment comment = new Comment(data, baseUri); [EOL]     last().appendChild(comment); [EOL] }
private void parseComment() { [EOL]     tq.consume("<!--"); [EOL]     String data = tq.chompTo("->"); [EOL]     if (data.endsWith("-")) [EOL]         data = data.substring(0, data.length() - 1); [EOL]     Comment comment = new Comment(data, baseUri); [EOL]     last().appendChild(comment); [EOL] }
private void parseComment() { [EOL]     tq.consume("<!--"); [EOL]     String data = tq.chompTo("->"); [EOL]     if (data.endsWith("-")) [EOL]         data = data.substring(0, data.length() - 1); [EOL]     Comment comment = new Comment(data, baseUri); [EOL]     last().appendChild(comment); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private void parseCdata() { [EOL]     tq.consume("<![CDATA["); [EOL]     String rawText = tq.chompTo("]]>"); [EOL]     TextNode textNode = new TextNode(rawText, baseUri); [EOL]     last().appendChild(textNode); [EOL] }
private void parseCdata() { [EOL]     tq.consume("<![CDATA["); [EOL]     String rawText = tq.chompTo("]]>"); [EOL]     TextNode textNode = new TextNode(rawText, baseUri); [EOL]     last().appendChild(textNode); [EOL] }
private void parseCdata() { [EOL]     tq.consume("<![CDATA["); [EOL]     String rawText = tq.chompTo("]]>"); [EOL]     TextNode textNode = new TextNode(rawText, baseUri); [EOL]     last().appendChild(textNode); [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static Whitelist basic() { [EOL]     return new Whitelist().addTags("a", "b", "blockquote", "br", "cite", "code", "dd", "dl", "dt", "em", "i", "li", "ol", "p", "pre", "q", "small", "strike", "strong", "sub", "sup", "u", "ul").addAttributes("a", "href").addAttributes("blockquote", "cite").addAttributes("q", "cite").addProtocols("a", "href", "ftp", "http", "https", "mailto").addProtocols("blockquote", "cite", "http", "https").addProtocols("cite", "cite", "http", "https").addEnforcedAttribute("a", "rel", "nofollow"); [EOL] }
public Whitelist addEnforcedAttribute(String tag, String key, String value) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     AttributeValue attrVal = AttributeValue.valueOf(value); [EOL]     if (enforcedAttributes.containsKey(tagName)) { [EOL]         enforcedAttributes.get(tagName).put(attrKey, attrVal); [EOL]     } else { [EOL]         Map<AttributeKey, AttributeValue> attrMap = new HashMap<AttributeKey, AttributeValue>(); [EOL]         attrMap.put(attrKey, attrVal); [EOL]         enforcedAttributes.put(tagName, attrMap); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addEnforcedAttribute(String tag, String key, String value) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     AttributeValue attrVal = AttributeValue.valueOf(value); [EOL]     if (enforcedAttributes.containsKey(tagName)) { [EOL]         enforcedAttributes.get(tagName).put(attrKey, attrVal); [EOL]     } else { [EOL]         Map<AttributeKey, AttributeValue> attrMap = new HashMap<AttributeKey, AttributeValue>(); [EOL]         attrMap.put(attrKey, attrVal); [EOL]         enforcedAttributes.put(tagName, attrMap); [EOL]     } [EOL]     return this; [EOL] }
public Whitelist addEnforcedAttribute(String tag, String key, String value) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     AttributeValue attrVal = AttributeValue.valueOf(value); [EOL]     if (enforcedAttributes.containsKey(tagName)) { [EOL]         enforcedAttributes.get(tagName).put(attrKey, attrVal); [EOL]     } else { [EOL]         Map<AttributeKey, AttributeValue> attrMap = new HashMap<AttributeKey, AttributeValue>(); [EOL]         attrMap.put(attrKey, attrVal); [EOL]         enforcedAttributes.put(tagName, attrMap); [EOL]     } [EOL]     return this; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] }
Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] }
AttributeValue(String value) { [EOL]     super(value); [EOL] }
AttributeValue(String value) { [EOL]     super(value); [EOL] }
static AttributeValue valueOf(String value) { [EOL]     return new AttributeValue(value); [EOL] }
static AttributeValue valueOf(String value) { [EOL]     return new AttributeValue(value); [EOL] }
static AttributeValue valueOf(String value) { [EOL]     return new AttributeValue(value); [EOL] }
public void remove(String key) { [EOL]     Validate.notEmpty(key); [EOL]     attributes.remove(key.toLowerCase()); [EOL] }
public void remove(String key) { [EOL]     Validate.notEmpty(key); [EOL]     attributes.remove(key.toLowerCase()); [EOL] }
public void remove(String key) { [EOL]     Validate.notEmpty(key); [EOL]     attributes.remove(key.toLowerCase()); [EOL] }
public void remove(String key) { [EOL]     Validate.notEmpty(key); [EOL]     attributes.remove(key.toLowerCase()); [EOL] }
public void remove(String key) { [EOL]     Validate.notEmpty(key); [EOL]     attributes.remove(key.toLowerCase()); [EOL] }
public int size() { [EOL]     return attributes.size(); [EOL] }
public int size() { [EOL]     return attributes.size(); [EOL] }
public Comment(String data, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(COMMENT_KEY, data); [EOL] }
public Comment(String data, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(COMMENT_KEY, data); [EOL] }
public Comment(String data, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(COMMENT_KEY, data); [EOL] }
public String getData() { [EOL]     return attributes.get(COMMENT_KEY); [EOL] }
public String getData() { [EOL]     return attributes.get(COMMENT_KEY); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     indent(accum); [EOL]     accum.append(String.format("<!--%s-->", getData())); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     indent(accum); [EOL]     accum.append(String.format("<!--%s-->", getData())); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     indent(accum); [EOL]     accum.append(String.format("<!--%s-->", getData())); [EOL] }
boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] }
private static Tag createBlock(String tagName) { [EOL]     return register(new Tag(tagName)); [EOL] }
private static Tag createInline(String tagName) { [EOL]     Tag inline = new Tag(tagName); [EOL]     inline.isBlock = false; [EOL]     inline.canContainBlock = false; [EOL]     return register(inline); [EOL] }
private static Tag createInline(String tagName) { [EOL]     Tag inline = new Tag(tagName); [EOL]     inline.isBlock = false; [EOL]     inline.canContainBlock = false; [EOL]     return register(inline); [EOL] }
private static Tag createInline(String tagName) { [EOL]     Tag inline = new Tag(tagName); [EOL]     inline.isBlock = false; [EOL]     inline.canContainBlock = false; [EOL]     return register(inline); [EOL] }
private static Tag register(Tag tag) { [EOL]     tag.setAncestor(defaultAncestor.tagName); [EOL]     synchronized (tags) { [EOL]         tags.put(tag.tagName, tag); [EOL]     } [EOL]     return tag; [EOL] }
private static Tag register(Tag tag) { [EOL]     tag.setAncestor(defaultAncestor.tagName); [EOL]     synchronized (tags) { [EOL]         tags.put(tag.tagName, tag); [EOL]     } [EOL]     return tag; [EOL] }
private Tag setContainInlineOnly() { [EOL]     canContainBlock = false; [EOL]     canContainInline = true; [EOL]     return this; [EOL] }
private Tag setContainDataOnly() { [EOL]     canContainBlock = false; [EOL]     canContainInline = false; [EOL]     preserveWhitespace = true; [EOL]     return this; [EOL] }
private Tag setEmpty() { [EOL]     canContainBlock = false; [EOL]     canContainInline = false; [EOL]     empty = true; [EOL]     return this; [EOL] }
private Tag setOptionalClosing() { [EOL]     optionalClosing = true; [EOL]     return this; [EOL] }
private Tag setPreserveWhitespace() { [EOL]     preserveWhitespace = true; [EOL]     return this; [EOL] }
